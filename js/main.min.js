! function(e) {
    var t = {};

    function n(r) {
        if (t[r]) return t[r].exports;
        var i = t[r] = {
            i: r,
            l: !1,
            exports: {}
        };
        return e[r].call(i.exports, i, i.exports, n), i.l = !0, i.exports
    }
    n.m = e, n.c = t, n.d = function(e, t, r) {
        n.o(e, t) || Object.defineProperty(e, t, {
            enumerable: !0,
            get: r
        })
    }, n.r = function(e) {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
            value: "Module"
        }), Object.defineProperty(e, "__esModule", {
            value: !0
        })
    }, n.t = function(e, t) {
        if (1 & t && (e = n(e)), 8 & t) return e;
        if (4 & t && "object" == typeof e && e && e.__esModule) return e;
        var r = Object.create(null);
        if (n.r(r), Object.defineProperty(r, "default", {
                enumerable: !0,
                value: e
            }), 2 & t && "string" != typeof e)
            for (var i in e) n.d(r, i, function(t) {
                return e[t]
            }.bind(null, i));
        return r
    }, n.n = function(e) {
        var t = e && e.__esModule ? function() {
            return e.default
        } : function() {
            return e
        };
        return n.d(t, "a", t), t
    }, n.o = function(e, t) {
        return Object.prototype.hasOwnProperty.call(e, t)
    }, n.p = "", n(n.s = 155)
}([function(e, t, n) {
    "use strict";
    n.r(t), n.d(t, "ACESFilmicToneMapping", (function() {
        return ce
    })), n.d(t, "AddEquation", (function() {
        return A
    })), n.d(t, "AddOperation", (function() {
        return ne
    })), n.d(t, "AdditiveBlending", (function() {
        return T
    })), n.d(t, "AlphaFormat", (function() {
        return Ue
    })), n.d(t, "AlwaysDepth", (function() {
        return X
    })), n.d(t, "AlwaysStencilFunc", (function() {
        return an
    })), n.d(t, "AmbientLight", (function() {
        return Gl
    })), n.d(t, "AmbientLightProbe", (function() {
        return uf
    })), n.d(t, "AnimationClip", (function() {
        return Yu
    })), n.d(t, "AnimationLoader", (function() {
        return el
    })), n.d(t, "AnimationMixer", (function() {
        return Gf
    })), n.d(t, "AnimationObjectGroup", (function() {
        return kf
    })), n.d(t, "AnimationUtils", (function() {
        return Ou
    })), n.d(t, "ArcCurve", (function() {
        return cl
    })), n.d(t, "ArrayCamera", (function() {
        return os
    })), n.d(t, "ArrowHelper", (function() {
        return Gd
    })), n.d(t, "Audio", (function() {
        return xf
    })), n.d(t, "AudioAnalyser", (function() {
        return Pf
    })), n.d(t, "AudioContext", (function() {
        return rf
    })), n.d(t, "AudioListener", (function() {
        return gf
    })), n.d(t, "AudioLoader", (function() {
        return of
    })), n.d(t, "AxesHelper", (function() {
        return Nd
    })), n.d(t, "AxisHelper", (function() {
        return dh
    })), n.d(t, "BackSide", (function() {
        return y
    })), n.d(t, "BasicDepthPacking", (function() {
        return Nt
    })), n.d(t, "BasicShadowMap", (function() {
        return d
    })), n.d(t, "BinaryTextureLoader", (function() {
        return yh
    })), n.d(t, "Bone", (function() {
        return Gs
    })), n.d(t, "BooleanKeyframeTrack", (function() {
        return Gu
    })), n.d(t, "BoundingBoxHelper", (function() {
        return hh
    })), n.d(t, "Box2", (function() {
        return qf
    })), n.d(t, "Box3", (function() {
        return lr
    })), n.d(t, "Box3Helper", (function() {
        return jd
    })), n.d(t, "BoxBufferGeometry", (function() {
        return Di
    })), n.d(t, "BoxGeometry", (function() {
        return Ii
    })), n.d(t, "BoxHelper", (function() {
        return Od
    })), n.d(t, "BufferAttribute", (function() {
        return Vr
    })), n.d(t, "BufferGeometry", (function() {
        return ui
    })), n.d(t, "BufferGeometryLoader", (function() {
        return Wl
    })), n.d(t, "ByteType", (function() {
        return Ce
    })), n.d(t, "Cache", (function() {
        return qu
    })), n.d(t, "Camera", (function() {
        return Hi
    })), n.d(t, "CameraHelper", (function() {
        return Ad
    })), n.d(t, "CanvasRenderer", (function() {
        return xh
    })), n.d(t, "CanvasTexture", (function() {
        return sc
    })), n.d(t, "CatmullRomCurve3", (function() {
        return vl
    })), n.d(t, "CineonToneMapping", (function() {
        return se
    })), n.d(t, "CircleBufferGeometry", (function() {
        return bu
    })), n.d(t, "CircleGeometry", (function() {
        return xu
    })), n.d(t, "ClampToEdgeWrapping", (function() {
        return ge
    })), n.d(t, "Clock", (function() {
        return hf
    })), n.d(t, "ClosedSplineCurve3", (function() {
        return uh
    })), n.d(t, "Color", (function() {
        return Dr
    })), n.d(t, "ColorKeyframeTrack", (function() {
        return Nu
    })), n.d(t, "CompressedTexture", (function() {
        return ac
    })), n.d(t, "CompressedTextureLoader", (function() {
        return tl
    })), n.d(t, "ConeBufferGeometry", (function() {
        return gu
    })), n.d(t, "ConeGeometry", (function() {
        return yu
    })), n.d(t, "CubeCamera", (function() {
        return Xi
    })), n.d(t, "CubeGeometry", (function() {
        return Ii
    })), n.d(t, "CubeReflectionMapping", (function() {
        return le
    })), n.d(t, "CubeRefractionMapping", (function() {
        return fe
    })), n.d(t, "CubeTexture", (function() {
        return Mo
    })), n.d(t, "CubeTextureLoader", (function() {
        return il
    })), n.d(t, "CubeUVReflectionMapping", (function() {
        return pe
    })), n.d(t, "CubeUVRefractionMapping", (function() {
        return me
    })), n.d(t, "CubicBezierCurve", (function() {
        return gl
    })), n.d(t, "CubicBezierCurve3", (function() {
        return xl
    })), n.d(t, "CubicInterpolant", (function() {
        return Iu
    })), n.d(t, "CullFaceBack", (function() {
        return s
    })), n.d(t, "CullFaceFront", (function() {
        return c
    })), n.d(t, "CullFaceFrontBack", (function() {
        return u
    })), n.d(t, "CullFaceNone", (function() {
        return a
    })), n.d(t, "Curve", (function() {
        return al
    })), n.d(t, "CurvePath", (function() {
        return Tl
    })), n.d(t, "CustomBlending", (function() {
        return L
    })), n.d(t, "CylinderBufferGeometry", (function() {
        return mu
    })), n.d(t, "CylinderGeometry", (function() {
        return pu
    })), n.d(t, "Cylindrical", (function() {
        return Yf
    })), n.d(t, "DataTexture", (function() {
        return Ki
    })), n.d(t, "DataTexture2DArray", (function() {
        return _o
    })), n.d(t, "DataTexture3D", (function() {
        return So
    })), n.d(t, "DataTextureLoader", (function() {
        return nl
    })), n.d(t, "DecrementStencilOp", (function() {
        return qt
    })), n.d(t, "DecrementWrapStencilOp", (function() {
        return Zt
    })), n.d(t, "DefaultLoadingManager", (function() {
        return Zu
    })), n.d(t, "DepthFormat", (function() {
        return qe
    })), n.d(t, "DepthStencilFormat", (function() {
        return Ke
    })), n.d(t, "DepthTexture", (function() {
        return cc
    })), n.d(t, "DirectionalLight", (function() {
        return Fl
    })), n.d(t, "DirectionalLightHelper", (function() {
        return Ed
    })), n.d(t, "DirectionalLightShadow", (function() {
        return kl
    })), n.d(t, "DiscreteInterpolant", (function() {
        return ku
    })), n.d(t, "DodecahedronBufferGeometry", (function() {
        return wc
    })), n.d(t, "DodecahedronGeometry", (function() {
        return bc
    })), n.d(t, "DoubleSide", (function() {
        return g
    })), n.d(t, "DstAlphaFactor", (function() {
        return B
    })), n.d(t, "DstColorFactor", (function() {
        return H
    })), n.d(t, "DynamicBufferAttribute", (function() {
        return $d
    })), n.d(t, "EdgesGeometry", (function() {
        return vu
    })), n.d(t, "EdgesHelper", (function() {
        return vh
    })), n.d(t, "EllipseCurve", (function() {
        return sl
    })), n.d(t, "EqualDepth", (function() {
        return Z
    })), n.d(t, "EqualStencilFunc", (function() {
        return en
    })), n.d(t, "EquirectangularReflectionMapping", (function() {
        return de
    })), n.d(t, "EquirectangularRefractionMapping", (function() {
        return he
    })), n.d(t, "Euler", (function() {
        return In
    })), n.d(t, "EventDispatcher", (function() {
        return sn
    })), n.d(t, "ExtrudeBufferGeometry", (function() {
        return eu
    })), n.d(t, "ExtrudeGeometry", (function() {
        return $c
    })), n.d(t, "Face3", (function() {
        return Nr
    })), n.d(t, "Face4", (function() {
        return Bd
    })), n.d(t, "FaceColors", (function() {
        return M
    })), n.d(t, "FaceNormalsHelper", (function() {
        return _d
    })), n.d(t, "FileLoader", (function() {
        return $u
    })), n.d(t, "FlatShading", (function() {
        return x
    })), n.d(t, "Float32Attribute", (function() {
        return sh
    })), n.d(t, "Float32BufferAttribute", (function() {
        return Qr
    })), n.d(t, "Float64Attribute", (function() {
        return ch
    })), n.d(t, "Float64BufferAttribute", (function() {
        return $r
    })), n.d(t, "FloatType", (function() {
        return De
    })), n.d(t, "Fog", (function() {
        return vs
    })), n.d(t, "FogExp2", (function() {
        return hs
    })), n.d(t, "Font", (function() {
        return ef
    })), n.d(t, "FontLoader", (function() {
        return nf
    })), n.d(t, "FrontFaceDirectionCCW", (function() {
        return f
    })), n.d(t, "FrontFaceDirectionCW", (function() {
        return l
    })), n.d(t, "FrontSide", (function() {
        return m
    })), n.d(t, "Frustum", (function() {
        return no
    })), n.d(t, "GammaEncoding", (function() {
        return jt
    })), n.d(t, "Geometry", (function() {
        return ji
    })), n.d(t, "GeometryUtils", (function() {
        return gh
    })), n.d(t, "GreaterDepth", (function() {
        return Q
    })), n.d(t, "GreaterEqualDepth", (function() {
        return J
    })), n.d(t, "GreaterEqualStencilFunc", (function() {
        return on
    })), n.d(t, "GreaterStencilFunc", (function() {
        return nn
    })), n.d(t, "GridHelper", (function() {
        return yd
    })), n.d(t, "Group", (function() {
        return is
    })), n.d(t, "HalfFloatType", (function() {
        return ke
    })), n.d(t, "HemisphereLight", (function() {
        return Al
    })), n.d(t, "HemisphereLightHelper", (function() {
        return pd
    })), n.d(t, "HemisphereLightProbe", (function() {
        return cf
    })), n.d(t, "IcosahedronBufferGeometry", (function() {
        return xc
    })), n.d(t, "IcosahedronGeometry", (function() {
        return gc
    })), n.d(t, "ImageBitmapLoader", (function() {
        return Ql
    })), n.d(t, "ImageLoader", (function() {
        return rl
    })), n.d(t, "ImageUtils", (function() {
        return xn
    })), n.d(t, "ImmediateRenderObject", (function() {
        return Qf
    })), n.d(t, "IncrementStencilOp", (function() {
        return Xt
    })), n.d(t, "IncrementWrapStencilOp", (function() {
        return Kt
    })), n.d(t, "InstancedBufferAttribute", (function() {
        return Vl
    })), n.d(t, "InstancedBufferGeometry", (function() {
        return Hl
    })), n.d(t, "InstancedInterleavedBuffer", (function() {
        return Bf
    })), n.d(t, "InstancedMesh", (function() {
        return Ns
    })), n.d(t, "Int16Attribute", (function() {
        return rh
    })), n.d(t, "Int16BufferAttribute", (function() {
        return qr
    })), n.d(t, "Int32Attribute", (function() {
        return oh
    })), n.d(t, "Int32BufferAttribute", (function() {
        return Zr
    })), n.d(t, "Int8Attribute", (function() {
        return eh
    })), n.d(t, "Int8BufferAttribute", (function() {
        return Wr
    })), n.d(t, "IntType", (function() {
        return je
    })), n.d(t, "InterleavedBuffer", (function() {
        return ps
    })), n.d(t, "InterleavedBufferAttribute", (function() {
        return ms
    })), n.d(t, "Interpolant", (function() {
        return ju
    })), n.d(t, "InterpolateDiscrete", (function() {
        return _t
    })), n.d(t, "InterpolateLinear", (function() {
        return St
    })), n.d(t, "InterpolateSmooth", (function() {
        return Pt
    })), n.d(t, "InvertStencilOp", (function() {
        return Jt
    })), n.d(t, "JSONLoader", (function() {
        return bh
    })), n.d(t, "KeepStencilOp", (function() {
        return Wt
    })), n.d(t, "KeyframeTrack", (function() {
        return Fu
    })), n.d(t, "LOD", (function() {
        return js
    })), n.d(t, "LatheBufferGeometry", (function() {
        return lu
    })), n.d(t, "LatheGeometry", (function() {
        return uu
    })), n.d(t, "Layers", (function() {
        return Dn
    })), n.d(t, "LensFlare", (function() {
        return Mh
    })), n.d(t, "LessDepth", (function() {
        return q
    })), n.d(t, "LessEqualDepth", (function() {
        return K
    })), n.d(t, "LessEqualStencilFunc", (function() {
        return tn
    })), n.d(t, "LessStencilFunc", (function() {
        return $t
    })), n.d(t, "Light", (function() {
        return Ll
    })), n.d(t, "LightProbe", (function() {
        return sf
    })), n.d(t, "LightProbeHelper", (function() {
        return md
    })), n.d(t, "LightShadow", (function() {
        return Cl
    })), n.d(t, "Line", (function() {
        return Xs
    })), n.d(t, "Line3", (function() {
        return Jf
    })), n.d(t, "LineBasicMaterial", (function() {
        return Bs
    })), n.d(t, "LineCurve", (function() {
        return bl
    })), n.d(t, "LineCurve3", (function() {
        return wl
    })), n.d(t, "LineDashedMaterial", (function() {
        return Cu
    })), n.d(t, "LineLoop", (function() {
        return Js
    })), n.d(t, "LinePieces", (function() {
        return Hd
    })), n.d(t, "LineSegments", (function() {
        return Zs
    })), n.d(t, "LineStrip", (function() {
        return Ud
    })), n.d(t, "LinearEncoding", (function() {
        return Rt
    })), n.d(t, "LinearFilter", (function() {
        return Pe
    })), n.d(t, "LinearInterpolant", (function() {
        return Du
    })), n.d(t, "LinearMipMapLinearFilter", (function() {
        return Le
    })), n.d(t, "LinearMipMapNearestFilter", (function() {
        return Ee
    })), n.d(t, "LinearMipmapLinearFilter", (function() {
        return ze
    })), n.d(t, "LinearMipmapNearestFilter", (function() {
        return Te
    })), n.d(t, "LinearToneMapping", (function() {
        return ie
    })), n.d(t, "Loader", (function() {
        return Ju
    })), n.d(t, "LoaderUtils", (function() {
        return Ul
    })), n.d(t, "LoadingManager", (function() {
        return Ku
    })), n.d(t, "LogLuvEncoding", (function() {
        return Dt
    })), n.d(t, "LoopOnce", (function() {
        return bt
    })), n.d(t, "LoopPingPong", (function() {
        return Mt
    })), n.d(t, "LoopRepeat", (function() {
        return wt
    })), n.d(t, "LuminanceAlphaFormat", (function() {
        return Ye
    })), n.d(t, "LuminanceFormat", (function() {
        return We
    })), n.d(t, "MOUSE", (function() {
        return i
    })), n.d(t, "Material", (function() {
        return Ur
    })), n.d(t, "MaterialLoader", (function() {
        return Bl
    })), n.d(t, "Math", (function() {
        return ln
    })), n.d(t, "Matrix3", (function() {
        return gn
    })), n.d(t, "Matrix4", (function() {
        return Rn
    })), n.d(t, "MaxEquation", (function() {
        return j
    })), n.d(t, "Mesh", (function() {
        return Ei
    })), n.d(t, "MeshBasicMaterial", (function() {
        return Hr
    })), n.d(t, "MeshDepthMaterial", (function() {
        return qa
    })), n.d(t, "MeshDistanceMaterial", (function() {
        return Ka
    })), n.d(t, "MeshFaceMaterial", (function() {
        return Vd
    })), n.d(t, "MeshLambertMaterial", (function() {
        return Lu
    })), n.d(t, "MeshMatcapMaterial", (function() {
        return Au
    })), n.d(t, "MeshNormalMaterial", (function() {
        return zu
    })), n.d(t, "MeshPhongMaterial", (function() {
        return Tu
    })), n.d(t, "MeshPhysicalMaterial", (function() {
        return Pu
    })), n.d(t, "MeshStandardMaterial", (function() {
        return Su
    })), n.d(t, "MeshToonMaterial", (function() {
        return Eu
    })), n.d(t, "MinEquation", (function() {
        return O
    })), n.d(t, "MirroredRepeatWrapping", (function() {
        return xe
    })), n.d(t, "MixOperation", (function() {
        return te
    })), n.d(t, "MultiMaterial", (function() {
        return Wd
    })), n.d(t, "MultiplyBlending", (function() {
        return z
    })), n.d(t, "MultiplyOperation", (function() {
        return ee
    })), n.d(t, "NearestFilter", (function() {
        return be
    })), n.d(t, "NearestMipMapLinearFilter", (function() {
        return Se
    })), n.d(t, "NearestMipMapNearestFilter", (function() {
        return Me
    })), n.d(t, "NearestMipmapLinearFilter", (function() {
        return _e
    })), n.d(t, "NearestMipmapNearestFilter", (function() {
        return we
    })), n.d(t, "NeverDepth", (function() {
        return Y
    })), n.d(t, "NeverStencilFunc", (function() {
        return Qt
    })), n.d(t, "NoBlending", (function() {
        return S
    })), n.d(t, "NoColors", (function() {
        return w
    })), n.d(t, "NoToneMapping", (function() {
        return re
    })), n.d(t, "NormalBlending", (function() {
        return P
    })), n.d(t, "NotEqualDepth", (function() {
        return $
    })), n.d(t, "NotEqualStencilFunc", (function() {
        return rn
    })), n.d(t, "NumberKeyframeTrack", (function() {
        return Bu
    })), n.d(t, "Object3D", (function() {
        return Zn
    })), n.d(t, "ObjectLoader", (function() {
        return Xl
    })), n.d(t, "ObjectSpaceNormalMap", (function() {
        return Ht
    })), n.d(t, "OctahedronBufferGeometry", (function() {
        return yc
    })), n.d(t, "OctahedronGeometry", (function() {
        return mc
    })), n.d(t, "OneFactor", (function() {
        return D
    })), n.d(t, "OneMinusDstAlphaFactor", (function() {
        return U
    })), n.d(t, "OneMinusDstColorFactor", (function() {
        return V
    })), n.d(t, "OneMinusSrcAlphaFactor", (function() {
        return N
    })), n.d(t, "OneMinusSrcColorFactor", (function() {
        return F
    })), n.d(t, "OrthographicCamera", (function() {
        return Dl
    })), n.d(t, "PCFShadowMap", (function() {
        return h
    })), n.d(t, "PCFSoftShadowMap", (function() {
        return v
    })), n.d(t, "ParametricBufferGeometry", (function() {
        return fc
    })), n.d(t, "ParametricGeometry", (function() {
        return lc
    })), n.d(t, "Particle", (function() {
        return Xd
    })), n.d(t, "ParticleBasicMaterial", (function() {
        return Zd
    })), n.d(t, "ParticleSystem", (function() {
        return qd
    })), n.d(t, "ParticleSystemMaterial", (function() {
        return Jd
    })), n.d(t, "Path", (function() {
        return El
    })), n.d(t, "PerspectiveCamera", (function() {
        return Vi
    })), n.d(t, "Plane", (function() {
        return $i
    })), n.d(t, "PlaneBufferGeometry", (function() {
        return uo
    })), n.d(t, "PlaneGeometry", (function() {
        return co
    })), n.d(t, "PlaneHelper", (function() {
        return Id
    })), n.d(t, "PointCloud", (function() {
        return Yd
    })), n.d(t, "PointCloudMaterial", (function() {
        return Kd
    })), n.d(t, "PointLight", (function() {
        return Il
    })), n.d(t, "PointLightHelper", (function() {
        return ld
    })), n.d(t, "Points", (function() {
        return rc
    })), n.d(t, "PointsMaterial", (function() {
        return Qs
    })), n.d(t, "PolarGridHelper", (function() {
        return gd
    })), n.d(t, "PolyhedronBufferGeometry", (function() {
        return hc
    })), n.d(t, "PolyhedronGeometry", (function() {
        return dc
    })), n.d(t, "PositionalAudio", (function() {
        return Sf
    })), n.d(t, "PositionalAudioHelper", (function() {
        return xd
    })), n.d(t, "PropertyBinding", (function() {
        return Df
    })), n.d(t, "PropertyMixer", (function() {
        return Tf
    })), n.d(t, "QuadraticBezierCurve", (function() {
        return Ml
    })), n.d(t, "QuadraticBezierCurve3", (function() {
        return _l
    })), n.d(t, "Quaternion", (function() {
        return dn
    })), n.d(t, "QuaternionKeyframeTrack", (function() {
        return Hu
    })), n.d(t, "QuaternionLinearInterpolant", (function() {
        return Uu
    })), n.d(t, "REVISION", (function() {
        return r
    })), n.d(t, "RGBADepthPacking", (function() {
        return Bt
    })), n.d(t, "RGBAFormat", (function() {
        return Ve
    })), n.d(t, "RGBA_ASTC_10x10_Format", (function() {
        return yt
    })), n.d(t, "RGBA_ASTC_10x5_Format", (function() {
        return vt
    })), n.d(t, "RGBA_ASTC_10x6_Format", (function() {
        return pt
    })), n.d(t, "RGBA_ASTC_10x8_Format", (function() {
        return mt
    })), n.d(t, "RGBA_ASTC_12x10_Format", (function() {
        return gt
    })), n.d(t, "RGBA_ASTC_12x12_Format", (function() {
        return xt
    })), n.d(t, "RGBA_ASTC_4x4_Format", (function() {
        return at
    })), n.d(t, "RGBA_ASTC_5x4_Format", (function() {
        return st
    })), n.d(t, "RGBA_ASTC_5x5_Format", (function() {
        return ct
    })), n.d(t, "RGBA_ASTC_6x5_Format", (function() {
        return ut
    })), n.d(t, "RGBA_ASTC_6x6_Format", (function() {
        return lt
    })), n.d(t, "RGBA_ASTC_8x5_Format", (function() {
        return ft
    })), n.d(t, "RGBA_ASTC_8x6_Format", (function() {
        return dt
    })), n.d(t, "RGBA_ASTC_8x8_Format", (function() {
        return ht
    })), n.d(t, "RGBA_PVRTC_2BPPV1_Format", (function() {
        return it
    })), n.d(t, "RGBA_PVRTC_4BPPV1_Format", (function() {
        return rt
    })), n.d(t, "RGBA_S3TC_DXT1_Format", (function() {
        return Qe
    })), n.d(t, "RGBA_S3TC_DXT3_Format", (function() {
        return $e
    })), n.d(t, "RGBA_S3TC_DXT5_Format", (function() {
        return et
    })), n.d(t, "RGBDEncoding", (function() {
        return Gt
    })), n.d(t, "RGBEEncoding", (function() {
        return It
    })), n.d(t, "RGBEFormat", (function() {
        return Xe
    })), n.d(t, "RGBFormat", (function() {
        return He
    })), n.d(t, "RGBM16Encoding", (function() {
        return Ft
    })), n.d(t, "RGBM7Encoding", (function() {
        return kt
    })), n.d(t, "RGB_ETC1_Format", (function() {
        return ot
    })), n.d(t, "RGB_PVRTC_2BPPV1_Format", (function() {
        return nt
    })), n.d(t, "RGB_PVRTC_4BPPV1_Format", (function() {
        return tt
    })), n.d(t, "RGB_S3TC_DXT1_Format", (function() {
        return Je
    })), n.d(t, "RawShaderMaterial", (function() {
        return _u
    })), n.d(t, "Ray", (function() {
        return wr
    })), n.d(t, "Raycaster", (function() {
        return Uf
    })), n.d(t, "RectAreaLight", (function() {
        return Nl
    })), n.d(t, "RectAreaLightHelper", (function() {
        return fd
    })), n.d(t, "RedFormat", (function() {
        return Ze
    })), n.d(t, "ReinhardToneMapping", (function() {
        return oe
    })), n.d(t, "RepeatWrapping", (function() {
        return ye
    })), n.d(t, "ReplaceStencilOp", (function() {
        return Yt
    })), n.d(t, "ReverseSubtractEquation", (function() {
        return R
    })), n.d(t, "RingBufferGeometry", (function() {
        return cu
    })), n.d(t, "RingGeometry", (function() {
        return su
    })), n.d(t, "Scene", (function() {
        return Jn
    })), n.d(t, "SceneUtils", (function() {
        return wh
    })), n.d(t, "ShaderChunk", (function() {
        return ro
    })), n.d(t, "ShaderLib", (function() {
        return oo
    })), n.d(t, "ShaderMaterial", (function() {
        return Ui
    })), n.d(t, "ShadowMaterial", (function() {
        return Mu
    })), n.d(t, "Shape", (function() {
        return zl
    })), n.d(t, "ShapeBufferGeometry", (function() {
        return du
    })), n.d(t, "ShapeGeometry", (function() {
        return fu
    })), n.d(t, "ShapePath", (function() {
        return $l
    })), n.d(t, "ShapeUtils", (function() {
        return Zc
    })), n.d(t, "ShortType", (function() {
        return Re
    })), n.d(t, "Skeleton", (function() {
        return Fs
    })), n.d(t, "SkeletonHelper", (function() {
        return ud
    })), n.d(t, "SkinnedMesh", (function() {
        return Is
    })), n.d(t, "SmoothShading", (function() {
        return b
    })), n.d(t, "Sphere", (function() {
        return hr
    })), n.d(t, "SphereBufferGeometry", (function() {
        return au
    })), n.d(t, "SphereGeometry", (function() {
        return ou
    })), n.d(t, "Spherical", (function() {
        return Wf
    })), n.d(t, "SphericalHarmonics3", (function() {
        return af
    })), n.d(t, "SphericalReflectionMapping", (function() {
        return ve
    })), n.d(t, "Spline", (function() {
        return fh
    })), n.d(t, "SplineCurve", (function() {
        return Sl
    })), n.d(t, "SplineCurve3", (function() {
        return lh
    })), n.d(t, "SpotLight", (function() {
        return Ol
    })), n.d(t, "SpotLightHelper", (function() {
        return od
    })), n.d(t, "SpotLightShadow", (function() {
        return Rl
    })), n.d(t, "Sprite", (function() {
        return As
    })), n.d(t, "SpriteMaterial", (function() {
        return ys
    })), n.d(t, "SrcAlphaFactor", (function() {
        return G
    })), n.d(t, "SrcAlphaSaturateFactor", (function() {
        return W
    })), n.d(t, "SrcColorFactor", (function() {
        return k
    })), n.d(t, "StereoCamera", (function() {
        return df
    })), n.d(t, "StringKeyframeTrack", (function() {
        return Vu
    })), n.d(t, "SubtractEquation", (function() {
        return C
    })), n.d(t, "SubtractiveBlending", (function() {
        return E
    })), n.d(t, "TOUCH", (function() {
        return o
    })), n.d(t, "TangentSpaceNormalMap", (function() {
        return Ut
    })), n.d(t, "TetrahedronBufferGeometry", (function() {
        return pc
    })), n.d(t, "TetrahedronGeometry", (function() {
        return vc
    })), n.d(t, "TextBufferGeometry", (function() {
        return iu
    })), n.d(t, "TextGeometry", (function() {
        return ru
    })), n.d(t, "Texture", (function() {
        return wn
    })), n.d(t, "TextureLoader", (function() {
        return ol
    })), n.d(t, "TorusBufferGeometry", (function() {
        return Ec
    })), n.d(t, "TorusGeometry", (function() {
        return Tc
    })), n.d(t, "TorusKnotBufferGeometry", (function() {
        return Pc
    })), n.d(t, "TorusKnotGeometry", (function() {
        return Sc
    })), n.d(t, "Triangle", (function() {
        return Rr
    })), n.d(t, "TriangleFanDrawMode", (function() {
        return Ct
    })), n.d(t, "TriangleStripDrawMode", (function() {
        return At
    })), n.d(t, "TrianglesDrawMode", (function() {
        return Lt
    })), n.d(t, "TubeBufferGeometry", (function() {
        return _c
    })), n.d(t, "TubeGeometry", (function() {
        return Mc
    })), n.d(t, "UVMapping", (function() {
        return ue
    })), n.d(t, "Uint16Attribute", (function() {
        return ih
    })), n.d(t, "Uint16BufferAttribute", (function() {
        return Kr
    })), n.d(t, "Uint32Attribute", (function() {
        return ah
    })), n.d(t, "Uint32BufferAttribute", (function() {
        return Jr
    })), n.d(t, "Uint8Attribute", (function() {
        return th
    })), n.d(t, "Uint8BufferAttribute", (function() {
        return Yr
    })), n.d(t, "Uint8ClampedAttribute", (function() {
        return nh
    })), n.d(t, "Uint8ClampedBufferAttribute", (function() {
        return Xr
    })), n.d(t, "Uncharted2ToneMapping", (function() {
        return ae
    })), n.d(t, "Uniform", (function() {
        return Nf
    })), n.d(t, "UniformsLib", (function() {
        return io
    })), n.d(t, "UniformsUtils", (function() {
        return Gi
    })), n.d(t, "UnsignedByteType", (function() {
        return Ae
    })), n.d(t, "UnsignedInt248Type", (function() {
        return Be
    })), n.d(t, "UnsignedIntType", (function() {
        return Ie
    })), n.d(t, "UnsignedShort4444Type", (function() {
        return Fe
    })), n.d(t, "UnsignedShort5551Type", (function() {
        return Ge
    })), n.d(t, "UnsignedShort565Type", (function() {
        return Ne
    })), n.d(t, "UnsignedShortType", (function() {
        return Oe
    })), n.d(t, "VSMShadowMap", (function() {
        return p
    })), n.d(t, "Vector2", (function() {
        return fn
    })), n.d(t, "Vector3", (function() {
        return pn
    })), n.d(t, "Vector4", (function() {
        return Mn
    })), n.d(t, "VectorKeyframeTrack", (function() {
        return Wu
    })), n.d(t, "Vertex", (function() {
        return Qd
    })), n.d(t, "VertexColors", (function() {
        return _
    })), n.d(t, "VertexNormalsHelper", (function() {
        return rd
    })), n.d(t, "VideoTexture", (function() {
        return oc
    })), n.d(t, "WebGLMultisampleRenderTarget", (function() {
        return Sn
    })), n.d(t, "WebGLRenderTarget", (function() {
        return _n
    })), n.d(t, "WebGLRenderTargetCube", (function() {
        return qi
    })), n.d(t, "WebGLRenderer", (function() {
        return ds
    })), n.d(t, "WebGLUtils", (function() {
        return ts
    })), n.d(t, "WireframeGeometry", (function() {
        return uc
    })), n.d(t, "WireframeHelper", (function() {
        return ph
    })), n.d(t, "WrapAroundEnding", (function() {
        return zt
    })), n.d(t, "XHRLoader", (function() {
        return mh
    })), n.d(t, "ZeroCurvatureEnding", (function() {
        return Tt
    })), n.d(t, "ZeroFactor", (function() {
        return I
    })), n.d(t, "ZeroSlopeEnding", (function() {
        return Et
    })), n.d(t, "ZeroStencilOp", (function() {
        return Vt
    })), n.d(t, "sRGBEncoding", (function() {
        return Ot
    })), void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)), void 0 === Number.isInteger && (Number.isInteger = function(e) {
        return "number" == typeof e && isFinite(e) && Math.floor(e) === e
    }), void 0 === Math.sign && (Math.sign = function(e) {
        return e < 0 ? -1 : e > 0 ? 1 : +e
    }), "name" in Function.prototype == !1 && Object.defineProperty(Function.prototype, "name", {
        get: function() {
            return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1]
        }
    }), void 0 === Object.assign && (Object.assign = function(e) {
        if (null == e) throw new TypeError("Cannot convert undefined or null to object");
        for (var t = Object(e), n = 1; n < arguments.length; n++) {
            var r = arguments[n];
            if (null != r)
                for (var i in r) Object.prototype.hasOwnProperty.call(r, i) && (t[i] = r[i])
        }
        return t
    });
    var r = "109",
        i = {
            LEFT: 0,
            MIDDLE: 1,
            RIGHT: 2,
            ROTATE: 0,
            DOLLY: 1,
            PAN: 2
        },
        o = {
            ROTATE: 0,
            PAN: 1,
            DOLLY_PAN: 2,
            DOLLY_ROTATE: 3
        },
        a = 0,
        s = 1,
        c = 2,
        u = 3,
        l = 0,
        f = 1,
        d = 0,
        h = 1,
        v = 2,
        p = 3,
        m = 0,
        y = 1,
        g = 2,
        x = 1,
        b = 2,
        w = 0,
        M = 1,
        _ = 2,
        S = 0,
        P = 1,
        T = 2,
        E = 3,
        z = 4,
        L = 5,
        A = 100,
        C = 101,
        R = 102,
        O = 103,
        j = 104,
        I = 200,
        D = 201,
        k = 202,
        F = 203,
        G = 204,
        N = 205,
        B = 206,
        U = 207,
        H = 208,
        V = 209,
        W = 210,
        Y = 0,
        X = 1,
        q = 2,
        K = 3,
        Z = 4,
        J = 5,
        Q = 6,
        $ = 7,
        ee = 0,
        te = 1,
        ne = 2,
        re = 0,
        ie = 1,
        oe = 2,
        ae = 3,
        se = 4,
        ce = 5,
        ue = 300,
        le = 301,
        fe = 302,
        de = 303,
        he = 304,
        ve = 305,
        pe = 306,
        me = 307,
        ye = 1e3,
        ge = 1001,
        xe = 1002,
        be = 1003,
        we = 1004,
        Me = 1004,
        _e = 1005,
        Se = 1005,
        Pe = 1006,
        Te = 1007,
        Ee = 1007,
        ze = 1008,
        Le = 1008,
        Ae = 1009,
        Ce = 1010,
        Re = 1011,
        Oe = 1012,
        je = 1013,
        Ie = 1014,
        De = 1015,
        ke = 1016,
        Fe = 1017,
        Ge = 1018,
        Ne = 1019,
        Be = 1020,
        Ue = 1021,
        He = 1022,
        Ve = 1023,
        We = 1024,
        Ye = 1025,
        Xe = Ve,
        qe = 1026,
        Ke = 1027,
        Ze = 1028,
        Je = 33776,
        Qe = 33777,
        $e = 33778,
        et = 33779,
        tt = 35840,
        nt = 35841,
        rt = 35842,
        it = 35843,
        ot = 36196,
        at = 37808,
        st = 37809,
        ct = 37810,
        ut = 37811,
        lt = 37812,
        ft = 37813,
        dt = 37814,
        ht = 37815,
        vt = 37816,
        pt = 37817,
        mt = 37818,
        yt = 37819,
        gt = 37820,
        xt = 37821,
        bt = 2200,
        wt = 2201,
        Mt = 2202,
        _t = 2300,
        St = 2301,
        Pt = 2302,
        Tt = 2400,
        Et = 2401,
        zt = 2402,
        Lt = 0,
        At = 1,
        Ct = 2,
        Rt = 3e3,
        Ot = 3001,
        jt = 3007,
        It = 3002,
        Dt = 3003,
        kt = 3004,
        Ft = 3005,
        Gt = 3006,
        Nt = 3200,
        Bt = 3201,
        Ut = 0,
        Ht = 1,
        Vt = 0,
        Wt = 7680,
        Yt = 7681,
        Xt = 7682,
        qt = 7683,
        Kt = 34055,
        Zt = 34056,
        Jt = 5386,
        Qt = 512,
        $t = 513,
        en = 514,
        tn = 515,
        nn = 516,
        rn = 517,
        on = 518,
        an = 519;

    function sn() {}
    Object.assign(sn.prototype, {
        addEventListener: function(e, t) {
            void 0 === this._listeners && (this._listeners = {});
            var n = this._listeners;
            void 0 === n[e] && (n[e] = []), -1 === n[e].indexOf(t) && n[e].push(t)
        },
        hasEventListener: function(e, t) {
            if (void 0 === this._listeners) return !1;
            var n = this._listeners;
            return void 0 !== n[e] && -1 !== n[e].indexOf(t)
        },
        removeEventListener: function(e, t) {
            if (void 0 !== this._listeners) {
                var n = this._listeners[e];
                if (void 0 !== n) {
                    var r = n.indexOf(t); - 1 !== r && n.splice(r, 1)
                }
            }
        },
        dispatchEvent: function(e) {
            if (void 0 !== this._listeners) {
                var t = this._listeners[e.type];
                if (void 0 !== t) {
                    e.target = this;
                    for (var n = t.slice(0), r = 0, i = n.length; r < i; r++) n[r].call(this, e)
                }
            }
        }
    });
    for (var cn = [], un = 0; un < 256; un++) cn[un] = (un < 16 ? "0" : "") + un.toString(16);
    var ln = {
        DEG2RAD: Math.PI / 180,
        RAD2DEG: 180 / Math.PI,
        generateUUID: function() {
            var e = 4294967295 * Math.random() | 0,
                t = 4294967295 * Math.random() | 0,
                n = 4294967295 * Math.random() | 0,
                r = 4294967295 * Math.random() | 0;
            return (cn[255 & e] + cn[e >> 8 & 255] + cn[e >> 16 & 255] + cn[e >> 24 & 255] + "-" + cn[255 & t] + cn[t >> 8 & 255] + "-" + cn[t >> 16 & 15 | 64] + cn[t >> 24 & 255] + "-" + cn[63 & n | 128] + cn[n >> 8 & 255] + "-" + cn[n >> 16 & 255] + cn[n >> 24 & 255] + cn[255 & r] + cn[r >> 8 & 255] + cn[r >> 16 & 255] + cn[r >> 24 & 255]).toUpperCase()
        },
        clamp: function(e, t, n) {
            return Math.max(t, Math.min(n, e))
        },
        euclideanModulo: function(e, t) {
            return (e % t + t) % t
        },
        mapLinear: function(e, t, n, r, i) {
            return r + (e - t) * (i - r) / (n - t)
        },
        lerp: function(e, t, n) {
            return (1 - n) * e + n * t
        },
        smoothstep: function(e, t, n) {
            return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t)) * e * (3 - 2 * e)
        },
        smootherstep: function(e, t, n) {
            return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t)) * e * e * (e * (6 * e - 15) + 10)
        },
        randInt: function(e, t) {
            return e + Math.floor(Math.random() * (t - e + 1))
        },
        randFloat: function(e, t) {
            return e + Math.random() * (t - e)
        },
        randFloatSpread: function(e) {
            return e * (.5 - Math.random())
        },
        degToRad: function(e) {
            return e * ln.DEG2RAD
        },
        radToDeg: function(e) {
            return e * ln.RAD2DEG
        },
        isPowerOfTwo: function(e) {
            return 0 == (e & e - 1) && 0 !== e
        },
        ceilPowerOfTwo: function(e) {
            return Math.pow(2, Math.ceil(Math.log(e) / Math.LN2))
        },
        floorPowerOfTwo: function(e) {
            return Math.pow(2, Math.floor(Math.log(e) / Math.LN2))
        }
    };

    function fn(e, t) {
        this.x = e || 0, this.y = t || 0
    }

    function dn(e, t, n, r) {
        this._x = e || 0, this._y = t || 0, this._z = n || 0, this._w = void 0 !== r ? r : 1
    }
    Object.defineProperties(fn.prototype, {
        width: {
            get: function() {
                return this.x
            },
            set: function(e) {
                this.x = e
            }
        },
        height: {
            get: function() {
                return this.y
            },
            set: function(e) {
                this.y = e
            }
        }
    }), Object.assign(fn.prototype, {
        isVector2: !0,
        set: function(e, t) {
            return this.x = e, this.y = t, this
        },
        setScalar: function(e) {
            return this.x = e, this.y = e, this
        },
        setX: function(e) {
            return this.x = e, this
        },
        setY: function(e) {
            return this.y = e, this
        },
        setComponent: function(e, t) {
            switch (e) {
                case 0:
                    this.x = t;
                    break;
                case 1:
                    this.y = t;
                    break;
                default:
                    throw new Error("index is out of range: " + e)
            }
            return this
        },
        getComponent: function(e) {
            switch (e) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                default:
                    throw new Error("index is out of range: " + e)
            }
        },
        clone: function() {
            return new this.constructor(this.x, this.y)
        },
        copy: function(e) {
            return this.x = e.x, this.y = e.y, this
        },
        add: function(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this)
        },
        addScalar: function(e) {
            return this.x += e, this.y += e, this
        },
        addVectors: function(e, t) {
            return this.x = e.x + t.x, this.y = e.y + t.y, this
        },
        addScaledVector: function(e, t) {
            return this.x += e.x * t, this.y += e.y * t, this
        },
        sub: function(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this)
        },
        subScalar: function(e) {
            return this.x -= e, this.y -= e, this
        },
        subVectors: function(e, t) {
            return this.x = e.x - t.x, this.y = e.y - t.y, this
        },
        multiply: function(e) {
            return this.x *= e.x, this.y *= e.y, this
        },
        multiplyScalar: function(e) {
            return this.x *= e, this.y *= e, this
        },
        divide: function(e) {
            return this.x /= e.x, this.y /= e.y, this
        },
        divideScalar: function(e) {
            return this.multiplyScalar(1 / e)
        },
        applyMatrix3: function(e) {
            var t = this.x,
                n = this.y,
                r = e.elements;
            return this.x = r[0] * t + r[3] * n + r[6], this.y = r[1] * t + r[4] * n + r[7], this
        },
        min: function(e) {
            return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this
        },
        max: function(e) {
            return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this
        },
        clamp: function(e, t) {
            return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this
        },
        clampScalar: function(e, t) {
            return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this
        },
        clampLength: function(e, t) {
            var n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
        },
        floor: function() {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
        },
        ceil: function() {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
        },
        round: function() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this
        },
        roundToZero: function() {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this
        },
        negate: function() {
            return this.x = -this.x, this.y = -this.y, this
        },
        dot: function(e) {
            return this.x * e.x + this.y * e.y
        },
        cross: function(e) {
            return this.x * e.y - this.y * e.x
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y)
        },
        manhattanLength: function() {
            return Math.abs(this.x) + Math.abs(this.y)
        },
        normalize: function() {
            return this.divideScalar(this.length() || 1)
        },
        angle: function() {
            var e = Math.atan2(this.y, this.x);
            return e < 0 && (e += 2 * Math.PI), e
        },
        distanceTo: function(e) {
            return Math.sqrt(this.distanceToSquared(e))
        },
        distanceToSquared: function(e) {
            var t = this.x - e.x,
                n = this.y - e.y;
            return t * t + n * n
        },
        manhattanDistanceTo: function(e) {
            return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
        },
        setLength: function(e) {
            return this.normalize().multiplyScalar(e)
        },
        lerp: function(e, t) {
            return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this
        },
        lerpVectors: function(e, t, n) {
            return this.subVectors(t, e).multiplyScalar(n).add(e)
        },
        equals: function(e) {
            return e.x === this.x && e.y === this.y
        },
        fromArray: function(e, t) {
            return void 0 === t && (t = 0), this.x = e[t], this.y = e[t + 1], this
        },
        toArray: function(e, t) {
            return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.x, e[t + 1] = this.y, e
        },
        fromBufferAttribute: function(e, t, n) {
            return void 0 !== n && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this
        },
        rotateAround: function(e, t) {
            var n = Math.cos(t),
                r = Math.sin(t),
                i = this.x - e.x,
                o = this.y - e.y;
            return this.x = i * n - o * r + e.x, this.y = i * r + o * n + e.y, this
        }
    }), Object.assign(dn, {
        slerp: function(e, t, n, r) {
            return n.copy(e).slerp(t, r)
        },
        slerpFlat: function(e, t, n, r, i, o, a) {
            var s = n[r + 0],
                c = n[r + 1],
                u = n[r + 2],
                l = n[r + 3],
                f = i[o + 0],
                d = i[o + 1],
                h = i[o + 2],
                v = i[o + 3];
            if (l !== v || s !== f || c !== d || u !== h) {
                var p = 1 - a,
                    m = s * f + c * d + u * h + l * v,
                    y = m >= 0 ? 1 : -1,
                    g = 1 - m * m;
                if (g > Number.EPSILON) {
                    var x = Math.sqrt(g),
                        b = Math.atan2(x, m * y);
                    p = Math.sin(p * b) / x, a = Math.sin(a * b) / x
                }
                var w = a * y;
                if (s = s * p + f * w, c = c * p + d * w, u = u * p + h * w, l = l * p + v * w, p === 1 - a) {
                    var M = 1 / Math.sqrt(s * s + c * c + u * u + l * l);
                    s *= M, c *= M, u *= M, l *= M
                }
            }
            e[t] = s, e[t + 1] = c, e[t + 2] = u, e[t + 3] = l
        }
    }), Object.defineProperties(dn.prototype, {
        x: {
            get: function() {
                return this._x
            },
            set: function(e) {
                this._x = e, this._onChangeCallback()
            }
        },
        y: {
            get: function() {
                return this._y
            },
            set: function(e) {
                this._y = e, this._onChangeCallback()
            }
        },
        z: {
            get: function() {
                return this._z
            },
            set: function(e) {
                this._z = e, this._onChangeCallback()
            }
        },
        w: {
            get: function() {
                return this._w
            },
            set: function(e) {
                this._w = e, this._onChangeCallback()
            }
        }
    }), Object.assign(dn.prototype, {
        isQuaternion: !0,
        set: function(e, t, n, r) {
            return this._x = e, this._y = t, this._z = n, this._w = r, this._onChangeCallback(), this
        },
        clone: function() {
            return new this.constructor(this._x, this._y, this._z, this._w)
        },
        copy: function(e) {
            return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this
        },
        setFromEuler: function(e, t) {
            if (!e || !e.isEuler) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
            var n = e._x,
                r = e._y,
                i = e._z,
                o = e.order,
                a = Math.cos,
                s = Math.sin,
                c = a(n / 2),
                u = a(r / 2),
                l = a(i / 2),
                f = s(n / 2),
                d = s(r / 2),
                h = s(i / 2);
            return "XYZ" === o ? (this._x = f * u * l + c * d * h, this._y = c * d * l - f * u * h, this._z = c * u * h + f * d * l, this._w = c * u * l - f * d * h) : "YXZ" === o ? (this._x = f * u * l + c * d * h, this._y = c * d * l - f * u * h, this._z = c * u * h - f * d * l, this._w = c * u * l + f * d * h) : "ZXY" === o ? (this._x = f * u * l - c * d * h, this._y = c * d * l + f * u * h, this._z = c * u * h + f * d * l, this._w = c * u * l - f * d * h) : "ZYX" === o ? (this._x = f * u * l - c * d * h, this._y = c * d * l + f * u * h, this._z = c * u * h - f * d * l, this._w = c * u * l + f * d * h) : "YZX" === o ? (this._x = f * u * l + c * d * h, this._y = c * d * l + f * u * h, this._z = c * u * h - f * d * l, this._w = c * u * l - f * d * h) : "XZY" === o && (this._x = f * u * l - c * d * h, this._y = c * d * l - f * u * h, this._z = c * u * h + f * d * l, this._w = c * u * l + f * d * h), !1 !== t && this._onChangeCallback(), this
        },
        setFromAxisAngle: function(e, t) {
            var n = t / 2,
                r = Math.sin(n);
            return this._x = e.x * r, this._y = e.y * r, this._z = e.z * r, this._w = Math.cos(n), this._onChangeCallback(), this
        },
        setFromRotationMatrix: function(e) {
            var t, n = e.elements,
                r = n[0],
                i = n[4],
                o = n[8],
                a = n[1],
                s = n[5],
                c = n[9],
                u = n[2],
                l = n[6],
                f = n[10],
                d = r + s + f;
            return d > 0 ? (t = .5 / Math.sqrt(d + 1), this._w = .25 / t, this._x = (l - c) * t, this._y = (o - u) * t, this._z = (a - i) * t) : r > s && r > f ? (t = 2 * Math.sqrt(1 + r - s - f), this._w = (l - c) / t, this._x = .25 * t, this._y = (i + a) / t, this._z = (o + u) / t) : s > f ? (t = 2 * Math.sqrt(1 + s - r - f), this._w = (o - u) / t, this._x = (i + a) / t, this._y = .25 * t, this._z = (c + l) / t) : (t = 2 * Math.sqrt(1 + f - r - s), this._w = (a - i) / t, this._x = (o + u) / t, this._y = (c + l) / t, this._z = .25 * t), this._onChangeCallback(), this
        },
        setFromUnitVectors: function(e, t) {
            var n = e.dot(t) + 1;
            return n < 1e-6 ? (n = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = n)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x, this._w = n), this.normalize()
        },
        angleTo: function(e) {
            return 2 * Math.acos(Math.abs(ln.clamp(this.dot(e), -1, 1)))
        },
        rotateTowards: function(e, t) {
            var n = this.angleTo(e);
            if (0 === n) return this;
            var r = Math.min(1, t / n);
            return this.slerp(e, r), this
        },
        inverse: function() {
            return this.conjugate()
        },
        conjugate: function() {
            return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this
        },
        dot: function(e) {
            return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
        },
        lengthSq: function() {
            return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
        },
        length: function() {
            return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
        },
        normalize: function() {
            var e = this.length();
            return 0 === e ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this
        },
        multiply: function(e, t) {
            return void 0 !== t ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(e, t)) : this.multiplyQuaternions(this, e)
        },
        premultiply: function(e) {
            return this.multiplyQuaternions(e, this)
        },
        multiplyQuaternions: function(e, t) {
            var n = e._x,
                r = e._y,
                i = e._z,
                o = e._w,
                a = t._x,
                s = t._y,
                c = t._z,
                u = t._w;
            return this._x = n * u + o * a + r * c - i * s, this._y = r * u + o * s + i * a - n * c, this._z = i * u + o * c + n * s - r * a, this._w = o * u - n * a - r * s - i * c, this._onChangeCallback(), this
        },
        slerp: function(e, t) {
            if (0 === t) return this;
            if (1 === t) return this.copy(e);
            var n = this._x,
                r = this._y,
                i = this._z,
                o = this._w,
                a = o * e._w + n * e._x + r * e._y + i * e._z;
            if (a < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, a = -a) : this.copy(e), a >= 1) return this._w = o, this._x = n, this._y = r, this._z = i, this;
            var s = 1 - a * a;
            if (s <= Number.EPSILON) {
                var c = 1 - t;
                return this._w = c * o + t * this._w, this._x = c * n + t * this._x, this._y = c * r + t * this._y, this._z = c * i + t * this._z, this.normalize(), this._onChangeCallback(), this
            }
            var u = Math.sqrt(s),
                l = Math.atan2(u, a),
                f = Math.sin((1 - t) * l) / u,
                d = Math.sin(t * l) / u;
            return this._w = o * f + this._w * d, this._x = n * f + this._x * d, this._y = r * f + this._y * d, this._z = i * f + this._z * d, this._onChangeCallback(), this
        },
        equals: function(e) {
            return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
        },
        fromArray: function(e, t) {
            return void 0 === t && (t = 0), this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this
        },
        toArray: function(e, t) {
            return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e
        },
        _onChange: function(e) {
            return this._onChangeCallback = e, this
        },
        _onChangeCallback: function() {}
    });
    var hn = new pn,
        vn = new dn;

    function pn(e, t, n) {
        this.x = e || 0, this.y = t || 0, this.z = n || 0
    }
    Object.assign(pn.prototype, {
        isVector3: !0,
        set: function(e, t, n) {
            return this.x = e, this.y = t, this.z = n, this
        },
        setScalar: function(e) {
            return this.x = e, this.y = e, this.z = e, this
        },
        setX: function(e) {
            return this.x = e, this
        },
        setY: function(e) {
            return this.y = e, this
        },
        setZ: function(e) {
            return this.z = e, this
        },
        setComponent: function(e, t) {
            switch (e) {
                case 0:
                    this.x = t;
                    break;
                case 1:
                    this.y = t;
                    break;
                case 2:
                    this.z = t;
                    break;
                default:
                    throw new Error("index is out of range: " + e)
            }
            return this
        },
        getComponent: function(e) {
            switch (e) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                default:
                    throw new Error("index is out of range: " + e)
            }
        },
        clone: function() {
            return new this.constructor(this.x, this.y, this.z)
        },
        copy: function(e) {
            return this.x = e.x, this.y = e.y, this.z = e.z, this
        },
        add: function(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this)
        },
        addScalar: function(e) {
            return this.x += e, this.y += e, this.z += e, this
        },
        addVectors: function(e, t) {
            return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this
        },
        addScaledVector: function(e, t) {
            return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this
        },
        sub: function(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this)
        },
        subScalar: function(e) {
            return this.x -= e, this.y -= e, this.z -= e, this
        },
        subVectors: function(e, t) {
            return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this
        },
        multiply: function(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(e, t)) : (this.x *= e.x, this.y *= e.y, this.z *= e.z, this)
        },
        multiplyScalar: function(e) {
            return this.x *= e, this.y *= e, this.z *= e, this
        },
        multiplyVectors: function(e, t) {
            return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this
        },
        applyEuler: function(e) {
            return e && e.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(vn.setFromEuler(e))
        },
        applyAxisAngle: function(e, t) {
            return this.applyQuaternion(vn.setFromAxisAngle(e, t))
        },
        applyMatrix3: function(e) {
            var t = this.x,
                n = this.y,
                r = this.z,
                i = e.elements;
            return this.x = i[0] * t + i[3] * n + i[6] * r, this.y = i[1] * t + i[4] * n + i[7] * r, this.z = i[2] * t + i[5] * n + i[8] * r, this
        },
        applyMatrix4: function(e) {
            var t = this.x,
                n = this.y,
                r = this.z,
                i = e.elements,
                o = 1 / (i[3] * t + i[7] * n + i[11] * r + i[15]);
            return this.x = (i[0] * t + i[4] * n + i[8] * r + i[12]) * o, this.y = (i[1] * t + i[5] * n + i[9] * r + i[13]) * o, this.z = (i[2] * t + i[6] * n + i[10] * r + i[14]) * o, this
        },
        applyQuaternion: function(e) {
            var t = this.x,
                n = this.y,
                r = this.z,
                i = e.x,
                o = e.y,
                a = e.z,
                s = e.w,
                c = s * t + o * r - a * n,
                u = s * n + a * t - i * r,
                l = s * r + i * n - o * t,
                f = -i * t - o * n - a * r;
            return this.x = c * s + f * -i + u * -a - l * -o, this.y = u * s + f * -o + l * -i - c * -a, this.z = l * s + f * -a + c * -o - u * -i, this
        },
        project: function(e) {
            return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)
        },
        unproject: function(e) {
            return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)
        },
        transformDirection: function(e) {
            var t = this.x,
                n = this.y,
                r = this.z,
                i = e.elements;
            return this.x = i[0] * t + i[4] * n + i[8] * r, this.y = i[1] * t + i[5] * n + i[9] * r, this.z = i[2] * t + i[6] * n + i[10] * r, this.normalize()
        },
        divide: function(e) {
            return this.x /= e.x, this.y /= e.y, this.z /= e.z, this
        },
        divideScalar: function(e) {
            return this.multiplyScalar(1 / e)
        },
        min: function(e) {
            return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this
        },
        max: function(e) {
            return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this
        },
        clamp: function(e, t) {
            return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this
        },
        clampScalar: function(e, t) {
            return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this
        },
        clampLength: function(e, t) {
            var n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
        },
        floor: function() {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
        },
        ceil: function() {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
        },
        round: function() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
        },
        roundToZero: function() {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this
        },
        negate: function() {
            return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
        },
        dot: function(e) {
            return this.x * e.x + this.y * e.y + this.z * e.z
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y + this.z * this.z
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
        },
        manhattanLength: function() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
        },
        normalize: function() {
            return this.divideScalar(this.length() || 1)
        },
        setLength: function(e) {
            return this.normalize().multiplyScalar(e)
        },
        lerp: function(e, t) {
            return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this
        },
        lerpVectors: function(e, t, n) {
            return this.subVectors(t, e).multiplyScalar(n).add(e)
        },
        cross: function(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(e, t)) : this.crossVectors(this, e)
        },
        crossVectors: function(e, t) {
            var n = e.x,
                r = e.y,
                i = e.z,
                o = t.x,
                a = t.y,
                s = t.z;
            return this.x = r * s - i * a, this.y = i * o - n * s, this.z = n * a - r * o, this
        },
        projectOnVector: function(e) {
            var t = e.dot(this) / e.lengthSq();
            return this.copy(e).multiplyScalar(t)
        },
        projectOnPlane: function(e) {
            return hn.copy(this).projectOnVector(e), this.sub(hn)
        },
        reflect: function(e) {
            return this.sub(hn.copy(e).multiplyScalar(2 * this.dot(e)))
        },
        angleTo: function(e) {
            var t = Math.sqrt(this.lengthSq() * e.lengthSq());
            0 === t && console.error("THREE.Vector3: angleTo() can't handle zero length vectors.");
            var n = this.dot(e) / t;
            return Math.acos(ln.clamp(n, -1, 1))
        },
        distanceTo: function(e) {
            return Math.sqrt(this.distanceToSquared(e))
        },
        distanceToSquared: function(e) {
            var t = this.x - e.x,
                n = this.y - e.y,
                r = this.z - e.z;
            return t * t + n * n + r * r
        },
        manhattanDistanceTo: function(e) {
            return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
        },
        setFromSpherical: function(e) {
            return this.setFromSphericalCoords(e.radius, e.phi, e.theta)
        },
        setFromSphericalCoords: function(e, t, n) {
            var r = Math.sin(t) * e;
            return this.x = r * Math.sin(n), this.y = Math.cos(t) * e, this.z = r * Math.cos(n), this
        },
        setFromCylindrical: function(e) {
            return this.setFromCylindricalCoords(e.radius, e.theta, e.y)
        },
        setFromCylindricalCoords: function(e, t, n) {
            return this.x = e * Math.sin(t), this.y = n, this.z = e * Math.cos(t), this
        },
        setFromMatrixPosition: function(e) {
            var t = e.elements;
            return this.x = t[12], this.y = t[13], this.z = t[14], this
        },
        setFromMatrixScale: function(e) {
            var t = this.setFromMatrixColumn(e, 0).length(),
                n = this.setFromMatrixColumn(e, 1).length(),
                r = this.setFromMatrixColumn(e, 2).length();
            return this.x = t, this.y = n, this.z = r, this
        },
        setFromMatrixColumn: function(e, t) {
            return this.fromArray(e.elements, 4 * t)
        },
        equals: function(e) {
            return e.x === this.x && e.y === this.y && e.z === this.z
        },
        fromArray: function(e, t) {
            return void 0 === t && (t = 0), this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this
        },
        toArray: function(e, t) {
            return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e
        },
        fromBufferAttribute: function(e, t, n) {
            return void 0 !== n && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this
        }
    });
    var mn, yn = new pn;

    function gn() {
        this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
    }
    Object.assign(gn.prototype, {
        isMatrix3: !0,
        set: function(e, t, n, r, i, o, a, s, c) {
            var u = this.elements;
            return u[0] = e, u[1] = r, u[2] = a, u[3] = t, u[4] = i, u[5] = s, u[6] = n, u[7] = o, u[8] = c, this
        },
        identity: function() {
            return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
        },
        clone: function() {
            return (new this.constructor).fromArray(this.elements)
        },
        copy: function(e) {
            var t = this.elements,
                n = e.elements;
            return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], this
        },
        setFromMatrix4: function(e) {
            var t = e.elements;
            return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this
        },
        applyToBufferAttribute: function(e) {
            for (var t = 0, n = e.count; t < n; t++) yn.x = e.getX(t), yn.y = e.getY(t), yn.z = e.getZ(t), yn.applyMatrix3(this), e.setXYZ(t, yn.x, yn.y, yn.z);
            return e
        },
        multiply: function(e) {
            return this.multiplyMatrices(this, e)
        },
        premultiply: function(e) {
            return this.multiplyMatrices(e, this)
        },
        multiplyMatrices: function(e, t) {
            var n = e.elements,
                r = t.elements,
                i = this.elements,
                o = n[0],
                a = n[3],
                s = n[6],
                c = n[1],
                u = n[4],
                l = n[7],
                f = n[2],
                d = n[5],
                h = n[8],
                v = r[0],
                p = r[3],
                m = r[6],
                y = r[1],
                g = r[4],
                x = r[7],
                b = r[2],
                w = r[5],
                M = r[8];
            return i[0] = o * v + a * y + s * b, i[3] = o * p + a * g + s * w, i[6] = o * m + a * x + s * M, i[1] = c * v + u * y + l * b, i[4] = c * p + u * g + l * w, i[7] = c * m + u * x + l * M, i[2] = f * v + d * y + h * b, i[5] = f * p + d * g + h * w, i[8] = f * m + d * x + h * M, this
        },
        multiplyScalar: function(e) {
            var t = this.elements;
            return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this
        },
        determinant: function() {
            var e = this.elements,
                t = e[0],
                n = e[1],
                r = e[2],
                i = e[3],
                o = e[4],
                a = e[5],
                s = e[6],
                c = e[7],
                u = e[8];
            return t * o * u - t * a * c - n * i * u + n * a * s + r * i * c - r * o * s
        },
        getInverse: function(e, t) {
            e && e.isMatrix4 && console.error("THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.");
            var n = e.elements,
                r = this.elements,
                i = n[0],
                o = n[1],
                a = n[2],
                s = n[3],
                c = n[4],
                u = n[5],
                l = n[6],
                f = n[7],
                d = n[8],
                h = d * c - u * f,
                v = u * l - d * s,
                p = f * s - c * l,
                m = i * h + o * v + a * p;
            if (0 === m) {
                var y = "THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0";
                if (!0 === t) throw new Error(y);
                return console.warn(y), this.identity()
            }
            var g = 1 / m;
            return r[0] = h * g, r[1] = (a * f - d * o) * g, r[2] = (u * o - a * c) * g, r[3] = v * g, r[4] = (d * i - a * l) * g, r[5] = (a * s - u * i) * g, r[6] = p * g, r[7] = (o * l - f * i) * g, r[8] = (c * i - o * s) * g, this
        },
        transpose: function() {
            var e, t = this.elements;
            return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this
        },
        getNormalMatrix: function(e) {
            return this.setFromMatrix4(e).getInverse(this).transpose()
        },
        transposeIntoArray: function(e) {
            var t = this.elements;
            return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this
        },
        setUvTransform: function(e, t, n, r, i, o, a) {
            var s = Math.cos(i),
                c = Math.sin(i);
            this.set(n * s, n * c, -n * (s * o + c * a) + o + e, -r * c, r * s, -r * (-c * o + s * a) + a + t, 0, 0, 1)
        },
        scale: function(e, t) {
            var n = this.elements;
            return n[0] *= e, n[3] *= e, n[6] *= e, n[1] *= t, n[4] *= t, n[7] *= t, this
        },
        rotate: function(e) {
            var t = Math.cos(e),
                n = Math.sin(e),
                r = this.elements,
                i = r[0],
                o = r[3],
                a = r[6],
                s = r[1],
                c = r[4],
                u = r[7];
            return r[0] = t * i + n * s, r[3] = t * o + n * c, r[6] = t * a + n * u, r[1] = -n * i + t * s, r[4] = -n * o + t * c, r[7] = -n * a + t * u, this
        },
        translate: function(e, t) {
            var n = this.elements;
            return n[0] += e * n[2], n[3] += e * n[5], n[6] += e * n[8], n[1] += t * n[2], n[4] += t * n[5], n[7] += t * n[8], this
        },
        equals: function(e) {
            for (var t = this.elements, n = e.elements, r = 0; r < 9; r++)
                if (t[r] !== n[r]) return !1;
            return !0
        },
        fromArray: function(e, t) {
            void 0 === t && (t = 0);
            for (var n = 0; n < 9; n++) this.elements[n] = e[n + t];
            return this
        },
        toArray: function(e, t) {
            void 0 === e && (e = []), void 0 === t && (t = 0);
            var n = this.elements;
            return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e
        }
    });
    var xn = {
            getDataURL: function(e) {
                var t;
                if ("undefined" == typeof HTMLCanvasElement) return e.src;
                if (e instanceof HTMLCanvasElement) t = e;
                else {
                    void 0 === mn && (mn = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")), mn.width = e.width, mn.height = e.height;
                    var n = mn.getContext("2d");
                    e instanceof ImageData ? n.putImageData(e, 0, 0) : n.drawImage(e, 0, 0, e.width, e.height), t = mn
                }
                return t.width > 2048 || t.height > 2048 ? t.toDataURL("image/jpeg", .6) : t.toDataURL("image/png")
            }
        },
        bn = 0;

    function wn(e, t, n, r, i, o, a, s, c, u) {
        Object.defineProperty(this, "id", {
            value: bn++
        }), this.uuid = ln.generateUUID(), this.name = "", this.image = void 0 !== e ? e : wn.DEFAULT_IMAGE, this.mipmaps = [], this.mapping = void 0 !== t ? t : wn.DEFAULT_MAPPING, this.wrapS = void 0 !== n ? n : ge, this.wrapT = void 0 !== r ? r : ge, this.magFilter = void 0 !== i ? i : Pe, this.minFilter = void 0 !== o ? o : ze, this.anisotropy = void 0 !== c ? c : 1, this.format = void 0 !== a ? a : Ve, this.type = void 0 !== s ? s : Ae, this.offset = new fn(0, 0), this.repeat = new fn(1, 1), this.center = new fn(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new gn, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = void 0 !== u ? u : Rt, this.version = 0, this.onUpdate = null
    }

    function Mn(e, t, n, r) {
        this.x = e || 0, this.y = t || 0, this.z = n || 0, this.w = void 0 !== r ? r : 1
    }

    function _n(e, t, n) {
        this.width = e, this.height = t, this.scissor = new Mn(0, 0, e, t), this.scissorTest = !1, this.viewport = new Mn(0, 0, e, t), n = n || {}, this.texture = new wn(void 0, void 0, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding), this.texture.image = {}, this.texture.image.width = e, this.texture.image.height = t, this.texture.generateMipmaps = void 0 !== n.generateMipmaps && n.generateMipmaps, this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : Pe, this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer, this.stencilBuffer = void 0 === n.stencilBuffer || n.stencilBuffer, this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null
    }

    function Sn(e, t, n) {
        _n.call(this, e, t, n), this.samples = 4
    }
    wn.DEFAULT_IMAGE = void 0, wn.DEFAULT_MAPPING = ue, wn.prototype = Object.assign(Object.create(sn.prototype), {
        constructor: wn,
        isTexture: !0,
        updateMatrix: function() {
            this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.name = e.name, this.image = e.image, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.encoding = e.encoding, this
        },
        toJSON: function(e) {
            var t = void 0 === e || "string" == typeof e;
            if (!t && void 0 !== e.textures[this.uuid]) return e.textures[this.uuid];
            var n = {
                metadata: {
                    version: 4.5,
                    type: "Texture",
                    generator: "Texture.toJSON"
                },
                uuid: this.uuid,
                name: this.name,
                mapping: this.mapping,
                repeat: [this.repeat.x, this.repeat.y],
                offset: [this.offset.x, this.offset.y],
                center: [this.center.x, this.center.y],
                rotation: this.rotation,
                wrap: [this.wrapS, this.wrapT],
                format: this.format,
                type: this.type,
                encoding: this.encoding,
                minFilter: this.minFilter,
                magFilter: this.magFilter,
                anisotropy: this.anisotropy,
                flipY: this.flipY,
                premultiplyAlpha: this.premultiplyAlpha,
                unpackAlignment: this.unpackAlignment
            };
            if (void 0 !== this.image) {
                var r = this.image;
                if (void 0 === r.uuid && (r.uuid = ln.generateUUID()), !t && void 0 === e.images[r.uuid]) {
                    var i;
                    if (Array.isArray(r)) {
                        i = [];
                        for (var o = 0, a = r.length; o < a; o++) i.push(xn.getDataURL(r[o]))
                    } else i = xn.getDataURL(r);
                    e.images[r.uuid] = {
                        uuid: r.uuid,
                        url: i
                    }
                }
                n.image = r.uuid
            }
            return t || (e.textures[this.uuid] = n), n
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        },
        transformUv: function(e) {
            if (this.mapping !== ue) return e;
            if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1) switch (this.wrapS) {
                case ye:
                    e.x = e.x - Math.floor(e.x);
                    break;
                case ge:
                    e.x = e.x < 0 ? 0 : 1;
                    break;
                case xe:
                    1 === Math.abs(Math.floor(e.x) % 2) ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x)
            }
            if (e.y < 0 || e.y > 1) switch (this.wrapT) {
                case ye:
                    e.y = e.y - Math.floor(e.y);
                    break;
                case ge:
                    e.y = e.y < 0 ? 0 : 1;
                    break;
                case xe:
                    1 === Math.abs(Math.floor(e.y) % 2) ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y)
            }
            return this.flipY && (e.y = 1 - e.y), e
        }
    }), Object.defineProperty(wn.prototype, "needsUpdate", {
        set: function(e) {
            !0 === e && this.version++
        }
    }), Object.defineProperties(Mn.prototype, {
        width: {
            get: function() {
                return this.z
            },
            set: function(e) {
                this.z = e
            }
        },
        height: {
            get: function() {
                return this.w
            },
            set: function(e) {
                this.w = e
            }
        }
    }), Object.assign(Mn.prototype, {
        isVector4: !0,
        set: function(e, t, n, r) {
            return this.x = e, this.y = t, this.z = n, this.w = r, this
        },
        setScalar: function(e) {
            return this.x = e, this.y = e, this.z = e, this.w = e, this
        },
        setX: function(e) {
            return this.x = e, this
        },
        setY: function(e) {
            return this.y = e, this
        },
        setZ: function(e) {
            return this.z = e, this
        },
        setW: function(e) {
            return this.w = e, this
        },
        setComponent: function(e, t) {
            switch (e) {
                case 0:
                    this.x = t;
                    break;
                case 1:
                    this.y = t;
                    break;
                case 2:
                    this.z = t;
                    break;
                case 3:
                    this.w = t;
                    break;
                default:
                    throw new Error("index is out of range: " + e)
            }
            return this
        },
        getComponent: function(e) {
            switch (e) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                case 3:
                    return this.w;
                default:
                    throw new Error("index is out of range: " + e)
            }
        },
        clone: function() {
            return new this.constructor(this.x, this.y, this.z, this.w)
        },
        copy: function(e) {
            return this.x = e.x, this.y = e.y, this.z = e.z, this.w = void 0 !== e.w ? e.w : 1, this
        },
        add: function(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this)
        },
        addScalar: function(e) {
            return this.x += e, this.y += e, this.z += e, this.w += e, this
        },
        addVectors: function(e, t) {
            return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this
        },
        addScaledVector: function(e, t) {
            return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this
        },
        sub: function(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this)
        },
        subScalar: function(e) {
            return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this
        },
        subVectors: function(e, t) {
            return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this
        },
        multiplyScalar: function(e) {
            return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this
        },
        applyMatrix4: function(e) {
            var t = this.x,
                n = this.y,
                r = this.z,
                i = this.w,
                o = e.elements;
            return this.x = o[0] * t + o[4] * n + o[8] * r + o[12] * i, this.y = o[1] * t + o[5] * n + o[9] * r + o[13] * i, this.z = o[2] * t + o[6] * n + o[10] * r + o[14] * i, this.w = o[3] * t + o[7] * n + o[11] * r + o[15] * i, this
        },
        divideScalar: function(e) {
            return this.multiplyScalar(1 / e)
        },
        setAxisAngleFromQuaternion: function(e) {
            this.w = 2 * Math.acos(e.w);
            var t = Math.sqrt(1 - e.w * e.w);
            return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this
        },
        setAxisAngleFromRotationMatrix: function(e) {
            var t, n, r, i, o = e.elements,
                a = o[0],
                s = o[4],
                c = o[8],
                u = o[1],
                l = o[5],
                f = o[9],
                d = o[2],
                h = o[6],
                v = o[10];
            if (Math.abs(s - u) < .01 && Math.abs(c - d) < .01 && Math.abs(f - h) < .01) {
                if (Math.abs(s + u) < .1 && Math.abs(c + d) < .1 && Math.abs(f + h) < .1 && Math.abs(a + l + v - 3) < .1) return this.set(1, 0, 0, 0), this;
                t = Math.PI;
                var p = (a + 1) / 2,
                    m = (l + 1) / 2,
                    y = (v + 1) / 2,
                    g = (s + u) / 4,
                    x = (c + d) / 4,
                    b = (f + h) / 4;
                return p > m && p > y ? p < .01 ? (n = 0, r = .707106781, i = .707106781) : (r = g / (n = Math.sqrt(p)), i = x / n) : m > y ? m < .01 ? (n = .707106781, r = 0, i = .707106781) : (n = g / (r = Math.sqrt(m)), i = b / r) : y < .01 ? (n = .707106781, r = .707106781, i = 0) : (n = x / (i = Math.sqrt(y)), r = b / i), this.set(n, r, i, t), this
            }
            var w = Math.sqrt((h - f) * (h - f) + (c - d) * (c - d) + (u - s) * (u - s));
            return Math.abs(w) < .001 && (w = 1), this.x = (h - f) / w, this.y = (c - d) / w, this.z = (u - s) / w, this.w = Math.acos((a + l + v - 1) / 2), this
        },
        min: function(e) {
            return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this
        },
        max: function(e) {
            return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this
        },
        clamp: function(e, t) {
            return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), this
        },
        clampScalar: function(e, t) {
            return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this.w = Math.max(e, Math.min(t, this.w)), this
        },
        clampLength: function(e, t) {
            var n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
        },
        floor: function() {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
        },
        ceil: function() {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
        },
        round: function() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
        },
        roundToZero: function() {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this
        },
        negate: function() {
            return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
        },
        dot: function(e) {
            return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
        },
        manhattanLength: function() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
        },
        normalize: function() {
            return this.divideScalar(this.length() || 1)
        },
        setLength: function(e) {
            return this.normalize().multiplyScalar(e)
        },
        lerp: function(e, t) {
            return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this
        },
        lerpVectors: function(e, t, n) {
            return this.subVectors(t, e).multiplyScalar(n).add(e)
        },
        equals: function(e) {
            return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
        },
        fromArray: function(e, t) {
            return void 0 === t && (t = 0), this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this
        },
        toArray: function(e, t) {
            return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e
        },
        fromBufferAttribute: function(e, t, n) {
            return void 0 !== n && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this
        }
    }), _n.prototype = Object.assign(Object.create(sn.prototype), {
        constructor: _n,
        isWebGLRenderTarget: !0,
        setSize: function(e, t) {
            this.width === e && this.height === t || (this.width = e, this.height = t, this.texture.image.width = e, this.texture.image.height = t, this.dispose()), this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t)
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.width = e.width, this.height = e.height, this.viewport.copy(e.viewport), this.texture = e.texture.clone(), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.depthTexture = e.depthTexture, this
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }), Sn.prototype = Object.assign(Object.create(_n.prototype), {
        constructor: Sn,
        isWebGLMultisampleRenderTarget: !0,
        copy: function(e) {
            return _n.prototype.copy.call(this, e), this.samples = e.samples, this
        }
    });
    var Pn = new pn,
        Tn = new Rn,
        En = new pn(0, 0, 0),
        zn = new pn(1, 1, 1),
        Ln = new pn,
        An = new pn,
        Cn = new pn;

    function Rn() {
        this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
    }
    Object.assign(Rn.prototype, {
        isMatrix4: !0,
        set: function(e, t, n, r, i, o, a, s, c, u, l, f, d, h, v, p) {
            var m = this.elements;
            return m[0] = e, m[4] = t, m[8] = n, m[12] = r, m[1] = i, m[5] = o, m[9] = a, m[13] = s, m[2] = c, m[6] = u, m[10] = l, m[14] = f, m[3] = d, m[7] = h, m[11] = v, m[15] = p, this
        },
        identity: function() {
            return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
        },
        clone: function() {
            return (new Rn).fromArray(this.elements)
        },
        copy: function(e) {
            var t = this.elements,
                n = e.elements;
            return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], t[9] = n[9], t[10] = n[10], t[11] = n[11], t[12] = n[12], t[13] = n[13], t[14] = n[14], t[15] = n[15], this
        },
        copyPosition: function(e) {
            var t = this.elements,
                n = e.elements;
            return t[12] = n[12], t[13] = n[13], t[14] = n[14], this
        },
        extractBasis: function(e, t, n) {
            return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this
        },
        makeBasis: function(e, t, n) {
            return this.set(e.x, t.x, n.x, 0, e.y, t.y, n.y, 0, e.z, t.z, n.z, 0, 0, 0, 0, 1), this
        },
        extractRotation: function(e) {
            var t = this.elements,
                n = e.elements,
                r = 1 / Pn.setFromMatrixColumn(e, 0).length(),
                i = 1 / Pn.setFromMatrixColumn(e, 1).length(),
                o = 1 / Pn.setFromMatrixColumn(e, 2).length();
            return t[0] = n[0] * r, t[1] = n[1] * r, t[2] = n[2] * r, t[3] = 0, t[4] = n[4] * i, t[5] = n[5] * i, t[6] = n[6] * i, t[7] = 0, t[8] = n[8] * o, t[9] = n[9] * o, t[10] = n[10] * o, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
        },
        makeRotationFromEuler: function(e) {
            e && e.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
            var t = this.elements,
                n = e.x,
                r = e.y,
                i = e.z,
                o = Math.cos(n),
                a = Math.sin(n),
                s = Math.cos(r),
                c = Math.sin(r),
                u = Math.cos(i),
                l = Math.sin(i);
            if ("XYZ" === e.order) {
                var f = o * u,
                    d = o * l,
                    h = a * u,
                    v = a * l;
                t[0] = s * u, t[4] = -s * l, t[8] = c, t[1] = d + h * c, t[5] = f - v * c, t[9] = -a * s, t[2] = v - f * c, t[6] = h + d * c, t[10] = o * s
            } else if ("YXZ" === e.order) {
                var p = s * u,
                    m = s * l,
                    y = c * u,
                    g = c * l;
                t[0] = p + g * a, t[4] = y * a - m, t[8] = o * c, t[1] = o * l, t[5] = o * u, t[9] = -a, t[2] = m * a - y, t[6] = g + p * a, t[10] = o * s
            } else if ("ZXY" === e.order) {
                p = s * u, m = s * l, y = c * u, g = c * l;
                t[0] = p - g * a, t[4] = -o * l, t[8] = y + m * a, t[1] = m + y * a, t[5] = o * u, t[9] = g - p * a, t[2] = -o * c, t[6] = a, t[10] = o * s
            } else if ("ZYX" === e.order) {
                f = o * u, d = o * l, h = a * u, v = a * l;
                t[0] = s * u, t[4] = h * c - d, t[8] = f * c + v, t[1] = s * l, t[5] = v * c + f, t[9] = d * c - h, t[2] = -c, t[6] = a * s, t[10] = o * s
            } else if ("YZX" === e.order) {
                var x = o * s,
                    b = o * c,
                    w = a * s,
                    M = a * c;
                t[0] = s * u, t[4] = M - x * l, t[8] = w * l + b, t[1] = l, t[5] = o * u, t[9] = -a * u, t[2] = -c * u, t[6] = b * l + w, t[10] = x - M * l
            } else if ("XZY" === e.order) {
                x = o * s, b = o * c, w = a * s, M = a * c;
                t[0] = s * u, t[4] = -l, t[8] = c * u, t[1] = x * l + M, t[5] = o * u, t[9] = b * l - w, t[2] = w * l - b, t[6] = a * u, t[10] = M * l + x
            }
            return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
        },
        makeRotationFromQuaternion: function(e) {
            return this.compose(En, e, zn)
        },
        lookAt: function(e, t, n) {
            var r = this.elements;
            return Cn.subVectors(e, t), 0 === Cn.lengthSq() && (Cn.z = 1), Cn.normalize(), Ln.crossVectors(n, Cn), 0 === Ln.lengthSq() && (1 === Math.abs(n.z) ? Cn.x += 1e-4 : Cn.z += 1e-4, Cn.normalize(), Ln.crossVectors(n, Cn)), Ln.normalize(), An.crossVectors(Cn, Ln), r[0] = Ln.x, r[4] = An.x, r[8] = Cn.x, r[1] = Ln.y, r[5] = An.y, r[9] = Cn.y, r[2] = Ln.z, r[6] = An.z, r[10] = Cn.z, this
        },
        multiply: function(e, t) {
            return void 0 !== t ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(e, t)) : this.multiplyMatrices(this, e)
        },
        premultiply: function(e) {
            return this.multiplyMatrices(e, this)
        },
        multiplyMatrices: function(e, t) {
            var n = e.elements,
                r = t.elements,
                i = this.elements,
                o = n[0],
                a = n[4],
                s = n[8],
                c = n[12],
                u = n[1],
                l = n[5],
                f = n[9],
                d = n[13],
                h = n[2],
                v = n[6],
                p = n[10],
                m = n[14],
                y = n[3],
                g = n[7],
                x = n[11],
                b = n[15],
                w = r[0],
                M = r[4],
                _ = r[8],
                S = r[12],
                P = r[1],
                T = r[5],
                E = r[9],
                z = r[13],
                L = r[2],
                A = r[6],
                C = r[10],
                R = r[14],
                O = r[3],
                j = r[7],
                I = r[11],
                D = r[15];
            return i[0] = o * w + a * P + s * L + c * O, i[4] = o * M + a * T + s * A + c * j, i[8] = o * _ + a * E + s * C + c * I, i[12] = o * S + a * z + s * R + c * D, i[1] = u * w + l * P + f * L + d * O, i[5] = u * M + l * T + f * A + d * j, i[9] = u * _ + l * E + f * C + d * I, i[13] = u * S + l * z + f * R + d * D, i[2] = h * w + v * P + p * L + m * O, i[6] = h * M + v * T + p * A + m * j, i[10] = h * _ + v * E + p * C + m * I, i[14] = h * S + v * z + p * R + m * D, i[3] = y * w + g * P + x * L + b * O, i[7] = y * M + g * T + x * A + b * j, i[11] = y * _ + g * E + x * C + b * I, i[15] = y * S + g * z + x * R + b * D, this
        },
        multiplyScalar: function(e) {
            var t = this.elements;
            return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this
        },
        applyToBufferAttribute: function(e) {
            for (var t = 0, n = e.count; t < n; t++) Pn.x = e.getX(t), Pn.y = e.getY(t), Pn.z = e.getZ(t), Pn.applyMatrix4(this), e.setXYZ(t, Pn.x, Pn.y, Pn.z);
            return e
        },
        determinant: function() {
            var e = this.elements,
                t = e[0],
                n = e[4],
                r = e[8],
                i = e[12],
                o = e[1],
                a = e[5],
                s = e[9],
                c = e[13],
                u = e[2],
                l = e[6],
                f = e[10],
                d = e[14];
            return e[3] * (+i * s * l - r * c * l - i * a * f + n * c * f + r * a * d - n * s * d) + e[7] * (+t * s * d - t * c * f + i * o * f - r * o * d + r * c * u - i * s * u) + e[11] * (+t * c * l - t * a * d - i * o * l + n * o * d + i * a * u - n * c * u) + e[15] * (-r * a * u - t * s * l + t * a * f + r * o * l - n * o * f + n * s * u)
        },
        transpose: function() {
            var e, t = this.elements;
            return e = t[1], t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this
        },
        setPosition: function(e, t, n) {
            var r = this.elements;
            return e.isVector3 ? (r[12] = e.x, r[13] = e.y, r[14] = e.z) : (r[12] = e, r[13] = t, r[14] = n), this
        },
        getInverse: function(e, t) {
            var n = this.elements,
                r = e.elements,
                i = r[0],
                o = r[1],
                a = r[2],
                s = r[3],
                c = r[4],
                u = r[5],
                l = r[6],
                f = r[7],
                d = r[8],
                h = r[9],
                v = r[10],
                p = r[11],
                m = r[12],
                y = r[13],
                g = r[14],
                x = r[15],
                b = h * g * f - y * v * f + y * l * p - u * g * p - h * l * x + u * v * x,
                w = m * v * f - d * g * f - m * l * p + c * g * p + d * l * x - c * v * x,
                M = d * y * f - m * h * f + m * u * p - c * y * p - d * u * x + c * h * x,
                _ = m * h * l - d * y * l - m * u * v + c * y * v + d * u * g - c * h * g,
                S = i * b + o * w + a * M + s * _;
            if (0 === S) {
                var P = "THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0";
                if (!0 === t) throw new Error(P);
                return console.warn(P), this.identity()
            }
            var T = 1 / S;
            return n[0] = b * T, n[1] = (y * v * s - h * g * s - y * a * p + o * g * p + h * a * x - o * v * x) * T, n[2] = (u * g * s - y * l * s + y * a * f - o * g * f - u * a * x + o * l * x) * T, n[3] = (h * l * s - u * v * s - h * a * f + o * v * f + u * a * p - o * l * p) * T, n[4] = w * T, n[5] = (d * g * s - m * v * s + m * a * p - i * g * p - d * a * x + i * v * x) * T, n[6] = (m * l * s - c * g * s - m * a * f + i * g * f + c * a * x - i * l * x) * T, n[7] = (c * v * s - d * l * s + d * a * f - i * v * f - c * a * p + i * l * p) * T, n[8] = M * T, n[9] = (m * h * s - d * y * s - m * o * p + i * y * p + d * o * x - i * h * x) * T, n[10] = (c * y * s - m * u * s + m * o * f - i * y * f - c * o * x + i * u * x) * T, n[11] = (d * u * s - c * h * s - d * o * f + i * h * f + c * o * p - i * u * p) * T, n[12] = _ * T, n[13] = (d * y * a - m * h * a + m * o * v - i * y * v - d * o * g + i * h * g) * T, n[14] = (m * u * a - c * y * a - m * o * l + i * y * l + c * o * g - i * u * g) * T, n[15] = (c * h * a - d * u * a + d * o * l - i * h * l - c * o * v + i * u * v) * T, this
        },
        scale: function(e) {
            var t = this.elements,
                n = e.x,
                r = e.y,
                i = e.z;
            return t[0] *= n, t[4] *= r, t[8] *= i, t[1] *= n, t[5] *= r, t[9] *= i, t[2] *= n, t[6] *= r, t[10] *= i, t[3] *= n, t[7] *= r, t[11] *= i, this
        },
        getMaxScaleOnAxis: function() {
            var e = this.elements,
                t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
                n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
                r = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
            return Math.sqrt(Math.max(t, n, r))
        },
        makeTranslation: function(e, t, n) {
            return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1), this
        },
        makeRotationX: function(e) {
            var t = Math.cos(e),
                n = Math.sin(e);
            return this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1), this
        },
        makeRotationY: function(e) {
            var t = Math.cos(e),
                n = Math.sin(e);
            return this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1), this
        },
        makeRotationZ: function(e) {
            var t = Math.cos(e),
                n = Math.sin(e);
            return this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
        },
        makeRotationAxis: function(e, t) {
            var n = Math.cos(t),
                r = Math.sin(t),
                i = 1 - n,
                o = e.x,
                a = e.y,
                s = e.z,
                c = i * o,
                u = i * a;
            return this.set(c * o + n, c * a - r * s, c * s + r * a, 0, c * a + r * s, u * a + n, u * s - r * o, 0, c * s - r * a, u * s + r * o, i * s * s + n, 0, 0, 0, 0, 1), this
        },
        makeScale: function(e, t, n) {
            return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this
        },
        makeShear: function(e, t, n) {
            return this.set(1, t, n, 0, e, 1, n, 0, e, t, 1, 0, 0, 0, 0, 1), this
        },
        compose: function(e, t, n) {
            var r = this.elements,
                i = t._x,
                o = t._y,
                a = t._z,
                s = t._w,
                c = i + i,
                u = o + o,
                l = a + a,
                f = i * c,
                d = i * u,
                h = i * l,
                v = o * u,
                p = o * l,
                m = a * l,
                y = s * c,
                g = s * u,
                x = s * l,
                b = n.x,
                w = n.y,
                M = n.z;
            return r[0] = (1 - (v + m)) * b, r[1] = (d + x) * b, r[2] = (h - g) * b, r[3] = 0, r[4] = (d - x) * w, r[5] = (1 - (f + m)) * w, r[6] = (p + y) * w, r[7] = 0, r[8] = (h + g) * M, r[9] = (p - y) * M, r[10] = (1 - (f + v)) * M, r[11] = 0, r[12] = e.x, r[13] = e.y, r[14] = e.z, r[15] = 1, this
        },
        decompose: function(e, t, n) {
            var r = this.elements,
                i = Pn.set(r[0], r[1], r[2]).length(),
                o = Pn.set(r[4], r[5], r[6]).length(),
                a = Pn.set(r[8], r[9], r[10]).length();
            this.determinant() < 0 && (i = -i), e.x = r[12], e.y = r[13], e.z = r[14], Tn.copy(this);
            var s = 1 / i,
                c = 1 / o,
                u = 1 / a;
            return Tn.elements[0] *= s, Tn.elements[1] *= s, Tn.elements[2] *= s, Tn.elements[4] *= c, Tn.elements[5] *= c, Tn.elements[6] *= c, Tn.elements[8] *= u, Tn.elements[9] *= u, Tn.elements[10] *= u, t.setFromRotationMatrix(Tn), n.x = i, n.y = o, n.z = a, this
        },
        makePerspective: function(e, t, n, r, i, o) {
            void 0 === o && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
            var a = this.elements,
                s = 2 * i / (t - e),
                c = 2 * i / (n - r),
                u = (t + e) / (t - e),
                l = (n + r) / (n - r),
                f = -(o + i) / (o - i),
                d = -2 * o * i / (o - i);
            return a[0] = s, a[4] = 0, a[8] = u, a[12] = 0, a[1] = 0, a[5] = c, a[9] = l, a[13] = 0, a[2] = 0, a[6] = 0, a[10] = f, a[14] = d, a[3] = 0, a[7] = 0, a[11] = -1, a[15] = 0, this
        },
        makeOrthographic: function(e, t, n, r, i, o) {
            var a = this.elements,
                s = 1 / (t - e),
                c = 1 / (n - r),
                u = 1 / (o - i),
                l = (t + e) * s,
                f = (n + r) * c,
                d = (o + i) * u;
            return a[0] = 2 * s, a[4] = 0, a[8] = 0, a[12] = -l, a[1] = 0, a[5] = 2 * c, a[9] = 0, a[13] = -f, a[2] = 0, a[6] = 0, a[10] = -2 * u, a[14] = -d, a[3] = 0, a[7] = 0, a[11] = 0, a[15] = 1, this
        },
        equals: function(e) {
            for (var t = this.elements, n = e.elements, r = 0; r < 16; r++)
                if (t[r] !== n[r]) return !1;
            return !0
        },
        fromArray: function(e, t) {
            void 0 === t && (t = 0);
            for (var n = 0; n < 16; n++) this.elements[n] = e[n + t];
            return this
        },
        toArray: function(e, t) {
            void 0 === e && (e = []), void 0 === t && (t = 0);
            var n = this.elements;
            return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e[t + 9] = n[9], e[t + 10] = n[10], e[t + 11] = n[11], e[t + 12] = n[12], e[t + 13] = n[13], e[t + 14] = n[14], e[t + 15] = n[15], e
        }
    });
    var On = new Rn,
        jn = new dn;

    function In(e, t, n, r) {
        this._x = e || 0, this._y = t || 0, this._z = n || 0, this._order = r || In.DefaultOrder
    }

    function Dn() {
        this.mask = 1
    }
    In.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"], In.DefaultOrder = "XYZ", Object.defineProperties(In.prototype, {
        x: {
            get: function() {
                return this._x
            },
            set: function(e) {
                this._x = e, this._onChangeCallback()
            }
        },
        y: {
            get: function() {
                return this._y
            },
            set: function(e) {
                this._y = e, this._onChangeCallback()
            }
        },
        z: {
            get: function() {
                return this._z
            },
            set: function(e) {
                this._z = e, this._onChangeCallback()
            }
        },
        order: {
            get: function() {
                return this._order
            },
            set: function(e) {
                this._order = e, this._onChangeCallback()
            }
        }
    }), Object.assign(In.prototype, {
        isEuler: !0,
        set: function(e, t, n, r) {
            return this._x = e, this._y = t, this._z = n, this._order = r || this._order, this._onChangeCallback(), this
        },
        clone: function() {
            return new this.constructor(this._x, this._y, this._z, this._order)
        },
        copy: function(e) {
            return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this
        },
        setFromRotationMatrix: function(e, t, n) {
            var r = ln.clamp,
                i = e.elements,
                o = i[0],
                a = i[4],
                s = i[8],
                c = i[1],
                u = i[5],
                l = i[9],
                f = i[2],
                d = i[6],
                h = i[10];
            return "XYZ" === (t = t || this._order) ? (this._y = Math.asin(r(s, -1, 1)), Math.abs(s) < .9999999 ? (this._x = Math.atan2(-l, h), this._z = Math.atan2(-a, o)) : (this._x = Math.atan2(d, u), this._z = 0)) : "YXZ" === t ? (this._x = Math.asin(-r(l, -1, 1)), Math.abs(l) < .9999999 ? (this._y = Math.atan2(s, h), this._z = Math.atan2(c, u)) : (this._y = Math.atan2(-f, o), this._z = 0)) : "ZXY" === t ? (this._x = Math.asin(r(d, -1, 1)), Math.abs(d) < .9999999 ? (this._y = Math.atan2(-f, h), this._z = Math.atan2(-a, u)) : (this._y = 0, this._z = Math.atan2(c, o))) : "ZYX" === t ? (this._y = Math.asin(-r(f, -1, 1)), Math.abs(f) < .9999999 ? (this._x = Math.atan2(d, h), this._z = Math.atan2(c, o)) : (this._x = 0, this._z = Math.atan2(-a, u))) : "YZX" === t ? (this._z = Math.asin(r(c, -1, 1)), Math.abs(c) < .9999999 ? (this._x = Math.atan2(-l, u), this._y = Math.atan2(-f, o)) : (this._x = 0, this._y = Math.atan2(s, h))) : "XZY" === t ? (this._z = Math.asin(-r(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(d, u), this._y = Math.atan2(s, o)) : (this._x = Math.atan2(-l, h), this._y = 0)) : console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + t), this._order = t, !1 !== n && this._onChangeCallback(), this
        },
        setFromQuaternion: function(e, t, n) {
            return On.makeRotationFromQuaternion(e), this.setFromRotationMatrix(On, t, n)
        },
        setFromVector3: function(e, t) {
            return this.set(e.x, e.y, e.z, t || this._order)
        },
        reorder: function(e) {
            return jn.setFromEuler(this), this.setFromQuaternion(jn, e)
        },
        equals: function(e) {
            return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
        },
        fromArray: function(e) {
            return this._x = e[0], this._y = e[1], this._z = e[2], void 0 !== e[3] && (this._order = e[3]), this._onChangeCallback(), this
        },
        toArray: function(e, t) {
            return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e
        },
        toVector3: function(e) {
            return e ? e.set(this._x, this._y, this._z) : new pn(this._x, this._y, this._z)
        },
        _onChange: function(e) {
            return this._onChangeCallback = e, this
        },
        _onChangeCallback: function() {}
    }), Object.assign(Dn.prototype, {
        set: function(e) {
            this.mask = 1 << e | 0
        },
        enable: function(e) {
            this.mask |= 1 << e | 0
        },
        enableAll: function() {
            this.mask = -1
        },
        toggle: function(e) {
            this.mask ^= 1 << e | 0
        },
        disable: function(e) {
            this.mask &= ~(1 << e | 0)
        },
        disableAll: function() {
            this.mask = 0
        },
        test: function(e) {
            return 0 != (this.mask & e.mask)
        }
    });
    var kn = 0,
        Fn = new pn,
        Gn = new dn,
        Nn = new Rn,
        Bn = new pn,
        Un = new pn,
        Hn = new pn,
        Vn = new dn,
        Wn = new pn(1, 0, 0),
        Yn = new pn(0, 1, 0),
        Xn = new pn(0, 0, 1),
        qn = {
            type: "added"
        },
        Kn = {
            type: "removed"
        };

    function Zn() {
        Object.defineProperty(this, "id", {
            value: kn++
        }), this.uuid = ln.generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Zn.DefaultUp.clone();
        var e = new pn,
            t = new In,
            n = new dn,
            r = new pn(1, 1, 1);
        t._onChange((function() {
            n.setFromEuler(t, !1)
        })), n._onChange((function() {
            t.setFromQuaternion(n, void 0, !1)
        })), Object.defineProperties(this, {
            position: {
                configurable: !0,
                enumerable: !0,
                value: e
            },
            rotation: {
                configurable: !0,
                enumerable: !0,
                value: t
            },
            quaternion: {
                configurable: !0,
                enumerable: !0,
                value: n
            },
            scale: {
                configurable: !0,
                enumerable: !0,
                value: r
            },
            modelViewMatrix: {
                value: new Rn
            },
            normalMatrix: {
                value: new gn
            }
        }), this.matrix = new Rn, this.matrixWorld = new Rn, this.matrixAutoUpdate = Zn.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new Dn, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.userData = {}
    }

    function Jn() {
        Zn.call(this), this.type = "Scene", this.background = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
            detail: this
        }))
    }
    Zn.DefaultUp = new pn(0, 1, 0), Zn.DefaultMatrixAutoUpdate = !0, Zn.prototype = Object.assign(Object.create(sn.prototype), {
        constructor: Zn,
        isObject3D: !0,
        onBeforeRender: function() {},
        onAfterRender: function() {},
        applyMatrix: function(e) {
            this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale)
        },
        applyQuaternion: function(e) {
            return this.quaternion.premultiply(e), this
        },
        setRotationFromAxisAngle: function(e, t) {
            this.quaternion.setFromAxisAngle(e, t)
        },
        setRotationFromEuler: function(e) {
            this.quaternion.setFromEuler(e, !0)
        },
        setRotationFromMatrix: function(e) {
            this.quaternion.setFromRotationMatrix(e)
        },
        setRotationFromQuaternion: function(e) {
            this.quaternion.copy(e)
        },
        rotateOnAxis: function(e, t) {
            return Gn.setFromAxisAngle(e, t), this.quaternion.multiply(Gn), this
        },
        rotateOnWorldAxis: function(e, t) {
            return Gn.setFromAxisAngle(e, t), this.quaternion.premultiply(Gn), this
        },
        rotateX: function(e) {
            return this.rotateOnAxis(Wn, e)
        },
        rotateY: function(e) {
            return this.rotateOnAxis(Yn, e)
        },
        rotateZ: function(e) {
            return this.rotateOnAxis(Xn, e)
        },
        translateOnAxis: function(e, t) {
            return Fn.copy(e).applyQuaternion(this.quaternion), this.position.add(Fn.multiplyScalar(t)), this
        },
        translateX: function(e) {
            return this.translateOnAxis(Wn, e)
        },
        translateY: function(e) {
            return this.translateOnAxis(Yn, e)
        },
        translateZ: function(e) {
            return this.translateOnAxis(Xn, e)
        },
        localToWorld: function(e) {
            return e.applyMatrix4(this.matrixWorld)
        },
        worldToLocal: function(e) {
            return e.applyMatrix4(Nn.getInverse(this.matrixWorld))
        },
        lookAt: function(e, t, n) {
            e.isVector3 ? Bn.copy(e) : Bn.set(e, t, n);
            var r = this.parent;
            this.updateWorldMatrix(!0, !1), Un.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? Nn.lookAt(Un, Bn, this.up) : Nn.lookAt(Bn, Un, this.up), this.quaternion.setFromRotationMatrix(Nn), r && (Nn.extractRotation(r.matrixWorld), Gn.setFromRotationMatrix(Nn), this.quaternion.premultiply(Gn.inverse()))
        },
        add: function(e) {
            if (arguments.length > 1) {
                for (var t = 0; t < arguments.length; t++) this.add(arguments[t]);
                return this
            }
            return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (null !== e.parent && e.parent.remove(e), e.parent = this, this.children.push(e), e.dispatchEvent(qn)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this)
        },
        remove: function(e) {
            if (arguments.length > 1) {
                for (var t = 0; t < arguments.length; t++) this.remove(arguments[t]);
                return this
            }
            var n = this.children.indexOf(e);
            return -1 !== n && (e.parent = null, this.children.splice(n, 1), e.dispatchEvent(Kn)), this
        },
        attach: function(e) {
            return this.updateWorldMatrix(!0, !1), Nn.getInverse(this.matrixWorld), null !== e.parent && (e.parent.updateWorldMatrix(!0, !1), Nn.multiply(e.parent.matrixWorld)), e.applyMatrix(Nn), e.updateWorldMatrix(!1, !1), this.add(e), this
        },
        getObjectById: function(e) {
            return this.getObjectByProperty("id", e)
        },
        getObjectByName: function(e) {
            return this.getObjectByProperty("name", e)
        },
        getObjectByProperty: function(e, t) {
            if (this[e] === t) return this;
            for (var n = 0, r = this.children.length; n < r; n++) {
                var i = this.children[n].getObjectByProperty(e, t);
                if (void 0 !== i) return i
            }
        },
        getWorldPosition: function(e) {
            return void 0 === e && (console.warn("THREE.Object3D: .getWorldPosition() target is now required"), e = new pn), this.updateMatrixWorld(!0), e.setFromMatrixPosition(this.matrixWorld)
        },
        getWorldQuaternion: function(e) {
            return void 0 === e && (console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"), e = new dn), this.updateMatrixWorld(!0), this.matrixWorld.decompose(Un, e, Hn), e
        },
        getWorldScale: function(e) {
            return void 0 === e && (console.warn("THREE.Object3D: .getWorldScale() target is now required"), e = new pn), this.updateMatrixWorld(!0), this.matrixWorld.decompose(Un, Vn, e), e
        },
        getWorldDirection: function(e) {
            void 0 === e && (console.warn("THREE.Object3D: .getWorldDirection() target is now required"), e = new pn), this.updateMatrixWorld(!0);
            var t = this.matrixWorld.elements;
            return e.set(t[8], t[9], t[10]).normalize()
        },
        raycast: function() {},
        traverse: function(e) {
            e(this);
            for (var t = this.children, n = 0, r = t.length; n < r; n++) t[n].traverse(e)
        },
        traverseVisible: function(e) {
            if (!1 !== this.visible) {
                e(this);
                for (var t = this.children, n = 0, r = t.length; n < r; n++) t[n].traverseVisible(e)
            }
        },
        traverseAncestors: function(e) {
            var t = this.parent;
            null !== t && (e(t), t.traverseAncestors(e))
        },
        updateMatrix: function() {
            this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
        },
        updateMatrixWorld: function(e) {
            this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, e = !0);
            for (var t = this.children, n = 0, r = t.length; n < r; n++) t[n].updateMatrixWorld(e)
        },
        updateWorldMatrix: function(e, t) {
            var n = this.parent;
            if (!0 === e && null !== n && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === t)
                for (var r = this.children, i = 0, o = r.length; i < o; i++) r[i].updateWorldMatrix(!1, !0)
        },
        toJSON: function(e) {
            var t = void 0 === e || "string" == typeof e,
                n = {};
            t && (e = {
                geometries: {},
                materials: {},
                textures: {},
                images: {},
                shapes: {}
            }, n.metadata = {
                version: 4.5,
                type: "Object",
                generator: "Object3D.toJSON"
            });
            var r = {};

            function i(t, n) {
                return void 0 === t[n.uuid] && (t[n.uuid] = n.toJSON(e)), n.uuid
            }
            if (r.uuid = this.uuid, r.type = this.type, "" !== this.name && (r.name = this.name), !0 === this.castShadow && (r.castShadow = !0), !0 === this.receiveShadow && (r.receiveShadow = !0), !1 === this.visible && (r.visible = !1), !1 === this.frustumCulled && (r.frustumCulled = !1), 0 !== this.renderOrder && (r.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (r.userData = this.userData), r.layers = this.layers.mask, r.matrix = this.matrix.toArray(), !1 === this.matrixAutoUpdate && (r.matrixAutoUpdate = !1), this.isMesh && this.drawMode !== Lt && (r.drawMode = this.drawMode), this.isMesh || this.isLine || this.isPoints) {
                r.geometry = i(e.geometries, this.geometry);
                var o = this.geometry.parameters;
                if (void 0 !== o && void 0 !== o.shapes) {
                    var a = o.shapes;
                    if (Array.isArray(a))
                        for (var s = 0, c = a.length; s < c; s++) {
                            var u = a[s];
                            i(e.shapes, u)
                        } else i(e.shapes, a)
                }
            }
            if (void 0 !== this.material)
                if (Array.isArray(this.material)) {
                    var l = [];
                    for (s = 0, c = this.material.length; s < c; s++) l.push(i(e.materials, this.material[s]));
                    r.material = l
                } else r.material = i(e.materials, this.material);
            if (this.children.length > 0) {
                r.children = [];
                for (s = 0; s < this.children.length; s++) r.children.push(this.children[s].toJSON(e).object)
            }
            if (t) {
                var f = p(e.geometries),
                    d = p(e.materials),
                    h = p(e.textures),
                    v = p(e.images);
                a = p(e.shapes);
                f.length > 0 && (n.geometries = f), d.length > 0 && (n.materials = d), h.length > 0 && (n.textures = h), v.length > 0 && (n.images = v), a.length > 0 && (n.shapes = a)
            }
            return n.object = r, n;

            function p(e) {
                var t = [];
                for (var n in e) {
                    var r = e[n];
                    delete r.metadata, t.push(r)
                }
                return t
            }
        },
        clone: function(e) {
            return (new this.constructor).copy(this, e)
        },
        copy: function(e, t) {
            if (void 0 === t && (t = !0), this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.userData = JSON.parse(JSON.stringify(e.userData)), !0 === t)
                for (var n = 0; n < e.children.length; n++) {
                    var r = e.children[n];
                    this.add(r.clone())
                }
            return this
        }
    }), Jn.prototype = Object.assign(Object.create(Zn.prototype), {
        constructor: Jn,
        isScene: !0,
        copy: function(e, t) {
            return Zn.prototype.copy.call(this, e, t), null !== e.background && (this.background = e.background.clone()), null !== e.fog && (this.fog = e.fog.clone()), null !== e.overrideMaterial && (this.overrideMaterial = e.overrideMaterial.clone()), this.autoUpdate = e.autoUpdate, this.matrixAutoUpdate = e.matrixAutoUpdate, this
        },
        toJSON: function(e) {
            var t = Zn.prototype.toJSON.call(this, e);
            return null !== this.background && (t.object.background = this.background.toJSON(e)), null !== this.fog && (t.object.fog = this.fog.toJSON()), t
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    });
    var Qn = [new pn, new pn, new pn, new pn, new pn, new pn, new pn, new pn],
        $n = new pn,
        er = new pn,
        tr = new pn,
        nr = new pn,
        rr = new pn,
        ir = new pn,
        or = new pn,
        ar = new pn,
        sr = new pn,
        cr = new pn,
        ur = new pn;

    function lr(e, t) {
        this.min = void 0 !== e ? e : new pn(1 / 0, 1 / 0, 1 / 0), this.max = void 0 !== t ? t : new pn(-1 / 0, -1 / 0, -1 / 0)
    }

    function fr(e, t, n, r, i) {
        var o, a;
        for (o = 0, a = e.length - 3; o <= a; o += 3) {
            ur.fromArray(e, o);
            var s = i.x * Math.abs(ur.x) + i.y * Math.abs(ur.y) + i.z * Math.abs(ur.z),
                c = t.dot(ur),
                u = n.dot(ur),
                l = r.dot(ur);
            if (Math.max(-Math.max(c, u, l), Math.min(c, u, l)) > s) return !1
        }
        return !0
    }
    Object.assign(lr.prototype, {
        isBox3: !0,
        set: function(e, t) {
            return this.min.copy(e), this.max.copy(t), this
        },
        setFromArray: function(e) {
            for (var t = 1 / 0, n = 1 / 0, r = 1 / 0, i = -1 / 0, o = -1 / 0, a = -1 / 0, s = 0, c = e.length; s < c; s += 3) {
                var u = e[s],
                    l = e[s + 1],
                    f = e[s + 2];
                u < t && (t = u), l < n && (n = l), f < r && (r = f), u > i && (i = u), l > o && (o = l), f > a && (a = f)
            }
            return this.min.set(t, n, r), this.max.set(i, o, a), this
        },
        setFromBufferAttribute: function(e) {
            for (var t = 1 / 0, n = 1 / 0, r = 1 / 0, i = -1 / 0, o = -1 / 0, a = -1 / 0, s = 0, c = e.count; s < c; s++) {
                var u = e.getX(s),
                    l = e.getY(s),
                    f = e.getZ(s);
                u < t && (t = u), l < n && (n = l), f < r && (r = f), u > i && (i = u), l > o && (o = l), f > a && (a = f)
            }
            return this.min.set(t, n, r), this.max.set(i, o, a), this
        },
        setFromPoints: function(e) {
            this.makeEmpty();
            for (var t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
            return this
        },
        setFromCenterAndSize: function(e, t) {
            var n = $n.copy(t).multiplyScalar(.5);
            return this.min.copy(e).sub(n), this.max.copy(e).add(n), this
        },
        setFromObject: function(e) {
            return this.makeEmpty(), this.expandByObject(e)
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.min.copy(e.min), this.max.copy(e.max), this
        },
        makeEmpty: function() {
            return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
        },
        isEmpty: function() {
            return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
        },
        getCenter: function(e) {
            return void 0 === e && (console.warn("THREE.Box3: .getCenter() target is now required"), e = new pn), this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
        },
        getSize: function(e) {
            return void 0 === e && (console.warn("THREE.Box3: .getSize() target is now required"), e = new pn), this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
        },
        expandByPoint: function(e) {
            return this.min.min(e), this.max.max(e), this
        },
        expandByVector: function(e) {
            return this.min.sub(e), this.max.add(e), this
        },
        expandByScalar: function(e) {
            return this.min.addScalar(-e), this.max.addScalar(e), this
        },
        expandByObject: function(e) {
            var t, n;
            e.updateWorldMatrix(!1, !1);
            var r = e.geometry;
            if (void 0 !== r)
                if (r.isGeometry) {
                    var i = r.vertices;
                    for (t = 0, n = i.length; t < n; t++) $n.copy(i[t]), $n.applyMatrix4(e.matrixWorld), this.expandByPoint($n)
                } else if (r.isBufferGeometry) {
                var o = r.attributes.position;
                if (void 0 !== o)
                    for (t = 0, n = o.count; t < n; t++) $n.fromBufferAttribute(o, t).applyMatrix4(e.matrixWorld), this.expandByPoint($n)
            }
            var a = e.children;
            for (t = 0, n = a.length; t < n; t++) this.expandByObject(a[t]);
            return this
        },
        containsPoint: function(e) {
            return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z)
        },
        containsBox: function(e) {
            return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
        },
        getParameter: function(e, t) {
            return void 0 === t && (console.warn("THREE.Box3: .getParameter() target is now required"), t = new pn), t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
        },
        intersectsBox: function(e) {
            return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z)
        },
        intersectsSphere: function(e) {
            return this.clampPoint(e.center, $n), $n.distanceToSquared(e.center) <= e.radius * e.radius
        },
        intersectsPlane: function(e) {
            var t, n;
            return e.normal.x > 0 ? (t = e.normal.x * this.min.x, n = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, n = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, n += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, n += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, n += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, n += e.normal.z * this.min.z), t <= -e.constant && n >= -e.constant
        },
        intersectsTriangle: function(e) {
            if (this.isEmpty()) return !1;
            this.getCenter(ar), sr.subVectors(this.max, ar), er.subVectors(e.a, ar), tr.subVectors(e.b, ar), nr.subVectors(e.c, ar), rr.subVectors(tr, er), ir.subVectors(nr, tr), or.subVectors(er, nr);
            var t = [0, -rr.z, rr.y, 0, -ir.z, ir.y, 0, -or.z, or.y, rr.z, 0, -rr.x, ir.z, 0, -ir.x, or.z, 0, -or.x, -rr.y, rr.x, 0, -ir.y, ir.x, 0, -or.y, or.x, 0];
            return !!fr(t, er, tr, nr, sr) && (!!fr(t = [1, 0, 0, 0, 1, 0, 0, 0, 1], er, tr, nr, sr) && (cr.crossVectors(rr, ir), fr(t = [cr.x, cr.y, cr.z], er, tr, nr, sr)))
        },
        clampPoint: function(e, t) {
            return void 0 === t && (console.warn("THREE.Box3: .clampPoint() target is now required"), t = new pn), t.copy(e).clamp(this.min, this.max)
        },
        distanceToPoint: function(e) {
            return $n.copy(e).clamp(this.min, this.max).sub(e).length()
        },
        getBoundingSphere: function(e) {
            return void 0 === e && console.error("THREE.Box3: .getBoundingSphere() target is now required"), this.getCenter(e.center), e.radius = .5 * this.getSize($n).length(), e
        },
        intersect: function(e) {
            return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this
        },
        union: function(e) {
            return this.min.min(e.min), this.max.max(e.max), this
        },
        applyMatrix4: function(e) {
            return this.isEmpty() ? this : (Qn[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), Qn[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), Qn[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), Qn[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), Qn[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), Qn[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), Qn[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), Qn[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(Qn), this)
        },
        translate: function(e) {
            return this.min.add(e), this.max.add(e), this
        },
        equals: function(e) {
            return e.min.equals(this.min) && e.max.equals(this.max)
        }
    });
    var dr = new lr;

    function hr(e, t) {
        this.center = void 0 !== e ? e : new pn, this.radius = void 0 !== t ? t : 0
    }
    Object.assign(hr.prototype, {
        set: function(e, t) {
            return this.center.copy(e), this.radius = t, this
        },
        setFromPoints: function(e, t) {
            var n = this.center;
            void 0 !== t ? n.copy(t) : dr.setFromPoints(e).getCenter(n);
            for (var r = 0, i = 0, o = e.length; i < o; i++) r = Math.max(r, n.distanceToSquared(e[i]));
            return this.radius = Math.sqrt(r), this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.center.copy(e.center), this.radius = e.radius, this
        },
        empty: function() {
            return this.radius <= 0
        },
        containsPoint: function(e) {
            return e.distanceToSquared(this.center) <= this.radius * this.radius
        },
        distanceToPoint: function(e) {
            return e.distanceTo(this.center) - this.radius
        },
        intersectsSphere: function(e) {
            var t = this.radius + e.radius;
            return e.center.distanceToSquared(this.center) <= t * t
        },
        intersectsBox: function(e) {
            return e.intersectsSphere(this)
        },
        intersectsPlane: function(e) {
            return Math.abs(e.distanceToPoint(this.center)) <= this.radius
        },
        clampPoint: function(e, t) {
            var n = this.center.distanceToSquared(e);
            return void 0 === t && (console.warn("THREE.Sphere: .clampPoint() target is now required"), t = new pn), t.copy(e), n > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t
        },
        getBoundingBox: function(e) {
            return void 0 === e && (console.warn("THREE.Sphere: .getBoundingBox() target is now required"), e = new lr), e.set(this.center, this.center), e.expandByScalar(this.radius), e
        },
        applyMatrix4: function(e) {
            return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this
        },
        translate: function(e) {
            return this.center.add(e), this
        },
        equals: function(e) {
            return e.center.equals(this.center) && e.radius === this.radius
        }
    });
    var vr = new pn,
        pr = new pn,
        mr = new pn,
        yr = new pn,
        gr = new pn,
        xr = new pn,
        br = new pn;

    function wr(e, t) {
        this.origin = void 0 !== e ? e : new pn, this.direction = void 0 !== t ? t : new pn
    }
    Object.assign(wr.prototype, {
        set: function(e, t) {
            return this.origin.copy(e), this.direction.copy(t), this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.origin.copy(e.origin), this.direction.copy(e.direction), this
        },
        at: function(e, t) {
            return void 0 === t && (console.warn("THREE.Ray: .at() target is now required"), t = new pn), t.copy(this.direction).multiplyScalar(e).add(this.origin)
        },
        lookAt: function(e) {
            return this.direction.copy(e).sub(this.origin).normalize(), this
        },
        recast: function(e) {
            return this.origin.copy(this.at(e, vr)), this
        },
        closestPointToPoint: function(e, t) {
            void 0 === t && (console.warn("THREE.Ray: .closestPointToPoint() target is now required"), t = new pn), t.subVectors(e, this.origin);
            var n = t.dot(this.direction);
            return n < 0 ? t.copy(this.origin) : t.copy(this.direction).multiplyScalar(n).add(this.origin)
        },
        distanceToPoint: function(e) {
            return Math.sqrt(this.distanceSqToPoint(e))
        },
        distanceSqToPoint: function(e) {
            var t = vr.subVectors(e, this.origin).dot(this.direction);
            return t < 0 ? this.origin.distanceToSquared(e) : (vr.copy(this.direction).multiplyScalar(t).add(this.origin), vr.distanceToSquared(e))
        },
        distanceSqToSegment: function(e, t, n, r) {
            pr.copy(e).add(t).multiplyScalar(.5), mr.copy(t).sub(e).normalize(), yr.copy(this.origin).sub(pr);
            var i, o, a, s, c = .5 * e.distanceTo(t),
                u = -this.direction.dot(mr),
                l = yr.dot(this.direction),
                f = -yr.dot(mr),
                d = yr.lengthSq(),
                h = Math.abs(1 - u * u);
            if (h > 0)
                if (o = u * l - f, s = c * h, (i = u * f - l) >= 0)
                    if (o >= -s)
                        if (o <= s) {
                            var v = 1 / h;
                            a = (i *= v) * (i + u * (o *= v) + 2 * l) + o * (u * i + o + 2 * f) + d
                        } else o = c, a = -(i = Math.max(0, -(u * o + l))) * i + o * (o + 2 * f) + d;
            else o = -c, a = -(i = Math.max(0, -(u * o + l))) * i + o * (o + 2 * f) + d;
            else o <= -s ? a = -(i = Math.max(0, -(-u * c + l))) * i + (o = i > 0 ? -c : Math.min(Math.max(-c, -f), c)) * (o + 2 * f) + d : o <= s ? (i = 0, a = (o = Math.min(Math.max(-c, -f), c)) * (o + 2 * f) + d) : a = -(i = Math.max(0, -(u * c + l))) * i + (o = i > 0 ? c : Math.min(Math.max(-c, -f), c)) * (o + 2 * f) + d;
            else o = u > 0 ? -c : c, a = -(i = Math.max(0, -(u * o + l))) * i + o * (o + 2 * f) + d;
            return n && n.copy(this.direction).multiplyScalar(i).add(this.origin), r && r.copy(mr).multiplyScalar(o).add(pr), a
        },
        intersectSphere: function(e, t) {
            vr.subVectors(e.center, this.origin);
            var n = vr.dot(this.direction),
                r = vr.dot(vr) - n * n,
                i = e.radius * e.radius;
            if (r > i) return null;
            var o = Math.sqrt(i - r),
                a = n - o,
                s = n + o;
            return a < 0 && s < 0 ? null : a < 0 ? this.at(s, t) : this.at(a, t)
        },
        intersectsSphere: function(e) {
            return this.distanceSqToPoint(e.center) <= e.radius * e.radius
        },
        distanceToPlane: function(e) {
            var t = e.normal.dot(this.direction);
            if (0 === t) return 0 === e.distanceToPoint(this.origin) ? 0 : null;
            var n = -(this.origin.dot(e.normal) + e.constant) / t;
            return n >= 0 ? n : null
        },
        intersectPlane: function(e, t) {
            var n = this.distanceToPlane(e);
            return null === n ? null : this.at(n, t)
        },
        intersectsPlane: function(e) {
            var t = e.distanceToPoint(this.origin);
            return 0 === t || e.normal.dot(this.direction) * t < 0
        },
        intersectBox: function(e, t) {
            var n, r, i, o, a, s, c = 1 / this.direction.x,
                u = 1 / this.direction.y,
                l = 1 / this.direction.z,
                f = this.origin;
            return c >= 0 ? (n = (e.min.x - f.x) * c, r = (e.max.x - f.x) * c) : (n = (e.max.x - f.x) * c, r = (e.min.x - f.x) * c), u >= 0 ? (i = (e.min.y - f.y) * u, o = (e.max.y - f.y) * u) : (i = (e.max.y - f.y) * u, o = (e.min.y - f.y) * u), n > o || i > r ? null : ((i > n || n != n) && (n = i), (o < r || r != r) && (r = o), l >= 0 ? (a = (e.min.z - f.z) * l, s = (e.max.z - f.z) * l) : (a = (e.max.z - f.z) * l, s = (e.min.z - f.z) * l), n > s || a > r ? null : ((a > n || n != n) && (n = a), (s < r || r != r) && (r = s), r < 0 ? null : this.at(n >= 0 ? n : r, t)))
        },
        intersectsBox: function(e) {
            return null !== this.intersectBox(e, vr)
        },
        intersectTriangle: function(e, t, n, r, i) {
            gr.subVectors(t, e), xr.subVectors(n, e), br.crossVectors(gr, xr);
            var o, a = this.direction.dot(br);
            if (a > 0) {
                if (r) return null;
                o = 1
            } else {
                if (!(a < 0)) return null;
                o = -1, a = -a
            }
            yr.subVectors(this.origin, e);
            var s = o * this.direction.dot(xr.crossVectors(yr, xr));
            if (s < 0) return null;
            var c = o * this.direction.dot(gr.cross(yr));
            if (c < 0) return null;
            if (s + c > a) return null;
            var u = -o * yr.dot(br);
            return u < 0 ? null : this.at(u / a, i)
        },
        applyMatrix4: function(e) {
            return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this
        },
        equals: function(e) {
            return e.origin.equals(this.origin) && e.direction.equals(this.direction)
        }
    });
    var Mr = new pn,
        _r = new pn,
        Sr = new pn,
        Pr = new pn,
        Tr = new pn,
        Er = new pn,
        zr = new pn,
        Lr = new pn,
        Ar = new pn,
        Cr = new pn;

    function Rr(e, t, n) {
        this.a = void 0 !== e ? e : new pn, this.b = void 0 !== t ? t : new pn, this.c = void 0 !== n ? n : new pn
    }
    Object.assign(Rr, {
        getNormal: function(e, t, n, r) {
            void 0 === r && (console.warn("THREE.Triangle: .getNormal() target is now required"), r = new pn), r.subVectors(n, t), Mr.subVectors(e, t), r.cross(Mr);
            var i = r.lengthSq();
            return i > 0 ? r.multiplyScalar(1 / Math.sqrt(i)) : r.set(0, 0, 0)
        },
        getBarycoord: function(e, t, n, r, i) {
            Mr.subVectors(r, t), _r.subVectors(n, t), Sr.subVectors(e, t);
            var o = Mr.dot(Mr),
                a = Mr.dot(_r),
                s = Mr.dot(Sr),
                c = _r.dot(_r),
                u = _r.dot(Sr),
                l = o * c - a * a;
            if (void 0 === i && (console.warn("THREE.Triangle: .getBarycoord() target is now required"), i = new pn), 0 === l) return i.set(-2, -1, -1);
            var f = 1 / l,
                d = (c * s - a * u) * f,
                h = (o * u - a * s) * f;
            return i.set(1 - d - h, h, d)
        },
        containsPoint: function(e, t, n, r) {
            return Rr.getBarycoord(e, t, n, r, Pr), Pr.x >= 0 && Pr.y >= 0 && Pr.x + Pr.y <= 1
        },
        getUV: function(e, t, n, r, i, o, a, s) {
            return this.getBarycoord(e, t, n, r, Pr), s.set(0, 0), s.addScaledVector(i, Pr.x), s.addScaledVector(o, Pr.y), s.addScaledVector(a, Pr.z), s
        },
        isFrontFacing: function(e, t, n, r) {
            return Mr.subVectors(n, t), _r.subVectors(e, t), Mr.cross(_r).dot(r) < 0
        }
    }), Object.assign(Rr.prototype, {
        set: function(e, t, n) {
            return this.a.copy(e), this.b.copy(t), this.c.copy(n), this
        },
        setFromPointsAndIndices: function(e, t, n, r) {
            return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[r]), this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this
        },
        getArea: function() {
            return Mr.subVectors(this.c, this.b), _r.subVectors(this.a, this.b), .5 * Mr.cross(_r).length()
        },
        getMidpoint: function(e) {
            return void 0 === e && (console.warn("THREE.Triangle: .getMidpoint() target is now required"), e = new pn), e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
        },
        getNormal: function(e) {
            return Rr.getNormal(this.a, this.b, this.c, e)
        },
        getPlane: function(e) {
            return void 0 === e && (console.warn("THREE.Triangle: .getPlane() target is now required"), e = new pn), e.setFromCoplanarPoints(this.a, this.b, this.c)
        },
        getBarycoord: function(e, t) {
            return Rr.getBarycoord(e, this.a, this.b, this.c, t)
        },
        getUV: function(e, t, n, r, i) {
            return Rr.getUV(e, this.a, this.b, this.c, t, n, r, i)
        },
        containsPoint: function(e) {
            return Rr.containsPoint(e, this.a, this.b, this.c)
        },
        isFrontFacing: function(e) {
            return Rr.isFrontFacing(this.a, this.b, this.c, e)
        },
        intersectsBox: function(e) {
            return e.intersectsTriangle(this)
        },
        closestPointToPoint: function(e, t) {
            void 0 === t && (console.warn("THREE.Triangle: .closestPointToPoint() target is now required"), t = new pn);
            var n, r, i = this.a,
                o = this.b,
                a = this.c;
            Tr.subVectors(o, i), Er.subVectors(a, i), Lr.subVectors(e, i);
            var s = Tr.dot(Lr),
                c = Er.dot(Lr);
            if (s <= 0 && c <= 0) return t.copy(i);
            Ar.subVectors(e, o);
            var u = Tr.dot(Ar),
                l = Er.dot(Ar);
            if (u >= 0 && l <= u) return t.copy(o);
            var f = s * l - u * c;
            if (f <= 0 && s >= 0 && u <= 0) return n = s / (s - u), t.copy(i).addScaledVector(Tr, n);
            Cr.subVectors(e, a);
            var d = Tr.dot(Cr),
                h = Er.dot(Cr);
            if (h >= 0 && d <= h) return t.copy(a);
            var v = d * c - s * h;
            if (v <= 0 && c >= 0 && h <= 0) return r = c / (c - h), t.copy(i).addScaledVector(Er, r);
            var p = u * h - d * l;
            if (p <= 0 && l - u >= 0 && d - h >= 0) return zr.subVectors(a, o), r = (l - u) / (l - u + (d - h)), t.copy(o).addScaledVector(zr, r);
            var m = 1 / (p + v + f);
            return n = v * m, r = f * m, t.copy(i).addScaledVector(Tr, n).addScaledVector(Er, r)
        },
        equals: function(e) {
            return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
        }
    });
    var Or = {
            aliceblue: 15792383,
            antiquewhite: 16444375,
            aqua: 65535,
            aquamarine: 8388564,
            azure: 15794175,
            beige: 16119260,
            bisque: 16770244,
            black: 0,
            blanchedalmond: 16772045,
            blue: 255,
            blueviolet: 9055202,
            brown: 10824234,
            burlywood: 14596231,
            cadetblue: 6266528,
            chartreuse: 8388352,
            chocolate: 13789470,
            coral: 16744272,
            cornflowerblue: 6591981,
            cornsilk: 16775388,
            crimson: 14423100,
            cyan: 65535,
            darkblue: 139,
            darkcyan: 35723,
            darkgoldenrod: 12092939,
            darkgray: 11119017,
            darkgreen: 25600,
            darkgrey: 11119017,
            darkkhaki: 12433259,
            darkmagenta: 9109643,
            darkolivegreen: 5597999,
            darkorange: 16747520,
            darkorchid: 10040012,
            darkred: 9109504,
            darksalmon: 15308410,
            darkseagreen: 9419919,
            darkslateblue: 4734347,
            darkslategray: 3100495,
            darkslategrey: 3100495,
            darkturquoise: 52945,
            darkviolet: 9699539,
            deeppink: 16716947,
            deepskyblue: 49151,
            dimgray: 6908265,
            dimgrey: 6908265,
            dodgerblue: 2003199,
            firebrick: 11674146,
            floralwhite: 16775920,
            forestgreen: 2263842,
            fuchsia: 16711935,
            gainsboro: 14474460,
            ghostwhite: 16316671,
            gold: 16766720,
            goldenrod: 14329120,
            gray: 8421504,
            green: 32768,
            greenyellow: 11403055,
            grey: 8421504,
            honeydew: 15794160,
            hotpink: 16738740,
            indianred: 13458524,
            indigo: 4915330,
            ivory: 16777200,
            khaki: 15787660,
            lavender: 15132410,
            lavenderblush: 16773365,
            lawngreen: 8190976,
            lemonchiffon: 16775885,
            lightblue: 11393254,
            lightcoral: 15761536,
            lightcyan: 14745599,
            lightgoldenrodyellow: 16448210,
            lightgray: 13882323,
            lightgreen: 9498256,
            lightgrey: 13882323,
            lightpink: 16758465,
            lightsalmon: 16752762,
            lightseagreen: 2142890,
            lightskyblue: 8900346,
            lightslategray: 7833753,
            lightslategrey: 7833753,
            lightsteelblue: 11584734,
            lightyellow: 16777184,
            lime: 65280,
            limegreen: 3329330,
            linen: 16445670,
            magenta: 16711935,
            maroon: 8388608,
            mediumaquamarine: 6737322,
            mediumblue: 205,
            mediumorchid: 12211667,
            mediumpurple: 9662683,
            mediumseagreen: 3978097,
            mediumslateblue: 8087790,
            mediumspringgreen: 64154,
            mediumturquoise: 4772300,
            mediumvioletred: 13047173,
            midnightblue: 1644912,
            mintcream: 16121850,
            mistyrose: 16770273,
            moccasin: 16770229,
            navajowhite: 16768685,
            navy: 128,
            oldlace: 16643558,
            olive: 8421376,
            olivedrab: 7048739,
            orange: 16753920,
            orangered: 16729344,
            orchid: 14315734,
            palegoldenrod: 15657130,
            palegreen: 10025880,
            paleturquoise: 11529966,
            palevioletred: 14381203,
            papayawhip: 16773077,
            peachpuff: 16767673,
            peru: 13468991,
            pink: 16761035,
            plum: 14524637,
            powderblue: 11591910,
            purple: 8388736,
            rebeccapurple: 6697881,
            red: 16711680,
            rosybrown: 12357519,
            royalblue: 4286945,
            saddlebrown: 9127187,
            salmon: 16416882,
            sandybrown: 16032864,
            seagreen: 3050327,
            seashell: 16774638,
            sienna: 10506797,
            silver: 12632256,
            skyblue: 8900331,
            slateblue: 6970061,
            slategray: 7372944,
            slategrey: 7372944,
            snow: 16775930,
            springgreen: 65407,
            steelblue: 4620980,
            tan: 13808780,
            teal: 32896,
            thistle: 14204888,
            tomato: 16737095,
            turquoise: 4251856,
            violet: 15631086,
            wheat: 16113331,
            white: 16777215,
            whitesmoke: 16119285,
            yellow: 16776960,
            yellowgreen: 10145074
        },
        jr = {
            h: 0,
            s: 0,
            l: 0
        },
        Ir = {
            h: 0,
            s: 0,
            l: 0
        };

    function Dr(e, t, n) {
        return void 0 === t && void 0 === n ? this.set(e) : this.setRGB(e, t, n)
    }

    function kr(e, t, n) {
        return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + 6 * (t - e) * n : n < .5 ? t : n < 2 / 3 ? e + 6 * (t - e) * (2 / 3 - n) : e
    }

    function Fr(e) {
        return e < .04045 ? .0773993808 * e : Math.pow(.9478672986 * e + .0521327014, 2.4)
    }

    function Gr(e) {
        return e < .0031308 ? 12.92 * e : 1.055 * Math.pow(e, .41666) - .055
    }

    function Nr(e, t, n, r, i, o) {
        this.a = e, this.b = t, this.c = n, this.normal = r && r.isVector3 ? r : new pn, this.vertexNormals = Array.isArray(r) ? r : [], this.color = i && i.isColor ? i : new Dr, this.vertexColors = Array.isArray(i) ? i : [], this.materialIndex = void 0 !== o ? o : 0
    }
    Object.assign(Dr.prototype, {
        isColor: !0,
        r: 1,
        g: 1,
        b: 1,
        set: function(e) {
            return e && e.isColor ? this.copy(e) : "number" == typeof e ? this.setHex(e) : "string" == typeof e && this.setStyle(e), this
        },
        setScalar: function(e) {
            return this.r = e, this.g = e, this.b = e, this
        },
        setHex: function(e) {
            return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (255 & e) / 255, this
        },
        setRGB: function(e, t, n) {
            return this.r = e, this.g = t, this.b = n, this
        },
        setHSL: function(e, t, n) {
            if (e = ln.euclideanModulo(e, 1), t = ln.clamp(t, 0, 1), n = ln.clamp(n, 0, 1), 0 === t) this.r = this.g = this.b = n;
            else {
                var r = n <= .5 ? n * (1 + t) : n + t - n * t,
                    i = 2 * n - r;
                this.r = kr(i, r, e + 1 / 3), this.g = kr(i, r, e), this.b = kr(i, r, e - 1 / 3)
            }
            return this
        },
        setStyle: function(e) {
            function t(t) {
                void 0 !== t && parseFloat(t) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.")
            }
            var n;
            if (n = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(e)) {
                var r, i = n[1],
                    o = n[2];
                switch (i) {
                    case "rgb":
                    case "rgba":
                        if (r = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(o)) return this.r = Math.min(255, parseInt(r[1], 10)) / 255, this.g = Math.min(255, parseInt(r[2], 10)) / 255, this.b = Math.min(255, parseInt(r[3], 10)) / 255, t(r[5]), this;
                        if (r = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(o)) return this.r = Math.min(100, parseInt(r[1], 10)) / 100, this.g = Math.min(100, parseInt(r[2], 10)) / 100, this.b = Math.min(100, parseInt(r[3], 10)) / 100, t(r[5]), this;
                        break;
                    case "hsl":
                    case "hsla":
                        if (r = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(o)) {
                            var a = parseFloat(r[1]) / 360,
                                s = parseInt(r[2], 10) / 100,
                                c = parseInt(r[3], 10) / 100;
                            return t(r[5]), this.setHSL(a, s, c)
                        }
                }
            } else if (n = /^\#([A-Fa-f0-9]+)$/.exec(e)) {
                var u, l = (u = n[1]).length;
                if (3 === l) return this.r = parseInt(u.charAt(0) + u.charAt(0), 16) / 255, this.g = parseInt(u.charAt(1) + u.charAt(1), 16) / 255, this.b = parseInt(u.charAt(2) + u.charAt(2), 16) / 255, this;
                if (6 === l) return this.r = parseInt(u.charAt(0) + u.charAt(1), 16) / 255, this.g = parseInt(u.charAt(2) + u.charAt(3), 16) / 255, this.b = parseInt(u.charAt(4) + u.charAt(5), 16) / 255, this
            }
            e && e.length > 0 && (void 0 !== (u = Or[e]) ? this.setHex(u) : console.warn("THREE.Color: Unknown color " + e));
            return this
        },
        clone: function() {
            return new this.constructor(this.r, this.g, this.b)
        },
        copy: function(e) {
            return this.r = e.r, this.g = e.g, this.b = e.b, this
        },
        copyGammaToLinear: function(e, t) {
            return void 0 === t && (t = 2), this.r = Math.pow(e.r, t), this.g = Math.pow(e.g, t), this.b = Math.pow(e.b, t), this
        },
        copyLinearToGamma: function(e, t) {
            void 0 === t && (t = 2);
            var n = t > 0 ? 1 / t : 1;
            return this.r = Math.pow(e.r, n), this.g = Math.pow(e.g, n), this.b = Math.pow(e.b, n), this
        },
        convertGammaToLinear: function(e) {
            return this.copyGammaToLinear(this, e), this
        },
        convertLinearToGamma: function(e) {
            return this.copyLinearToGamma(this, e), this
        },
        copySRGBToLinear: function(e) {
            return this.r = Fr(e.r), this.g = Fr(e.g), this.b = Fr(e.b), this
        },
        copyLinearToSRGB: function(e) {
            return this.r = Gr(e.r), this.g = Gr(e.g), this.b = Gr(e.b), this
        },
        convertSRGBToLinear: function() {
            return this.copySRGBToLinear(this), this
        },
        convertLinearToSRGB: function() {
            return this.copyLinearToSRGB(this), this
        },
        getHex: function() {
            return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
        },
        getHexString: function() {
            return ("000000" + this.getHex().toString(16)).slice(-6)
        },
        getHSL: function(e) {
            void 0 === e && (console.warn("THREE.Color: .getHSL() target is now required"), e = {
                h: 0,
                s: 0,
                l: 0
            });
            var t, n, r = this.r,
                i = this.g,
                o = this.b,
                a = Math.max(r, i, o),
                s = Math.min(r, i, o),
                c = (s + a) / 2;
            if (s === a) t = 0, n = 0;
            else {
                var u = a - s;
                switch (n = c <= .5 ? u / (a + s) : u / (2 - a - s), a) {
                    case r:
                        t = (i - o) / u + (i < o ? 6 : 0);
                        break;
                    case i:
                        t = (o - r) / u + 2;
                        break;
                    case o:
                        t = (r - i) / u + 4
                }
                t /= 6
            }
            return e.h = t, e.s = n, e.l = c, e
        },
        getStyle: function() {
            return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
        },
        offsetHSL: function(e, t, n) {
            return this.getHSL(jr), jr.h += e, jr.s += t, jr.l += n, this.setHSL(jr.h, jr.s, jr.l), this
        },
        add: function(e) {
            return this.r += e.r, this.g += e.g, this.b += e.b, this
        },
        addColors: function(e, t) {
            return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this
        },
        addScalar: function(e) {
            return this.r += e, this.g += e, this.b += e, this
        },
        sub: function(e) {
            return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this
        },
        multiply: function(e) {
            return this.r *= e.r, this.g *= e.g, this.b *= e.b, this
        },
        multiplyScalar: function(e) {
            return this.r *= e, this.g *= e, this.b *= e, this
        },
        lerp: function(e, t) {
            return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this
        },
        lerpHSL: function(e, t) {
            this.getHSL(jr), e.getHSL(Ir);
            var n = ln.lerp(jr.h, Ir.h, t),
                r = ln.lerp(jr.s, Ir.s, t),
                i = ln.lerp(jr.l, Ir.l, t);
            return this.setHSL(n, r, i), this
        },
        equals: function(e) {
            return e.r === this.r && e.g === this.g && e.b === this.b
        },
        fromArray: function(e, t) {
            return void 0 === t && (t = 0), this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this
        },
        toArray: function(e, t) {
            return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e
        },
        toJSON: function() {
            return this.getHex()
        }
    }), Object.assign(Nr.prototype, {
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            this.a = e.a, this.b = e.b, this.c = e.c, this.normal.copy(e.normal), this.color.copy(e.color), this.materialIndex = e.materialIndex;
            for (var t = 0, n = e.vertexNormals.length; t < n; t++) this.vertexNormals[t] = e.vertexNormals[t].clone();
            for (t = 0, n = e.vertexColors.length; t < n; t++) this.vertexColors[t] = e.vertexColors[t].clone();
            return this
        }
    });
    var Br = 0;

    function Ur() {
        Object.defineProperty(this, "id", {
            value: Br++
        }), this.uuid = ln.generateUUID(), this.name = "", this.type = "Material", this.fog = !0, this.blending = P, this.side = m, this.flatShading = !1, this.vertexTangents = !1, this.vertexColors = w, this.opacity = 1, this.transparent = !1, this.blendSrc = G, this.blendDst = N, this.blendEquation = A, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = K, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = an, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = Wt, this.stencilZFail = Wt, this.stencilZPass = Wt, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaTest = 0, this.premultipliedAlpha = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.needsUpdate = !0
    }

    function Hr(e) {
        Ur.call(this), this.type = "MeshBasicMaterial", this.color = new Dr(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = ee, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.setValues(e)
    }

    function Vr(e, t, n) {
        if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
        this.name = "", this.array = e, this.itemSize = t, this.count = void 0 !== e ? e.length / t : 0, this.normalized = !0 === n, this.dynamic = !1, this.updateRange = {
            offset: 0,
            count: -1
        }, this.version = 0
    }

    function Wr(e, t, n) {
        Vr.call(this, new Int8Array(e), t, n)
    }

    function Yr(e, t, n) {
        Vr.call(this, new Uint8Array(e), t, n)
    }

    function Xr(e, t, n) {
        Vr.call(this, new Uint8ClampedArray(e), t, n)
    }

    function qr(e, t, n) {
        Vr.call(this, new Int16Array(e), t, n)
    }

    function Kr(e, t, n) {
        Vr.call(this, new Uint16Array(e), t, n)
    }

    function Zr(e, t, n) {
        Vr.call(this, new Int32Array(e), t, n)
    }

    function Jr(e, t, n) {
        Vr.call(this, new Uint32Array(e), t, n)
    }

    function Qr(e, t, n) {
        Vr.call(this, new Float32Array(e), t, n)
    }

    function $r(e, t, n) {
        Vr.call(this, new Float64Array(e), t, n)
    }

    function ei() {
        this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], this.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [], this.boundingBox = null, this.boundingSphere = null, this.verticesNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.uvsNeedUpdate = !1, this.groupsNeedUpdate = !1
    }

    function ti(e) {
        if (0 === e.length) return -1 / 0;
        for (var t = e[0], n = 1, r = e.length; n < r; ++n) e[n] > t && (t = e[n]);
        return t
    }
    Ur.prototype = Object.assign(Object.create(sn.prototype), {
        constructor: Ur,
        isMaterial: !0,
        onBeforeCompile: function() {},
        setValues: function(e) {
            if (void 0 !== e)
                for (var t in e) {
                    var n = e[t];
                    if (void 0 !== n)
                        if ("shading" !== t) {
                            var r = this[t];
                            void 0 !== r ? r && r.isColor ? r.set(n) : r && r.isVector3 && n && n.isVector3 ? r.copy(n) : this[t] = n : console.warn("THREE." + this.type + ": '" + t + "' is not a property of this material.")
                        } else console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = n === x;
                    else console.warn("THREE.Material: '" + t + "' parameter is undefined.")
                }
        },
        toJSON: function(e) {
            var t = void 0 === e || "string" == typeof e;
            t && (e = {
                textures: {},
                images: {}
            });
            var n = {
                metadata: {
                    version: 4.5,
                    type: "Material",
                    generator: "Material.toJSON"
                }
            };

            function r(e) {
                var t = [];
                for (var n in e) {
                    var r = e[n];
                    delete r.metadata, t.push(r)
                }
                return t
            }
            if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), void 0 !== this.roughness && (n.roughness = this.roughness), void 0 !== this.metalness && (n.metalness = this.metalness), this.sheen && this.sheen.isColor && (n.sheen = this.sheen.getHex()), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), void 0 !== this.shininess && (n.shininess = this.shininess), void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(e).uuid), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(e).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(e).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(e).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(e).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(e).uuid, n.reflectivity = this.reflectivity, n.refractionRatio = this.refractionRatio, void 0 !== this.combine && (n.combine = this.combine), void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity)), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(e).uuid), void 0 !== this.size && (n.size = this.size), void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation), this.blending !== P && (n.blending = this.blending), !0 === this.flatShading && (n.flatShading = this.flatShading), this.side !== m && (n.side = this.side), this.vertexColors !== w && (n.vertexColors = this.vertexColors), this.opacity < 1 && (n.opacity = this.opacity), !0 === this.transparent && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, n.stencilWrite = this.stencilWrite, n.stencilWriteMask = this.stencilWriteMask, n.stencilFunc = this.stencilFunc, n.stencilRef = this.stencilRef, n.stencilFuncMask = this.stencilFuncMask, n.stencilFail = this.stencilFail, n.stencilZFail = this.stencilZFail, n.stencilZPass = this.stencilZPass, this.rotation && 0 !== this.rotation && (n.rotation = this.rotation), !0 === this.polygonOffset && (n.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth), void 0 !== this.dashSize && (n.dashSize = this.dashSize), void 0 !== this.gapSize && (n.gapSize = this.gapSize), void 0 !== this.scale && (n.scale = this.scale), !0 === this.dithering && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (n.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin), !0 === this.morphTargets && (n.morphTargets = !0), !0 === this.morphNormals && (n.morphNormals = !0), !0 === this.skinning && (n.skinning = !0), !1 === this.visible && (n.visible = !1), !1 === this.toneMapped && (n.toneMapped = !1), "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), t) {
                var i = r(e.textures),
                    o = r(e.images);
                i.length > 0 && (n.textures = i), o.length > 0 && (n.images = o)
            }
            return n
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            this.name = e.name, this.fog = e.fog, this.blending = e.blending, this.side = e.side, this.flatShading = e.flatShading, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWrite = e.stencilWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.premultipliedAlpha = e.premultipliedAlpha, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this.clipShadows = e.clipShadows, this.clipIntersection = e.clipIntersection;
            var t = e.clippingPlanes,
                n = null;
            if (null !== t) {
                var r = t.length;
                n = new Array(r);
                for (var i = 0; i !== r; ++i) n[i] = t[i].clone()
            }
            return this.clippingPlanes = n, this.shadowSide = e.shadowSide, this
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }), Hr.prototype = Object.create(Ur.prototype), Hr.prototype.constructor = Hr, Hr.prototype.isMeshBasicMaterial = !0, Hr.prototype.copy = function(e) {
        return Ur.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this
    }, Object.defineProperty(Vr.prototype, "needsUpdate", {
        set: function(e) {
            !0 === e && this.version++
        }
    }), Object.assign(Vr.prototype, {
        isBufferAttribute: !0,
        onUploadCallback: function() {},
        setDynamic: function(e) {
            return this.dynamic = e, this
        },
        copy: function(e) {
            return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.dynamic = e.dynamic, this
        },
        copyAt: function(e, t, n) {
            e *= this.itemSize, n *= t.itemSize;
            for (var r = 0, i = this.itemSize; r < i; r++) this.array[e + r] = t.array[n + r];
            return this
        },
        copyArray: function(e) {
            return this.array.set(e), this
        },
        copyColorsArray: function(e) {
            for (var t = this.array, n = 0, r = 0, i = e.length; r < i; r++) {
                var o = e[r];
                void 0 === o && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", r), o = new Dr), t[n++] = o.r, t[n++] = o.g, t[n++] = o.b
            }
            return this
        },
        copyVector2sArray: function(e) {
            for (var t = this.array, n = 0, r = 0, i = e.length; r < i; r++) {
                var o = e[r];
                void 0 === o && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", r), o = new fn), t[n++] = o.x, t[n++] = o.y
            }
            return this
        },
        copyVector3sArray: function(e) {
            for (var t = this.array, n = 0, r = 0, i = e.length; r < i; r++) {
                var o = e[r];
                void 0 === o && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", r), o = new pn), t[n++] = o.x, t[n++] = o.y, t[n++] = o.z
            }
            return this
        },
        copyVector4sArray: function(e) {
            for (var t = this.array, n = 0, r = 0, i = e.length; r < i; r++) {
                var o = e[r];
                void 0 === o && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", r), o = new Mn), t[n++] = o.x, t[n++] = o.y, t[n++] = o.z, t[n++] = o.w
            }
            return this
        },
        set: function(e, t) {
            return void 0 === t && (t = 0), this.array.set(e, t), this
        },
        getX: function(e) {
            return this.array[e * this.itemSize]
        },
        setX: function(e, t) {
            return this.array[e * this.itemSize] = t, this
        },
        getY: function(e) {
            return this.array[e * this.itemSize + 1]
        },
        setY: function(e, t) {
            return this.array[e * this.itemSize + 1] = t, this
        },
        getZ: function(e) {
            return this.array[e * this.itemSize + 2]
        },
        setZ: function(e, t) {
            return this.array[e * this.itemSize + 2] = t, this
        },
        getW: function(e) {
            return this.array[e * this.itemSize + 3]
        },
        setW: function(e, t) {
            return this.array[e * this.itemSize + 3] = t, this
        },
        setXY: function(e, t, n) {
            return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = n, this
        },
        setXYZ: function(e, t, n, r) {
            return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = r, this
        },
        setXYZW: function(e, t, n, r, i) {
            return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = r, this.array[e + 3] = i, this
        },
        onUpload: function(e) {
            return this.onUploadCallback = e, this
        },
        clone: function() {
            return new this.constructor(this.array, this.itemSize).copy(this)
        },
        toJSON: function() {
            return {
                itemSize: this.itemSize,
                type: this.array.constructor.name,
                array: Array.prototype.slice.call(this.array),
                normalized: this.normalized
            }
        }
    }), Wr.prototype = Object.create(Vr.prototype), Wr.prototype.constructor = Wr, Yr.prototype = Object.create(Vr.prototype), Yr.prototype.constructor = Yr, Xr.prototype = Object.create(Vr.prototype), Xr.prototype.constructor = Xr, qr.prototype = Object.create(Vr.prototype), qr.prototype.constructor = qr, Kr.prototype = Object.create(Vr.prototype), Kr.prototype.constructor = Kr, Zr.prototype = Object.create(Vr.prototype), Zr.prototype.constructor = Zr, Jr.prototype = Object.create(Vr.prototype), Jr.prototype.constructor = Jr, Qr.prototype = Object.create(Vr.prototype), Qr.prototype.constructor = Qr, $r.prototype = Object.create(Vr.prototype), $r.prototype.constructor = $r, Object.assign(ei.prototype, {
        computeGroups: function(e) {
            for (var t, n = [], r = void 0, i = e.faces, o = 0; o < i.length; o++) {
                var a = i[o];
                a.materialIndex !== r && (r = a.materialIndex, void 0 !== t && (t.count = 3 * o - t.start, n.push(t)), t = {
                    start: 3 * o,
                    materialIndex: r
                })
            }
            void 0 !== t && (t.count = 3 * o - t.start, n.push(t)), this.groups = n
        },
        fromGeometry: function(e) {
            var t, n = e.faces,
                r = e.vertices,
                i = e.faceVertexUvs,
                o = i[0] && i[0].length > 0,
                a = i[1] && i[1].length > 0,
                s = e.morphTargets,
                c = s.length;
            if (c > 0) {
                t = [];
                for (var u = 0; u < c; u++) t[u] = {
                    name: s[u].name,
                    data: []
                };
                this.morphTargets.position = t
            }
            var l, f = e.morphNormals,
                d = f.length;
            if (d > 0) {
                l = [];
                for (u = 0; u < d; u++) l[u] = {
                    name: f[u].name,
                    data: []
                };
                this.morphTargets.normal = l
            }
            var h = e.skinIndices,
                v = e.skinWeights,
                p = h.length === r.length,
                m = v.length === r.length;
            r.length > 0 && 0 === n.length && console.error("THREE.DirectGeometry: Faceless geometries are not supported.");
            for (u = 0; u < n.length; u++) {
                var y = n[u];
                this.vertices.push(r[y.a], r[y.b], r[y.c]);
                var g = y.vertexNormals;
                if (3 === g.length) this.normals.push(g[0], g[1], g[2]);
                else {
                    var x = y.normal;
                    this.normals.push(x, x, x)
                }
                var b, w = y.vertexColors;
                if (3 === w.length) this.colors.push(w[0], w[1], w[2]);
                else {
                    var M = y.color;
                    this.colors.push(M, M, M)
                }
                if (!0 === o) void 0 !== (b = i[0][u]) ? this.uvs.push(b[0], b[1], b[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", u), this.uvs.push(new fn, new fn, new fn));
                if (!0 === a) void 0 !== (b = i[1][u]) ? this.uvs2.push(b[0], b[1], b[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", u), this.uvs2.push(new fn, new fn, new fn));
                for (var _ = 0; _ < c; _++) {
                    var S = s[_].vertices;
                    t[_].data.push(S[y.a], S[y.b], S[y.c])
                }
                for (_ = 0; _ < d; _++) {
                    var P = f[_].vertexNormals[u];
                    l[_].data.push(P.a, P.b, P.c)
                }
                p && this.skinIndices.push(h[y.a], h[y.b], h[y.c]), m && this.skinWeights.push(v[y.a], v[y.b], v[y.c])
            }
            return this.computeGroups(e), this.verticesNeedUpdate = e.verticesNeedUpdate, this.normalsNeedUpdate = e.normalsNeedUpdate, this.colorsNeedUpdate = e.colorsNeedUpdate, this.uvsNeedUpdate = e.uvsNeedUpdate, this.groupsNeedUpdate = e.groupsNeedUpdate, null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()), this
        }
    });
    var ni = 1,
        ri = new Rn,
        ii = new Zn,
        oi = new pn,
        ai = new lr,
        si = new lr,
        ci = new pn;

    function ui() {
        Object.defineProperty(this, "id", {
            value: ni += 2
        }), this.uuid = ln.generateUUID(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
            start: 0,
            count: 1 / 0
        }, this.userData = {}
    }
    ui.prototype = Object.assign(Object.create(sn.prototype), {
        constructor: ui,
        isBufferGeometry: !0,
        getIndex: function() {
            return this.index
        },
        setIndex: function(e) {
            Array.isArray(e) ? this.index = new(ti(e) > 65535 ? Jr : Kr)(e, 1) : this.index = e
        },
        addAttribute: function(e, t) {
            return t && t.isBufferAttribute || t && t.isInterleavedBufferAttribute ? "index" === e ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(t), this) : this.setAttribute(e, t) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.addAttribute(e, new Vr(arguments[1], arguments[2])))
        },
        getAttribute: function(e) {
            return this.attributes[e]
        },
        setAttribute: function(e, t) {
            return this.attributes[e] = t, this
        },
        removeAttribute: function(e) {
            return delete this.attributes[e], this
        },
        addGroup: function(e, t, n) {
            this.groups.push({
                start: e,
                count: t,
                materialIndex: void 0 !== n ? n : 0
            })
        },
        clearGroups: function() {
            this.groups = []
        },
        setDrawRange: function(e, t) {
            this.drawRange.start = e, this.drawRange.count = t
        },
        applyMatrix: function(e) {
            var t = this.attributes.position;
            void 0 !== t && (e.applyToBufferAttribute(t), t.needsUpdate = !0);
            var n = this.attributes.normal;
            void 0 !== n && ((new gn).getNormalMatrix(e).applyToBufferAttribute(n), n.needsUpdate = !0);
            var r = this.attributes.tangent;
            void 0 !== r && ((new gn).getNormalMatrix(e).applyToBufferAttribute(r), r.needsUpdate = !0);
            return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
        },
        rotateX: function(e) {
            return ri.makeRotationX(e), this.applyMatrix(ri), this
        },
        rotateY: function(e) {
            return ri.makeRotationY(e), this.applyMatrix(ri), this
        },
        rotateZ: function(e) {
            return ri.makeRotationZ(e), this.applyMatrix(ri), this
        },
        translate: function(e, t, n) {
            return ri.makeTranslation(e, t, n), this.applyMatrix(ri), this
        },
        scale: function(e, t, n) {
            return ri.makeScale(e, t, n), this.applyMatrix(ri), this
        },
        lookAt: function(e) {
            return ii.lookAt(e), ii.updateMatrix(), this.applyMatrix(ii.matrix), this
        },
        center: function() {
            return this.computeBoundingBox(), this.boundingBox.getCenter(oi).negate(), this.translate(oi.x, oi.y, oi.z), this
        },
        setFromObject: function(e) {
            var t = e.geometry;
            if (e.isPoints || e.isLine) {
                var n = new Qr(3 * t.vertices.length, 3),
                    r = new Qr(3 * t.colors.length, 3);
                if (this.addAttribute("position", n.copyVector3sArray(t.vertices)), this.addAttribute("color", r.copyColorsArray(t.colors)), t.lineDistances && t.lineDistances.length === t.vertices.length) {
                    var i = new Qr(t.lineDistances.length, 1);
                    this.addAttribute("lineDistance", i.copyArray(t.lineDistances))
                }
                null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone())
            } else e.isMesh && t && t.isGeometry && this.fromGeometry(t);
            return this
        },
        setFromPoints: function(e) {
            for (var t = [], n = 0, r = e.length; n < r; n++) {
                var i = e[n];
                t.push(i.x, i.y, i.z || 0)
            }
            return this.addAttribute("position", new Qr(t, 3)), this
        },
        updateFromObject: function(e) {
            var t, n = e.geometry;
            if (e.isMesh) {
                var r = n.__directGeometry;
                if (!0 === n.elementsNeedUpdate && (r = void 0, n.elementsNeedUpdate = !1), void 0 === r) return this.fromGeometry(n);
                r.verticesNeedUpdate = n.verticesNeedUpdate, r.normalsNeedUpdate = n.normalsNeedUpdate, r.colorsNeedUpdate = n.colorsNeedUpdate, r.uvsNeedUpdate = n.uvsNeedUpdate, r.groupsNeedUpdate = n.groupsNeedUpdate, n.verticesNeedUpdate = !1, n.normalsNeedUpdate = !1, n.colorsNeedUpdate = !1, n.uvsNeedUpdate = !1, n.groupsNeedUpdate = !1, n = r
            }
            return !0 === n.verticesNeedUpdate && (void 0 !== (t = this.attributes.position) && (t.copyVector3sArray(n.vertices), t.needsUpdate = !0), n.verticesNeedUpdate = !1), !0 === n.normalsNeedUpdate && (void 0 !== (t = this.attributes.normal) && (t.copyVector3sArray(n.normals), t.needsUpdate = !0), n.normalsNeedUpdate = !1), !0 === n.colorsNeedUpdate && (void 0 !== (t = this.attributes.color) && (t.copyColorsArray(n.colors), t.needsUpdate = !0), n.colorsNeedUpdate = !1), n.uvsNeedUpdate && (void 0 !== (t = this.attributes.uv) && (t.copyVector2sArray(n.uvs), t.needsUpdate = !0), n.uvsNeedUpdate = !1), n.lineDistancesNeedUpdate && (void 0 !== (t = this.attributes.lineDistance) && (t.copyArray(n.lineDistances), t.needsUpdate = !0), n.lineDistancesNeedUpdate = !1), n.groupsNeedUpdate && (n.computeGroups(e.geometry), this.groups = n.groups, n.groupsNeedUpdate = !1), this
        },
        fromGeometry: function(e) {
            return e.__directGeometry = (new ei).fromGeometry(e), this.fromDirectGeometry(e.__directGeometry)
        },
        fromDirectGeometry: function(e) {
            var t = new Float32Array(3 * e.vertices.length);
            if (this.addAttribute("position", new Vr(t, 3).copyVector3sArray(e.vertices)), e.normals.length > 0) {
                var n = new Float32Array(3 * e.normals.length);
                this.addAttribute("normal", new Vr(n, 3).copyVector3sArray(e.normals))
            }
            if (e.colors.length > 0) {
                var r = new Float32Array(3 * e.colors.length);
                this.addAttribute("color", new Vr(r, 3).copyColorsArray(e.colors))
            }
            if (e.uvs.length > 0) {
                var i = new Float32Array(2 * e.uvs.length);
                this.addAttribute("uv", new Vr(i, 2).copyVector2sArray(e.uvs))
            }
            if (e.uvs2.length > 0) {
                var o = new Float32Array(2 * e.uvs2.length);
                this.addAttribute("uv2", new Vr(o, 2).copyVector2sArray(e.uvs2))
            }
            for (var a in this.groups = e.groups, e.morphTargets) {
                for (var s = [], c = e.morphTargets[a], u = 0, l = c.length; u < l; u++) {
                    var f = c[u],
                        d = new Qr(3 * f.data.length, 3);
                    d.name = f.name, s.push(d.copyVector3sArray(f.data))
                }
                this.morphAttributes[a] = s
            }
            if (e.skinIndices.length > 0) {
                var h = new Qr(4 * e.skinIndices.length, 4);
                this.addAttribute("skinIndex", h.copyVector4sArray(e.skinIndices))
            }
            if (e.skinWeights.length > 0) {
                var v = new Qr(4 * e.skinWeights.length, 4);
                this.addAttribute("skinWeight", v.copyVector4sArray(e.skinWeights))
            }
            return null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()), this
        },
        computeBoundingBox: function() {
            null === this.boundingBox && (this.boundingBox = new lr);
            var e = this.attributes.position,
                t = this.morphAttributes.position;
            if (void 0 !== e) {
                if (this.boundingBox.setFromBufferAttribute(e), t)
                    for (var n = 0, r = t.length; n < r; n++) {
                        var i = t[n];
                        ai.setFromBufferAttribute(i), this.boundingBox.expandByPoint(ai.min), this.boundingBox.expandByPoint(ai.max)
                    }
            } else this.boundingBox.makeEmpty();
            (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
        },
        computeBoundingSphere: function() {
            null === this.boundingSphere && (this.boundingSphere = new hr);
            var e = this.attributes.position,
                t = this.morphAttributes.position;
            if (e) {
                var n = this.boundingSphere.center;
                if (ai.setFromBufferAttribute(e), t)
                    for (var r = 0, i = t.length; r < i; r++) {
                        var o = t[r];
                        si.setFromBufferAttribute(o), ai.expandByPoint(si.min), ai.expandByPoint(si.max)
                    }
                ai.getCenter(n);
                var a = 0;
                for (r = 0, i = e.count; r < i; r++) ci.fromBufferAttribute(e, r), a = Math.max(a, n.distanceToSquared(ci));
                if (t)
                    for (r = 0, i = t.length; r < i; r++)
                        for (var s = 0, c = (o = t[r]).count; s < c; s++) ci.fromBufferAttribute(o, s), a = Math.max(a, n.distanceToSquared(ci));
                this.boundingSphere.radius = Math.sqrt(a), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
            }
        },
        computeFaceNormals: function() {},
        computeVertexNormals: function() {
            var e = this.index,
                t = this.attributes;
            if (t.position) {
                var n = t.position.array;
                if (void 0 === t.normal) this.addAttribute("normal", new Vr(new Float32Array(n.length), 3));
                else
                    for (var r = t.normal.array, i = 0, o = r.length; i < o; i++) r[i] = 0;
                var a, s, c, u = t.normal.array,
                    l = new pn,
                    f = new pn,
                    d = new pn,
                    h = new pn,
                    v = new pn;
                if (e) {
                    var p = e.array;
                    for (i = 0, o = e.count; i < o; i += 3) a = 3 * p[i + 0], s = 3 * p[i + 1], c = 3 * p[i + 2], l.fromArray(n, a), f.fromArray(n, s), d.fromArray(n, c), h.subVectors(d, f), v.subVectors(l, f), h.cross(v), u[a] += h.x, u[a + 1] += h.y, u[a + 2] += h.z, u[s] += h.x, u[s + 1] += h.y, u[s + 2] += h.z, u[c] += h.x, u[c + 1] += h.y, u[c + 2] += h.z
                } else
                    for (i = 0, o = n.length; i < o; i += 9) l.fromArray(n, i), f.fromArray(n, i + 3), d.fromArray(n, i + 6), h.subVectors(d, f), v.subVectors(l, f), h.cross(v), u[i] = h.x, u[i + 1] = h.y, u[i + 2] = h.z, u[i + 3] = h.x, u[i + 4] = h.y, u[i + 5] = h.z, u[i + 6] = h.x, u[i + 7] = h.y, u[i + 8] = h.z;
                this.normalizeNormals(), t.normal.needsUpdate = !0
            }
        },
        merge: function(e, t) {
            if (e && e.isBufferGeometry) {
                void 0 === t && (t = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
                var n = this.attributes;
                for (var r in n)
                    if (void 0 !== e.attributes[r])
                        for (var i = n[r].array, o = e.attributes[r], a = o.array, s = o.itemSize * t, c = Math.min(a.length, i.length - s), u = 0, l = s; u < c; u++, l++) i[l] = a[u];
                return this
            }
            console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", e)
        },
        normalizeNormals: function() {
            for (var e = this.attributes.normal, t = 0, n = e.count; t < n; t++) ci.x = e.getX(t), ci.y = e.getY(t), ci.z = e.getZ(t), ci.normalize(), e.setXYZ(t, ci.x, ci.y, ci.z)
        },
        toNonIndexed: function() {
            function e(e, t) {
                for (var n = e.array, r = e.itemSize, i = new n.constructor(t.length * r), o = 0, a = 0, s = 0, c = t.length; s < c; s++) {
                    o = t[s] * r;
                    for (var u = 0; u < r; u++) i[a++] = n[o++]
                }
                return new Vr(i, r)
            }
            if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."), this;
            var t = new ui,
                n = this.index.array,
                r = this.attributes;
            for (var i in r) {
                var o = e(r[i], n);
                t.addAttribute(i, o)
            }
            var a = this.morphAttributes;
            for (i in a) {
                for (var s = [], c = a[i], u = 0, l = c.length; u < l; u++) {
                    o = e(c[u], n);
                    s.push(o)
                }
                t.morphAttributes[i] = s
            }
            for (var f = this.groups, d = (u = 0, f.length); u < d; u++) {
                var h = f[u];
                t.addGroup(h.start, h.count, h.materialIndex)
            }
            return t
        },
        toJSON: function() {
            var e = {
                metadata: {
                    version: 4.5,
                    type: "BufferGeometry",
                    generator: "BufferGeometry.toJSON"
                }
            };
            if (e.uuid = this.uuid, e.type = this.type, "" !== this.name && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), void 0 !== this.parameters) {
                var t = this.parameters;
                for (var n in t) void 0 !== t[n] && (e[n] = t[n]);
                return e
            }
            e.data = {
                attributes: {}
            };
            var r = this.index;
            null !== r && (e.data.index = {
                type: r.array.constructor.name,
                array: Array.prototype.slice.call(r.array)
            });
            var i = this.attributes;
            for (var n in i) {
                var o = (d = i[n]).toJSON();
                "" !== d.name && (o.name = d.name), e.data.attributes[n] = o
            }
            var a = {},
                s = !1;
            for (var n in this.morphAttributes) {
                for (var c = this.morphAttributes[n], u = [], l = 0, f = c.length; l < f; l++) {
                    var d;
                    o = (d = c[l]).toJSON();
                    "" !== d.name && (o.name = d.name), u.push(o)
                }
                u.length > 0 && (a[n] = u, s = !0)
            }
            s && (e.data.morphAttributes = a);
            var h = this.groups;
            h.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(h)));
            var v = this.boundingSphere;
            return null !== v && (e.data.boundingSphere = {
                center: v.center.toArray(),
                radius: v.radius
            }), e
        },
        clone: function() {
            return (new ui).copy(this)
        },
        copy: function(e) {
            var t, n, r;
            this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.name = e.name;
            var i = e.index;
            null !== i && this.setIndex(i.clone());
            var o = e.attributes;
            for (t in o) {
                var a = o[t];
                this.addAttribute(t, a.clone())
            }
            var s = e.morphAttributes;
            for (t in s) {
                var c = [],
                    u = s[t];
                for (n = 0, r = u.length; n < r; n++) c.push(u[n].clone());
                this.morphAttributes[t] = c
            }
            var l = e.groups;
            for (n = 0, r = l.length; n < r; n++) {
                var f = l[n];
                this.addGroup(f.start, f.count, f.materialIndex)
            }
            var d = e.boundingBox;
            null !== d && (this.boundingBox = d.clone());
            var h = e.boundingSphere;
            return null !== h && (this.boundingSphere = h.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    });
    var li = new Rn,
        fi = new wr,
        di = new hr,
        hi = new pn,
        vi = new pn,
        pi = new pn,
        mi = new pn,
        yi = new pn,
        gi = new pn,
        xi = new pn,
        bi = new pn,
        wi = new pn,
        Mi = new fn,
        _i = new fn,
        Si = new fn,
        Pi = new pn,
        Ti = new pn;

    function Ei(e, t) {
        Zn.call(this), this.type = "Mesh", this.geometry = void 0 !== e ? e : new ui, this.material = void 0 !== t ? t : new Hr({
            color: 16777215 * Math.random()
        }), this.drawMode = Lt, this.updateMorphTargets()
    }

    function zi(e, t, n, r, i, o, a, s) {
        if (null === (t.side === y ? r.intersectTriangle(a, o, i, !0, s) : r.intersectTriangle(i, o, a, t.side !== g, s))) return null;
        Ti.copy(s), Ti.applyMatrix4(e.matrixWorld);
        var c = n.ray.origin.distanceTo(Ti);
        return c < n.near || c > n.far ? null : {
            distance: c,
            point: Ti.clone(),
            object: e
        }
    }

    function Li(e, t, n, r, i, o, a, s, c, u, l) {
        hi.fromBufferAttribute(i, c), vi.fromBufferAttribute(i, u), pi.fromBufferAttribute(i, l);
        var f = e.morphTargetInfluences;
        if (t.morphTargets && o && f) {
            xi.set(0, 0, 0), bi.set(0, 0, 0), wi.set(0, 0, 0);
            for (var d = 0, h = o.length; d < h; d++) {
                var v = f[d],
                    p = o[d];
                0 !== v && (mi.fromBufferAttribute(p, c), yi.fromBufferAttribute(p, u), gi.fromBufferAttribute(p, l), xi.addScaledVector(mi.sub(hi), v), bi.addScaledVector(yi.sub(vi), v), wi.addScaledVector(gi.sub(pi), v))
            }
            hi.add(xi), vi.add(bi), pi.add(wi)
        }
        var m = zi(e, t, n, r, hi, vi, pi, Pi);
        if (m) {
            a && (Mi.fromBufferAttribute(a, c), _i.fromBufferAttribute(a, u), Si.fromBufferAttribute(a, l), m.uv = Rr.getUV(Pi, hi, vi, pi, Mi, _i, Si, new fn)), s && (Mi.fromBufferAttribute(s, c), _i.fromBufferAttribute(s, u), Si.fromBufferAttribute(s, l), m.uv2 = Rr.getUV(Pi, hi, vi, pi, Mi, _i, Si, new fn));
            var y = new Nr(c, u, l);
            Rr.getNormal(hi, vi, pi, y.normal), m.face = y
        }
        return m
    }
    Ei.prototype = Object.assign(Object.create(Zn.prototype), {
        constructor: Ei,
        isMesh: !0,
        setDrawMode: function(e) {
            this.drawMode = e
        },
        copy: function(e) {
            return Zn.prototype.copy.call(this, e), this.drawMode = e.drawMode, void 0 !== e.morphTargetInfluences && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), void 0 !== e.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this
        },
        updateMorphTargets: function() {
            var e, t, n, r = this.geometry;
            if (r.isBufferGeometry) {
                var i = r.morphAttributes,
                    o = Object.keys(i);
                if (o.length > 0) {
                    var a = i[o[0]];
                    if (void 0 !== a)
                        for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, e = 0, t = a.length; e < t; e++) n = a[e].name || String(e), this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = e
                }
            } else {
                var s = r.morphTargets;
                void 0 !== s && s.length > 0 && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
            }
        },
        raycast: function(e, t) {
            var n, r = this.geometry,
                i = this.material,
                o = this.matrixWorld;
            if (void 0 !== i && (null === r.boundingSphere && r.computeBoundingSphere(), di.copy(r.boundingSphere), di.applyMatrix4(o), !1 !== e.ray.intersectsSphere(di) && (li.getInverse(o), fi.copy(e.ray).applyMatrix4(li), null === r.boundingBox || !1 !== fi.intersectsBox(r.boundingBox))))
                if (r.isBufferGeometry) {
                    var a, s, c, u, l, f, d, h, v, p = r.index,
                        m = r.attributes.position,
                        y = r.morphAttributes.position,
                        g = r.attributes.uv,
                        x = r.attributes.uv2,
                        b = r.groups,
                        w = r.drawRange;
                    if (null !== p)
                        if (Array.isArray(i))
                            for (u = 0, f = b.length; u < f; u++)
                                for (v = i[(h = b[u]).materialIndex], l = Math.max(h.start, w.start), d = Math.min(h.start + h.count, w.start + w.count); l < d; l += 3) a = p.getX(l), s = p.getX(l + 1), c = p.getX(l + 2), (n = Li(this, v, e, fi, m, y, g, x, a, s, c)) && (n.faceIndex = Math.floor(l / 3), n.face.materialIndex = h.materialIndex, t.push(n));
                        else
                            for (u = Math.max(0, w.start), f = Math.min(p.count, w.start + w.count); u < f; u += 3) a = p.getX(u), s = p.getX(u + 1), c = p.getX(u + 2), (n = Li(this, i, e, fi, m, y, g, x, a, s, c)) && (n.faceIndex = Math.floor(u / 3), t.push(n));
                    else if (void 0 !== m)
                        if (Array.isArray(i))
                            for (u = 0, f = b.length; u < f; u++)
                                for (v = i[(h = b[u]).materialIndex], l = Math.max(h.start, w.start), d = Math.min(h.start + h.count, w.start + w.count); l < d; l += 3)(n = Li(this, v, e, fi, m, y, g, x, a = l, s = l + 1, c = l + 2)) && (n.faceIndex = Math.floor(l / 3), n.face.materialIndex = h.materialIndex, t.push(n));
                        else
                            for (u = Math.max(0, w.start), f = Math.min(m.count, w.start + w.count); u < f; u += 3)(n = Li(this, i, e, fi, m, y, g, x, a = u, s = u + 1, c = u + 2)) && (n.faceIndex = Math.floor(u / 3), t.push(n))
                } else if (r.isGeometry) {
                var M, _, S, P, T = Array.isArray(i),
                    E = r.vertices,
                    z = r.faces,
                    L = r.faceVertexUvs[0];
                L.length > 0 && (P = L);
                for (var A = 0, C = z.length; A < C; A++) {
                    var R = z[A],
                        O = T ? i[R.materialIndex] : i;
                    if (void 0 !== O && (M = E[R.a], _ = E[R.b], S = E[R.c], n = zi(this, O, e, fi, M, _, S, Pi))) {
                        if (P && P[A]) {
                            var j = P[A];
                            Mi.copy(j[0]), _i.copy(j[1]), Si.copy(j[2]), n.uv = Rr.getUV(Pi, M, _, S, Mi, _i, Si, new fn)
                        }
                        n.face = R, n.faceIndex = A, t.push(n)
                    }
                }
            }
        },
        clone: function() {
            return new this.constructor(this.geometry, this.material).copy(this)
        }
    });
    var Ai = 0,
        Ci = new Rn,
        Ri = new Zn,
        Oi = new pn;

    function ji() {
        Object.defineProperty(this, "id", {
            value: Ai += 2
        }), this.uuid = ln.generateUUID(), this.name = "", this.type = "Geometry", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
            []
        ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.elementsNeedUpdate = !1, this.verticesNeedUpdate = !1, this.uvsNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.lineDistancesNeedUpdate = !1, this.groupsNeedUpdate = !1
    }
    ji.prototype = Object.assign(Object.create(sn.prototype), {
        constructor: ji,
        isGeometry: !0,
        applyMatrix: function(e) {
            for (var t = (new gn).getNormalMatrix(e), n = 0, r = this.vertices.length; n < r; n++) {
                this.vertices[n].applyMatrix4(e)
            }
            for (n = 0, r = this.faces.length; n < r; n++) {
                var i = this.faces[n];
                i.normal.applyMatrix3(t).normalize();
                for (var o = 0, a = i.vertexNormals.length; o < a; o++) i.vertexNormals[o].applyMatrix3(t).normalize()
            }
            return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this.verticesNeedUpdate = !0, this.normalsNeedUpdate = !0, this
        },
        rotateX: function(e) {
            return Ci.makeRotationX(e), this.applyMatrix(Ci), this
        },
        rotateY: function(e) {
            return Ci.makeRotationY(e), this.applyMatrix(Ci), this
        },
        rotateZ: function(e) {
            return Ci.makeRotationZ(e), this.applyMatrix(Ci), this
        },
        translate: function(e, t, n) {
            return Ci.makeTranslation(e, t, n), this.applyMatrix(Ci), this
        },
        scale: function(e, t, n) {
            return Ci.makeScale(e, t, n), this.applyMatrix(Ci), this
        },
        lookAt: function(e) {
            return Ri.lookAt(e), Ri.updateMatrix(), this.applyMatrix(Ri.matrix), this
        },
        fromBufferGeometry: function(e) {
            var t = this,
                n = null !== e.index ? e.index.array : void 0,
                r = e.attributes;
            if (void 0 === r.position) return console.error("THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion."), this;
            var i = r.position.array,
                o = void 0 !== r.normal ? r.normal.array : void 0,
                a = void 0 !== r.color ? r.color.array : void 0,
                s = void 0 !== r.uv ? r.uv.array : void 0,
                c = void 0 !== r.uv2 ? r.uv2.array : void 0;
            void 0 !== c && (this.faceVertexUvs[1] = []);
            for (var u = 0; u < i.length; u += 3) t.vertices.push((new pn).fromArray(i, u)), void 0 !== a && t.colors.push((new Dr).fromArray(a, u));

            function l(e, n, r, i) {
                var u = void 0 === a ? [] : [t.colors[e].clone(), t.colors[n].clone(), t.colors[r].clone()],
                    l = new Nr(e, n, r, void 0 === o ? [] : [(new pn).fromArray(o, 3 * e), (new pn).fromArray(o, 3 * n), (new pn).fromArray(o, 3 * r)], u, i);
                t.faces.push(l), void 0 !== s && t.faceVertexUvs[0].push([(new fn).fromArray(s, 2 * e), (new fn).fromArray(s, 2 * n), (new fn).fromArray(s, 2 * r)]), void 0 !== c && t.faceVertexUvs[1].push([(new fn).fromArray(c, 2 * e), (new fn).fromArray(c, 2 * n), (new fn).fromArray(c, 2 * r)])
            }
            var f = e.groups;
            if (f.length > 0)
                for (u = 0; u < f.length; u++)
                    for (var d = f[u], h = d.start, v = h, p = h + d.count; v < p; v += 3) void 0 !== n ? l(n[v], n[v + 1], n[v + 2], d.materialIndex) : l(v, v + 1, v + 2, d.materialIndex);
            else if (void 0 !== n)
                for (u = 0; u < n.length; u += 3) l(n[u], n[u + 1], n[u + 2]);
            else
                for (u = 0; u < i.length / 3; u += 3) l(u, u + 1, u + 2);
            return this.computeFaceNormals(), null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()), null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), this
        },
        center: function() {
            return this.computeBoundingBox(), this.boundingBox.getCenter(Oi).negate(), this.translate(Oi.x, Oi.y, Oi.z), this
        },
        normalize: function() {
            this.computeBoundingSphere();
            var e = this.boundingSphere.center,
                t = this.boundingSphere.radius,
                n = 0 === t ? 1 : 1 / t,
                r = new Rn;
            return r.set(n, 0, 0, -n * e.x, 0, n, 0, -n * e.y, 0, 0, n, -n * e.z, 0, 0, 0, 1), this.applyMatrix(r), this
        },
        computeFaceNormals: function() {
            for (var e = new pn, t = new pn, n = 0, r = this.faces.length; n < r; n++) {
                var i = this.faces[n],
                    o = this.vertices[i.a],
                    a = this.vertices[i.b],
                    s = this.vertices[i.c];
                e.subVectors(s, a), t.subVectors(o, a), e.cross(t), e.normalize(), i.normal.copy(e)
            }
        },
        computeVertexNormals: function(e) {
            var t, n, r, i, o, a;
            for (void 0 === e && (e = !0), a = new Array(this.vertices.length), t = 0, n = this.vertices.length; t < n; t++) a[t] = new pn;
            if (e) {
                var s, c, u, l = new pn,
                    f = new pn;
                for (r = 0, i = this.faces.length; r < i; r++) o = this.faces[r], s = this.vertices[o.a], c = this.vertices[o.b], u = this.vertices[o.c], l.subVectors(u, c), f.subVectors(s, c), l.cross(f), a[o.a].add(l), a[o.b].add(l), a[o.c].add(l)
            } else
                for (this.computeFaceNormals(), r = 0, i = this.faces.length; r < i; r++) a[(o = this.faces[r]).a].add(o.normal), a[o.b].add(o.normal), a[o.c].add(o.normal);
            for (t = 0, n = this.vertices.length; t < n; t++) a[t].normalize();
            for (r = 0, i = this.faces.length; r < i; r++) {
                var d = (o = this.faces[r]).vertexNormals;
                3 === d.length ? (d[0].copy(a[o.a]), d[1].copy(a[o.b]), d[2].copy(a[o.c])) : (d[0] = a[o.a].clone(), d[1] = a[o.b].clone(), d[2] = a[o.c].clone())
            }
            this.faces.length > 0 && (this.normalsNeedUpdate = !0)
        },
        computeFlatVertexNormals: function() {
            var e, t, n;
            for (this.computeFaceNormals(), e = 0, t = this.faces.length; e < t; e++) {
                var r = (n = this.faces[e]).vertexNormals;
                3 === r.length ? (r[0].copy(n.normal), r[1].copy(n.normal), r[2].copy(n.normal)) : (r[0] = n.normal.clone(), r[1] = n.normal.clone(), r[2] = n.normal.clone())
            }
            this.faces.length > 0 && (this.normalsNeedUpdate = !0)
        },
        computeMorphNormals: function() {
            var e, t, n, r, i;
            for (n = 0, r = this.faces.length; n < r; n++)
                for ((i = this.faces[n]).__originalFaceNormal ? i.__originalFaceNormal.copy(i.normal) : i.__originalFaceNormal = i.normal.clone(), i.__originalVertexNormals || (i.__originalVertexNormals = []), e = 0, t = i.vertexNormals.length; e < t; e++) i.__originalVertexNormals[e] ? i.__originalVertexNormals[e].copy(i.vertexNormals[e]) : i.__originalVertexNormals[e] = i.vertexNormals[e].clone();
            var o = new ji;
            for (o.faces = this.faces, e = 0, t = this.morphTargets.length; e < t; e++) {
                if (!this.morphNormals[e]) {
                    this.morphNormals[e] = {}, this.morphNormals[e].faceNormals = [], this.morphNormals[e].vertexNormals = [];
                    var a = this.morphNormals[e].faceNormals,
                        s = this.morphNormals[e].vertexNormals;
                    for (n = 0, r = this.faces.length; n < r; n++) c = new pn, u = {
                        a: new pn,
                        b: new pn,
                        c: new pn
                    }, a.push(c), s.push(u)
                }
                var c, u, l = this.morphNormals[e];
                for (o.vertices = this.morphTargets[e].vertices, o.computeFaceNormals(), o.computeVertexNormals(), n = 0, r = this.faces.length; n < r; n++) i = this.faces[n], c = l.faceNormals[n], u = l.vertexNormals[n], c.copy(i.normal), u.a.copy(i.vertexNormals[0]), u.b.copy(i.vertexNormals[1]), u.c.copy(i.vertexNormals[2])
            }
            for (n = 0, r = this.faces.length; n < r; n++)(i = this.faces[n]).normal = i.__originalFaceNormal, i.vertexNormals = i.__originalVertexNormals
        },
        computeBoundingBox: function() {
            null === this.boundingBox && (this.boundingBox = new lr), this.boundingBox.setFromPoints(this.vertices)
        },
        computeBoundingSphere: function() {
            null === this.boundingSphere && (this.boundingSphere = new hr), this.boundingSphere.setFromPoints(this.vertices)
        },
        merge: function(e, t, n) {
            if (e && e.isGeometry) {
                var r, i = this.vertices.length,
                    o = this.vertices,
                    a = e.vertices,
                    s = this.faces,
                    c = e.faces,
                    u = this.colors,
                    l = e.colors;
                void 0 === n && (n = 0), void 0 !== t && (r = (new gn).getNormalMatrix(t));
                for (var f = 0, d = a.length; f < d; f++) {
                    var h = a[f].clone();
                    void 0 !== t && h.applyMatrix4(t), o.push(h)
                }
                for (f = 0, d = l.length; f < d; f++) u.push(l[f].clone());
                for (f = 0, d = c.length; f < d; f++) {
                    var v, p, m, y = c[f],
                        g = y.vertexNormals,
                        x = y.vertexColors;
                    (v = new Nr(y.a + i, y.b + i, y.c + i)).normal.copy(y.normal), void 0 !== r && v.normal.applyMatrix3(r).normalize();
                    for (var b = 0, w = g.length; b < w; b++) p = g[b].clone(), void 0 !== r && p.applyMatrix3(r).normalize(), v.vertexNormals.push(p);
                    v.color.copy(y.color);
                    for (b = 0, w = x.length; b < w; b++) m = x[b], v.vertexColors.push(m.clone());
                    v.materialIndex = y.materialIndex + n, s.push(v)
                }
                for (f = 0, d = e.faceVertexUvs.length; f < d; f++) {
                    var M = e.faceVertexUvs[f];
                    void 0 === this.faceVertexUvs[f] && (this.faceVertexUvs[f] = []);
                    for (b = 0, w = M.length; b < w; b++) {
                        for (var _ = M[b], S = [], P = 0, T = _.length; P < T; P++) S.push(_[P].clone());
                        this.faceVertexUvs[f].push(S)
                    }
                }
            } else console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", e)
        },
        mergeMesh: function(e) {
            e && e.isMesh ? (e.matrixAutoUpdate && e.updateMatrix(), this.merge(e.geometry, e.matrix)) : console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", e)
        },
        mergeVertices: function() {
            var e, t, n, r, i, o, a, s, c = {},
                u = [],
                l = [],
                f = Math.pow(10, 4);
            for (n = 0, r = this.vertices.length; n < r; n++) e = this.vertices[n], void 0 === c[t = Math.round(e.x * f) + "_" + Math.round(e.y * f) + "_" + Math.round(e.z * f)] ? (c[t] = n, u.push(this.vertices[n]), l[n] = u.length - 1) : l[n] = l[c[t]];
            var d = [];
            for (n = 0, r = this.faces.length; n < r; n++) {
                (i = this.faces[n]).a = l[i.a], i.b = l[i.b], i.c = l[i.c], o = [i.a, i.b, i.c];
                for (var h = 0; h < 3; h++)
                    if (o[h] === o[(h + 1) % 3]) {
                        d.push(n);
                        break
                    }
            }
            for (n = d.length - 1; n >= 0; n--) {
                var v = d[n];
                for (this.faces.splice(v, 1), a = 0, s = this.faceVertexUvs.length; a < s; a++) this.faceVertexUvs[a].splice(v, 1)
            }
            var p = this.vertices.length - u.length;
            return this.vertices = u, p
        },
        setFromPoints: function(e) {
            this.vertices = [];
            for (var t = 0, n = e.length; t < n; t++) {
                var r = e[t];
                this.vertices.push(new pn(r.x, r.y, r.z || 0))
            }
            return this
        },
        sortFacesByMaterialIndex: function() {
            for (var e = this.faces, t = e.length, n = 0; n < t; n++) e[n]._id = n;
            e.sort((function(e, t) {
                return e.materialIndex - t.materialIndex
            }));
            var r, i, o = this.faceVertexUvs[0],
                a = this.faceVertexUvs[1];
            o && o.length === t && (r = []), a && a.length === t && (i = []);
            for (n = 0; n < t; n++) {
                var s = e[n]._id;
                r && r.push(o[s]), i && i.push(a[s])
            }
            r && (this.faceVertexUvs[0] = r), i && (this.faceVertexUvs[1] = i)
        },
        toJSON: function() {
            var e = {
                metadata: {
                    version: 4.5,
                    type: "Geometry",
                    generator: "Geometry.toJSON"
                }
            };
            if (e.uuid = this.uuid, e.type = this.type, "" !== this.name && (e.name = this.name), void 0 !== this.parameters) {
                var t = this.parameters;
                for (var n in t) void 0 !== t[n] && (e[n] = t[n]);
                return e
            }
            for (var r = [], i = 0; i < this.vertices.length; i++) {
                var o = this.vertices[i];
                r.push(o.x, o.y, o.z)
            }
            var a = [],
                s = [],
                c = {},
                u = [],
                l = {},
                f = [],
                d = {};
            for (i = 0; i < this.faces.length; i++) {
                var h = this.faces[i],
                    v = void 0 !== this.faceVertexUvs[0][i],
                    p = h.normal.length() > 0,
                    m = h.vertexNormals.length > 0,
                    y = 1 !== h.color.r || 1 !== h.color.g || 1 !== h.color.b,
                    g = h.vertexColors.length > 0,
                    x = 0;
                if (x = _(x, 0, 0), x = _(x, 1, !0), x = _(x, 2, !1), x = _(x, 3, v), x = _(x, 4, p), x = _(x, 5, m), x = _(x, 6, y), x = _(x, 7, g), a.push(x), a.push(h.a, h.b, h.c), a.push(h.materialIndex), v) {
                    var b = this.faceVertexUvs[0][i];
                    a.push(T(b[0]), T(b[1]), T(b[2]))
                }
                if (p && a.push(S(h.normal)), m) {
                    var w = h.vertexNormals;
                    a.push(S(w[0]), S(w[1]), S(w[2]))
                }
                if (y && a.push(P(h.color)), g) {
                    var M = h.vertexColors;
                    a.push(P(M[0]), P(M[1]), P(M[2]))
                }
            }

            function _(e, t, n) {
                return n ? e | 1 << t : e & ~(1 << t)
            }

            function S(e) {
                var t = e.x.toString() + e.y.toString() + e.z.toString();
                return void 0 !== c[t] ? c[t] : (c[t] = s.length / 3, s.push(e.x, e.y, e.z), c[t])
            }

            function P(e) {
                var t = e.r.toString() + e.g.toString() + e.b.toString();
                return void 0 !== l[t] ? l[t] : (l[t] = u.length, u.push(e.getHex()), l[t])
            }

            function T(e) {
                var t = e.x.toString() + e.y.toString();
                return void 0 !== d[t] ? d[t] : (d[t] = f.length / 2, f.push(e.x, e.y), d[t])
            }
            return e.data = {}, e.data.vertices = r, e.data.normals = s, u.length > 0 && (e.data.colors = u), f.length > 0 && (e.data.uvs = [f]), e.data.faces = a, e
        },
        clone: function() {
            return (new ji).copy(this)
        },
        copy: function(e) {
            var t, n, r, i, o, a;
            this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
                []
            ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.name = e.name;
            var s = e.vertices;
            for (t = 0, n = s.length; t < n; t++) this.vertices.push(s[t].clone());
            var c = e.colors;
            for (t = 0, n = c.length; t < n; t++) this.colors.push(c[t].clone());
            var u = e.faces;
            for (t = 0, n = u.length; t < n; t++) this.faces.push(u[t].clone());
            for (t = 0, n = e.faceVertexUvs.length; t < n; t++) {
                var l = e.faceVertexUvs[t];
                for (void 0 === this.faceVertexUvs[t] && (this.faceVertexUvs[t] = []), r = 0, i = l.length; r < i; r++) {
                    var f = l[r],
                        d = [];
                    for (o = 0, a = f.length; o < a; o++) {
                        var h = f[o];
                        d.push(h.clone())
                    }
                    this.faceVertexUvs[t].push(d)
                }
            }
            var v = e.morphTargets;
            for (t = 0, n = v.length; t < n; t++) {
                var p = {};
                if (p.name = v[t].name, void 0 !== v[t].vertices)
                    for (p.vertices = [], r = 0, i = v[t].vertices.length; r < i; r++) p.vertices.push(v[t].vertices[r].clone());
                if (void 0 !== v[t].normals)
                    for (p.normals = [], r = 0, i = v[t].normals.length; r < i; r++) p.normals.push(v[t].normals[r].clone());
                this.morphTargets.push(p)
            }
            var m = e.morphNormals;
            for (t = 0, n = m.length; t < n; t++) {
                var y = {};
                if (void 0 !== m[t].vertexNormals)
                    for (y.vertexNormals = [], r = 0, i = m[t].vertexNormals.length; r < i; r++) {
                        var g = m[t].vertexNormals[r],
                            x = {};
                        x.a = g.a.clone(), x.b = g.b.clone(), x.c = g.c.clone(), y.vertexNormals.push(x)
                    }
                if (void 0 !== m[t].faceNormals)
                    for (y.faceNormals = [], r = 0, i = m[t].faceNormals.length; r < i; r++) y.faceNormals.push(m[t].faceNormals[r].clone());
                this.morphNormals.push(y)
            }
            var b = e.skinWeights;
            for (t = 0, n = b.length; t < n; t++) this.skinWeights.push(b[t].clone());
            var w = e.skinIndices;
            for (t = 0, n = w.length; t < n; t++) this.skinIndices.push(w[t].clone());
            var M = e.lineDistances;
            for (t = 0, n = M.length; t < n; t++) this.lineDistances.push(M[t]);
            var _ = e.boundingBox;
            null !== _ && (this.boundingBox = _.clone());
            var S = e.boundingSphere;
            return null !== S && (this.boundingSphere = S.clone()), this.elementsNeedUpdate = e.elementsNeedUpdate, this.verticesNeedUpdate = e.verticesNeedUpdate, this.uvsNeedUpdate = e.uvsNeedUpdate, this.normalsNeedUpdate = e.normalsNeedUpdate, this.colorsNeedUpdate = e.colorsNeedUpdate, this.lineDistancesNeedUpdate = e.lineDistancesNeedUpdate, this.groupsNeedUpdate = e.groupsNeedUpdate, this
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    });
    class Ii extends ji {
        constructor(e, t, n, r, i, o) {
            super(), this.type = "BoxGeometry", this.parameters = {
                width: e,
                height: t,
                depth: n,
                widthSegments: r,
                heightSegments: i,
                depthSegments: o
            }, this.fromBufferGeometry(new Di(e, t, n, r, i, o)), this.mergeVertices()
        }
    }
    class Di extends ui {
        constructor(e, t, n, r, i, o) {
            super(), this.type = "BoxBufferGeometry", this.parameters = {
                width: e,
                height: t,
                depth: n,
                widthSegments: r,
                heightSegments: i,
                depthSegments: o
            };
            var a = this;
            e = e || 1, t = t || 1, n = n || 1, r = Math.floor(r) || 1, i = Math.floor(i) || 1, o = Math.floor(o) || 1;
            var s = [],
                c = [],
                u = [],
                l = [],
                f = 0,
                d = 0;

            function h(e, t, n, r, i, o, h, v, p, m, y) {
                var g, x, b = o / p,
                    w = h / m,
                    M = o / 2,
                    _ = h / 2,
                    S = v / 2,
                    P = p + 1,
                    T = m + 1,
                    E = 0,
                    z = 0,
                    L = new pn;
                for (x = 0; x < T; x++) {
                    var A = x * w - _;
                    for (g = 0; g < P; g++) {
                        var C = g * b - M;
                        L[e] = C * r, L[t] = A * i, L[n] = S, c.push(L.x, L.y, L.z), L[e] = 0, L[t] = 0, L[n] = v > 0 ? 1 : -1, u.push(L.x, L.y, L.z), l.push(g / p), l.push(1 - x / m), E += 1
                    }
                }
                for (x = 0; x < m; x++)
                    for (g = 0; g < p; g++) {
                        var R = f + g + P * x,
                            O = f + g + P * (x + 1),
                            j = f + (g + 1) + P * (x + 1),
                            I = f + (g + 1) + P * x;
                        s.push(R, O, I), s.push(O, j, I), z += 6
                    }
                a.addGroup(d, z, y), d += z, f += E
            }
            h("z", "y", "x", -1, -1, n, t, e, o, i, 0), h("z", "y", "x", 1, -1, n, t, -e, o, i, 1), h("x", "z", "y", 1, 1, e, n, t, r, o, 2), h("x", "z", "y", 1, -1, e, n, -t, r, o, 3), h("x", "y", "z", 1, -1, e, t, n, r, i, 4), h("x", "y", "z", -1, -1, e, t, -n, r, i, 5), this.setIndex(s), this.addAttribute("position", new Qr(c, 3)), this.addAttribute("normal", new Qr(u, 3)), this.addAttribute("uv", new Qr(l, 2))
        }
    }

    function ki(e) {
        var t = {};
        for (var n in e)
            for (var r in t[n] = {}, e[n]) {
                var i = e[n][r];
                i && (i.isColor || i.isMatrix3 || i.isMatrix4 || i.isVector2 || i.isVector3 || i.isVector4 || i.isTexture) ? t[n][r] = i.clone() : Array.isArray(i) ? t[n][r] = i.slice() : t[n][r] = i
            }
        return t
    }

    function Fi(e) {
        for (var t = {}, n = 0; n < e.length; n++) {
            var r = ki(e[n]);
            for (var i in r) t[i] = r[i]
        }
        return t
    }
    var Gi = {
            clone: ki,
            merge: Fi
        },
        Ni = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
        Bi = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";

    function Ui(e) {
        Ur.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = Ni, this.fragmentShader = Bi, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.extensions = {
            derivatives: !1,
            fragDepth: !1,
            drawBuffers: !1,
            shaderTextureLOD: !1
        }, this.defaultAttributeValues = {
            color: [1, 1, 1],
            uv: [0, 0],
            uv2: [0, 0]
        }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, void 0 !== e && (void 0 !== e.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(e))
    }

    function Hi() {
        Zn.call(this), this.type = "Camera", this.matrixWorldInverse = new Rn, this.projectionMatrix = new Rn, this.projectionMatrixInverse = new Rn
    }

    function Vi(e, t, n, r) {
        Hi.call(this), this.type = "PerspectiveCamera", this.fov = void 0 !== e ? e : 50, this.zoom = 1, this.near = void 0 !== n ? n : .1, this.far = void 0 !== r ? r : 2e3, this.focus = 10, this.aspect = void 0 !== t ? t : 1, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
    }
    Ui.prototype = Object.create(Ur.prototype), Ui.prototype.constructor = Ui, Ui.prototype.isShaderMaterial = !0, Ui.prototype.copy = function(e) {
        return Ur.prototype.copy.call(this, e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = ki(e.uniforms), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.lights = e.lights, this.clipping = e.clipping, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this.extensions = e.extensions, this
    }, Ui.prototype.toJSON = function(e) {
        var t = Ur.prototype.toJSON.call(this, e);
        for (var n in t.uniforms = {}, this.uniforms) {
            var r = this.uniforms[n].value;
            r && r.isTexture ? t.uniforms[n] = {
                type: "t",
                value: r.toJSON(e).uuid
            } : r && r.isColor ? t.uniforms[n] = {
                type: "c",
                value: r.getHex()
            } : r && r.isVector2 ? t.uniforms[n] = {
                type: "v2",
                value: r.toArray()
            } : r && r.isVector3 ? t.uniforms[n] = {
                type: "v3",
                value: r.toArray()
            } : r && r.isVector4 ? t.uniforms[n] = {
                type: "v4",
                value: r.toArray()
            } : r && r.isMatrix3 ? t.uniforms[n] = {
                type: "m3",
                value: r.toArray()
            } : r && r.isMatrix4 ? t.uniforms[n] = {
                type: "m4",
                value: r.toArray()
            } : t.uniforms[n] = {
                value: r
            }
        }
        Object.keys(this.defines).length > 0 && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader;
        var i = {};
        for (var o in this.extensions) !0 === this.extensions[o] && (i[o] = !0);
        return Object.keys(i).length > 0 && (t.extensions = i), t
    }, Hi.prototype = Object.assign(Object.create(Zn.prototype), {
        constructor: Hi,
        isCamera: !0,
        copy: function(e, t) {
            return Zn.prototype.copy.call(this, e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this
        },
        getWorldDirection: function(e) {
            void 0 === e && (console.warn("THREE.Camera: .getWorldDirection() target is now required"), e = new pn), this.updateMatrixWorld(!0);
            var t = this.matrixWorld.elements;
            return e.set(-t[8], -t[9], -t[10]).normalize()
        },
        updateMatrixWorld: function(e) {
            Zn.prototype.updateMatrixWorld.call(this, e), this.matrixWorldInverse.getInverse(this.matrixWorld)
        },
        clone: function() {
            return (new this.constructor).copy(this)
        }
    }), Vi.prototype = Object.assign(Object.create(Hi.prototype), {
        constructor: Vi,
        isPerspectiveCamera: !0,
        copy: function(e, t) {
            return Hi.prototype.copy.call(this, e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = null === e.view ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this
        },
        setFocalLength: function(e) {
            var t = .5 * this.getFilmHeight() / e;
            this.fov = 2 * ln.RAD2DEG * Math.atan(t), this.updateProjectionMatrix()
        },
        getFocalLength: function() {
            var e = Math.tan(.5 * ln.DEG2RAD * this.fov);
            return .5 * this.getFilmHeight() / e
        },
        getEffectiveFOV: function() {
            return 2 * ln.RAD2DEG * Math.atan(Math.tan(.5 * ln.DEG2RAD * this.fov) / this.zoom)
        },
        getFilmWidth: function() {
            return this.filmGauge * Math.min(this.aspect, 1)
        },
        getFilmHeight: function() {
            return this.filmGauge / Math.max(this.aspect, 1)
        },
        setViewOffset: function(e, t, n, r, i, o) {
            this.aspect = e / t, null === this.view && (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1
            }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = r, this.view.width = i, this.view.height = o, this.updateProjectionMatrix()
        },
        clearViewOffset: function() {
            null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
        },
        updateProjectionMatrix: function() {
            var e = this.near,
                t = e * Math.tan(.5 * ln.DEG2RAD * this.fov) / this.zoom,
                n = 2 * t,
                r = this.aspect * n,
                i = -.5 * r,
                o = this.view;
            if (null !== this.view && this.view.enabled) {
                var a = o.fullWidth,
                    s = o.fullHeight;
                i += o.offsetX * r / a, t -= o.offsetY * n / s, r *= o.width / a, n *= o.height / s
            }
            var c = this.filmOffset;
            0 !== c && (i += e * c / this.getFilmWidth()), this.projectionMatrix.makePerspective(i, i + r, t, t - n, e, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix)
        },
        toJSON: function(e) {
            var t = Zn.prototype.toJSON.call(this, e);
            return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, null !== this.view && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t
        }
    });
    var Wi = 90,
        Yi = 1;

    function Xi(e, t, n, r) {
        Zn.call(this), this.type = "CubeCamera";
        var i = new Vi(Wi, Yi, e, t);
        i.up.set(0, -1, 0), i.lookAt(new pn(1, 0, 0)), this.add(i);
        var o = new Vi(Wi, Yi, e, t);
        o.up.set(0, -1, 0), o.lookAt(new pn(-1, 0, 0)), this.add(o);
        var a = new Vi(Wi, Yi, e, t);
        a.up.set(0, 0, 1), a.lookAt(new pn(0, 1, 0)), this.add(a);
        var s = new Vi(Wi, Yi, e, t);
        s.up.set(0, 0, -1), s.lookAt(new pn(0, -1, 0)), this.add(s);
        var c = new Vi(Wi, Yi, e, t);
        c.up.set(0, -1, 0), c.lookAt(new pn(0, 0, 1)), this.add(c);
        var u = new Vi(Wi, Yi, e, t);
        u.up.set(0, -1, 0), u.lookAt(new pn(0, 0, -1)), this.add(u), r = r || {
            format: He,
            magFilter: Pe,
            minFilter: Pe
        }, this.renderTarget = new qi(n, n, r), this.renderTarget.texture.name = "CubeCamera", this.update = function(e, t) {
            null === this.parent && this.updateMatrixWorld();
            var n = e.getRenderTarget(),
                r = this.renderTarget,
                l = r.texture.generateMipmaps;
            r.texture.generateMipmaps = !1, e.setRenderTarget(r, 0), e.render(t, i), e.setRenderTarget(r, 1), e.render(t, o), e.setRenderTarget(r, 2), e.render(t, a), e.setRenderTarget(r, 3), e.render(t, s), e.setRenderTarget(r, 4), e.render(t, c), r.texture.generateMipmaps = l, e.setRenderTarget(r, 5), e.render(t, u), e.setRenderTarget(n)
        }, this.clear = function(e, t, n, r) {
            for (var i = e.getRenderTarget(), o = this.renderTarget, a = 0; a < 6; a++) e.setRenderTarget(o, a), e.clear(t, n, r);
            e.setRenderTarget(i)
        }
    }

    function qi(e, t, n) {
        _n.call(this, e, t, n)
    }

    function Ki(e, t, n, r, i, o, a, s, c, u, l, f) {
        wn.call(this, null, o, a, s, c, u, r, i, l, f), this.image = {
            data: e || null,
            width: t || 1,
            height: n || 1
        }, this.magFilter = void 0 !== c ? c : be, this.minFilter = void 0 !== u ? u : be, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.needsUpdate = !0
    }
    Xi.prototype = Object.create(Zn.prototype), Xi.prototype.constructor = Xi, qi.prototype = Object.create(_n.prototype), qi.prototype.constructor = qi, qi.prototype.isWebGLRenderTargetCube = !0, qi.prototype.fromEquirectangularTexture = function(e, t) {
        this.texture.type = t.type, this.texture.format = t.format, this.texture.encoding = t.encoding;
        var n = new Jn,
            r = {
                uniforms: {
                    tEquirect: {
                        value: null
                    }
                },
                vertexShader: ["varying vec3 vWorldDirection;", "vec3 transformDirection( in vec3 dir, in mat4 matrix ) {", "\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );", "}", "void main() {", "\tvWorldDirection = transformDirection( position, modelMatrix );", "\t#include <begin_vertex>", "\t#include <project_vertex>", "}"].join("\n"),
                fragmentShader: ["uniform sampler2D tEquirect;", "varying vec3 vWorldDirection;", "#define RECIPROCAL_PI 0.31830988618", "#define RECIPROCAL_PI2 0.15915494", "void main() {", "\tvec3 direction = normalize( vWorldDirection );", "\tvec2 sampleUV;", "\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;", "\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;", "\tgl_FragColor = texture2D( tEquirect, sampleUV );", "}"].join("\n")
            },
            i = new Ui({
                type: "CubemapFromEquirect",
                uniforms: ki(r.uniforms),
                vertexShader: r.vertexShader,
                fragmentShader: r.fragmentShader,
                side: y,
                blending: S
            });
        i.uniforms.tEquirect.value = t;
        var o = new Ei(new Di(5, 5, 5), i);
        n.add(o);
        var a = new Xi(1, 10, 1);
        return a.renderTarget = this, a.renderTarget.texture.name = "CubeCameraTexture", a.update(e, n), o.geometry.dispose(), o.material.dispose(), this
    }, Ki.prototype = Object.create(wn.prototype), Ki.prototype.constructor = Ki, Ki.prototype.isDataTexture = !0;
    var Zi = new pn,
        Ji = new pn,
        Qi = new gn;

    function $i(e, t) {
        this.normal = void 0 !== e ? e : new pn(1, 0, 0), this.constant = void 0 !== t ? t : 0
    }
    Object.assign($i.prototype, {
        isPlane: !0,
        set: function(e, t) {
            return this.normal.copy(e), this.constant = t, this
        },
        setComponents: function(e, t, n, r) {
            return this.normal.set(e, t, n), this.constant = r, this
        },
        setFromNormalAndCoplanarPoint: function(e, t) {
            return this.normal.copy(e), this.constant = -t.dot(this.normal), this
        },
        setFromCoplanarPoints: function(e, t, n) {
            var r = Zi.subVectors(n, t).cross(Ji.subVectors(e, t)).normalize();
            return this.setFromNormalAndCoplanarPoint(r, e), this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.normal.copy(e.normal), this.constant = e.constant, this
        },
        normalize: function() {
            var e = 1 / this.normal.length();
            return this.normal.multiplyScalar(e), this.constant *= e, this
        },
        negate: function() {
            return this.constant *= -1, this.normal.negate(), this
        },
        distanceToPoint: function(e) {
            return this.normal.dot(e) + this.constant
        },
        distanceToSphere: function(e) {
            return this.distanceToPoint(e.center) - e.radius
        },
        projectPoint: function(e, t) {
            return void 0 === t && (console.warn("THREE.Plane: .projectPoint() target is now required"), t = new pn), t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e)
        },
        intersectLine: function(e, t) {
            void 0 === t && (console.warn("THREE.Plane: .intersectLine() target is now required"), t = new pn);
            var n = e.delta(Zi),
                r = this.normal.dot(n);
            if (0 === r) return 0 === this.distanceToPoint(e.start) ? t.copy(e.start) : void 0;
            var i = -(e.start.dot(this.normal) + this.constant) / r;
            return i < 0 || i > 1 ? void 0 : t.copy(n).multiplyScalar(i).add(e.start)
        },
        intersectsLine: function(e) {
            var t = this.distanceToPoint(e.start),
                n = this.distanceToPoint(e.end);
            return t < 0 && n > 0 || n < 0 && t > 0
        },
        intersectsBox: function(e) {
            return e.intersectsPlane(this)
        },
        intersectsSphere: function(e) {
            return e.intersectsPlane(this)
        },
        coplanarPoint: function(e) {
            return void 0 === e && (console.warn("THREE.Plane: .coplanarPoint() target is now required"), e = new pn), e.copy(this.normal).multiplyScalar(-this.constant)
        },
        applyMatrix4: function(e, t) {
            var n = t || Qi.getNormalMatrix(e),
                r = this.coplanarPoint(Zi).applyMatrix4(e),
                i = this.normal.applyMatrix3(n).normalize();
            return this.constant = -r.dot(i), this
        },
        translate: function(e) {
            return this.constant -= e.dot(this.normal), this
        },
        equals: function(e) {
            return e.normal.equals(this.normal) && e.constant === this.constant
        }
    });
    var eo = new hr,
        to = new pn;

    function no(e, t, n, r, i, o) {
        this.planes = [void 0 !== e ? e : new $i, void 0 !== t ? t : new $i, void 0 !== n ? n : new $i, void 0 !== r ? r : new $i, void 0 !== i ? i : new $i, void 0 !== o ? o : new $i]
    }
    Object.assign(no.prototype, {
        set: function(e, t, n, r, i, o) {
            var a = this.planes;
            return a[0].copy(e), a[1].copy(t), a[2].copy(n), a[3].copy(r), a[4].copy(i), a[5].copy(o), this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            for (var t = this.planes, n = 0; n < 6; n++) t[n].copy(e.planes[n]);
            return this
        },
        setFromMatrix: function(e) {
            var t = this.planes,
                n = e.elements,
                r = n[0],
                i = n[1],
                o = n[2],
                a = n[3],
                s = n[4],
                c = n[5],
                u = n[6],
                l = n[7],
                f = n[8],
                d = n[9],
                h = n[10],
                v = n[11],
                p = n[12],
                m = n[13],
                y = n[14],
                g = n[15];
            return t[0].setComponents(a - r, l - s, v - f, g - p).normalize(), t[1].setComponents(a + r, l + s, v + f, g + p).normalize(), t[2].setComponents(a + i, l + c, v + d, g + m).normalize(), t[3].setComponents(a - i, l - c, v - d, g - m).normalize(), t[4].setComponents(a - o, l - u, v - h, g - y).normalize(), t[5].setComponents(a + o, l + u, v + h, g + y).normalize(), this
        },
        intersectsObject: function(e) {
            var t = e.geometry;
            return null === t.boundingSphere && t.computeBoundingSphere(), eo.copy(t.boundingSphere).applyMatrix4(e.matrixWorld), this.intersectsSphere(eo)
        },
        intersectsSprite: function(e) {
            return eo.center.set(0, 0, 0), eo.radius = .7071067811865476, eo.applyMatrix4(e.matrixWorld), this.intersectsSphere(eo)
        },
        intersectsSphere: function(e) {
            for (var t = this.planes, n = e.center, r = -e.radius, i = 0; i < 6; i++) {
                if (t[i].distanceToPoint(n) < r) return !1
            }
            return !0
        },
        intersectsBox: function(e) {
            for (var t = this.planes, n = 0; n < 6; n++) {
                var r = t[n];
                if (to.x = r.normal.x > 0 ? e.max.x : e.min.x, to.y = r.normal.y > 0 ? e.max.y : e.min.y, to.z = r.normal.z > 0 ? e.max.z : e.min.z, r.distanceToPoint(to) < 0) return !1
            }
            return !0
        },
        containsPoint: function(e) {
            for (var t = this.planes, n = 0; n < 6; n++)
                if (t[n].distanceToPoint(e) < 0) return !1;
            return !0
        }
    });
    var ro = {
            alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
            alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
            alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif",
            aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif",
            aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
            begin_vertex: "vec3 transformed = vec3( position );",
            beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
            bsdfs: "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha  = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif",
            bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
            clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
            clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( STANDARD ) && ! defined( PHONG ) && ! defined( MATCAP )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
            clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( STANDARD ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvarying vec3 vViewPosition;\n#endif",
            clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( STANDARD ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif",
            color_fragment: "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",
            color_pars_fragment: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
            color_pars_vertex: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
            color_vertex: "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif",
            common: "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n  return m[ 2 ][ 3 ] == - 1.0;\n}",
            cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV( sampler2D envMap, vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif",
            defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\ttransformedNormal = mat3( instanceMatrix ) * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = normalMatrix * objectTangent;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
            displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
            displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",
            emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
            emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
            encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
            encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",
            envmap_fragment: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
            envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
            envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
            envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
            envmap_physical_pars_fragment: "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t  vec3 reflectVec = reflect( -viewDir, normal );\n\t\t  reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t  vec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryReflectVec, roughness );\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif",
            envmap_vertex: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
            fog_vertex: "#ifdef USE_FOG\n\tfogDepth = -mvPosition.z;\n#endif",
            fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif",
            fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
            fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
            gradientmap_pars_fragment: "#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif",
            lightmap_fragment: "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif",
            lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
            lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif",
            lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif",
            lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
            lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
            lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = saturate( clearcoat );\tmaterial.clearcoatRoughness = clamp( clearcoatRoughness, 0.04, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif",
            lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
            lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tdirectLight.color *= all( bvec3( pointLight.shadow, directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tdirectLight.color *= all( bvec3( spotLight.shadow, directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectLight.color *= all( bvec3( directionalLight.shadow, directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
            lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif",
            lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
            logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 1.0 ? log2( vFragDepth ) * logDepthBufFC * 0.5 : gl_FragCoord.z;\n#endif",
            logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
            logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
            logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
            map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",
            map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
            map_particle_fragment: "#ifdef USE_MAP\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif",
            map_particle_pars_fragment: "#ifdef USE_MAP\n\tuniform mat3 uvTransform;\n\tuniform sampler2D map;\n#endif",
            metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
            metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
            morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif",
            morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
            morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif",
            normal_fragment_begin: "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",
            normal_fragment_maps: "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\t#ifdef USE_TANGENT\n\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = normalScale * mapN.xy;\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, normalScale, normalMap );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif",
            normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec2 normalScale, in sampler2D normalMap ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\tvec3 N = normalize( surf_norm );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy *= normalScale;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tbool frontFacing = dot( cross( S, T ), N ) > 0.0;\n\t\t\tmapN.xy *= ( float( frontFacing ) * 2.0 - 1.0 );\n\t\t#else\n\t\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\tmat3 tsn = mat3( S, T, N );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif",
            clearcoat_normal_fragment_begin: "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",
            clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\t#ifdef USE_TANGENT\n\t\tmat3 vTBN = mat3( tangent, bitangent, clearcoatNormal );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = clearcoatNormalScale * mapN.xy;\n\t\tclearcoatNormal = normalize( vTBN * mapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatNormalScale, clearcoatNormalMap );\n\t#endif\n#endif",
            clearcoat_normalmap_pars_fragment: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",
            packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 encodeHalfRGBA ( vec2 v ) {\n\tvec4 encoded = vec4( 0.0 );\n\tconst vec2 offset = vec2( 1.0 / 255.0, 0.0 );\n\tencoded.xy = vec2( v.x, fract( v.x * 255.0 ) );\n\tencoded.xy = encoded.xy - ( encoded.yy * offset );\n\tencoded.zw = vec2( v.y, fract( v.y * 255.0 ) );\n\tencoded.zw = encoded.zw - ( encoded.ww * offset );\n\treturn encoded;\n}\nvec2 decodeHalfRGBA( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
            premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
            project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
            dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
            dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
            roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
            roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
            shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn decodeHalfRGBA( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = ( floor( uv * size - 0.5 ) + 0.5 ) * texelSize;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
            shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
            shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif",
            shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= all( bvec2( directionalLight.shadow, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= all( bvec2( spotLight.shadow, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= all( bvec2( pointLight.shadow, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}",
            skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
            skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",
            skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
            skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
            specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
            specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
            tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
            tonemapping_pars_fragment: "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( ( color * ( 2.51 * color + 0.03 ) ) / ( color * ( 2.43 * color + 0.59 ) + 0.14 ) );\n}",
            uv_pars_fragment: "#ifdef USE_UV\n\tvarying vec2 vUv;\n#endif",
            uv_pars_vertex: "#ifdef USE_UV\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif",
            uv_vertex: "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
            uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
            uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif",
            uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif",
            worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
            background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
            background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
            cube_frag: "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
            cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
            depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}",
            depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}",
            distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
            distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
            equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
            equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
            linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
            linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
            meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
            meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
            meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
            meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
            meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSPARENCY\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSPARENCY\n\tuniform float transparency;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSPARENCY\n\t\tdiffuseColor.a *= saturate( 1. - transparency + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",
            normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
            points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
            points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
            shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <fog_fragment>\n}",
            shadow_vert: "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
            sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}"
        },
        io = {
            common: {
                diffuse: {
                    value: new Dr(15658734)
                },
                opacity: {
                    value: 1
                },
                map: {
                    value: null
                },
                uvTransform: {
                    value: new gn
                },
                alphaMap: {
                    value: null
                }
            },
            specularmap: {
                specularMap: {
                    value: null
                }
            },
            envmap: {
                envMap: {
                    value: null
                },
                flipEnvMap: {
                    value: -1
                },
                reflectivity: {
                    value: 1
                },
                refractionRatio: {
                    value: .98
                },
                maxMipLevel: {
                    value: 0
                }
            },
            aomap: {
                aoMap: {
                    value: null
                },
                aoMapIntensity: {
                    value: 1
                }
            },
            lightmap: {
                lightMap: {
                    value: null
                },
                lightMapIntensity: {
                    value: 1
                }
            },
            emissivemap: {
                emissiveMap: {
                    value: null
                }
            },
            bumpmap: {
                bumpMap: {
                    value: null
                },
                bumpScale: {
                    value: 1
                }
            },
            normalmap: {
                normalMap: {
                    value: null
                },
                normalScale: {
                    value: new fn(1, 1)
                }
            },
            displacementmap: {
                displacementMap: {
                    value: null
                },
                displacementScale: {
                    value: 1
                },
                displacementBias: {
                    value: 0
                }
            },
            roughnessmap: {
                roughnessMap: {
                    value: null
                }
            },
            metalnessmap: {
                metalnessMap: {
                    value: null
                }
            },
            gradientmap: {
                gradientMap: {
                    value: null
                }
            },
            fog: {
                fogDensity: {
                    value: 25e-5
                },
                fogNear: {
                    value: 1
                },
                fogFar: {
                    value: 2e3
                },
                fogColor: {
                    value: new Dr(16777215)
                }
            },
            lights: {
                ambientLightColor: {
                    value: []
                },
                lightProbe: {
                    value: []
                },
                directionalLights: {
                    value: [],
                    properties: {
                        direction: {},
                        color: {},
                        shadow: {},
                        shadowBias: {},
                        shadowRadius: {},
                        shadowMapSize: {}
                    }
                },
                directionalShadowMap: {
                    value: []
                },
                directionalShadowMatrix: {
                    value: []
                },
                spotLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        direction: {},
                        distance: {},
                        coneCos: {},
                        penumbraCos: {},
                        decay: {},
                        shadow: {},
                        shadowBias: {},
                        shadowRadius: {},
                        shadowMapSize: {}
                    }
                },
                spotShadowMap: {
                    value: []
                },
                spotShadowMatrix: {
                    value: []
                },
                pointLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        decay: {},
                        distance: {},
                        shadow: {},
                        shadowBias: {},
                        shadowRadius: {},
                        shadowMapSize: {},
                        shadowCameraNear: {},
                        shadowCameraFar: {}
                    }
                },
                pointShadowMap: {
                    value: []
                },
                pointShadowMatrix: {
                    value: []
                },
                hemisphereLights: {
                    value: [],
                    properties: {
                        direction: {},
                        skyColor: {},
                        groundColor: {}
                    }
                },
                rectAreaLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        width: {},
                        height: {}
                    }
                }
            },
            points: {
                diffuse: {
                    value: new Dr(15658734)
                },
                opacity: {
                    value: 1
                },
                size: {
                    value: 1
                },
                scale: {
                    value: 1
                },
                map: {
                    value: null
                },
                uvTransform: {
                    value: new gn
                }
            },
            sprite: {
                diffuse: {
                    value: new Dr(15658734)
                },
                opacity: {
                    value: 1
                },
                center: {
                    value: new fn(.5, .5)
                },
                rotation: {
                    value: 0
                },
                map: {
                    value: null
                },
                uvTransform: {
                    value: new gn
                }
            }
        },
        oo = {
            basic: {
                uniforms: Fi([io.common, io.specularmap, io.envmap, io.aomap, io.lightmap, io.fog]),
                vertexShader: ro.meshbasic_vert,
                fragmentShader: ro.meshbasic_frag
            },
            lambert: {
                uniforms: Fi([io.common, io.specularmap, io.envmap, io.aomap, io.lightmap, io.emissivemap, io.fog, io.lights, {
                    emissive: {
                        value: new Dr(0)
                    }
                }]),
                vertexShader: ro.meshlambert_vert,
                fragmentShader: ro.meshlambert_frag
            },
            phong: {
                uniforms: Fi([io.common, io.specularmap, io.envmap, io.aomap, io.lightmap, io.emissivemap, io.bumpmap, io.normalmap, io.displacementmap, io.gradientmap, io.fog, io.lights, {
                    emissive: {
                        value: new Dr(0)
                    },
                    specular: {
                        value: new Dr(1118481)
                    },
                    shininess: {
                        value: 30
                    }
                }]),
                vertexShader: ro.meshphong_vert,
                fragmentShader: ro.meshphong_frag
            },
            standard: {
                uniforms: Fi([io.common, io.envmap, io.aomap, io.lightmap, io.emissivemap, io.bumpmap, io.normalmap, io.displacementmap, io.roughnessmap, io.metalnessmap, io.fog, io.lights, {
                    emissive: {
                        value: new Dr(0)
                    },
                    roughness: {
                        value: .5
                    },
                    metalness: {
                        value: .5
                    },
                    envMapIntensity: {
                        value: 1
                    }
                }]),
                vertexShader: ro.meshphysical_vert,
                fragmentShader: ro.meshphysical_frag
            },
            matcap: {
                uniforms: Fi([io.common, io.bumpmap, io.normalmap, io.displacementmap, io.fog, {
                    matcap: {
                        value: null
                    }
                }]),
                vertexShader: ro.meshmatcap_vert,
                fragmentShader: ro.meshmatcap_frag
            },
            points: {
                uniforms: Fi([io.points, io.fog]),
                vertexShader: ro.points_vert,
                fragmentShader: ro.points_frag
            },
            dashed: {
                uniforms: Fi([io.common, io.fog, {
                    scale: {
                        value: 1
                    },
                    dashSize: {
                        value: 1
                    },
                    totalSize: {
                        value: 2
                    }
                }]),
                vertexShader: ro.linedashed_vert,
                fragmentShader: ro.linedashed_frag
            },
            depth: {
                uniforms: Fi([io.common, io.displacementmap]),
                vertexShader: ro.depth_vert,
                fragmentShader: ro.depth_frag
            },
            normal: {
                uniforms: Fi([io.common, io.bumpmap, io.normalmap, io.displacementmap, {
                    opacity: {
                        value: 1
                    }
                }]),
                vertexShader: ro.normal_vert,
                fragmentShader: ro.normal_frag
            },
            sprite: {
                uniforms: Fi([io.sprite, io.fog]),
                vertexShader: ro.sprite_vert,
                fragmentShader: ro.sprite_frag
            },
            background: {
                uniforms: {
                    uvTransform: {
                        value: new gn
                    },
                    t2D: {
                        value: null
                    }
                },
                vertexShader: ro.background_vert,
                fragmentShader: ro.background_frag
            },
            cube: {
                uniforms: {
                    tCube: {
                        value: null
                    },
                    tFlip: {
                        value: -1
                    },
                    opacity: {
                        value: 1
                    }
                },
                vertexShader: ro.cube_vert,
                fragmentShader: ro.cube_frag
            },
            equirect: {
                uniforms: {
                    tEquirect: {
                        value: null
                    }
                },
                vertexShader: ro.equirect_vert,
                fragmentShader: ro.equirect_frag
            },
            distanceRGBA: {
                uniforms: Fi([io.common, io.displacementmap, {
                    referencePosition: {
                        value: new pn
                    },
                    nearDistance: {
                        value: 1
                    },
                    farDistance: {
                        value: 1e3
                    }
                }]),
                vertexShader: ro.distanceRGBA_vert,
                fragmentShader: ro.distanceRGBA_frag
            },
            shadow: {
                uniforms: Fi([io.lights, io.fog, {
                    color: {
                        value: new Dr(0)
                    },
                    opacity: {
                        value: 1
                    }
                }]),
                vertexShader: ro.shadow_vert,
                fragmentShader: ro.shadow_frag
            }
        };

    function ao() {
        var e = null,
            t = !1,
            n = null;

        function r(i, o) {
            !1 !== t && (n(i, o), e.requestAnimationFrame(r))
        }
        return {
            start: function() {
                !0 !== t && null !== n && (e.requestAnimationFrame(r), t = !0)
            },
            stop: function() {
                t = !1
            },
            setAnimationLoop: function(e) {
                n = e
            },
            setContext: function(t) {
                e = t
            }
        }
    }

    function so(e) {
        var t = new WeakMap;
        return {
            get: function(e) {
                return e.isInterleavedBufferAttribute && (e = e.data), t.get(e)
            },
            remove: function(n) {
                n.isInterleavedBufferAttribute && (n = n.data);
                var r = t.get(n);
                r && (e.deleteBuffer(r.buffer), t.delete(n))
            },
            update: function(n, r) {
                n.isInterleavedBufferAttribute && (n = n.data);
                var i = t.get(n);
                void 0 === i ? t.set(n, function(t, n) {
                    var r = t.array,
                        i = t.dynamic ? 35048 : 35044,
                        o = e.createBuffer();
                    e.bindBuffer(n, o), e.bufferData(n, r, i), t.onUploadCallback();
                    var a = 5126;
                    return r instanceof Float32Array ? a = 5126 : r instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : r instanceof Uint16Array ? a = 5123 : r instanceof Int16Array ? a = 5122 : r instanceof Uint32Array ? a = 5125 : r instanceof Int32Array ? a = 5124 : r instanceof Int8Array ? a = 5120 : r instanceof Uint8Array && (a = 5121), {
                        buffer: o,
                        type: a,
                        bytesPerElement: r.BYTES_PER_ELEMENT,
                        version: t.version
                    }
                }(n, r)) : i.version < n.version && (! function(t, n, r) {
                    var i = n.array,
                        o = n.updateRange;
                    e.bindBuffer(r, t), !1 === n.dynamic ? e.bufferData(r, i, 35044) : -1 === o.count ? e.bufferSubData(r, 0, i) : 0 === o.count ? console.error("THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.") : (e.bufferSubData(r, o.offset * i.BYTES_PER_ELEMENT, i.subarray(o.offset, o.offset + o.count)), o.count = -1)
                }(i.buffer, n, r), i.version = n.version)
            }
        }
    }

    function co(e, t, n, r) {
        ji.call(this), this.type = "PlaneGeometry", this.parameters = {
            width: e,
            height: t,
            widthSegments: n,
            heightSegments: r
        }, this.fromBufferGeometry(new uo(e, t, n, r)), this.mergeVertices()
    }

    function uo(e, t, n, r) {
        ui.call(this), this.type = "PlaneBufferGeometry", this.parameters = {
            width: e,
            height: t,
            widthSegments: n,
            heightSegments: r
        };
        var i, o, a = (e = e || 1) / 2,
            s = (t = t || 1) / 2,
            c = Math.floor(n) || 1,
            u = Math.floor(r) || 1,
            l = c + 1,
            f = u + 1,
            d = e / c,
            h = t / u,
            v = [],
            p = [],
            m = [],
            y = [];
        for (o = 0; o < f; o++) {
            var g = o * h - s;
            for (i = 0; i < l; i++) {
                var x = i * d - a;
                p.push(x, -g, 0), m.push(0, 0, 1), y.push(i / c), y.push(1 - o / u)
            }
        }
        for (o = 0; o < u; o++)
            for (i = 0; i < c; i++) {
                var b = i + l * o,
                    w = i + l * (o + 1),
                    M = i + 1 + l * (o + 1),
                    _ = i + 1 + l * o;
                v.push(b, w, _), v.push(w, M, _)
            }
        this.setIndex(v), this.addAttribute("position", new Qr(p, 3)), this.addAttribute("normal", new Qr(m, 3)), this.addAttribute("uv", new Qr(y, 2))
    }

    function lo(e, t, n, r) {
        var i, o, a = new Dr(0),
            s = 0,
            c = null,
            u = 0;

        function l(e, n) {
            t.buffers.color.setClear(e.r, e.g, e.b, n, r)
        }
        return {
            getClearColor: function() {
                return a
            },
            setClearColor: function(e, t) {
                a.set(e), l(a, s = void 0 !== t ? t : 1)
            },
            getClearAlpha: function() {
                return s
            },
            setClearAlpha: function(e) {
                l(a, s = e)
            },
            render: function(t, r, f, d) {
                var h = r.background,
                    v = e.vr,
                    p = v.getSession && v.getSession();
                if (p && "additive" === p.environmentBlendMode && (h = null), null === h ? (l(a, s), c = null, u = 0) : h && h.isColor && (l(h, 1), d = !0, c = null, u = 0), (e.autoClear || d) && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), h && (h.isCubeTexture || h.isWebGLRenderTargetCube)) {
                    void 0 === o && ((o = new Ei(new Di(1, 1, 1), new Ui({
                        type: "BackgroundCubeMaterial",
                        uniforms: ki(oo.cube.uniforms),
                        vertexShader: oo.cube.vertexShader,
                        fragmentShader: oo.cube.fragmentShader,
                        side: y,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1
                    }))).geometry.removeAttribute("normal"), o.geometry.removeAttribute("uv"), o.onBeforeRender = function(e, t, n) {
                        this.matrixWorld.copyPosition(n.matrixWorld)
                    }, Object.defineProperty(o.material, "map", {
                        get: function() {
                            return this.uniforms.tCube.value
                        }
                    }), n.update(o));
                    var g = h.isWebGLRenderTargetCube ? h.texture : h;
                    o.material.uniforms.tCube.value = g, o.material.uniforms.tFlip.value = h.isWebGLRenderTargetCube ? 1 : -1, c === h && u === g.version || (o.material.needsUpdate = !0, c = h, u = g.version), t.unshift(o, o.geometry, o.material, 0, 0, null)
                } else h && h.isTexture && (void 0 === i && ((i = new Ei(new uo(2, 2), new Ui({
                    type: "BackgroundMaterial",
                    uniforms: ki(oo.background.uniforms),
                    vertexShader: oo.background.vertexShader,
                    fragmentShader: oo.background.fragmentShader,
                    side: m,
                    depthTest: !1,
                    depthWrite: !1,
                    fog: !1
                }))).geometry.removeAttribute("normal"), Object.defineProperty(i.material, "map", {
                    get: function() {
                        return this.uniforms.t2D.value
                    }
                }), n.update(i)), i.material.uniforms.t2D.value = h, !0 === h.matrixAutoUpdate && h.updateMatrix(), i.material.uniforms.uvTransform.value.copy(h.matrix), c === h && u === h.version || (i.material.needsUpdate = !0, c = h, u = h.version), t.unshift(i, i.geometry, i.material, 0, 0, null))
            }
        }
    }

    function fo(e, t, n, r) {
        var i;
        this.setMode = function(e) {
            i = e
        }, this.render = function(t, r) {
            e.drawArrays(i, t, r), n.update(r, i)
        }, this.renderInstances = function(o, a, s, c) {
            if (0 !== c) {
                var u, l;
                if (r.isWebGL2) u = e, l = "drawArraysInstanced";
                else if (l = "drawArraysInstancedANGLE", null === (u = t.get("ANGLE_instanced_arrays"))) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                u[l](i, a, s, c), n.update(s, i, c)
            }
        }
    }

    function ho(e, t, n) {
        var r;

        function i(t) {
            if ("highp" === t) {
                if (e.getShaderPrecisionFormat(35633, 36338).precision > 0 && e.getShaderPrecisionFormat(35632, 36338).precision > 0) return "highp";
                t = "mediump"
            }
            return "mediump" === t && e.getShaderPrecisionFormat(35633, 36337).precision > 0 && e.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp"
        }
        var o = "undefined" != typeof WebGL2RenderingContext && e instanceof WebGL2RenderingContext,
            a = void 0 !== n.precision ? n.precision : "highp",
            s = i(a);
        s !== a && (console.warn("THREE.WebGLRenderer:", a, "not supported, using", s, "instead."), a = s);
        var c = !0 === n.logarithmicDepthBuffer,
            u = e.getParameter(34930),
            l = e.getParameter(35660),
            f = e.getParameter(3379),
            d = e.getParameter(34076),
            h = e.getParameter(34921),
            v = e.getParameter(36347),
            p = e.getParameter(36348),
            m = e.getParameter(36349),
            y = l > 0,
            g = o || !!t.get("OES_texture_float");
        return {
            isWebGL2: o,
            getMaxAnisotropy: function() {
                if (void 0 !== r) return r;
                var n = t.get("EXT_texture_filter_anisotropic");
                return r = null !== n ? e.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0
            },
            getMaxPrecision: i,
            precision: a,
            logarithmicDepthBuffer: c,
            maxTextures: u,
            maxVertexTextures: l,
            maxTextureSize: f,
            maxCubemapSize: d,
            maxAttributes: h,
            maxVertexUniforms: v,
            maxVaryings: p,
            maxFragmentUniforms: m,
            vertexTextures: y,
            floatFragmentTextures: g,
            floatVertexTextures: y && g,
            maxSamples: o ? e.getParameter(36183) : 0
        }
    }

    function vo() {
        var e = this,
            t = null,
            n = 0,
            r = !1,
            i = !1,
            o = new $i,
            a = new gn,
            s = {
                value: null,
                needsUpdate: !1
            };

        function c() {
            s.value !== t && (s.value = t, s.needsUpdate = n > 0), e.numPlanes = n, e.numIntersection = 0
        }

        function u(t, n, r, i) {
            var c = null !== t ? t.length : 0,
                u = null;
            if (0 !== c) {
                if (u = s.value, !0 !== i || null === u) {
                    var l = r + 4 * c,
                        f = n.matrixWorldInverse;
                    a.getNormalMatrix(f), (null === u || u.length < l) && (u = new Float32Array(l));
                    for (var d = 0, h = r; d !== c; ++d, h += 4) o.copy(t[d]).applyMatrix4(f, a), o.normal.toArray(u, h), u[h + 3] = o.constant
                }
                s.value = u, s.needsUpdate = !0
            }
            return e.numPlanes = c, u
        }
        this.uniform = s, this.numPlanes = 0, this.numIntersection = 0, this.init = function(e, i, o) {
            var a = 0 !== e.length || i || 0 !== n || r;
            return r = i, t = u(e, o, 0), n = e.length, a
        }, this.beginShadows = function() {
            i = !0, u(null)
        }, this.endShadows = function() {
            i = !1, c()
        }, this.setState = function(e, o, a, l, f, d) {
            if (!r || null === e || 0 === e.length || i && !a) i ? u(null) : c();
            else {
                var h = i ? 0 : n,
                    v = 4 * h,
                    p = f.clippingState || null;
                s.value = p, p = u(e, l, v, d);
                for (var m = 0; m !== v; ++m) p[m] = t[m];
                f.clippingState = p, this.numIntersection = o ? this.numPlanes : 0, this.numPlanes += h
            }
        }
    }

    function po(e) {
        var t = {};
        return {
            get: function(n) {
                if (void 0 !== t[n]) return t[n];
                var r;
                switch (n) {
                    case "WEBGL_depth_texture":
                        r = e.getExtension("WEBGL_depth_texture") || e.getExtension("MOZ_WEBGL_depth_texture") || e.getExtension("WEBKIT_WEBGL_depth_texture");
                        break;
                    case "EXT_texture_filter_anisotropic":
                        r = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                        break;
                    case "WEBGL_compressed_texture_s3tc":
                        r = e.getExtension("WEBGL_compressed_texture_s3tc") || e.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                        break;
                    case "WEBGL_compressed_texture_pvrtc":
                        r = e.getExtension("WEBGL_compressed_texture_pvrtc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                        break;
                    default:
                        r = e.getExtension(n)
                }
                return null === r && console.warn("THREE.WebGLRenderer: " + n + " extension not supported."), t[n] = r, r
            }
        }
    }

    function mo(e, t, n) {
        var r = new WeakMap,
            i = new WeakMap;

        function o(e) {
            var a = e.target,
                s = r.get(a);
            for (var c in null !== s.index && t.remove(s.index), s.attributes) t.remove(s.attributes[c]);
            a.removeEventListener("dispose", o), r.delete(a);
            var u = i.get(s);
            u && (t.remove(u), i.delete(s)), n.memory.geometries--
        }

        function a(e) {
            var n = [],
                r = e.index,
                o = e.attributes.position,
                a = 0;
            if (null !== r) {
                var s = r.array;
                a = r.version;
                for (var c = 0, u = s.length; c < u; c += 3) {
                    var l = s[c + 0],
                        f = s[c + 1],
                        d = s[c + 2];
                    n.push(l, f, f, d, d, l)
                }
            } else {
                s = o.array;
                a = o.version;
                for (c = 0, u = s.length / 3 - 1; c < u; c += 3) {
                    l = c + 0, f = c + 1, d = c + 2;
                    n.push(l, f, f, d, d, l)
                }
            }
            var h = new(ti(n) > 65535 ? Jr : Kr)(n, 1);
            h.version = a, t.update(h, 34963);
            var v = i.get(e);
            v && t.remove(v), i.set(e, h)
        }
        return {
            get: function(e, t) {
                var i = r.get(t);
                return i || (t.addEventListener("dispose", o), t.isBufferGeometry ? i = t : t.isGeometry && (void 0 === t._bufferGeometry && (t._bufferGeometry = (new ui).setFromObject(e)), i = t._bufferGeometry), r.set(t, i), n.memory.geometries++, i)
            },
            update: function(e) {
                var n = e.index,
                    r = e.attributes;
                for (var i in null !== n && t.update(n, 34963), r) t.update(r[i], 34962);
                var o = e.morphAttributes;
                for (var i in o)
                    for (var a = o[i], s = 0, c = a.length; s < c; s++) t.update(a[s], 34962)
            },
            getWireframeAttribute: function(e) {
                var t = i.get(e);
                if (t) {
                    var n = e.index;
                    null !== n && t.version < n.version && a(e)
                } else a(e);
                return i.get(e)
            }
        }
    }

    function yo(e, t, n, r) {
        var i, o, a;
        this.setMode = function(e) {
            i = e
        }, this.setIndex = function(e) {
            o = e.type, a = e.bytesPerElement
        }, this.render = function(t, r) {
            e.drawElements(i, r, o, t * a), n.update(r, i)
        }, this.renderInstances = function(s, c, u, l) {
            if (0 !== l) {
                var f, d;
                if (r.isWebGL2) f = e, d = "drawElementsInstanced";
                else if (d = "drawElementsInstancedANGLE", null === (f = t.get("ANGLE_instanced_arrays"))) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                f[d](i, u, o, c * a, l), n.update(u, i, l)
            }
        }
    }

    function go(e) {
        var t = {
            frame: 0,
            calls: 0,
            triangles: 0,
            points: 0,
            lines: 0
        };
        return {
            memory: {
                geometries: 0,
                textures: 0
            },
            render: t,
            programs: null,
            autoReset: !0,
            reset: function() {
                t.frame++, t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0
            },
            update: function(e, n, r) {
                switch (r = r || 1, t.calls++, n) {
                    case 4:
                        t.triangles += r * (e / 3);
                        break;
                    case 5:
                    case 6:
                        t.triangles += r * (e - 2);
                        break;
                    case 1:
                        t.lines += r * (e / 2);
                        break;
                    case 3:
                        t.lines += r * (e - 1);
                        break;
                    case 2:
                        t.lines += r * e;
                        break;
                    case 0:
                        t.points += r * e;
                        break;
                    default:
                        console.error("THREE.WebGLInfo: Unknown draw mode:", n)
                }
            }
        }
    }

    function xo(e, t) {
        return Math.abs(t[1]) - Math.abs(e[1])
    }

    function bo(e) {
        var t = {},
            n = new Float32Array(8);
        return {
            update: function(r, i, o, a) {
                var s = r.morphTargetInfluences,
                    c = s.length,
                    u = t[i.id];
                if (void 0 === u) {
                    u = [];
                    for (var l = 0; l < c; l++) u[l] = [l, 0];
                    t[i.id] = u
                }
                var f = o.morphTargets && i.morphAttributes.position,
                    d = o.morphNormals && i.morphAttributes.normal;
                for (l = 0; l < c; l++) {
                    0 !== (h = u[l])[1] && (f && i.removeAttribute("morphTarget" + l), d && i.removeAttribute("morphNormal" + l))
                }
                for (l = 0; l < c; l++) {
                    (h = u[l])[0] = l, h[1] = s[l]
                }
                for (u.sort(xo), l = 0; l < 8; l++) {
                    var h;
                    if (h = u[l]) {
                        var v = h[0],
                            p = h[1];
                        if (p) {
                            f && i.addAttribute("morphTarget" + l, f[v]), d && i.addAttribute("morphNormal" + l, d[v]), n[l] = p;
                            continue
                        }
                    }
                    n[l] = 0
                }
                a.getUniforms().setValue(e, "morphTargetInfluences", n)
            }
        }
    }

    function wo(e, t, n, r) {
        var i = {};
        return {
            update: function(e) {
                var o = r.render.frame,
                    a = e.geometry,
                    s = t.get(e, a);
                return i[s.id] !== o && (a.isGeometry && s.updateFromObject(e), t.update(s), i[s.id] = o), e.isInstancedMesh && n.update(e.instanceMatrix, 34962), s
            },
            dispose: function() {
                i = {}
            }
        }
    }

    function Mo(e, t, n, r, i, o, a, s, c, u) {
        e = void 0 !== e ? e : [], t = void 0 !== t ? t : le, a = void 0 !== a ? a : He, wn.call(this, e, t, n, r, i, o, a, s, c, u), this.flipY = !1
    }

    function _o(e, t, n, r) {
        wn.call(this, null), this.image = {
            data: e || null,
            width: t || 1,
            height: n || 1,
            depth: r || 1
        }, this.magFilter = be, this.minFilter = be, this.wrapR = ge, this.generateMipmaps = !1, this.flipY = !1, this.needsUpdate = !0
    }

    function So(e, t, n, r) {
        wn.call(this, null), this.image = {
            data: e || null,
            width: t || 1,
            height: n || 1,
            depth: r || 1
        }, this.magFilter = be, this.minFilter = be, this.wrapR = ge, this.generateMipmaps = !1, this.flipY = !1, this.needsUpdate = !0
    }
    oo.physical = {
        uniforms: Fi([oo.standard.uniforms, {
            transparency: {
                value: 0
            },
            clearcoat: {
                value: 0
            },
            clearcoatRoughness: {
                value: 0
            },
            sheen: {
                value: new Dr(0)
            },
            clearcoatNormalScale: {
                value: new fn(1, 1)
            },
            clearcoatNormalMap: {
                value: null
            }
        }]),
        vertexShader: ro.meshphysical_vert,
        fragmentShader: ro.meshphysical_frag
    }, co.prototype = Object.create(ji.prototype), co.prototype.constructor = co, uo.prototype = Object.create(ui.prototype), uo.prototype.constructor = uo, Mo.prototype = Object.create(wn.prototype), Mo.prototype.constructor = Mo, Mo.prototype.isCubeTexture = !0, Object.defineProperty(Mo.prototype, "images", {
        get: function() {
            return this.image
        },
        set: function(e) {
            this.image = e
        }
    }), _o.prototype = Object.create(wn.prototype), _o.prototype.constructor = _o, _o.prototype.isDataTexture2DArray = !0, So.prototype = Object.create(wn.prototype), So.prototype.constructor = So, So.prototype.isDataTexture3D = !0;
    var Po = new wn,
        To = new _o,
        Eo = new So,
        zo = new Mo,
        Lo = [],
        Ao = [],
        Co = new Float32Array(16),
        Ro = new Float32Array(9),
        Oo = new Float32Array(4);

    function jo(e, t, n) {
        var r = e[0];
        if (r <= 0 || r > 0) return e;
        var i = t * n,
            o = Lo[i];
        if (void 0 === o && (o = new Float32Array(i), Lo[i] = o), 0 !== t) {
            r.toArray(o, 0);
            for (var a = 1, s = 0; a !== t; ++a) s += n, e[a].toArray(o, s)
        }
        return o
    }

    function Io(e, t) {
        if (e.length !== t.length) return !1;
        for (var n = 0, r = e.length; n < r; n++)
            if (e[n] !== t[n]) return !1;
        return !0
    }

    function Do(e, t) {
        for (var n = 0, r = t.length; n < r; n++) e[n] = t[n]
    }

    function ko(e, t) {
        var n = Ao[t];
        void 0 === n && (n = new Int32Array(t), Ao[t] = n);
        for (var r = 0; r !== t; ++r) n[r] = e.allocateTextureUnit();
        return n
    }

    function Fo(e, t) {
        var n = this.cache;
        n[0] !== t && (e.uniform1f(this.addr, t), n[0] = t)
    }

    function Go(e, t) {
        var n = this.cache;
        if (void 0 !== t.x) n[0] === t.x && n[1] === t.y || (e.uniform2f(this.addr, t.x, t.y), n[0] = t.x, n[1] = t.y);
        else {
            if (Io(n, t)) return;
            e.uniform2fv(this.addr, t), Do(n, t)
        }
    }

    function No(e, t) {
        var n = this.cache;
        if (void 0 !== t.x) n[0] === t.x && n[1] === t.y && n[2] === t.z || (e.uniform3f(this.addr, t.x, t.y, t.z), n[0] = t.x, n[1] = t.y, n[2] = t.z);
        else if (void 0 !== t.r) n[0] === t.r && n[1] === t.g && n[2] === t.b || (e.uniform3f(this.addr, t.r, t.g, t.b), n[0] = t.r, n[1] = t.g, n[2] = t.b);
        else {
            if (Io(n, t)) return;
            e.uniform3fv(this.addr, t), Do(n, t)
        }
    }

    function Bo(e, t) {
        var n = this.cache;
        if (void 0 !== t.x) n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] === t.w || (e.uniform4f(this.addr, t.x, t.y, t.z, t.w), n[0] = t.x, n[1] = t.y, n[2] = t.z, n[3] = t.w);
        else {
            if (Io(n, t)) return;
            e.uniform4fv(this.addr, t), Do(n, t)
        }
    }

    function Uo(e, t) {
        var n = this.cache,
            r = t.elements;
        if (void 0 === r) {
            if (Io(n, t)) return;
            e.uniformMatrix2fv(this.addr, !1, t), Do(n, t)
        } else {
            if (Io(n, r)) return;
            Oo.set(r), e.uniformMatrix2fv(this.addr, !1, Oo), Do(n, r)
        }
    }

    function Ho(e, t) {
        var n = this.cache,
            r = t.elements;
        if (void 0 === r) {
            if (Io(n, t)) return;
            e.uniformMatrix3fv(this.addr, !1, t), Do(n, t)
        } else {
            if (Io(n, r)) return;
            Ro.set(r), e.uniformMatrix3fv(this.addr, !1, Ro), Do(n, r)
        }
    }

    function Vo(e, t) {
        var n = this.cache,
            r = t.elements;
        if (void 0 === r) {
            if (Io(n, t)) return;
            e.uniformMatrix4fv(this.addr, !1, t), Do(n, t)
        } else {
            if (Io(n, r)) return;
            Co.set(r), e.uniformMatrix4fv(this.addr, !1, Co), Do(n, r)
        }
    }

    function Wo(e, t, n) {
        var r = this.cache,
            i = n.allocateTextureUnit();
        r[0] !== i && (e.uniform1i(this.addr, i), r[0] = i), n.safeSetTexture2D(t || Po, i)
    }

    function Yo(e, t, n) {
        var r = this.cache,
            i = n.allocateTextureUnit();
        r[0] !== i && (e.uniform1i(this.addr, i), r[0] = i), n.setTexture2DArray(t || To, i)
    }

    function Xo(e, t, n) {
        var r = this.cache,
            i = n.allocateTextureUnit();
        r[0] !== i && (e.uniform1i(this.addr, i), r[0] = i), n.setTexture3D(t || Eo, i)
    }

    function qo(e, t, n) {
        var r = this.cache,
            i = n.allocateTextureUnit();
        r[0] !== i && (e.uniform1i(this.addr, i), r[0] = i), n.safeSetTextureCube(t || zo, i)
    }

    function Ko(e, t) {
        var n = this.cache;
        n[0] !== t && (e.uniform1i(this.addr, t), n[0] = t)
    }

    function Zo(e, t) {
        var n = this.cache;
        Io(n, t) || (e.uniform2iv(this.addr, t), Do(n, t))
    }

    function Jo(e, t) {
        var n = this.cache;
        Io(n, t) || (e.uniform3iv(this.addr, t), Do(n, t))
    }

    function Qo(e, t) {
        var n = this.cache;
        Io(n, t) || (e.uniform4iv(this.addr, t), Do(n, t))
    }

    function $o(e, t) {
        e.uniform1fv(this.addr, t)
    }

    function ea(e, t) {
        e.uniform1iv(this.addr, t)
    }

    function ta(e, t) {
        e.uniform2iv(this.addr, t)
    }

    function na(e, t) {
        e.uniform3iv(this.addr, t)
    }

    function ra(e, t) {
        e.uniform4iv(this.addr, t)
    }

    function ia(e, t) {
        var n = jo(t, this.size, 2);
        e.uniform2fv(this.addr, n)
    }

    function oa(e, t) {
        var n = jo(t, this.size, 3);
        e.uniform3fv(this.addr, n)
    }

    function aa(e, t) {
        var n = jo(t, this.size, 4);
        e.uniform4fv(this.addr, n)
    }

    function sa(e, t) {
        var n = jo(t, this.size, 4);
        e.uniformMatrix2fv(this.addr, !1, n)
    }

    function ca(e, t) {
        var n = jo(t, this.size, 9);
        e.uniformMatrix3fv(this.addr, !1, n)
    }

    function ua(e, t) {
        var n = jo(t, this.size, 16);
        e.uniformMatrix4fv(this.addr, !1, n)
    }

    function la(e, t, n) {
        var r = t.length,
            i = ko(n, r);
        e.uniform1iv(this.addr, i);
        for (var o = 0; o !== r; ++o) n.safeSetTexture2D(t[o] || Po, i[o])
    }

    function fa(e, t, n) {
        var r = t.length,
            i = ko(n, r);
        e.uniform1iv(this.addr, i);
        for (var o = 0; o !== r; ++o) n.safeSetTextureCube(t[o] || zo, i[o])
    }

    function da(e, t, n) {
        this.id = e, this.addr = n, this.cache = [], this.setValue = function(e) {
            switch (e) {
                case 5126:
                    return Fo;
                case 35664:
                    return Go;
                case 35665:
                    return No;
                case 35666:
                    return Bo;
                case 35674:
                    return Uo;
                case 35675:
                    return Ho;
                case 35676:
                    return Vo;
                case 35678:
                case 36198:
                    return Wo;
                case 35679:
                    return Xo;
                case 35680:
                    return qo;
                case 36289:
                    return Yo;
                case 5124:
                case 35670:
                    return Ko;
                case 35667:
                case 35671:
                    return Zo;
                case 35668:
                case 35672:
                    return Jo;
                case 35669:
                case 35673:
                    return Qo
            }
        }(t.type)
    }

    function ha(e, t, n) {
        this.id = e, this.addr = n, this.cache = [], this.size = t.size, this.setValue = function(e) {
            switch (e) {
                case 5126:
                    return $o;
                case 35664:
                    return ia;
                case 35665:
                    return oa;
                case 35666:
                    return aa;
                case 35674:
                    return sa;
                case 35675:
                    return ca;
                case 35676:
                    return ua;
                case 35678:
                    return la;
                case 35680:
                    return fa;
                case 5124:
                case 35670:
                    return ea;
                case 35667:
                case 35671:
                    return ta;
                case 35668:
                case 35672:
                    return na;
                case 35669:
                case 35673:
                    return ra
            }
        }(t.type)
    }

    function va(e) {
        this.id = e, this.seq = [], this.map = {}
    }
    ha.prototype.updateCache = function(e) {
        var t = this.cache;
        e instanceof Float32Array && t.length !== e.length && (this.cache = new Float32Array(e.length)), Do(t, e)
    }, va.prototype.setValue = function(e, t, n) {
        for (var r = this.seq, i = 0, o = r.length; i !== o; ++i) {
            var a = r[i];
            a.setValue(e, t[a.id], n)
        }
    };
    var pa = /([\w\d_]+)(\])?(\[|\.)?/g;

    function ma(e, t) {
        e.seq.push(t), e.map[t.id] = t
    }

    function ya(e, t, n) {
        var r = e.name,
            i = r.length;
        for (pa.lastIndex = 0;;) {
            var o = pa.exec(r),
                a = pa.lastIndex,
                s = o[1],
                c = "]" === o[2],
                u = o[3];
            if (c && (s |= 0), void 0 === u || "[" === u && a + 2 === i) {
                ma(n, void 0 === u ? new da(s, e, t) : new ha(s, e, t));
                break
            }
            var l = n.map[s];
            void 0 === l && ma(n, l = new va(s)), n = l
        }
    }

    function ga(e, t) {
        this.seq = [], this.map = {};
        for (var n = e.getProgramParameter(t, 35718), r = 0; r < n; ++r) {
            var i = e.getActiveUniform(t, r);
            ya(i, e.getUniformLocation(t, i.name), this)
        }
    }

    function xa(e, t, n) {
        var r = e.createShader(t);
        return e.shaderSource(r, n), e.compileShader(r), r
    }
    ga.prototype.setValue = function(e, t, n, r) {
        var i = this.map[t];
        void 0 !== i && i.setValue(e, n, r)
    }, ga.prototype.setOptional = function(e, t, n) {
        var r = t[n];
        void 0 !== r && this.setValue(e, n, r)
    }, ga.upload = function(e, t, n, r) {
        for (var i = 0, o = t.length; i !== o; ++i) {
            var a = t[i],
                s = n[a.id];
            !1 !== s.needsUpdate && a.setValue(e, s.value, r)
        }
    }, ga.seqWithValue = function(e, t) {
        for (var n = [], r = 0, i = e.length; r !== i; ++r) {
            var o = e[r];
            o.id in t && n.push(o)
        }
        return n
    };
    var ba = 0;

    function wa(e) {
        switch (e) {
            case Rt:
                return ["Linear", "( value )"];
            case Ot:
                return ["sRGB", "( value )"];
            case It:
                return ["RGBE", "( value )"];
            case kt:
                return ["RGBM", "( value, 7.0 )"];
            case Ft:
                return ["RGBM", "( value, 16.0 )"];
            case Gt:
                return ["RGBD", "( value, 256.0 )"];
            case jt:
                return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
            case Dt:
                return ["LogLuv", "( value )"];
            default:
                throw new Error("unsupported encoding: " + e)
        }
    }

    function Ma(e, t, n) {
        var r = e.getShaderParameter(t, 35713),
            i = e.getShaderInfoLog(t).trim();
        return r && "" === i ? "" : "THREE.WebGLShader: gl.getShaderInfoLog() " + n + "\n" + i + function(e) {
            for (var t = e.split("\n"), n = 0; n < t.length; n++) t[n] = n + 1 + ": " + t[n];
            return t.join("\n")
        }(e.getShaderSource(t))
    }

    function _a(e, t) {
        var n = wa(t);
        return "vec4 " + e + "( vec4 value ) { return " + n[0] + "ToLinear" + n[1] + "; }"
    }

    function Sa(e, t) {
        var n;
        switch (t) {
            case ie:
                n = "Linear";
                break;
            case oe:
                n = "Reinhard";
                break;
            case ae:
                n = "Uncharted2";
                break;
            case se:
                n = "OptimizedCineon";
                break;
            case ce:
                n = "ACESFilmic";
                break;
            default:
                throw new Error("unsupported toneMapping: " + t)
        }
        return "vec3 " + e + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
    }

    function Pa(e) {
        return "" !== e
    }

    function Ta(e, t) {
        return e.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows)
    }

    function Ea(e, t) {
        return e.replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection)
    }
    var za = /^[ \t]*#include +<([\w\d./]+)>/gm;

    function La(e) {
        return e.replace(za, Aa)
    }

    function Aa(e, t) {
        var n = ro[t];
        if (void 0 === n) throw new Error("Can not resolve #include <" + t + ">");
        return La(n)
    }
    var Ca = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;

    function Ra(e) {
        return e.replace(Ca, Oa)
    }

    function Oa(e, t, n, r) {
        for (var i = "", o = parseInt(t); o < parseInt(n); o++) i += r.replace(/\[ i \]/g, "[ " + o + " ]").replace(/UNROLLED_LOOP_INDEX/g, o);
        return i
    }

    function ja(e) {
        var t = "precision " + e.precision + " float;\nprecision " + e.precision + " int;";
        return "highp" === e.precision ? t += "\n#define HIGH_PRECISION" : "mediump" === e.precision ? t += "\n#define MEDIUM_PRECISION" : "lowp" === e.precision && (t += "\n#define LOW_PRECISION"), t
    }

    function Ia(e, t, n, r, i, o) {
        var a, s, c, u, l, f = e.getContext(),
            d = r.defines,
            m = i.vertexShader,
            y = i.fragmentShader,
            g = function(e) {
                var t = "SHADOWMAP_TYPE_BASIC";
                return e.shadowMapType === h ? t = "SHADOWMAP_TYPE_PCF" : e.shadowMapType === v ? t = "SHADOWMAP_TYPE_PCF_SOFT" : e.shadowMapType === p && (t = "SHADOWMAP_TYPE_VSM"), t
            }(o),
            x = function(e, t) {
                var n = "ENVMAP_TYPE_CUBE";
                if (e.envMap) switch (t.envMap.mapping) {
                    case le:
                    case fe:
                        n = "ENVMAP_TYPE_CUBE";
                        break;
                    case pe:
                    case me:
                        n = "ENVMAP_TYPE_CUBE_UV";
                        break;
                    case de:
                    case he:
                        n = "ENVMAP_TYPE_EQUIREC";
                        break;
                    case ve:
                        n = "ENVMAP_TYPE_SPHERE"
                }
                return n
            }(o, r),
            b = function(e, t) {
                var n = "ENVMAP_MODE_REFLECTION";
                if (e.envMap) switch (t.envMap.mapping) {
                    case fe:
                    case he:
                        n = "ENVMAP_MODE_REFRACTION"
                }
                return n
            }(o, r),
            w = function(e, t) {
                var n = "ENVMAP_BLENDING_MULTIPLY";
                if (e.envMap) switch (t.combine) {
                    case ee:
                        n = "ENVMAP_BLENDING_MULTIPLY";
                        break;
                    case te:
                        n = "ENVMAP_BLENDING_MIX";
                        break;
                    case ne:
                        n = "ENVMAP_BLENDING_ADD"
                }
                return n
            }(o, r),
            M = e.gammaFactor > 0 ? e.gammaFactor : 1,
            _ = o.isWebGL2 ? "" : function(e, t, n) {
                return [(e = e || {}).derivatives || t.envMapCubeUV || t.bumpMap || t.tangentSpaceNormalMap || t.clearcoatNormalMap || t.flatShading ? "#extension GL_OES_standard_derivatives : enable" : "", (e.fragDepth || t.logarithmicDepthBuffer) && n.get("EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable" : "", e.drawBuffers && n.get("WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require" : "", (e.shaderTextureLOD || t.envMap) && n.get("EXT_shader_texture_lod") ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Pa).join("\n")
            }(r.extensions, o, t),
            S = function(e) {
                var t = [];
                for (var n in e) {
                    var r = e[n];
                    !1 !== r && t.push("#define " + n + " " + r)
                }
                return t.join("\n")
            }(d),
            P = f.createProgram(),
            T = e.getRenderTarget(),
            E = T && T.isWebGLMultiviewRenderTarget ? T.numViews : 0;
        if (r.isRawShaderMaterial ? ((a = [S].filter(Pa).join("\n")).length > 0 && (a += "\n"), (s = [_, S].filter(Pa).join("\n")).length > 0 && (s += "\n")) : (a = [ja(o), "#define SHADER_NAME " + i.name, S, o.instancing ? "#define USE_INSTANCING" : "", o.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + M, "#define MAX_BONES " + o.maxBones, o.useFog && o.fog ? "#define USE_FOG" : "", o.useFog && o.fogExp2 ? "#define FOG_EXP2" : "", o.map ? "#define USE_MAP" : "", o.envMap ? "#define USE_ENVMAP" : "", o.envMap ? "#define " + b : "", o.lightMap ? "#define USE_LIGHTMAP" : "", o.aoMap ? "#define USE_AOMAP" : "", o.emissiveMap ? "#define USE_EMISSIVEMAP" : "", o.bumpMap ? "#define USE_BUMPMAP" : "", o.normalMap ? "#define USE_NORMALMAP" : "", o.normalMap && o.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", o.normalMap && o.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", o.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", o.displacementMap && o.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", o.specularMap ? "#define USE_SPECULARMAP" : "", o.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", o.metalnessMap ? "#define USE_METALNESSMAP" : "", o.alphaMap ? "#define USE_ALPHAMAP" : "", o.vertexTangents ? "#define USE_TANGENT" : "", o.vertexColors ? "#define USE_COLOR" : "", o.vertexUvs ? "#define USE_UV" : "", o.flatShading ? "#define FLAT_SHADED" : "", o.skinning ? "#define USE_SKINNING" : "", o.useVertexTexture ? "#define BONE_TEXTURE" : "", o.morphTargets ? "#define USE_MORPHTARGETS" : "", o.morphNormals && !1 === o.flatShading ? "#define USE_MORPHNORMALS" : "", o.doubleSided ? "#define DOUBLE_SIDED" : "", o.flipSided ? "#define FLIP_SIDED" : "", o.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", o.shadowMapEnabled ? "#define " + g : "", o.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", o.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", o.logarithmicDepthBuffer && (o.isWebGL2 || t.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "#ifdef USE_INSTANCING", " attribute mat4 instanceMatrix;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(Pa).join("\n"), s = [_, ja(o), "#define SHADER_NAME " + i.name, S, o.alphaTest ? "#define ALPHATEST " + o.alphaTest + (o.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + M, o.useFog && o.fog ? "#define USE_FOG" : "", o.useFog && o.fogExp2 ? "#define FOG_EXP2" : "", o.map ? "#define USE_MAP" : "", o.matcap ? "#define USE_MATCAP" : "", o.envMap ? "#define USE_ENVMAP" : "", o.envMap ? "#define " + x : "", o.envMap ? "#define " + b : "", o.envMap ? "#define " + w : "", o.lightMap ? "#define USE_LIGHTMAP" : "", o.aoMap ? "#define USE_AOMAP" : "", o.emissiveMap ? "#define USE_EMISSIVEMAP" : "", o.bumpMap ? "#define USE_BUMPMAP" : "", o.normalMap ? "#define USE_NORMALMAP" : "", o.normalMap && o.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", o.normalMap && o.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", o.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", o.specularMap ? "#define USE_SPECULARMAP" : "", o.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", o.metalnessMap ? "#define USE_METALNESSMAP" : "", o.alphaMap ? "#define USE_ALPHAMAP" : "", o.sheen ? "#define USE_SHEEN" : "", o.vertexTangents ? "#define USE_TANGENT" : "", o.vertexColors ? "#define USE_COLOR" : "", o.vertexUvs ? "#define USE_UV" : "", o.gradientMap ? "#define USE_GRADIENTMAP" : "", o.flatShading ? "#define FLAT_SHADED" : "", o.doubleSided ? "#define DOUBLE_SIDED" : "", o.flipSided ? "#define FLIP_SIDED" : "", o.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", o.shadowMapEnabled ? "#define " + g : "", o.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", o.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", o.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", o.logarithmicDepthBuffer && (o.isWebGL2 || t.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "", (r.extensions && r.extensions.shaderTextureLOD || o.envMap) && (o.isWebGL2 || t.get("EXT_shader_texture_lod")) ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", o.toneMapping !== re ? "#define TONE_MAPPING" : "", o.toneMapping !== re ? ro.tonemapping_pars_fragment : "", o.toneMapping !== re ? Sa("toneMapping", o.toneMapping) : "", o.dithering ? "#define DITHERING" : "", o.outputEncoding || o.mapEncoding || o.matcapEncoding || o.envMapEncoding || o.emissiveMapEncoding ? ro.encodings_pars_fragment : "", o.mapEncoding ? _a("mapTexelToLinear", o.mapEncoding) : "", o.matcapEncoding ? _a("matcapTexelToLinear", o.matcapEncoding) : "", o.envMapEncoding ? _a("envMapTexelToLinear", o.envMapEncoding) : "", o.emissiveMapEncoding ? _a("emissiveMapTexelToLinear", o.emissiveMapEncoding) : "", o.outputEncoding ? (c = "linearToOutputTexel", u = o.outputEncoding, l = wa(u), "vec4 " + c + "( vec4 value ) { return LinearTo" + l[0] + l[1] + "; }") : "", o.depthPacking ? "#define DEPTH_PACKING " + r.depthPacking : "", "\n"].filter(Pa).join("\n")), m = Ea(m = Ta(m = La(m), o), o), y = Ea(y = Ta(y = La(y), o), o), m = Ra(m), y = Ra(y), o.isWebGL2 && !r.isRawShaderMaterial) {
            var z = !1,
                L = /^\s*#version\s+300\s+es\s*\n/;
            r.isShaderMaterial && null !== m.match(L) && null !== y.match(L) && (z = !0, m = m.replace(L, ""), y = y.replace(L, "")), a = ["#version 300 es\n", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + a, s = ["#version 300 es\n", "#define varying in", z ? "" : "out highp vec4 pc_fragColor;", z ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + s, E > 0 && (a = (a = a.replace("#version 300 es\n", ["#version 300 es\n", "#extension GL_OVR_multiview2 : require", "layout(num_views = " + E + ") in;", "#define VIEW_ID gl_ViewID_OVR"].join("\n"))).replace(["uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;"].join("\n"), ["uniform mat4 modelViewMatrices[" + E + "];", "uniform mat4 projectionMatrices[" + E + "];", "uniform mat4 viewMatrices[" + E + "];", "uniform mat3 normalMatrices[" + E + "];", "#define modelViewMatrix modelViewMatrices[VIEW_ID]", "#define projectionMatrix projectionMatrices[VIEW_ID]", "#define viewMatrix viewMatrices[VIEW_ID]", "#define normalMatrix normalMatrices[VIEW_ID]"].join("\n")), s = (s = s.replace("#version 300 es\n", ["#version 300 es\n", "#extension GL_OVR_multiview2 : require", "#define VIEW_ID gl_ViewID_OVR"].join("\n"))).replace("uniform mat4 viewMatrix;", ["uniform mat4 viewMatrices[" + E + "];", "#define viewMatrix viewMatrices[VIEW_ID]"].join("\n")))
        }
        var A, C, R = s + y,
            O = xa(f, 35633, a + m),
            j = xa(f, 35632, R);
        if (f.attachShader(P, O), f.attachShader(P, j), void 0 !== r.index0AttributeName ? f.bindAttribLocation(P, 0, r.index0AttributeName) : !0 === o.morphTargets && f.bindAttribLocation(P, 0, "position"), f.linkProgram(P), e.debug.checkShaderErrors) {
            var I = f.getProgramInfoLog(P).trim(),
                D = f.getShaderInfoLog(O).trim(),
                k = f.getShaderInfoLog(j).trim(),
                F = !0,
                G = !0;
            if (!1 === f.getProgramParameter(P, 35714)) {
                F = !1;
                var N = Ma(f, O, "vertex"),
                    B = Ma(f, j, "fragment");
                console.error("THREE.WebGLProgram: shader error: ", f.getError(), "35715", f.getProgramParameter(P, 35715), "gl.getProgramInfoLog", I, N, B)
            } else "" !== I ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", I) : "" !== D && "" !== k || (G = !1);
            G && (this.diagnostics = {
                runnable: F,
                material: r,
                programLog: I,
                vertexShader: {
                    log: D,
                    prefix: a
                },
                fragmentShader: {
                    log: k,
                    prefix: s
                }
            })
        }
        return f.deleteShader(O), f.deleteShader(j), this.getUniforms = function() {
            return void 0 === A && (A = new ga(f, P)), A
        }, this.getAttributes = function() {
            return void 0 === C && (C = function(e, t) {
                for (var n = {}, r = e.getProgramParameter(t, 35721), i = 0; i < r; i++) {
                    var o = e.getActiveAttrib(t, i).name;
                    n[o] = e.getAttribLocation(t, o)
                }
                return n
            }(f, P)), C
        }, this.destroy = function() {
            f.deleteProgram(P), this.program = void 0
        }, this.name = i.name, this.id = ba++, this.code = n, this.usedTimes = 1, this.program = P, this.vertexShader = O, this.fragmentShader = j, this.numMultiviewViews = E, this
    }

    function Da(e, t, n) {
        var r = [],
            i = {
                MeshDepthMaterial: "depth",
                MeshDistanceMaterial: "distanceRGBA",
                MeshNormalMaterial: "normal",
                MeshBasicMaterial: "basic",
                MeshLambertMaterial: "lambert",
                MeshPhongMaterial: "phong",
                MeshToonMaterial: "phong",
                MeshStandardMaterial: "physical",
                MeshPhysicalMaterial: "physical",
                MeshMatcapMaterial: "matcap",
                LineBasicMaterial: "basic",
                LineDashedMaterial: "dashed",
                PointsMaterial: "points",
                ShadowMaterial: "shadow",
                SpriteMaterial: "sprite"
            },
            o = ["precision", "supportsVertexTextures", "instancing", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "lightMap", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "tangentSpaceNormalMap", "clearcoatNormalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "vertexTangents", "fog", "useFog", "fogExp2", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering", "sheen"];

        function a(e, t) {
            var n;
            return e ? e.isTexture ? n = e.encoding : e.isWebGLRenderTarget && (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), n = e.texture.encoding) : n = Rt, n === Rt && t && (n = jt), n
        }
        this.getParameters = function(t, r, o, s, c, u, l) {
            var f = i[t.type],
                d = l.isSkinnedMesh ? function(e) {
                    var t = e.skeleton.bones;
                    if (n.floatVertexTextures) return 1024;
                    var r = n.maxVertexUniforms,
                        i = Math.floor((r - 20) / 4),
                        o = Math.min(i, t.length);
                    return o < t.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + t.length + " bones. This GPU supports " + o + "."), 0) : o
                }(l) : 0,
                h = n.precision;
            null !== t.precision && (h = n.getMaxPrecision(t.precision)) !== t.precision && console.warn("THREE.WebGLProgram.getParameters:", t.precision, "not supported, using", h, "instead.");
            var v = e.getRenderTarget();
            return {
                isWebGL2: n.isWebGL2,
                shaderID: f,
                precision: h,
                instancing: !0 === l.isInstancedMesh,
                supportsVertexTextures: n.vertexTextures,
                outputEncoding: a(v ? v.texture : null, e.gammaOutput),
                map: !!t.map,
                mapEncoding: a(t.map, e.gammaInput),
                matcap: !!t.matcap,
                matcapEncoding: a(t.matcap, e.gammaInput),
                envMap: !!t.envMap,
                envMapMode: t.envMap && t.envMap.mapping,
                envMapEncoding: a(t.envMap, e.gammaInput),
                envMapCubeUV: !!t.envMap && (t.envMap.mapping === pe || t.envMap.mapping === me),
                lightMap: !!t.lightMap,
                aoMap: !!t.aoMap,
                emissiveMap: !!t.emissiveMap,
                emissiveMapEncoding: a(t.emissiveMap, e.gammaInput),
                bumpMap: !!t.bumpMap,
                normalMap: !!t.normalMap,
                objectSpaceNormalMap: t.normalMapType === Ht,
                tangentSpaceNormalMap: t.normalMapType === Ut,
                clearcoatNormalMap: !!t.clearcoatNormalMap,
                displacementMap: !!t.displacementMap,
                roughnessMap: !!t.roughnessMap,
                metalnessMap: !!t.metalnessMap,
                specularMap: !!t.specularMap,
                alphaMap: !!t.alphaMap,
                gradientMap: !!t.gradientMap,
                sheen: !!t.sheen,
                combine: t.combine,
                vertexTangents: t.normalMap && t.vertexTangents,
                vertexColors: t.vertexColors,
                vertexUvs: !!(t.map || t.bumpMap || t.normalMap || t.specularMap || t.alphaMap || t.emissiveMap || t.roughnessMap || t.metalnessMap || t.clearcoatNormalMap),
                fog: !!s,
                useFog: t.fog,
                fogExp2: s && s.isFogExp2,
                flatShading: t.flatShading,
                sizeAttenuation: t.sizeAttenuation,
                logarithmicDepthBuffer: n.logarithmicDepthBuffer,
                skinning: t.skinning && d > 0,
                maxBones: d,
                useVertexTexture: n.floatVertexTextures,
                morphTargets: t.morphTargets,
                morphNormals: t.morphNormals,
                maxMorphTargets: e.maxMorphTargets,
                maxMorphNormals: e.maxMorphNormals,
                numDirLights: r.directional.length,
                numPointLights: r.point.length,
                numSpotLights: r.spot.length,
                numRectAreaLights: r.rectArea.length,
                numHemiLights: r.hemi.length,
                numDirLightShadows: r.directionalShadowMap.length,
                numPointLightShadows: r.pointShadowMap.length,
                numSpotLightShadows: r.spotShadowMap.length,
                numClippingPlanes: c,
                numClipIntersection: u,
                dithering: t.dithering,
                shadowMapEnabled: e.shadowMap.enabled && o.length > 0,
                shadowMapType: e.shadowMap.type,
                toneMapping: t.toneMapped ? e.toneMapping : re,
                physicallyCorrectLights: e.physicallyCorrectLights,
                premultipliedAlpha: t.premultipliedAlpha,
                alphaTest: t.alphaTest,
                doubleSided: t.side === g,
                flipSided: t.side === y,
                depthPacking: void 0 !== t.depthPacking && t.depthPacking
            }
        }, this.getProgramCode = function(t, n) {
            var r = [];
            if (n.shaderID ? r.push(n.shaderID) : (r.push(t.fragmentShader), r.push(t.vertexShader)), void 0 !== t.defines)
                for (var i in t.defines) r.push(i), r.push(t.defines[i]);
            for (var a = 0; a < o.length; a++) r.push(n[o[a]]);
            return r.push(t.onBeforeCompile.toString()), r.push(e.gammaOutput), r.push(e.gammaFactor), r.join()
        }, this.acquireProgram = function(n, i, o, a) {
            for (var s, c = 0, u = r.length; c < u; c++) {
                var l = r[c];
                if (l.code === a) {
                    ++(s = l).usedTimes;
                    break
                }
            }
            return void 0 === s && (s = new Ia(e, t, a, n, i, o), r.push(s)), s
        }, this.releaseProgram = function(e) {
            if (0 == --e.usedTimes) {
                var t = r.indexOf(e);
                r[t] = r[r.length - 1], r.pop(), e.destroy()
            }
        }, this.programs = r
    }

    function ka() {
        var e = new WeakMap;
        return {
            get: function(t) {
                var n = e.get(t);
                return void 0 === n && (n = {}, e.set(t, n)), n
            },
            remove: function(t) {
                e.delete(t)
            },
            update: function(t, n, r) {
                e.get(t)[n] = r
            },
            dispose: function() {
                e = new WeakMap
            }
        }
    }

    function Fa(e, t) {
        return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.program !== t.program ? e.program.id - t.program.id : e.material.id !== t.material.id ? e.material.id - t.material.id : e.z !== t.z ? e.z - t.z : e.id - t.id
    }

    function Ga(e, t) {
        return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.z !== t.z ? t.z - e.z : e.id - t.id
    }

    function Na() {
        var e = [],
            t = 0,
            n = [],
            r = [],
            i = {
                id: -1
            };

        function o(n, r, o, a, s, c) {
            var u = e[t];
            return void 0 === u ? (u = {
                id: n.id,
                object: n,
                geometry: r,
                material: o,
                program: o.program || i,
                groupOrder: a,
                renderOrder: n.renderOrder,
                z: s,
                group: c
            }, e[t] = u) : (u.id = n.id, u.object = n, u.geometry = r, u.material = o, u.program = o.program || i, u.groupOrder = a, u.renderOrder = n.renderOrder, u.z = s, u.group = c), t++, u
        }
        return {
            opaque: n,
            transparent: r,
            init: function() {
                t = 0, n.length = 0, r.length = 0
            },
            push: function(e, t, i, a, s, c) {
                var u = o(e, t, i, a, s, c);
                (!0 === i.transparent ? r : n).push(u)
            },
            unshift: function(e, t, i, a, s, c) {
                var u = o(e, t, i, a, s, c);
                (!0 === i.transparent ? r : n).unshift(u)
            },
            sort: function() {
                n.length > 1 && n.sort(Fa), r.length > 1 && r.sort(Ga)
            }
        }
    }

    function Ba() {
        var e = new WeakMap;

        function t(n) {
            var r = n.target;
            r.removeEventListener("dispose", t), e.delete(r)
        }
        return {
            get: function(n, r) {
                var i, o = e.get(n);
                return void 0 === o ? (i = new Na, e.set(n, new WeakMap), e.get(n).set(r, i), n.addEventListener("dispose", t)) : void 0 === (i = o.get(r)) && (i = new Na, o.set(r, i)), i
            },
            dispose: function() {
                e = new WeakMap
            }
        }
    }

    function Ua() {
        var e = {};
        return {
            get: function(t) {
                if (void 0 !== e[t.id]) return e[t.id];
                var n;
                switch (t.type) {
                    case "DirectionalLight":
                        n = {
                            direction: new pn,
                            color: new Dr,
                            shadow: !1,
                            shadowBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new fn
                        };
                        break;
                    case "SpotLight":
                        n = {
                            position: new pn,
                            direction: new pn,
                            color: new Dr,
                            distance: 0,
                            coneCos: 0,
                            penumbraCos: 0,
                            decay: 0,
                            shadow: !1,
                            shadowBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new fn
                        };
                        break;
                    case "PointLight":
                        n = {
                            position: new pn,
                            color: new Dr,
                            distance: 0,
                            decay: 0,
                            shadow: !1,
                            shadowBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new fn,
                            shadowCameraNear: 1,
                            shadowCameraFar: 1e3
                        };
                        break;
                    case "HemisphereLight":
                        n = {
                            direction: new pn,
                            skyColor: new Dr,
                            groundColor: new Dr
                        };
                        break;
                    case "RectAreaLight":
                        n = {
                            color: new Dr,
                            position: new pn,
                            halfWidth: new pn,
                            halfHeight: new pn
                        }
                }
                return e[t.id] = n, n
            }
        }
    }
    var Ha = 0;

    function Va(e, t) {
        return (t.castShadow ? 1 : 0) - (e.castShadow ? 1 : 0)
    }

    function Wa() {
        for (var e = new Ua, t = {
                version: 0,
                hash: {
                    directionalLength: -1,
                    pointLength: -1,
                    spotLength: -1,
                    rectAreaLength: -1,
                    hemiLength: -1,
                    numDirectionalShadows: -1,
                    numPointShadows: -1,
                    numSpotShadows: -1
                },
                ambient: [0, 0, 0],
                probe: [],
                directional: [],
                directionalShadowMap: [],
                directionalShadowMatrix: [],
                spot: [],
                spotShadowMap: [],
                spotShadowMatrix: [],
                rectArea: [],
                point: [],
                pointShadowMap: [],
                pointShadowMatrix: [],
                hemi: [],
                numDirectionalShadows: -1,
                numPointShadows: -1,
                numSpotShadows: -1
            }, n = 0; n < 9; n++) t.probe.push(new pn);
        var r = new pn,
            i = new Rn,
            o = new Rn;
        return {
            setup: function(n, a, s) {
                for (var c = 0, u = 0, l = 0, f = 0; f < 9; f++) t.probe[f].set(0, 0, 0);
                var d = 0,
                    h = 0,
                    v = 0,
                    p = 0,
                    m = 0,
                    y = 0,
                    g = 0,
                    x = 0,
                    b = s.matrixWorldInverse;
                n.sort(Va), f = 0;
                for (var w = n.length; f < w; f++) {
                    var M = n[f],
                        _ = M.color,
                        S = M.intensity,
                        P = M.distance,
                        T = M.shadow && M.shadow.map ? M.shadow.map.texture : null;
                    if (M.isAmbientLight) c += _.r * S, u += _.g * S, l += _.b * S;
                    else if (M.isLightProbe)
                        for (var E = 0; E < 9; E++) t.probe[E].addScaledVector(M.sh.coefficients[E], S);
                    else if (M.isDirectionalLight) {
                        if ((L = e.get(M)).color.copy(M.color).multiplyScalar(M.intensity), L.direction.setFromMatrixPosition(M.matrixWorld), r.setFromMatrixPosition(M.target.matrixWorld), L.direction.sub(r), L.direction.transformDirection(b), L.shadow = M.castShadow, M.castShadow) {
                            var z = M.shadow;
                            L.shadowBias = z.bias, L.shadowRadius = z.radius, L.shadowMapSize = z.mapSize, t.directionalShadowMap[d] = T, t.directionalShadowMatrix[d] = M.shadow.matrix, y++
                        }
                        t.directional[d] = L, d++
                    } else if (M.isSpotLight) {
                        if ((L = e.get(M)).position.setFromMatrixPosition(M.matrixWorld), L.position.applyMatrix4(b), L.color.copy(_).multiplyScalar(S), L.distance = P, L.direction.setFromMatrixPosition(M.matrixWorld), r.setFromMatrixPosition(M.target.matrixWorld), L.direction.sub(r), L.direction.transformDirection(b), L.coneCos = Math.cos(M.angle), L.penumbraCos = Math.cos(M.angle * (1 - M.penumbra)), L.decay = M.decay, L.shadow = M.castShadow, M.castShadow) {
                            z = M.shadow;
                            L.shadowBias = z.bias, L.shadowRadius = z.radius, L.shadowMapSize = z.mapSize, t.spotShadowMap[v] = T, t.spotShadowMatrix[v] = M.shadow.matrix, x++
                        }
                        t.spot[v] = L, v++
                    } else if (M.isRectAreaLight) {
                        (L = e.get(M)).color.copy(_).multiplyScalar(S), L.position.setFromMatrixPosition(M.matrixWorld), L.position.applyMatrix4(b), o.identity(), i.copy(M.matrixWorld), i.premultiply(b), o.extractRotation(i), L.halfWidth.set(.5 * M.width, 0, 0), L.halfHeight.set(0, .5 * M.height, 0), L.halfWidth.applyMatrix4(o), L.halfHeight.applyMatrix4(o), t.rectArea[p] = L, p++
                    } else if (M.isPointLight) {
                        if ((L = e.get(M)).position.setFromMatrixPosition(M.matrixWorld), L.position.applyMatrix4(b), L.color.copy(M.color).multiplyScalar(M.intensity), L.distance = M.distance, L.decay = M.decay, L.shadow = M.castShadow, M.castShadow) {
                            z = M.shadow;
                            L.shadowBias = z.bias, L.shadowRadius = z.radius, L.shadowMapSize = z.mapSize, L.shadowCameraNear = z.camera.near, L.shadowCameraFar = z.camera.far, t.pointShadowMap[h] = T, t.pointShadowMatrix[h] = M.shadow.matrix, g++
                        }
                        t.point[h] = L, h++
                    } else if (M.isHemisphereLight) {
                        var L;
                        (L = e.get(M)).direction.setFromMatrixPosition(M.matrixWorld), L.direction.transformDirection(b), L.direction.normalize(), L.skyColor.copy(M.color).multiplyScalar(S), L.groundColor.copy(M.groundColor).multiplyScalar(S), t.hemi[m] = L, m++
                    }
                }
                t.ambient[0] = c, t.ambient[1] = u, t.ambient[2] = l;
                var A = t.hash;
                A.directionalLength === d && A.pointLength === h && A.spotLength === v && A.rectAreaLength === p && A.hemiLength === m && A.numDirectionalShadows === y && A.numPointShadows === g && A.numSpotShadows === x || (t.directional.length = d, t.spot.length = v, t.rectArea.length = p, t.point.length = h, t.hemi.length = m, t.directionalShadowMap.length = y, t.pointShadowMap.length = g, t.spotShadowMap.length = x, t.directionalShadowMatrix.length = y, t.pointShadowMatrix.length = g, t.spotShadowMatrix.length = x, A.directionalLength = d, A.pointLength = h, A.spotLength = v, A.rectAreaLength = p, A.hemiLength = m, A.numDirectionalShadows = y, A.numPointShadows = g, A.numSpotShadows = x, t.version = Ha++)
            },
            state: t
        }
    }

    function Ya() {
        var e = new Wa,
            t = [],
            n = [];
        return {
            init: function() {
                t.length = 0, n.length = 0
            },
            state: {
                lightsArray: t,
                shadowsArray: n,
                lights: e
            },
            setupLights: function(r) {
                e.setup(t, n, r)
            },
            pushLight: function(e) {
                t.push(e)
            },
            pushShadow: function(e) {
                n.push(e)
            }
        }
    }

    function Xa() {
        var e = new WeakMap;

        function t(n) {
            var r = n.target;
            r.removeEventListener("dispose", t), e.delete(r)
        }
        return {
            get: function(n, r) {
                var i;
                return !1 === e.has(n) ? (i = new Ya, e.set(n, new WeakMap), e.get(n).set(r, i), n.addEventListener("dispose", t)) : !1 === e.get(n).has(r) ? (i = new Ya, e.get(n).set(r, i)) : i = e.get(n).get(r), i
            },
            dispose: function() {
                e = new WeakMap
            }
        }
    }

    function qa(e) {
        Ur.call(this), this.type = "MeshDepthMaterial", this.depthPacking = Nt, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.setValues(e)
    }

    function Ka(e) {
        Ur.call(this), this.type = "MeshDistanceMaterial", this.referencePosition = new pn, this.nearDistance = 1, this.farDistance = 1e3, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.setValues(e)
    }
    qa.prototype = Object.create(Ur.prototype), qa.prototype.constructor = qa, qa.prototype.isMeshDepthMaterial = !0, qa.prototype.copy = function(e) {
        return Ur.prototype.copy.call(this, e), this.depthPacking = e.depthPacking, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this
    }, Ka.prototype = Object.create(Ur.prototype), Ka.prototype.constructor = Ka, Ka.prototype.isMeshDistanceMaterial = !0, Ka.prototype.copy = function(e) {
        return Ur.prototype.copy.call(this, e), this.referencePosition.copy(e.referencePosition), this.nearDistance = e.nearDistance, this.farDistance = e.farDistance, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this
    };
    var Za = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n  float mean = 0.0;\n  float squared_mean = 0.0;\n  \n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy  ) / resolution ) );\n  for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n    #ifdef HORIZONAL_PASS\n      vec2 distribution = decodeHalfRGBA ( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n      mean += distribution.x;\n      squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n    #else\n      float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0,  i )  * radius ) / resolution ) );\n      mean += depth;\n      squared_mean += depth * depth;\n    #endif\n  }\n  mean = mean * HALF_SAMPLE_RATE;\n  squared_mean = squared_mean * HALF_SAMPLE_RATE;\n  float std_dev = pow( squared_mean - mean * mean, 0.5 );\n  gl_FragColor = encodeHalfRGBA( vec2( mean, std_dev ) );\n}",
        Ja = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}";

    function Qa(e, t, n) {
        var r = new no,
            i = new fn,
            o = new fn,
            a = new Mn,
            s = 1,
            c = 2,
            u = 1 + (s | c),
            l = new Array(u),
            f = new Array(u),
            d = {},
            v = {
                0: y,
                1: m,
                2: g
            },
            x = new Ui({
                defines: {
                    SAMPLE_RATE: .25,
                    HALF_SAMPLE_RATE: 1 / 8
                },
                uniforms: {
                    shadow_pass: {
                        value: null
                    },
                    resolution: {
                        value: new fn
                    },
                    radius: {
                        value: 4
                    }
                },
                vertexShader: Ja,
                fragmentShader: Za
            }),
            b = x.clone();
        b.defines.HORIZONAL_PASS = 1;
        var w = new ui;
        w.addAttribute("position", new Vr(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
        for (var M = new Ei(w, x), _ = 0; _ !== u; ++_) {
            var P = 0 != (_ & s),
                T = 0 != (_ & c),
                E = new qa({
                    depthPacking: Bt,
                    morphTargets: P,
                    skinning: T
                });
            l[_] = E;
            var z = new Ka({
                morphTargets: P,
                skinning: T
            });
            f[_] = z
        }
        var L = this;

        function A(n, r) {
            var i = t.update(M);
            x.uniforms.shadow_pass.value = n.map.texture, x.uniforms.resolution.value = n.mapSize, x.uniforms.radius.value = n.radius, e.setRenderTarget(n.mapPass), e.clear(), e.renderBufferDirect(r, null, i, x, M, null), b.uniforms.shadow_pass.value = n.mapPass.texture, b.uniforms.resolution.value = n.mapSize, b.uniforms.radius.value = n.radius, e.setRenderTarget(n.map), e.clear(), e.renderBufferDirect(r, null, i, b, M, null)
        }

        function C(t, n, r, i, o, a) {
            var u = t.geometry,
                h = null,
                m = l,
                y = t.customDepthMaterial;
            if (r.isPointLight && (m = f, y = t.customDistanceMaterial), y) h = y;
            else {
                var g = !1;
                n.morphTargets && (u && u.isBufferGeometry ? g = u.morphAttributes && u.morphAttributes.position && u.morphAttributes.position.length > 0 : u && u.isGeometry && (g = u.morphTargets && u.morphTargets.length > 0)), t.isSkinnedMesh && !1 === n.skinning && console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", t);
                var x = t.isSkinnedMesh && n.skinning,
                    b = 0;
                g && (b |= s), x && (b |= c), h = m[b]
            }
            if (e.localClippingEnabled && !0 === n.clipShadows && 0 !== n.clippingPlanes.length) {
                var w = h.uuid,
                    M = n.uuid,
                    _ = d[w];
                void 0 === _ && (_ = {}, d[w] = _);
                var S = _[M];
                void 0 === S && (S = h.clone(), _[M] = S), h = S
            }
            return h.visible = n.visible, h.wireframe = n.wireframe, h.side = a === p ? null != n.shadowSide ? n.shadowSide : n.side : null != n.shadowSide ? n.shadowSide : v[n.side], h.clipShadows = n.clipShadows, h.clippingPlanes = n.clippingPlanes, h.clipIntersection = n.clipIntersection, h.wireframeLinewidth = n.wireframeLinewidth, h.linewidth = n.linewidth, r.isPointLight && h.isMeshDistanceMaterial && (h.referencePosition.setFromMatrixPosition(r.matrixWorld), h.nearDistance = i, h.farDistance = o), h
        }

        function R(n, i, o, a, s) {
            if (!1 !== n.visible) {
                if (n.layers.test(i.layers) && (n.isMesh || n.isLine || n.isPoints) && (n.castShadow || n.receiveShadow && s === p) && (!n.frustumCulled || r.intersectsObject(n))) {
                    n.modelViewMatrix.multiplyMatrices(o.matrixWorldInverse, n.matrixWorld);
                    var c = t.update(n),
                        u = n.material;
                    if (Array.isArray(u))
                        for (var l = c.groups, f = 0, d = l.length; f < d; f++) {
                            var h = l[f],
                                v = u[h.materialIndex];
                            if (v && v.visible) {
                                var m = C(n, v, a, o.near, o.far, s);
                                e.renderBufferDirect(o, null, c, m, n, h)
                            }
                        } else if (u.visible) {
                            m = C(n, u, a, o.near, o.far, s);
                            e.renderBufferDirect(o, null, c, m, n, null)
                        }
                }
                for (var y = n.children, g = 0, x = y.length; g < x; g++) R(y[g], i, o, a, s)
            }
        }
        this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = h, this.render = function(t, s, c) {
            if (!1 !== L.enabled && (!1 !== L.autoUpdate || !1 !== L.needsUpdate) && 0 !== t.length) {
                var u = e.getRenderTarget(),
                    l = e.getActiveCubeFace(),
                    f = e.getActiveMipmapLevel(),
                    d = e.state;
                d.setBlending(S), d.buffers.color.setClear(1, 1, 1, 1), d.buffers.depth.setTest(!0), d.setScissorTest(!1);
                for (var h = 0, v = t.length; h < v; h++) {
                    var m = t[h],
                        y = m.shadow;
                    if (void 0 !== y) {
                        i.copy(y.mapSize);
                        var g = y.getFrameExtents();
                        if (i.multiply(g), o.copy(y.mapSize), (i.x > n || i.y > n) && (console.warn("THREE.WebGLShadowMap:", m, "has shadow exceeding max texture size, reducing"), i.x > n && (o.x = Math.floor(n / g.x), i.x = o.x * g.x, y.mapSize.x = o.x), i.y > n && (o.y = Math.floor(n / g.y), i.y = o.y * g.y, y.mapSize.y = o.y)), null === y.map && !y.isPointLightShadow && this.type === p) {
                            var x = {
                                minFilter: Pe,
                                magFilter: Pe,
                                format: Ve
                            };
                            y.map = new _n(i.x, i.y, x), y.map.texture.name = m.name + ".shadowMap", y.mapPass = new _n(i.x, i.y, x), y.camera.updateProjectionMatrix()
                        }
                        if (null === y.map) {
                            x = {
                                minFilter: be,
                                magFilter: be,
                                format: Ve
                            };
                            y.map = new _n(i.x, i.y, x), y.map.texture.name = m.name + ".shadowMap", y.camera.updateProjectionMatrix()
                        }
                        e.setRenderTarget(y.map), e.clear();
                        for (var b = y.getViewportCount(), w = 0; w < b; w++) {
                            var M = y.getViewport(w);
                            a.set(o.x * M.x, o.y * M.y, o.x * M.z, o.y * M.w), d.viewport(a), y.updateMatrices(m, c, w), r = y.getFrustum(), R(s, c, y.camera, m, this.type)
                        }
                        y.isPointLightShadow || this.type !== p || A(y, c)
                    } else console.warn("THREE.WebGLShadowMap:", m, "has no shadow.")
                }
                L.needsUpdate = !1, e.setRenderTarget(u, l, f)
            }
        }
    }

    function $a(e, t, n, r) {
        var i = new function() {
                var t = !1,
                    n = new Mn,
                    r = null,
                    i = new Mn(0, 0, 0, 0);
                return {
                    setMask: function(n) {
                        r === n || t || (e.colorMask(n, n, n, n), r = n)
                    },
                    setLocked: function(e) {
                        t = e
                    },
                    setClear: function(t, r, o, a, s) {
                        !0 === s && (t *= a, r *= a, o *= a), n.set(t, r, o, a), !1 === i.equals(n) && (e.clearColor(t, r, o, a), i.copy(n))
                    },
                    reset: function() {
                        t = !1, r = null, i.set(-1, 0, 0, 0)
                    }
                }
            },
            o = new function() {
                var t = !1,
                    n = null,
                    r = null,
                    i = null;
                return {
                    setTest: function(e) {
                        e ? oe(2929) : ae(2929)
                    },
                    setMask: function(r) {
                        n === r || t || (e.depthMask(r), n = r)
                    },
                    setFunc: function(t) {
                        if (r !== t) {
                            if (t) switch (t) {
                                case Y:
                                    e.depthFunc(512);
                                    break;
                                case X:
                                    e.depthFunc(519);
                                    break;
                                case q:
                                    e.depthFunc(513);
                                    break;
                                case K:
                                    e.depthFunc(515);
                                    break;
                                case Z:
                                    e.depthFunc(514);
                                    break;
                                case J:
                                    e.depthFunc(518);
                                    break;
                                case Q:
                                    e.depthFunc(516);
                                    break;
                                case $:
                                    e.depthFunc(517);
                                    break;
                                default:
                                    e.depthFunc(515)
                            } else e.depthFunc(515);
                            r = t
                        }
                    },
                    setLocked: function(e) {
                        t = e
                    },
                    setClear: function(t) {
                        i !== t && (e.clearDepth(t), i = t)
                    },
                    reset: function() {
                        t = !1, n = null, r = null, i = null
                    }
                }
            },
            u = new function() {
                var t = !1,
                    n = null,
                    r = null,
                    i = null,
                    o = null,
                    a = null,
                    s = null,
                    c = null,
                    u = null;
                return {
                    setTest: function(e) {
                        t || (e ? oe(2960) : ae(2960))
                    },
                    setMask: function(r) {
                        n === r || t || (e.stencilMask(r), n = r)
                    },
                    setFunc: function(t, n, a) {
                        r === t && i === n && o === a || (e.stencilFunc(t, n, a), r = t, i = n, o = a)
                    },
                    setOp: function(t, n, r) {
                        a === t && s === n && c === r || (e.stencilOp(t, n, r), a = t, s = n, c = r)
                    },
                    setLocked: function(e) {
                        t = e
                    },
                    setClear: function(t) {
                        u !== t && (e.clearStencil(t), u = t)
                    },
                    reset: function() {
                        t = !1, n = null, r = null, i = null, o = null, a = null, s = null, c = null, u = null
                    }
                }
            },
            l = e.getParameter(34921),
            f = new Uint8Array(l),
            d = new Uint8Array(l),
            h = new Uint8Array(l),
            v = {},
            p = null,
            m = null,
            x = null,
            b = null,
            w = null,
            M = null,
            _ = null,
            C = null,
            R = null,
            O = null,
            j = !1,
            I = null,
            D = null,
            k = null,
            F = null,
            G = null,
            N = e.getParameter(35661),
            B = !1,
            U = 0,
            H = e.getParameter(7938); - 1 !== H.indexOf("WebGL") ? (U = parseFloat(/^WebGL\ ([0-9])/.exec(H)[1]), B = U >= 1) : -1 !== H.indexOf("OpenGL ES") && (U = parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(H)[1]), B = U >= 2);
        var V = null,
            W = {},
            ee = new Mn,
            te = new Mn;

        function ne(t, n, r) {
            var i = new Uint8Array(4),
                o = e.createTexture();
            e.bindTexture(t, o), e.texParameteri(t, 10241, 9728), e.texParameteri(t, 10240, 9728);
            for (var a = 0; a < r; a++) e.texImage2D(n + a, 0, 6408, 1, 1, 0, 6408, 5121, i);
            return o
        }
        var re = {};

        function ie(n, i) {
            (f[n] = 1, 0 === d[n] && (e.enableVertexAttribArray(n), d[n] = 1), h[n] !== i) && ((r.isWebGL2 ? e : t.get("ANGLE_instanced_arrays"))[r.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](n, i), h[n] = i)
        }

        function oe(t) {
            !0 !== v[t] && (e.enable(t), v[t] = !0)
        }

        function ae(t) {
            !1 !== v[t] && (e.disable(t), v[t] = !1)
        }

        function se(t, r, i, o, a, s, c, u) {
            if (t !== S) {
                if (x || (oe(3042), x = !0), t === L) a = a || r, s = s || i, c = c || o, r === w && a === C || (e.blendEquationSeparate(n.convert(r), n.convert(a)), w = r, C = a), i === M && o === _ && s === R && c === O || (e.blendFuncSeparate(n.convert(i), n.convert(o), n.convert(s), n.convert(c)), M = i, _ = o, R = s, O = c), b = t, j = null;
                else if (t !== b || u !== j) {
                    if (w === A && C === A || (e.blendEquation(32774), w = A, C = A), u) switch (t) {
                        case P:
                            e.blendFuncSeparate(1, 771, 1, 771);
                            break;
                        case T:
                            e.blendFunc(1, 1);
                            break;
                        case E:
                            e.blendFuncSeparate(0, 0, 769, 771);
                            break;
                        case z:
                            e.blendFuncSeparate(0, 768, 0, 770);
                            break;
                        default:
                            console.error("THREE.WebGLState: Invalid blending: ", t)
                    } else switch (t) {
                        case P:
                            e.blendFuncSeparate(770, 771, 1, 771);
                            break;
                        case T:
                            e.blendFunc(770, 1);
                            break;
                        case E:
                            e.blendFunc(0, 769);
                            break;
                        case z:
                            e.blendFunc(0, 768);
                            break;
                        default:
                            console.error("THREE.WebGLState: Invalid blending: ", t)
                    }
                    M = null, _ = null, R = null, O = null, b = t, j = u
                }
            } else x && (ae(3042), x = !1)
        }

        function ce(t) {
            I !== t && (t ? e.frontFace(2304) : e.frontFace(2305), I = t)
        }

        function ue(t) {
            t !== a ? (oe(2884), t !== D && (t === s ? e.cullFace(1029) : t === c ? e.cullFace(1028) : e.cullFace(1032))) : ae(2884), D = t
        }

        function le(t, n, r) {
            t ? (oe(32823), F === n && G === r || (e.polygonOffset(n, r), F = n, G = r)) : ae(32823)
        }

        function fe(t) {
            void 0 === t && (t = 33984 + N - 1), V !== t && (e.activeTexture(t), V = t)
        }
        return re[3553] = ne(3553, 3553, 1), re[34067] = ne(34067, 34069, 6), i.setClear(0, 0, 0, 1), o.setClear(1), u.setClear(0), oe(2929), o.setFunc(K), ce(!1), ue(s), oe(2884), se(S), {
            buffers: {
                color: i,
                depth: o,
                stencil: u
            },
            initAttributes: function() {
                for (var e = 0, t = f.length; e < t; e++) f[e] = 0
            },
            enableAttribute: function(e) {
                ie(e, 0)
            },
            enableAttributeAndDivisor: ie,
            disableUnusedAttributes: function() {
                for (var t = 0, n = d.length; t !== n; ++t) d[t] !== f[t] && (e.disableVertexAttribArray(t), d[t] = 0)
            },
            enable: oe,
            disable: ae,
            getCompressedTextureFormats: function() {
                if (null === p && (p = [], t.get("WEBGL_compressed_texture_pvrtc") || t.get("WEBGL_compressed_texture_s3tc") || t.get("WEBGL_compressed_texture_etc1") || t.get("WEBGL_compressed_texture_astc")))
                    for (var n = e.getParameter(34467), r = 0; r < n.length; r++) p.push(n[r]);
                return p
            },
            useProgram: function(t) {
                return m !== t && (e.useProgram(t), m = t, !0)
            },
            setBlending: se,
            setMaterial: function(e, t) {
                e.side === g ? ae(2884) : oe(2884);
                var n = e.side === y;
                t && (n = !n), ce(n), e.blending === P && !1 === e.transparent ? se(S) : se(e.blending, e.blendEquation, e.blendSrc, e.blendDst, e.blendEquationAlpha, e.blendSrcAlpha, e.blendDstAlpha, e.premultipliedAlpha), o.setFunc(e.depthFunc), o.setTest(e.depthTest), o.setMask(e.depthWrite), i.setMask(e.colorWrite);
                var r = e.stencilWrite;
                u.setTest(r), r && (u.setMask(e.stencilWriteMask), u.setFunc(e.stencilFunc, e.stencilRef, e.stencilFuncMask), u.setOp(e.stencilFail, e.stencilZFail, e.stencilZPass)), le(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits)
            },
            setFlipSided: ce,
            setCullFace: ue,
            setLineWidth: function(t) {
                t !== k && (B && e.lineWidth(t), k = t)
            },
            setPolygonOffset: le,
            setScissorTest: function(e) {
                e ? oe(3089) : ae(3089)
            },
            activeTexture: fe,
            bindTexture: function(t, n) {
                null === V && fe();
                var r = W[V];
                void 0 === r && (r = {
                    type: void 0,
                    texture: void 0
                }, W[V] = r), r.type === t && r.texture === n || (e.bindTexture(t, n || re[t]), r.type = t, r.texture = n)
            },
            compressedTexImage2D: function() {
                try {
                    e.compressedTexImage2D.apply(e, arguments)
                } catch (e) {
                    console.error("THREE.WebGLState:", e)
                }
            },
            texImage2D: function() {
                try {
                    e.texImage2D.apply(e, arguments)
                } catch (e) {
                    console.error("THREE.WebGLState:", e)
                }
            },
            texImage3D: function() {
                try {
                    e.texImage3D.apply(e, arguments)
                } catch (e) {
                    console.error("THREE.WebGLState:", e)
                }
            },
            scissor: function(t) {
                !1 === ee.equals(t) && (e.scissor(t.x, t.y, t.z, t.w), ee.copy(t))
            },
            viewport: function(t) {
                !1 === te.equals(t) && (e.viewport(t.x, t.y, t.z, t.w), te.copy(t))
            },
            reset: function() {
                for (var t = 0; t < d.length; t++) 1 === d[t] && (e.disableVertexAttribArray(t), d[t] = 0);
                v = {}, p = null, V = null, W = {}, m = null, b = null, I = null, D = null, i.reset(), o.reset(), u.reset()
            }
        }
    }

    function es(e, t, n, r, i, o, a) {
        var s, c = new WeakMap,
            u = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d");

        function l(e, t) {
            return u ? new OffscreenCanvas(e, t) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")
        }

        function f(e, t, n, r) {
            var i = 1;
            if ((e.width > r || e.height > r) && (i = r / Math.max(e.width, e.height)), i < 1 || !0 === t) {
                if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap) {
                    var o = t ? ln.floorPowerOfTwo : Math.floor,
                        a = o(i * e.width),
                        c = o(i * e.height);
                    void 0 === s && (s = l(a, c));
                    var u = n ? l(a, c) : s;
                    return u.width = a, u.height = c, u.getContext("2d").drawImage(e, 0, 0, a, c), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + e.width + "x" + e.height + ") to (" + a + "x" + c + ")."), u
                }
                return "data" in e && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + e.width + "x" + e.height + ")."), e
            }
            return e
        }

        function d(e) {
            return ln.isPowerOfTwo(e.width) && ln.isPowerOfTwo(e.height)
        }

        function h(e, t) {
            return e.generateMipmaps && t && e.minFilter !== be && e.minFilter !== Pe
        }

        function v(t, n, i, o) {
            e.generateMipmap(t), r.get(n).__maxMipLevel = Math.log(Math.max(i, o)) * Math.LOG2E
        }

        function p(e, n) {
            if (!i.isWebGL2) return e;
            var r = e;
            return 6403 === e && (5126 === n && (r = 33326), 5131 === n && (r = 33325), 5121 === n && (r = 33321)), 6407 === e && (5126 === n && (r = 34837), 5131 === n && (r = 34843), 5121 === n && (r = 32849)), 6408 === e && (5126 === n && (r = 34836), 5131 === n && (r = 34842), 5121 === n && (r = 32856)), 33325 === r || 33326 === r || 34842 === r || 34836 === r ? t.get("EXT_color_buffer_float") : 34843 !== r && 34837 !== r || console.warn("THREE.WebGLRenderer: Floating point textures with RGB format not supported. Please use RGBA instead."), r
        }

        function m(e) {
            return e === be || e === we || e === _e ? 9728 : 9729
        }

        function y(t) {
            var n = t.target;
            n.removeEventListener("dispose", y),
                function(t) {
                    var n = r.get(t);
                    if (void 0 === n.__webglInit) return;
                    e.deleteTexture(n.__webglTexture), r.remove(t)
                }(n), n.isVideoTexture && c.delete(n), a.memory.textures--
        }

        function g(t) {
            var n = t.target;
            n.removeEventListener("dispose", g),
                function(t) {
                    var n = r.get(t),
                        i = r.get(t.texture);
                    if (!t) return;
                    void 0 !== i.__webglTexture && e.deleteTexture(i.__webglTexture);
                    t.depthTexture && t.depthTexture.dispose();
                    if (t.isWebGLRenderTargetCube)
                        for (var o = 0; o < 6; o++) e.deleteFramebuffer(n.__webglFramebuffer[o]), n.__webglDepthbuffer && e.deleteRenderbuffer(n.__webglDepthbuffer[o]);
                    else e.deleteFramebuffer(n.__webglFramebuffer), n.__webglDepthbuffer && e.deleteRenderbuffer(n.__webglDepthbuffer);
                    if (t.isWebGLMultiviewRenderTarget) {
                        e.deleteTexture(n.__webglColorTexture), e.deleteTexture(n.__webglDepthStencilTexture), a.memory.textures -= 2;
                        o = 0;
                        for (var s = n.__webglViewFramebuffers.length; o < s; o++) e.deleteFramebuffer(n.__webglViewFramebuffers[o])
                    }
                    r.remove(t.texture), r.remove(t)
                }(n), a.memory.textures--
        }
        var x = 0;

        function b(e, t) {
            var i = r.get(e);
            if (e.isVideoTexture && function(e) {
                    var t = a.render.frame;
                    c.get(e) !== t && (c.set(e, t), e.update())
                }(e), e.version > 0 && i.__version !== e.version) {
                var o = e.image;
                if (void 0 === o) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
                else {
                    if (!1 !== o.complete) return void P(i, e, t);
                    console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
                }
            }
            n.activeTexture(33984 + t), n.bindTexture(3553, i.__webglTexture)
        }

        function w(t, a) {
            if (6 === t.image.length) {
                var s = r.get(t);
                if (t.version > 0 && s.__version !== t.version) {
                    S(s, t), n.activeTexture(33984 + a), n.bindTexture(34067, s.__webglTexture), e.pixelStorei(37440, t.flipY);
                    for (var c = t && t.isCompressedTexture, u = t.image[0] && t.image[0].isDataTexture, l = [], m = 0; m < 6; m++) l[m] = c || u ? u ? t.image[m].image : t.image[m] : f(t.image[m], !1, !0, i.maxCubemapSize);
                    var y, g = l[0],
                        x = d(g) || i.isWebGL2,
                        b = o.convert(t.format),
                        w = o.convert(t.type),
                        M = p(b, w);
                    if (_(34067, t, x), c) {
                        for (m = 0; m < 6; m++) {
                            y = l[m].mipmaps;
                            for (var P = 0; P < y.length; P++) {
                                var T = y[P];
                                t.format !== Ve && t.format !== He ? n.getCompressedTextureFormats().indexOf(b) > -1 ? n.compressedTexImage2D(34069 + m, P, M, T.width, T.height, 0, T.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : n.texImage2D(34069 + m, P, M, T.width, T.height, 0, b, w, T.data)
                            }
                        }
                        s.__maxMipLevel = y.length - 1
                    } else {
                        y = t.mipmaps;
                        for (m = 0; m < 6; m++)
                            if (u) {
                                n.texImage2D(34069 + m, 0, M, l[m].width, l[m].height, 0, b, w, l[m].data);
                                for (P = 0; P < y.length; P++) {
                                    var E = (T = y[P]).image[m].image;
                                    n.texImage2D(34069 + m, P + 1, M, E.width, E.height, 0, b, w, E.data)
                                }
                            } else {
                                n.texImage2D(34069 + m, 0, M, b, w, l[m]);
                                for (P = 0; P < y.length; P++) {
                                    T = y[P];
                                    n.texImage2D(34069 + m, P + 1, M, b, w, T.image[m])
                                }
                            }
                        s.__maxMipLevel = y.length
                    }
                    h(t, x) && v(34067, t, g.width, g.height), s.__version = t.version, t.onUpdate && t.onUpdate(t)
                } else n.activeTexture(33984 + a), n.bindTexture(34067, s.__webglTexture)
            }
        }

        function M(e, t) {
            n.activeTexture(33984 + t), n.bindTexture(34067, r.get(e).__webglTexture)
        }

        function _(n, a, s) {
            var c;
            if (s ? (e.texParameteri(n, 10242, o.convert(a.wrapS)), e.texParameteri(n, 10243, o.convert(a.wrapT)), 32879 !== n && 35866 !== n || e.texParameteri(n, 32882, o.convert(a.wrapR)), e.texParameteri(n, 10240, o.convert(a.magFilter)), e.texParameteri(n, 10241, o.convert(a.minFilter))) : (e.texParameteri(n, 10242, 33071), e.texParameteri(n, 10243, 33071), 32879 !== n && 35866 !== n || e.texParameteri(n, 32882, 33071), a.wrapS === ge && a.wrapT === ge || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), e.texParameteri(n, 10240, m(a.magFilter)), e.texParameteri(n, 10241, m(a.minFilter)), a.minFilter !== be && a.minFilter !== Pe && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), c = t.get("EXT_texture_filter_anisotropic")) {
                if (a.type === De && null === t.get("OES_texture_float_linear")) return;
                if (a.type === ke && null === (i.isWebGL2 || t.get("OES_texture_half_float_linear"))) return;
                (a.anisotropy > 1 || r.get(a).__currentAnisotropy) && (e.texParameterf(n, c.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(a.anisotropy, i.getMaxAnisotropy())), r.get(a).__currentAnisotropy = a.anisotropy)
            }
        }

        function S(t, n) {
            void 0 === t.__webglInit && (t.__webglInit = !0, n.addEventListener("dispose", y), t.__webglTexture = e.createTexture(), a.memory.textures++)
        }

        function P(t, r, a) {
            var s = 3553;
            r.isDataTexture2DArray && (s = 35866), r.isDataTexture3D && (s = 32879), S(t, r), n.activeTexture(33984 + a), n.bindTexture(s, t.__webglTexture), e.pixelStorei(37440, r.flipY), e.pixelStorei(37441, r.premultiplyAlpha), e.pixelStorei(3317, r.unpackAlignment);
            var c = function(e) {
                    return !i.isWebGL2 && (e.wrapS !== ge || e.wrapT !== ge || e.minFilter !== be && e.minFilter !== Pe)
                }(r) && !1 === d(r.image),
                u = f(r.image, c, !1, i.maxTextureSize),
                l = d(u) || i.isWebGL2,
                m = o.convert(r.format),
                y = o.convert(r.type),
                g = p(m, y);
            _(s, r, l);
            var x, b = r.mipmaps;
            if (r.isDepthTexture) {
                if (g = 6402, r.type === De) {
                    if (!i.isWebGL2) throw new Error("Float Depth Texture only supported in WebGL2.0");
                    g = 36012
                } else i.isWebGL2 && (g = 33189);
                r.format === qe && 6402 === g && r.type !== Oe && r.type !== Ie && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), r.type = Oe, y = o.convert(r.type)), r.format === Ke && (g = 34041, r.type !== Be && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), r.type = Be, y = o.convert(r.type))), n.texImage2D(3553, 0, g, u.width, u.height, 0, m, y, null)
            } else if (r.isDataTexture)
                if (b.length > 0 && l) {
                    for (var w = 0, M = b.length; w < M; w++) x = b[w], n.texImage2D(3553, w, g, x.width, x.height, 0, m, y, x.data);
                    r.generateMipmaps = !1, t.__maxMipLevel = b.length - 1
                } else n.texImage2D(3553, 0, g, u.width, u.height, 0, m, y, u.data), t.__maxMipLevel = 0;
            else if (r.isCompressedTexture) {
                for (w = 0, M = b.length; w < M; w++) x = b[w], r.format !== Ve && r.format !== He ? n.getCompressedTextureFormats().indexOf(m) > -1 ? n.compressedTexImage2D(3553, w, g, x.width, x.height, 0, x.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : n.texImage2D(3553, w, g, x.width, x.height, 0, m, y, x.data);
                t.__maxMipLevel = b.length - 1
            } else if (r.isDataTexture2DArray) n.texImage3D(35866, 0, g, u.width, u.height, u.depth, 0, m, y, u.data), t.__maxMipLevel = 0;
            else if (r.isDataTexture3D) n.texImage3D(32879, 0, g, u.width, u.height, u.depth, 0, m, y, u.data), t.__maxMipLevel = 0;
            else if (b.length > 0 && l) {
                for (w = 0, M = b.length; w < M; w++) x = b[w], n.texImage2D(3553, w, g, m, y, x);
                r.generateMipmaps = !1, t.__maxMipLevel = b.length - 1
            } else n.texImage2D(3553, 0, g, m, y, u), t.__maxMipLevel = 0;
            h(r, l) && v(3553, r, u.width, u.height), t.__version = r.version, r.onUpdate && r.onUpdate(r)
        }

        function T(t, i, a, s) {
            var c = o.convert(i.texture.format),
                u = o.convert(i.texture.type),
                l = p(c, u);
            n.texImage2D(s, 0, l, i.width, i.height, 0, c, u, null), e.bindFramebuffer(36160, t), e.framebufferTexture2D(36160, a, s, r.get(i.texture).__webglTexture, 0), e.bindFramebuffer(36160, null)
        }

        function E(t, n, r) {
            if (e.bindRenderbuffer(36161, t), n.depthBuffer && !n.stencilBuffer) {
                if (r) {
                    var i = L(n);
                    e.renderbufferStorageMultisample(36161, i, 33189, n.width, n.height)
                } else e.renderbufferStorage(36161, 33189, n.width, n.height);
                e.framebufferRenderbuffer(36160, 36096, 36161, t)
            } else if (n.depthBuffer && n.stencilBuffer) {
                if (r) {
                    i = L(n);
                    e.renderbufferStorageMultisample(36161, i, 35056, n.width, n.height)
                } else e.renderbufferStorage(36161, 34041, n.width, n.height);
                e.framebufferRenderbuffer(36160, 33306, 36161, t)
            } else {
                var a = p(o.convert(n.texture.format), o.convert(n.texture.type));
                if (r) {
                    i = L(n);
                    e.renderbufferStorageMultisample(36161, i, a, n.width, n.height)
                } else e.renderbufferStorage(36161, a, n.width, n.height)
            }
            e.bindRenderbuffer(36161, null)
        }

        function z(t) {
            var n = r.get(t),
                i = !0 === t.isWebGLRenderTargetCube;
            if (t.depthTexture) {
                if (i) throw new Error("target.depthTexture not supported in Cube render targets");
                ! function(t, n) {
                    if (n && n.isWebGLRenderTargetCube) throw new Error("Depth Texture with cube render targets is not supported");
                    if (e.bindFramebuffer(36160, t), !n.depthTexture || !n.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                    r.get(n.depthTexture).__webglTexture && n.depthTexture.image.width === n.width && n.depthTexture.image.height === n.height || (n.depthTexture.image.width = n.width, n.depthTexture.image.height = n.height, n.depthTexture.needsUpdate = !0), b(n.depthTexture, 0);
                    var i = r.get(n.depthTexture).__webglTexture;
                    if (n.depthTexture.format === qe) e.framebufferTexture2D(36160, 36096, 3553, i, 0);
                    else {
                        if (n.depthTexture.format !== Ke) throw new Error("Unknown depthTexture format");
                        e.framebufferTexture2D(36160, 33306, 3553, i, 0)
                    }
                }(n.__webglFramebuffer, t)
            } else if (i) {
                n.__webglDepthbuffer = [];
                for (var o = 0; o < 6; o++) e.bindFramebuffer(36160, n.__webglFramebuffer[o]), n.__webglDepthbuffer[o] = e.createRenderbuffer(), E(n.__webglDepthbuffer[o], t)
            } else e.bindFramebuffer(36160, n.__webglFramebuffer), n.__webglDepthbuffer = e.createRenderbuffer(), E(n.__webglDepthbuffer, t);
            e.bindFramebuffer(36160, null)
        }

        function L(e) {
            return i.isWebGL2 && e.isWebGLMultisampleRenderTarget ? Math.min(i.maxSamples, e.samples) : 0
        }
        var A = !1,
            C = !1;
        this.allocateTextureUnit = function() {
            var e = x;
            return e >= i.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + e + " texture units while this GPU supports only " + i.maxTextures), x += 1, e
        }, this.resetTextureUnits = function() {
            x = 0
        }, this.setTexture2D = b, this.setTexture2DArray = function(e, t) {
            var i = r.get(e);
            e.version > 0 && i.__version !== e.version ? P(i, e, t) : (n.activeTexture(33984 + t), n.bindTexture(35866, i.__webglTexture))
        }, this.setTexture3D = function(e, t) {
            var i = r.get(e);
            e.version > 0 && i.__version !== e.version ? P(i, e, t) : (n.activeTexture(33984 + t), n.bindTexture(32879, i.__webglTexture))
        }, this.setTextureCube = w, this.setTextureCubeDynamic = M, this.setupRenderTarget = function(s) {
            var c = r.get(s),
                u = r.get(s.texture);
            s.addEventListener("dispose", g), u.__webglTexture = e.createTexture(), a.memory.textures++;
            var l = !0 === s.isWebGLRenderTargetCube,
                f = !0 === s.isWebGLMultisampleRenderTarget,
                m = !0 === s.isWebGLMultiviewRenderTarget,
                y = d(s) || i.isWebGL2;
            if (l) {
                c.__webglFramebuffer = [];
                for (var x = 0; x < 6; x++) c.__webglFramebuffer[x] = e.createFramebuffer()
            } else if (c.__webglFramebuffer = e.createFramebuffer(), f)
                if (i.isWebGL2) {
                    c.__webglMultisampledFramebuffer = e.createFramebuffer(), c.__webglColorRenderbuffer = e.createRenderbuffer(), e.bindRenderbuffer(36161, c.__webglColorRenderbuffer);
                    var b = p(o.convert(s.texture.format), o.convert(s.texture.type)),
                        w = L(s);
                    e.renderbufferStorageMultisample(36161, w, b, s.width, s.height), e.bindFramebuffer(36160, c.__webglMultisampledFramebuffer), e.framebufferRenderbuffer(36160, 36064, 36161, c.__webglColorRenderbuffer), e.bindRenderbuffer(36161, null), s.depthBuffer && (c.__webglDepthRenderbuffer = e.createRenderbuffer(), E(c.__webglDepthRenderbuffer, s, !0)), e.bindFramebuffer(36160, null)
                } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
            else if (m) {
                var M = s.width,
                    S = s.height,
                    P = s.numViews;
                e.bindFramebuffer(36160, c.__webglFramebuffer);
                var A = t.get("OVR_multiview2");
                a.memory.textures += 2;
                var C = e.createTexture();
                e.bindTexture(35866, C), e.texParameteri(35866, 10240, 9728), e.texParameteri(35866, 10241, 9728), e.texImage3D(35866, 0, 32856, M, S, P, 0, 6408, 5121, null), A.framebufferTextureMultiviewOVR(36160, 36064, C, 0, 0, P);
                var R = e.createTexture();
                e.bindTexture(35866, R), e.texParameteri(35866, 10240, 9728), e.texParameteri(35866, 10241, 9728), e.texImage3D(35866, 0, 35056, M, S, P, 0, 34041, 34042, null), A.framebufferTextureMultiviewOVR(36160, 33306, R, 0, 0, P);
                var O = new Array(P);
                for (x = 0; x < P; ++x) O[x] = e.createFramebuffer(), e.bindFramebuffer(36160, O[x]), e.framebufferTextureLayer(36160, 36064, C, 0, x);
                c.__webglColorTexture = C, c.__webglDepthStencilTexture = R, c.__webglViewFramebuffers = O, e.bindFramebuffer(36160, null), e.bindTexture(35866, null)
            }
            if (l) {
                n.bindTexture(34067, u.__webglTexture), _(34067, s.texture, y);
                for (x = 0; x < 6; x++) T(c.__webglFramebuffer[x], s, 36064, 34069 + x);
                h(s.texture, y) && v(34067, s.texture, s.width, s.height), n.bindTexture(34067, null)
            } else m || (n.bindTexture(3553, u.__webglTexture), _(3553, s.texture, y), T(c.__webglFramebuffer, s, 36064, 3553), h(s.texture, y) && v(3553, s.texture, s.width, s.height), n.bindTexture(3553, null));
            s.depthBuffer && z(s)
        }, this.updateRenderTargetMipmap = function(e) {
            var t = e.texture;
            if (h(t, d(e) || i.isWebGL2)) {
                var o = e.isWebGLRenderTargetCube ? 34067 : 3553,
                    a = r.get(t).__webglTexture;
                n.bindTexture(o, a), v(o, t, e.width, e.height), n.bindTexture(o, null)
            }
        }, this.updateMultisampleRenderTarget = function(t) {
            if (t.isWebGLMultisampleRenderTarget)
                if (i.isWebGL2) {
                    var n = r.get(t);
                    e.bindFramebuffer(36008, n.__webglMultisampledFramebuffer), e.bindFramebuffer(36009, n.__webglFramebuffer);
                    var o = t.width,
                        a = t.height,
                        s = 16384;
                    t.depthBuffer && (s |= 256), t.stencilBuffer && (s |= 1024), e.blitFramebuffer(0, 0, o, a, 0, 0, o, a, s, 9728)
                } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")
        }, this.safeSetTexture2D = function(e, t) {
            e && e.isWebGLRenderTarget && (!1 === A && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."), A = !0), e = e.texture), b(e, t)
        }, this.safeSetTextureCube = function(e, t) {
            e && e.isWebGLRenderTargetCube && (!1 === C && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."), C = !0), e = e.texture), e && e.isCubeTexture || Array.isArray(e.image) && 6 === e.image.length ? w(e, t) : M(e, t)
        }
    }

    function ts(e, t, n) {
        return {
            convert: function(e) {
                var r;
                if (e === ye) return 10497;
                if (e === ge) return 33071;
                if (e === xe) return 33648;
                if (e === be) return 9728;
                if (e === we) return 9984;
                if (e === _e) return 9986;
                if (e === Pe) return 9729;
                if (e === Te) return 9985;
                if (e === ze) return 9987;
                if (e === Ae) return 5121;
                if (e === Fe) return 32819;
                if (e === Ge) return 32820;
                if (e === Ne) return 33635;
                if (e === Ce) return 5120;
                if (e === Re) return 5122;
                if (e === Oe) return 5123;
                if (e === je) return 5124;
                if (e === Ie) return 5125;
                if (e === De) return 5126;
                if (e === ke) {
                    if (n.isWebGL2) return 5131;
                    if (null !== (r = t.get("OES_texture_half_float"))) return r.HALF_FLOAT_OES
                }
                if (e === Ue) return 6406;
                if (e === He) return 6407;
                if (e === Ve) return 6408;
                if (e === We) return 6409;
                if (e === Ye) return 6410;
                if (e === qe) return 6402;
                if (e === Ke) return 34041;
                if (e === Ze) return 6403;
                if (e === A) return 32774;
                if (e === C) return 32778;
                if (e === R) return 32779;
                if (e === I) return 0;
                if (e === D) return 1;
                if (e === k) return 768;
                if (e === F) return 769;
                if (e === G) return 770;
                if (e === N) return 771;
                if (e === B) return 772;
                if (e === U) return 773;
                if (e === H) return 774;
                if (e === V) return 775;
                if (e === W) return 776;
                if ((e === Je || e === Qe || e === $e || e === et) && null !== (r = t.get("WEBGL_compressed_texture_s3tc"))) {
                    if (e === Je) return r.COMPRESSED_RGB_S3TC_DXT1_EXT;
                    if (e === Qe) return r.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                    if (e === $e) return r.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                    if (e === et) return r.COMPRESSED_RGBA_S3TC_DXT5_EXT
                }
                if ((e === tt || e === nt || e === rt || e === it) && null !== (r = t.get("WEBGL_compressed_texture_pvrtc"))) {
                    if (e === tt) return r.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                    if (e === nt) return r.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                    if (e === rt) return r.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                    if (e === it) return r.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                }
                if (e === ot && null !== (r = t.get("WEBGL_compressed_texture_etc1"))) return r.COMPRESSED_RGB_ETC1_WEBGL;
                if ((e === at || e === st || e === ct || e === ut || e === lt || e === ft || e === dt || e === ht || e === vt || e === pt || e === mt || e === yt || e === gt || e === xt) && null !== (r = t.get("WEBGL_compressed_texture_astc"))) return e;
                if (e === O || e === j) {
                    if (n.isWebGL2) {
                        if (e === O) return 32775;
                        if (e === j) return 32776
                    }
                    if (null !== (r = t.get("EXT_blend_minmax"))) {
                        if (e === O) return r.MIN_EXT;
                        if (e === j) return r.MAX_EXT
                    }
                }
                if (e === Be) {
                    if (n.isWebGL2) return 34042;
                    if (null !== (r = t.get("WEBGL_depth_texture"))) return r.UNSIGNED_INT_24_8_WEBGL
                }
                return 0
            }
        }
    }

    function ns(e, t, n, r) {
        _n.call(this, e, t, r), this.depthBuffer = !1, this.stencilBuffer = !1, this.numViews = n
    }

    function rs(e, t) {
        var n, r, i, o, a, s, c, u = 2,
            l = e.extensions,
            f = e.properties,
            d = 0;

        function h(e) {
            return e.isArrayCamera ? e.cameras : (a[0] = e, a)
        }
        this.isAvailable = function() {
            if (void 0 === c) {
                var e = l.get("OVR_multiview2");
                if (c = null !== e && !1 === t.getContextAttributes().antialias) {
                    d = t.getParameter(e.MAX_VIEWS_OVR), n = new ns(0, 0, u), s = new fn, o = [], i = [], a = [];
                    for (var r = 0; r < d; r++) o[r] = new Rn, i[r] = new gn
                }
            }
            return c
        }, this.attachCamera = function(t) {
            !1 !== function(e) {
                if (void 0 === e.isArrayCamera) return !0;
                var t = e.cameras;
                if (t.length > d) return !1;
                for (var n = 1, r = t.length; n < r; n++)
                    if (t[0].viewport.z !== t[n].viewport.z || t[0].viewport.w !== t[n].viewport.w) return !1;
                return !0
            }(t) && (r = e.getRenderTarget(), function(t) {
                if (r ? s.set(r.width, r.height) : e.getDrawingBufferSize(s), t.isArrayCamera) {
                    var i = t.cameras[0].viewport;
                    n.setSize(i.z, i.w), n.setNumViews(t.cameras.length)
                } else n.setSize(s.x, s.y), n.setNumViews(u)
            }(t), e.setRenderTarget(n))
        }, this.detachCamera = function(i) {
            n === e.getRenderTarget() && (e.setRenderTarget(r), function(e) {
                var r = n,
                    i = r.numViews,
                    o = f.get(r).__webglViewFramebuffers,
                    a = r.width,
                    c = r.height;
                if (e.isArrayCamera)
                    for (var u = 0; u < i; u++) {
                        var l = e.cameras[u].viewport,
                            d = l.x,
                            h = l.y,
                            v = d + l.z,
                            p = h + l.w;
                        t.bindFramebuffer(36008, o[u]), t.blitFramebuffer(0, 0, a, c, d, h, v, p, 16384, 9728)
                    } else t.bindFramebuffer(36008, o[0]), t.blitFramebuffer(0, 0, a, c, 0, 0, s.x, s.y, 16384, 9728)
            }(i))
        }, this.updateCameraProjectionMatricesUniform = function(e, n) {
            for (var r = h(e), i = 0; i < r.length; i++) o[i].copy(r[i].projectionMatrix);
            n.setValue(t, "projectionMatrices", o)
        }, this.updateCameraViewMatricesUniform = function(e, n) {
            for (var r = h(e), i = 0; i < r.length; i++) o[i].copy(r[i].matrixWorldInverse);
            n.setValue(t, "viewMatrices", o)
        }, this.updateObjectMatricesUniforms = function(e, n, r) {
            for (var a = h(n), s = 0; s < a.length; s++) o[s].multiplyMatrices(a[s].matrixWorldInverse, e.matrixWorld), i[s].getNormalMatrix(o[s]);
            r.setValue(t, "modelViewMatrices", o), r.setValue(t, "normalMatrices", i)
        }
    }

    function is() {
        Zn.call(this), this.type = "Group"
    }

    function os(e) {
        Vi.call(this), this.cameras = e || []
    }
    ns.prototype = Object.assign(Object.create(_n.prototype), {
        constructor: ns,
        isWebGLMultiviewRenderTarget: !0,
        copy: function(e) {
            return _n.prototype.copy.call(this, e), this.numViews = e.numViews, this
        },
        setNumViews: function(e) {
            return this.numViews !== e && (this.numViews = e, this.dispose()), this
        }
    }), is.prototype = Object.assign(Object.create(Zn.prototype), {
        constructor: is,
        isGroup: !0
    }), os.prototype = Object.assign(Object.create(Vi.prototype), {
        constructor: os,
        isArrayCamera: !0
    });
    var as, ss = new pn,
        cs = new pn;

    function us(e, t, n) {
        ss.setFromMatrixPosition(t.matrixWorld), cs.setFromMatrixPosition(n.matrixWorld);
        var r = ss.distanceTo(cs),
            i = t.projectionMatrix.elements,
            o = n.projectionMatrix.elements,
            a = i[14] / (i[10] - 1),
            s = i[14] / (i[10] + 1),
            c = (i[9] + 1) / i[5],
            u = (i[9] - 1) / i[5],
            l = (i[8] - 1) / i[0],
            f = (o[8] + 1) / o[0],
            d = a * l,
            h = a * f,
            v = r / (-l + f),
            p = v * -l;
        t.matrixWorld.decompose(e.position, e.quaternion, e.scale), e.translateX(p), e.translateZ(v), e.matrixWorld.compose(e.position, e.quaternion, e.scale), e.matrixWorldInverse.getInverse(e.matrixWorld);
        var m = a + v,
            y = s + v,
            g = d - p,
            x = h + (r - p),
            b = c * s / y * m,
            w = u * s / y * m;
        e.projectionMatrix.makePerspective(g, x, b, w, m, y)
    }

    function ls(e) {
        var t, n, r = this,
            i = null,
            o = null,
            a = null,
            s = [],
            c = new Rn,
            u = new Rn,
            l = 1,
            f = "local-floor";
        "undefined" != typeof window && "VRFrameData" in window && (o = new window.VRFrameData, window.addEventListener("vrdisplaypresentchange", w, !1));
        var d = new Rn,
            h = new dn,
            v = new pn,
            p = new Vi;
        p.viewport = new Mn, p.layers.enable(1);
        var m = new Vi;
        m.viewport = new Mn, m.layers.enable(2);
        var y = new os([p, m]);

        function g() {
            return null !== i && !0 === i.isPresenting
        }
        y.layers.enable(1), y.layers.enable(2);
        var x, b = new fn;

        function w() {
            if (g()) {
                var o = i.getEyeParameters("left");
                t = 2 * o.renderWidth * l, n = o.renderHeight * l, x = e.getPixelRatio(), e.getSize(b), e.setDrawingBufferSize(t, n, 1), p.viewport.set(0, 0, t / 2, n), m.viewport.set(t / 2, 0, t / 2, n), P.start(), r.dispatchEvent({
                    type: "sessionstart"
                })
            } else r.enabled && e.setDrawingBufferSize(b.width, b.height, x), P.stop(), r.dispatchEvent({
                type: "sessionend"
            })
        }
        var M = [];

        function _(e) {
            for (var t = navigator.getGamepads && navigator.getGamepads(), n = 0, r = 0, i = t.length; n < i; n++) {
                var o = t[n];
                if (o && ("Daydream Controller" === o.id || "Gear VR Controller" === o.id || "Oculus Go Controller" === o.id || "OpenVR Gamepad" === o.id || o.id.startsWith("Oculus Touch") || o.id.startsWith("HTC Vive Focus") || o.id.startsWith("Spatial Controller"))) {
                    if (r === e) return o;
                    r++
                }
            }
        }

        function S(e, r) {
            null !== r && 4 === r.length && e.set(r[0] * t, r[1] * n, r[2] * t, r[3] * n)
        }
        this.enabled = !1, this.getController = function(e) {
            var t = s[e];
            return void 0 === t && ((t = new is).matrixAutoUpdate = !1, t.visible = !1, s[e] = t), t
        }, this.getDevice = function() {
            return i
        }, this.setDevice = function(e) {
            void 0 !== e && (i = e), P.setContext(e)
        }, this.setFramebufferScaleFactor = function(e) {
            l = e
        }, this.setReferenceSpaceType = function(e) {
            f = e
        }, this.setPoseTarget = function(e) {
            void 0 !== e && (a = e)
        }, this.getCamera = function(e) {
            var t = "local-floor" === f ? 1.6 : 0;
            if (!1 === g()) return e.position.set(0, t, 0), e.rotation.set(0, 0, 0), e;
            if (i.depthNear = e.near, i.depthFar = e.far, i.getFrameData(o), "local-floor" === f) {
                var n = i.stageParameters;
                n ? c.fromArray(n.sittingToStandingTransform) : c.makeTranslation(0, t, 0)
            }
            var r = o.pose,
                l = null !== a ? a : e;
            l.matrix.copy(c), l.matrix.decompose(l.position, l.quaternion, l.scale), null !== r.orientation && (h.fromArray(r.orientation), l.quaternion.multiply(h)), null !== r.position && (h.setFromRotationMatrix(c), v.fromArray(r.position), v.applyQuaternion(h), l.position.add(v)), l.updateMatrixWorld(), p.near = e.near, m.near = e.near, p.far = e.far, m.far = e.far, p.matrixWorldInverse.fromArray(o.leftViewMatrix), m.matrixWorldInverse.fromArray(o.rightViewMatrix), u.getInverse(c), "local-floor" === f && (p.matrixWorldInverse.multiply(u), m.matrixWorldInverse.multiply(u));
            var x = l.parent;
            null !== x && (d.getInverse(x.matrixWorld), p.matrixWorldInverse.multiply(d), m.matrixWorldInverse.multiply(d)), p.matrixWorld.getInverse(p.matrixWorldInverse), m.matrixWorld.getInverse(m.matrixWorldInverse), p.projectionMatrix.fromArray(o.leftProjectionMatrix), m.projectionMatrix.fromArray(o.rightProjectionMatrix), us(y, p, m);
            var b = i.getLayers();
            if (b.length) {
                var w = b[0];
                S(p.viewport, w.leftBounds), S(m.viewport, w.rightBounds)
            }
            return function() {
                for (var e = 0; e < s.length; e++) {
                    var t = s[e],
                        n = _(e);
                    if (void 0 !== n && void 0 !== n.pose) {
                        if (null === n.pose) return;
                        var r = n.pose;
                        !1 === r.hasPosition && t.position.set(.2, -.6, -.05), null !== r.position && t.position.fromArray(r.position), null !== r.orientation && t.quaternion.fromArray(r.orientation), t.matrix.compose(t.position, t.quaternion, t.scale), t.matrix.premultiply(c), t.matrix.decompose(t.position, t.quaternion, t.scale), t.matrixWorldNeedsUpdate = !0, t.visible = !0;
                        var i = "Daydream Controller" === n.id ? 0 : 1;
                        void 0 === M[e] && (M[e] = !1), M[e] !== n.buttons[i].pressed && (M[e] = n.buttons[i].pressed, !0 === M[e] ? t.dispatchEvent({
                            type: "selectstart"
                        }) : (t.dispatchEvent({
                            type: "selectend"
                        }), t.dispatchEvent({
                            type: "select"
                        })))
                    } else t.visible = !1
                }
            }(), y
        }, this.getStandingMatrix = function() {
            return c
        }, this.isPresenting = g;
        var P = new ao;
        this.setAnimationLoop = function(e) {
            P.setAnimationLoop(e), g() && P.start()
        }, this.submitFrame = function() {
            g() && i.submitFrame()
        }, this.dispose = function() {
            "undefined" != typeof window && window.removeEventListener("vrdisplaypresentchange", w)
        }, this.setFrameOfReferenceType = function() {
            console.warn("THREE.WebVRManager: setFrameOfReferenceType() has been deprecated.")
        }
    }

    function fs(e, t) {
        var n = this,
            r = null,
            i = null,
            o = "local-floor",
            a = null,
            s = [],
            c = [];

        function u() {
            return null !== r && null !== i
        }
        var l = new Vi;
        l.layers.enable(1), l.viewport = new Mn;
        var f = new Vi;
        f.layers.enable(2), f.viewport = new Mn;
        var d = new os([l, f]);

        function h(e) {
            for (var t = 0; t < s.length; t++) c[t] === e.inputSource && s[t].dispatchEvent({
                type: e.type
            })
        }

        function v() {
            e.setFramebuffer(null), e.setRenderTarget(e.getRenderTarget()), g.stop(), n.dispatchEvent({
                type: "sessionend"
            })
        }

        function p(e) {
            i = e, g.setContext(r), g.start(), n.dispatchEvent({
                type: "sessionstart"
            })
        }

        function m(e, t) {
            null === t ? e.matrixWorld.copy(e.matrix) : e.matrixWorld.multiplyMatrices(t.matrixWorld, e.matrix), e.matrixWorldInverse.getInverse(e.matrixWorld)
        }
        d.layers.enable(1), d.layers.enable(2), this.enabled = !1, this.getController = function(e) {
            var t = s[e];
            return void 0 === t && ((t = new is).matrixAutoUpdate = !1, t.visible = !1, s[e] = t), t
        }, this.setFramebufferScaleFactor = function() {}, this.setReferenceSpaceType = function(e) {
            o = e
        }, this.getSession = function() {
            return r
        }, this.setSession = function(e) {
            null !== (r = e) && (r.addEventListener("select", h), r.addEventListener("selectstart", h), r.addEventListener("selectend", h), r.addEventListener("end", v), r.updateRenderState({
                baseLayer: new XRWebGLLayer(r, t)
            }), r.requestReferenceSpace(o).then(p), c = r.inputSources, r.addEventListener("inputsourceschange", (function() {
                c = r.inputSources, console.log(c);
                for (var e = 0; e < s.length; e++) {
                    s[e].userData.inputSource = c[e]
                }
            })))
        }, this.getCamera = function(e) {
            if (u()) {
                var t = e.parent,
                    n = d.cameras;
                m(d, t);
                for (var r = 0; r < n.length; r++) m(n[r], t);
                e.matrixWorld.copy(d.matrixWorld);
                for (var i = e.children, o = (r = 0, i.length); r < o; r++) i[r].updateMatrixWorld(!0);
                return us(d, l, f), d
            }
            return e
        }, this.isPresenting = u;
        var y = null;
        var g = new ao;
        g.setAnimationLoop((function(t, n) {
            if (null !== (a = n.getViewerPose(i))) {
                var o = a.views,
                    u = r.renderState.baseLayer;
                e.setFramebuffer(u.framebuffer);
                for (var l = 0; l < o.length; l++) {
                    var f = o[l],
                        h = u.getViewport(f),
                        v = f.transform.inverse.matrix,
                        p = d.cameras[l];
                    p.matrix.fromArray(v).getInverse(p.matrix), p.projectionMatrix.fromArray(f.projectionMatrix), p.viewport.set(h.x, h.y, h.width, h.height), 0 === l && d.matrix.copy(p.matrix)
                }
            }
            for (l = 0; l < s.length; l++) {
                var m = s[l],
                    g = c[l];
                if (g) {
                    var x = n.getPose(g.targetRaySpace, i);
                    if (null !== x) {
                        m.matrix.fromArray(x.transform.matrix), m.matrix.decompose(m.position, m.rotation, m.scale), m.visible = !0;
                        continue
                    }
                }
                m.visible = !1
            }
            y && y(t)
        })), this.setAnimationLoop = function(e) {
            y = e
        }, this.dispose = function() {}, this.getStandingMatrix = function() {
            return console.warn("THREE.WebXRManager: getStandingMatrix() is no longer needed."), new Rn
        }, this.getDevice = function() {
            console.warn("THREE.WebXRManager: getDevice() has been deprecated.")
        }, this.setDevice = function() {
            console.warn("THREE.WebXRManager: setDevice() has been deprecated.")
        }, this.setFrameOfReferenceType = function() {
            console.warn("THREE.WebXRManager: setFrameOfReferenceType() has been deprecated.")
        }, this.submitFrame = function() {}
    }

    function ds(e) {
        var t = void 0 !== (e = e || {}).canvas ? e.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"),
            n = void 0 !== e.context ? e.context : null,
            r = void 0 !== e.alpha && e.alpha,
            i = void 0 === e.depth || e.depth,
            o = void 0 === e.stencil || e.stencil,
            a = void 0 !== e.antialias && e.antialias,
            s = void 0 === e.premultipliedAlpha || e.premultipliedAlpha,
            c = void 0 !== e.preserveDrawingBuffer && e.preserveDrawingBuffer,
            u = void 0 !== e.powerPreference ? e.powerPreference : "default",
            l = void 0 !== e.failIfMajorPerformanceCaveat && e.failIfMajorPerformanceCaveat,
            f = null,
            d = null;
        this.domElement = t, this.debug = {
            checkShaderErrors: !0
        }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.gammaInput = !1, this.gammaOutput = !1, this.physicallyCorrectLights = !1, this.toneMapping = ie, this.toneMappingExposure = 1, this.toneMappingWhitePoint = 1, this.maxMorphTargets = 8, this.maxMorphNormals = 4;
        var h, v, p, m, g, x, b, w, M, _, S, P, T, E, z, L, A, C, R = this,
            O = !1,
            j = null,
            I = 0,
            D = 0,
            k = null,
            F = null,
            G = -1,
            N = {
                geometry: null,
                program: null,
                wireframe: !1
            },
            B = null,
            U = null,
            H = new Mn,
            V = new Mn,
            W = null,
            Y = t.width,
            X = t.height,
            q = 1,
            K = new Mn(0, 0, Y, X),
            Z = new Mn(0, 0, Y, X),
            J = !1,
            Q = new no,
            $ = new vo,
            ee = !1,
            te = !1,
            ne = new Rn,
            re = new pn;

        function oe() {
            return null === k ? q : 1
        }
        try {
            var ae = {
                alpha: r,
                depth: i,
                stencil: o,
                antialias: a,
                premultipliedAlpha: s,
                preserveDrawingBuffer: c,
                powerPreference: u,
                failIfMajorPerformanceCaveat: l,
                xrCompatible: !0
            };
            if (t.addEventListener("webglcontextlost", fe, !1), t.addEventListener("webglcontextrestored", de, !1), null === (h = n || t.getContext("webgl", ae) || t.getContext("experimental-webgl", ae))) throw null !== t.getContext("webgl") ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
            void 0 === h.getShaderPrecisionFormat && (h.getShaderPrecisionFormat = function() {
                return {
                    rangeMin: 1,
                    rangeMax: 1,
                    precision: 1
                }
            })
        } catch (e) {
            throw console.error("THREE.WebGLRenderer: " + e.message), e
        }

        function se() {
            v = new po(h), !1 === (p = new ho(h, v, e)).isWebGL2 && (v.get("WEBGL_depth_texture"), v.get("OES_texture_float"), v.get("OES_texture_half_float"), v.get("OES_texture_half_float_linear"), v.get("OES_standard_derivatives"), v.get("OES_element_index_uint"), v.get("ANGLE_instanced_arrays")), v.get("OES_texture_float_linear"), C = new ts(h, v, p), (m = new $a(h, v, C, p)).scissor(V.copy(Z).multiplyScalar(q).floor()), m.viewport(H.copy(K).multiplyScalar(q).floor()), g = new go(h), x = new ka, b = new es(h, v, m, x, p, C, g), w = new so(h), M = new mo(h, w, g), _ = new wo(h, M, w, g), z = new bo(h), S = new Da(R, v, p), P = new Ba, T = new Xa, E = new lo(R, m, _, s), L = new fo(h, v, g, p), A = new yo(h, v, g, p), g.programs = S.programs, R.capabilities = p, R.extensions = v, R.properties = x, R.renderLists = P, R.state = m, R.info = g
        }
        se();
        var ce = "undefined" != typeof navigator && "xr" in navigator && "supportsSession" in navigator.xr ? new fs(R, h) : new ls(R);
        this.vr = ce;
        var ue = new rs(R, h),
            le = new Qa(R, _, p.maxTextureSize);

        function fe(e) {
            e.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), O = !0
        }

        function de() {
            console.log("THREE.WebGLRenderer: Context Restored."), O = !1, se()
        }

        function he(e) {
            var t = e.target;
            t.removeEventListener("dispose", he),
                function(e) {
                    ve(e), x.remove(e)
                }(t)
        }

        function ve(e) {
            var t = x.get(e).program;
            e.program = void 0, void 0 !== t && S.releaseProgram(t)
        }
        this.shadowMap = le, this.getContext = function() {
            return h
        }, this.getContextAttributes = function() {
            return h.getContextAttributes()
        }, this.forceContextLoss = function() {
            var e = v.get("WEBGL_lose_context");
            e && e.loseContext()
        }, this.forceContextRestore = function() {
            var e = v.get("WEBGL_lose_context");
            e && e.restoreContext()
        }, this.getPixelRatio = function() {
            return q
        }, this.setPixelRatio = function(e) {
            void 0 !== e && (q = e, this.setSize(Y, X, !1))
        }, this.getSize = function(e) {
            return void 0 === e && (console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"), e = new fn), e.set(Y, X)
        }, this.setSize = function(e, n, r) {
            ce.isPresenting() ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (Y = e, X = n, t.width = Math.floor(e * q), t.height = Math.floor(n * q), !1 !== r && (t.style.width = e + "px", t.style.height = n + "px"), this.setViewport(0, 0, e, n))
        }, this.getDrawingBufferSize = function(e) {
            return void 0 === e && (console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"), e = new fn), e.set(Y * q, X * q).floor()
        }, this.setDrawingBufferSize = function(e, n, r) {
            Y = e, X = n, q = r, t.width = Math.floor(e * r), t.height = Math.floor(n * r), this.setViewport(0, 0, e, n)
        }, this.getCurrentViewport = function(e) {
            return void 0 === e && (console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"), e = new Mn), e.copy(H)
        }, this.getViewport = function(e) {
            return e.copy(K)
        }, this.setViewport = function(e, t, n, r) {
            e.isVector4 ? K.set(e.x, e.y, e.z, e.w) : K.set(e, t, n, r), m.viewport(H.copy(K).multiplyScalar(q).floor())
        }, this.getScissor = function(e) {
            return e.copy(Z)
        }, this.setScissor = function(e, t, n, r) {
            e.isVector4 ? Z.set(e.x, e.y, e.z, e.w) : Z.set(e, t, n, r), m.scissor(V.copy(Z).multiplyScalar(q).floor())
        }, this.getScissorTest = function() {
            return J
        }, this.setScissorTest = function(e) {
            m.setScissorTest(J = e)
        }, this.getClearColor = function() {
            return E.getClearColor()
        }, this.setClearColor = function() {
            E.setClearColor.apply(E, arguments)
        }, this.getClearAlpha = function() {
            return E.getClearAlpha()
        }, this.setClearAlpha = function() {
            E.setClearAlpha.apply(E, arguments)
        }, this.clear = function(e, t, n) {
            var r = 0;
            (void 0 === e || e) && (r |= 16384), (void 0 === t || t) && (r |= 256), (void 0 === n || n) && (r |= 1024), h.clear(r)
        }, this.clearColor = function() {
            this.clear(!0, !1, !1)
        }, this.clearDepth = function() {
            this.clear(!1, !0, !1)
        }, this.clearStencil = function() {
            this.clear(!1, !1, !0)
        }, this.dispose = function() {
            t.removeEventListener("webglcontextlost", fe, !1), t.removeEventListener("webglcontextrestored", de, !1), P.dispose(), T.dispose(), x.dispose(), _.dispose(), ce.dispose(), me.stop()
        }, this.renderBufferImmediate = function(e, t) {
            m.initAttributes();
            var n = x.get(e);
            e.hasPositions && !n.position && (n.position = h.createBuffer()), e.hasNormals && !n.normal && (n.normal = h.createBuffer()), e.hasUvs && !n.uv && (n.uv = h.createBuffer()), e.hasColors && !n.color && (n.color = h.createBuffer());
            var r = t.getAttributes();
            e.hasPositions && (h.bindBuffer(34962, n.position), h.bufferData(34962, e.positionArray, 35048), m.enableAttribute(r.position), h.vertexAttribPointer(r.position, 3, 5126, !1, 0, 0)), e.hasNormals && (h.bindBuffer(34962, n.normal), h.bufferData(34962, e.normalArray, 35048), m.enableAttribute(r.normal), h.vertexAttribPointer(r.normal, 3, 5126, !1, 0, 0)), e.hasUvs && (h.bindBuffer(34962, n.uv), h.bufferData(34962, e.uvArray, 35048), m.enableAttribute(r.uv), h.vertexAttribPointer(r.uv, 2, 5126, !1, 0, 0)), e.hasColors && (h.bindBuffer(34962, n.color), h.bufferData(34962, e.colorArray, 35048), m.enableAttribute(r.color), h.vertexAttribPointer(r.color, 3, 5126, !1, 0, 0)), m.disableUnusedAttributes(), h.drawArrays(4, 0, e.count), e.count = 0
        }, this.renderBufferDirect = function(e, t, n, r, i, o) {
            var a = i.isMesh && i.matrixWorld.determinant() < 0;
            m.setMaterial(r, a);
            var s = we(e, t, r, i),
                c = !1;
            N.geometry === n.id && N.program === s.id && N.wireframe === (!0 === r.wireframe) || (N.geometry = n.id, N.program = s.id, N.wireframe = !0 === r.wireframe, c = !0), i.morphTargetInfluences && (z.update(i, n, r, s), c = !0);
            var u, l = n.index,
                f = n.attributes.position,
                d = 1;
            !0 === r.wireframe && (l = M.getWireframeAttribute(n), d = 2);
            var y = L;
            null !== l && (u = w.get(l), (y = A).setIndex(u)), c && (! function(e, t, n, r) {
                if (!1 === p.isWebGL2 && (e.isInstancedMesh || t.isInstancedBufferGeometry) && null === v.get("ANGLE_instanced_arrays")) return;
                m.initAttributes();
                var i = t.attributes,
                    o = r.getAttributes(),
                    a = n.defaultAttributeValues;
                for (var s in o) {
                    var c = o[s];
                    if (c >= 0) {
                        var u = i[s];
                        if (void 0 !== u) {
                            var l = u.normalized,
                                f = u.itemSize;
                            if (void 0 === (_ = w.get(u))) continue;
                            var d = _.buffer,
                                y = _.type,
                                g = _.bytesPerElement;
                            if (u.isInterleavedBufferAttribute) {
                                var x = u.data,
                                    b = x.stride,
                                    M = u.offset;
                                x && x.isInstancedInterleavedBuffer ? (m.enableAttributeAndDivisor(c, x.meshPerAttribute), void 0 === t.maxInstancedCount && (t.maxInstancedCount = x.meshPerAttribute * x.count)) : m.enableAttribute(c), h.bindBuffer(34962, d), h.vertexAttribPointer(c, f, y, l, b * g, M * g)
                            } else u.isInstancedBufferAttribute ? (m.enableAttributeAndDivisor(c, u.meshPerAttribute), void 0 === t.maxInstancedCount && (t.maxInstancedCount = u.meshPerAttribute * u.count)) : m.enableAttribute(c), h.bindBuffer(34962, d), h.vertexAttribPointer(c, f, y, l, 0, 0)
                        } else if ("instanceMatrix" === s) {
                            var _;
                            if (void 0 === (_ = w.get(e.instanceMatrix))) continue;
                            d = _.buffer, y = _.type;
                            m.enableAttributeAndDivisor(c + 0, 1), m.enableAttributeAndDivisor(c + 1, 1), m.enableAttributeAndDivisor(c + 2, 1), m.enableAttributeAndDivisor(c + 3, 1), h.bindBuffer(34962, d), h.vertexAttribPointer(c + 0, 4, y, !1, 64, 0), h.vertexAttribPointer(c + 1, 4, y, !1, 64, 16), h.vertexAttribPointer(c + 2, 4, y, !1, 64, 32), h.vertexAttribPointer(c + 3, 4, y, !1, 64, 48)
                        } else if (void 0 !== a) {
                            var S = a[s];
                            if (void 0 !== S) switch (S.length) {
                                case 2:
                                    h.vertexAttrib2fv(c, S);
                                    break;
                                case 3:
                                    h.vertexAttrib3fv(c, S);
                                    break;
                                case 4:
                                    h.vertexAttrib4fv(c, S);
                                    break;
                                default:
                                    h.vertexAttrib1fv(c, S)
                            }
                        }
                    }
                }
                m.disableUnusedAttributes()
            }(i, n, r, s), null !== l && h.bindBuffer(34963, u.buffer));
            var g = 1 / 0;
            null !== l ? g = l.count : void 0 !== f && (g = f.count);
            var x = n.drawRange.start * d,
                b = n.drawRange.count * d,
                _ = null !== o ? o.start * d : 0,
                S = null !== o ? o.count * d : 1 / 0,
                P = Math.max(x, _),
                T = Math.min(g, x + b, _ + S) - 1,
                E = Math.max(0, T - P + 1);
            if (0 !== E) {
                if (i.isMesh)
                    if (!0 === r.wireframe) m.setLineWidth(r.wireframeLinewidth * oe()), y.setMode(1);
                    else switch (i.drawMode) {
                        case Lt:
                            y.setMode(4);
                            break;
                        case At:
                            y.setMode(5);
                            break;
                        case Ct:
                            y.setMode(6)
                    } else if (i.isLine) {
                        var C = r.linewidth;
                        void 0 === C && (C = 1), m.setLineWidth(C * oe()), i.isLineSegments ? y.setMode(1) : i.isLineLoop ? y.setMode(2) : y.setMode(3)
                    } else i.isPoints ? y.setMode(0) : i.isSprite && y.setMode(4);
                i.isInstancedMesh ? y.renderInstances(n, P, E, i.count) : n.isInstancedBufferGeometry ? y.renderInstances(n, P, E, n.maxInstancedCount) : y.render(P, E)
            }
        }, this.compile = function(e, t) {
            (d = T.get(e, t)).init(), e.traverse((function(e) {
                e.isLight && (d.pushLight(e), e.castShadow && d.pushShadow(e))
            })), d.setupLights(t), e.traverse((function(t) {
                if (t.material)
                    if (Array.isArray(t.material))
                        for (var n = 0; n < t.material.length; n++) be(t.material[n], e.fog, t);
                    else be(t.material, e.fog, t)
            }))
        };
        var pe = null;
        var me = new ao;

        function ye(e, t, n, r) {
            if (!1 !== e.visible) {
                if (e.layers.test(t.layers))
                    if (e.isGroup) n = e.renderOrder;
                    else if (e.isLOD) !0 === e.autoUpdate && e.update(t);
                else if (e.isLight) d.pushLight(e), e.castShadow && d.pushShadow(e);
                else if (e.isSprite) {
                    if (!e.frustumCulled || Q.intersectsSprite(e)) {
                        r && re.setFromMatrixPosition(e.matrixWorld).applyMatrix4(ne);
                        var i = _.update(e);
                        (o = e.material).visible && f.push(e, i, o, n, re.z, null)
                    }
                } else if (e.isImmediateRenderObject) r && re.setFromMatrixPosition(e.matrixWorld).applyMatrix4(ne), f.push(e, null, e.material, n, re.z, null);
                else if ((e.isMesh || e.isLine || e.isPoints) && (e.isSkinnedMesh && e.skeleton.frame !== g.render.frame && (e.skeleton.update(), e.skeleton.frame = g.render.frame), !e.frustumCulled || Q.intersectsObject(e))) {
                    r && re.setFromMatrixPosition(e.matrixWorld).applyMatrix4(ne);
                    i = _.update(e);
                    var o = e.material;
                    if (Array.isArray(o))
                        for (var a = i.groups, s = 0, c = a.length; s < c; s++) {
                            var u = a[s],
                                l = o[u.materialIndex];
                            l && l.visible && f.push(e, i, l, n, re.z, u)
                        } else o.visible && f.push(e, i, o, n, re.z, null)
                }
                var h = e.children;
                for (s = 0, c = h.length; s < c; s++) ye(h[s], t, n, r)
            }
        }

        function ge(e, t, n, r) {
            for (var i = 0, o = e.length; i < o; i++) {
                var a = e[i],
                    s = a.object,
                    c = a.geometry,
                    u = void 0 === r ? a.material : r,
                    l = a.group;
                if (n.isArrayCamera)
                    if (U = n, ce.enabled && ue.isAvailable()) xe(s, t, n, c, u, l);
                    else
                        for (var f = n.cameras, h = 0, v = f.length; h < v; h++) {
                            var p = f[h];
                            s.layers.test(p.layers) && (m.viewport(H.copy(p.viewport)), d.setupLights(p), xe(s, t, p, c, u, l))
                        } else U = null, xe(s, t, n, c, u, l)
            }
        }

        function xe(e, t, n, r, i, o) {
            if (e.onBeforeRender(R, t, n, r, i, o), d = T.get(t, U || n), e.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, e.matrixWorld), e.normalMatrix.getNormalMatrix(e.modelViewMatrix), e.isImmediateRenderObject) {
                m.setMaterial(i);
                var a = we(n, t.fog, i, e);
                N.geometry = null, N.program = null, N.wireframe = !1,
                    function(e, t) {
                        e.render((function(e) {
                            R.renderBufferImmediate(e, t)
                        }))
                    }(e, a)
            } else R.renderBufferDirect(n, t.fog, r, i, e, o);
            e.onAfterRender(R, t, n, r, i, o), d = T.get(t, U || n)
        }

        function be(e, t, n) {
            var r = x.get(e),
                i = d.state.lights,
                o = d.state.shadowsArray,
                a = i.state.version,
                s = S.getParameters(e, i.state, o, t, $.numPlanes, $.numIntersection, n),
                c = S.getProgramCode(e, s),
                u = r.program,
                l = !0;
            if (void 0 === u) e.addEventListener("dispose", he);
            else if (u.code !== c) ve(e);
            else if (r.lightsStateVersion !== a) r.lightsStateVersion = a, l = !1;
            else {
                if (void 0 !== s.shaderID) return;
                l = !1
            }
            if (l) {
                if (s.shaderID) {
                    var f = oo[s.shaderID];
                    r.shader = {
                        name: e.type,
                        uniforms: ki(f.uniforms),
                        vertexShader: f.vertexShader,
                        fragmentShader: f.fragmentShader
                    }
                } else r.shader = {
                    name: e.type,
                    uniforms: e.uniforms,
                    vertexShader: e.vertexShader,
                    fragmentShader: e.fragmentShader
                };
                e.onBeforeCompile(r.shader, R), c = S.getProgramCode(e, s), u = S.acquireProgram(e, r.shader, s, c), r.program = u, e.program = u
            }
            var h = u.getAttributes();
            if (e.morphTargets) {
                e.numSupportedMorphTargets = 0;
                for (var v = 0; v < R.maxMorphTargets; v++) h["morphTarget" + v] >= 0 && e.numSupportedMorphTargets++
            }
            if (e.morphNormals) {
                e.numSupportedMorphNormals = 0;
                for (v = 0; v < R.maxMorphNormals; v++) h["morphNormal" + v] >= 0 && e.numSupportedMorphNormals++
            }
            var p = r.shader.uniforms;
            (e.isShaderMaterial || e.isRawShaderMaterial) && !0 !== e.clipping || (r.numClippingPlanes = $.numPlanes, r.numIntersection = $.numIntersection, p.clippingPlanes = $.uniform), r.fog = t, r.needsLights = function(e) {
                return e.isMeshLambertMaterial || e.isMeshPhongMaterial || e.isMeshStandardMaterial || e.isShadowMaterial || e.isShaderMaterial && !0 === e.lights
            }(e), r.lightsStateVersion = a, r.needsLights && (p.ambientLightColor.value = i.state.ambient, p.lightProbe.value = i.state.probe, p.directionalLights.value = i.state.directional, p.spotLights.value = i.state.spot, p.rectAreaLights.value = i.state.rectArea, p.pointLights.value = i.state.point, p.hemisphereLights.value = i.state.hemi, p.directionalShadowMap.value = i.state.directionalShadowMap, p.directionalShadowMatrix.value = i.state.directionalShadowMatrix, p.spotShadowMap.value = i.state.spotShadowMap, p.spotShadowMatrix.value = i.state.spotShadowMatrix, p.pointShadowMap.value = i.state.pointShadowMap, p.pointShadowMatrix.value = i.state.pointShadowMatrix);
            var m = r.program.getUniforms(),
                y = ga.seqWithValue(m.seq, p);
            r.uniformsList = y
        }

        function we(e, t, n, r) {
            b.resetTextureUnits();
            var i = x.get(n),
                o = d.state.lights;
            if (ee && (te || e !== B)) {
                var a = e === B && n.id === G;
                $.setState(n.clippingPlanes, n.clipIntersection, n.clipShadows, e, i, a)
            }!1 === n.needsUpdate && (void 0 === i.program ? n.needsUpdate = !0 : n.fog && i.fog !== t ? n.needsUpdate = !0 : i.needsLights && i.lightsStateVersion !== o.state.version ? n.needsUpdate = !0 : void 0 === i.numClippingPlanes || i.numClippingPlanes === $.numPlanes && i.numIntersection === $.numIntersection || (n.needsUpdate = !0)), n.needsUpdate && (be(n, t, r), n.needsUpdate = !1);
            var s, c, u = !1,
                l = !1,
                f = !1,
                v = i.program,
                g = v.getUniforms(),
                w = i.shader.uniforms;
            if (m.useProgram(v.program) && (u = !0, l = !0, f = !0), n.id !== G && (G = n.id, l = !0), u || B !== e) {
                if (v.numMultiviewViews > 0 ? ue.updateCameraProjectionMatricesUniform(e, g) : g.setValue(h, "projectionMatrix", e.projectionMatrix), p.logarithmicDepthBuffer && g.setValue(h, "logDepthBufFC", 2 / (Math.log(e.far + 1) / Math.LN2)), B !== e && (B = e, l = !0, f = !0), n.isShaderMaterial || n.isMeshPhongMaterial || n.isMeshStandardMaterial || n.envMap) {
                    var M = g.map.cameraPosition;
                    void 0 !== M && M.setValue(h, re.setFromMatrixPosition(e.matrixWorld))
                }(n.isMeshPhongMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial || n.skinning) && (v.numMultiviewViews > 0 ? ue.updateCameraViewMatricesUniform(e, g) : g.setValue(h, "viewMatrix", e.matrixWorldInverse))
            }
            if (n.skinning) {
                g.setOptional(h, r, "bindMatrix"), g.setOptional(h, r, "bindMatrixInverse");
                var _ = r.skeleton;
                if (_) {
                    var S = _.bones;
                    if (p.floatVertexTextures) {
                        if (void 0 === _.boneTexture) {
                            var P = Math.sqrt(4 * S.length);
                            P = ln.ceilPowerOfTwo(P), P = Math.max(P, 4);
                            var T = new Float32Array(P * P * 4);
                            T.set(_.boneMatrices);
                            var E = new Ki(T, P, P, Ve, De);
                            _.boneMatrices = T, _.boneTexture = E, _.boneTextureSize = P
                        }
                        g.setValue(h, "boneTexture", _.boneTexture, b), g.setValue(h, "boneTextureSize", _.boneTextureSize)
                    } else g.setOptional(h, _, "boneMatrices")
                }
            }
            return (l || i.receiveShadow !== r.receiveShadow) && (i.receiveShadow = r.receiveShadow, g.setValue(h, "receiveShadow", r.receiveShadow)), l && (g.setValue(h, "toneMappingExposure", R.toneMappingExposure), g.setValue(h, "toneMappingWhitePoint", R.toneMappingWhitePoint), i.needsLights && (c = f, (s = w).ambientLightColor.needsUpdate = c, s.lightProbe.needsUpdate = c, s.directionalLights.needsUpdate = c, s.pointLights.needsUpdate = c, s.spotLights.needsUpdate = c, s.rectAreaLights.needsUpdate = c, s.hemisphereLights.needsUpdate = c), t && n.fog && function(e, t) {
                e.fogColor.value.copy(t.color), t.isFog ? (e.fogNear.value = t.near, e.fogFar.value = t.far) : t.isFogExp2 && (e.fogDensity.value = t.density)
            }(w, t), n.isMeshBasicMaterial ? Me(w, n) : n.isMeshLambertMaterial ? (Me(w, n), function(e, t) {
                t.emissiveMap && (e.emissiveMap.value = t.emissiveMap)
            }(w, n)) : n.isMeshPhongMaterial ? (Me(w, n), n.isMeshToonMaterial ? function(e, t) {
                _e(e, t), t.gradientMap && (e.gradientMap.value = t.gradientMap)
            }(w, n) : _e(w, n)) : n.isMeshStandardMaterial ? (Me(w, n), n.isMeshPhysicalMaterial ? function(e, t) {
                Se(e, t), e.reflectivity.value = t.reflectivity, e.clearcoat.value = t.clearcoat, e.clearcoatRoughness.value = t.clearcoatRoughness, t.sheen && e.sheen.value.copy(t.sheen);
                t.clearcoatNormalMap && (e.clearcoatNormalScale.value.copy(t.clearcoatNormalScale), e.clearcoatNormalMap.value = t.clearcoatNormalMap, t.side === y && e.clearcoatNormalScale.value.negate());
                e.transparency.value = t.transparency
            }(w, n) : Se(w, n)) : n.isMeshMatcapMaterial ? (Me(w, n), function(e, t) {
                t.matcap && (e.matcap.value = t.matcap);
                t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, t.side === y && (e.bumpScale.value *= -1));
                t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), t.side === y && e.normalScale.value.negate());
                t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias)
            }(w, n)) : n.isMeshDepthMaterial ? (Me(w, n), function(e, t) {
                t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias)
            }(w, n)) : n.isMeshDistanceMaterial ? (Me(w, n), function(e, t) {
                t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias);
                e.referencePosition.value.copy(t.referencePosition), e.nearDistance.value = t.nearDistance, e.farDistance.value = t.farDistance
            }(w, n)) : n.isMeshNormalMaterial ? (Me(w, n), function(e, t) {
                t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, t.side === y && (e.bumpScale.value *= -1));
                t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), t.side === y && e.normalScale.value.negate());
                t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias)
            }(w, n)) : n.isLineBasicMaterial ? (function(e, t) {
                e.diffuse.value.copy(t.color), e.opacity.value = t.opacity
            }(w, n), n.isLineDashedMaterial && function(e, t) {
                e.dashSize.value = t.dashSize, e.totalSize.value = t.dashSize + t.gapSize, e.scale.value = t.scale
            }(w, n)) : n.isPointsMaterial ? function(e, t) {
                e.diffuse.value.copy(t.color), e.opacity.value = t.opacity, e.size.value = t.size * q, e.scale.value = .5 * X, e.map.value = t.map, null !== t.map && (!0 === t.map.matrixAutoUpdate && t.map.updateMatrix(), e.uvTransform.value.copy(t.map.matrix))
            }(w, n) : n.isSpriteMaterial ? function(e, t) {
                e.diffuse.value.copy(t.color), e.opacity.value = t.opacity, e.rotation.value = t.rotation, e.map.value = t.map, null !== t.map && (!0 === t.map.matrixAutoUpdate && t.map.updateMatrix(), e.uvTransform.value.copy(t.map.matrix))
            }(w, n) : n.isShadowMaterial && (w.color.value.copy(n.color), w.opacity.value = n.opacity), void 0 !== w.ltc_1 && (w.ltc_1.value = io.LTC_1), void 0 !== w.ltc_2 && (w.ltc_2.value = io.LTC_2), ga.upload(h, i.uniformsList, w, b)), n.isShaderMaterial && !0 === n.uniformsNeedUpdate && (ga.upload(h, i.uniformsList, w, b), n.uniformsNeedUpdate = !1), n.isSpriteMaterial && g.setValue(h, "center", r.center), v.numMultiviewViews > 0 ? ue.updateObjectMatricesUniforms(r, e, g) : (g.setValue(h, "modelViewMatrix", r.modelViewMatrix), g.setValue(h, "normalMatrix", r.normalMatrix)), g.setValue(h, "modelMatrix", r.matrixWorld), v
        }

        function Me(e, t) {
            var n;
            e.opacity.value = t.opacity, t.color && e.diffuse.value.copy(t.color), t.emissive && e.emissive.value.copy(t.emissive).multiplyScalar(t.emissiveIntensity), t.map && (e.map.value = t.map), t.alphaMap && (e.alphaMap.value = t.alphaMap), t.specularMap && (e.specularMap.value = t.specularMap), t.envMap && (e.envMap.value = t.envMap, e.flipEnvMap.value = t.envMap.isCubeTexture ? -1 : 1, e.reflectivity.value = t.reflectivity, e.refractionRatio.value = t.refractionRatio, e.maxMipLevel.value = x.get(t.envMap).__maxMipLevel), t.lightMap && (e.lightMap.value = t.lightMap, e.lightMapIntensity.value = t.lightMapIntensity), t.aoMap && (e.aoMap.value = t.aoMap, e.aoMapIntensity.value = t.aoMapIntensity), t.map ? n = t.map : t.specularMap ? n = t.specularMap : t.displacementMap ? n = t.displacementMap : t.normalMap ? n = t.normalMap : t.bumpMap ? n = t.bumpMap : t.roughnessMap ? n = t.roughnessMap : t.metalnessMap ? n = t.metalnessMap : t.alphaMap ? n = t.alphaMap : t.emissiveMap && (n = t.emissiveMap), void 0 !== n && (n.isWebGLRenderTarget && (n = n.texture), !0 === n.matrixAutoUpdate && n.updateMatrix(), e.uvTransform.value.copy(n.matrix))
        }

        function _e(e, t) {
            e.specular.value.copy(t.specular), e.shininess.value = Math.max(t.shininess, 1e-4), t.emissiveMap && (e.emissiveMap.value = t.emissiveMap), t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, t.side === y && (e.bumpScale.value *= -1)), t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), t.side === y && e.normalScale.value.negate()), t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias)
        }

        function Se(e, t) {
            e.roughness.value = t.roughness, e.metalness.value = t.metalness, t.roughnessMap && (e.roughnessMap.value = t.roughnessMap), t.metalnessMap && (e.metalnessMap.value = t.metalnessMap), t.emissiveMap && (e.emissiveMap.value = t.emissiveMap), t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, t.side === y && (e.bumpScale.value *= -1)), t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), t.side === y && e.normalScale.value.negate()), t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias), t.envMap && (e.envMapIntensity.value = t.envMapIntensity)
        }
        me.setAnimationLoop((function(e) {
            ce.isPresenting() || pe && pe(e)
        })), "undefined" != typeof window && me.setContext(window), this.setAnimationLoop = function(e) {
            pe = e, ce.setAnimationLoop(e), me.start()
        }, this.render = function(e, t) {
            var n, r;
            if (void 0 !== arguments[2] && (console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."), n = arguments[2]), void 0 !== arguments[3] && (console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."), r = arguments[3]), t && t.isCamera) {
                if (!O) {
                    N.geometry = null, N.program = null, N.wireframe = !1, G = -1, B = null, !0 === e.autoUpdate && e.updateMatrixWorld(), null === t.parent && t.updateMatrixWorld(), ce.enabled && (t = ce.getCamera(t)), (d = T.get(e, t)).init(), e.onBeforeRender(R, e, t, n || k), ne.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), Q.setFromMatrix(ne), te = this.localClippingEnabled, ee = $.init(this.clippingPlanes, te, t), (f = P.get(e, t)).init(), ye(e, t, 0, R.sortObjects), !0 === R.sortObjects && f.sort(), ee && $.beginShadows();
                    var i = d.state.shadowsArray;
                    le.render(i, e, t), d.setupLights(t), ee && $.endShadows(), this.info.autoReset && this.info.reset(), void 0 !== n && this.setRenderTarget(n), ce.enabled && ue.isAvailable() && ue.attachCamera(t), E.render(f, e, t, r);
                    var o = f.opaque,
                        a = f.transparent;
                    if (e.overrideMaterial) {
                        var s = e.overrideMaterial;
                        o.length && ge(o, e, t, s), a.length && ge(a, e, t, s)
                    } else o.length && ge(o, e, t), a.length && ge(a, e, t);
                    e.onAfterRender(R, e, t), null !== k && (b.updateRenderTargetMipmap(k), b.updateMultisampleRenderTarget(k)), m.buffers.depth.setTest(!0), m.buffers.depth.setMask(!0), m.buffers.color.setMask(!0), m.setPolygonOffset(!1), ce.enabled && (ue.isAvailable() && ue.detachCamera(t), ce.submitFrame()), f = null, d = null
                }
            } else console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.")
        }, this.setFramebuffer = function(e) {
            j !== e && h.bindFramebuffer(36160, e), j = e
        }, this.getActiveCubeFace = function() {
            return I
        }, this.getActiveMipmapLevel = function() {
            return D
        }, this.getRenderTarget = function() {
            return k
        }, this.setRenderTarget = function(e, t, n) {
            k = e, I = t, D = n, e && void 0 === x.get(e).__webglFramebuffer && b.setupRenderTarget(e);
            var r = j,
                i = !1;
            if (e) {
                var o = x.get(e).__webglFramebuffer;
                e.isWebGLRenderTargetCube ? (r = o[t || 0], i = !0) : r = e.isWebGLMultisampleRenderTarget ? x.get(e).__webglMultisampledFramebuffer : o, H.copy(e.viewport), V.copy(e.scissor), W = e.scissorTest
            } else H.copy(K).multiplyScalar(q).floor(), V.copy(Z).multiplyScalar(q).floor(), W = J;
            if (F !== r && (h.bindFramebuffer(36160, r), F = r), m.viewport(H), m.scissor(V), m.setScissorTest(W), i) {
                var a = x.get(e.texture);
                h.framebufferTexture2D(36160, 36064, 34069 + (t || 0), a.__webglTexture, n || 0)
            }
        }, this.readRenderTargetPixels = function(e, t, n, r, i, o, a) {
            if (e && e.isWebGLRenderTarget) {
                var s = x.get(e).__webglFramebuffer;
                if (e.isWebGLRenderTargetCube && void 0 !== a && (s = s[a]), s) {
                    var c = !1;
                    s !== F && (h.bindFramebuffer(36160, s), c = !0);
                    try {
                        var u = e.texture,
                            l = u.format,
                            f = u.type;
                        if (l !== Ve && C.convert(l) !== h.getParameter(35739)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                        if (!(f === Ae || C.convert(f) === h.getParameter(35738) || f === De && (p.isWebGL2 || v.get("OES_texture_float") || v.get("WEBGL_color_buffer_float")) || f === ke && (p.isWebGL2 ? v.get("EXT_color_buffer_float") : v.get("EXT_color_buffer_half_float")))) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                        36053 === h.checkFramebufferStatus(36160) ? t >= 0 && t <= e.width - r && n >= 0 && n <= e.height - i && h.readPixels(t, n, r, i, C.convert(l), C.convert(f), o) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")
                    } finally {
                        c && h.bindFramebuffer(36160, F)
                    }
                }
            } else console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.")
        }, this.copyFramebufferToTexture = function(e, t, n) {
            var r = t.image.width,
                i = t.image.height,
                o = C.convert(t.format);
            b.setTexture2D(t, 0), h.copyTexImage2D(3553, n || 0, o, e.x, e.y, r, i, 0)
        }, this.copyTextureToTexture = function(e, t, n, r) {
            var i = t.image.width,
                o = t.image.height,
                a = C.convert(n.format),
                s = C.convert(n.type);
            b.setTexture2D(n, 0), t.isDataTexture ? h.texSubImage2D(3553, r || 0, e.x, e.y, i, o, a, s, t.image.data) : h.texSubImage2D(3553, r || 0, e.x, e.y, a, s, t.image)
        }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
            detail: this
        }))
    }

    function hs(e, t) {
        this.name = "", this.color = new Dr(e), this.density = void 0 !== t ? t : 25e-5
    }

    function vs(e, t, n) {
        this.name = "", this.color = new Dr(e), this.near = void 0 !== t ? t : 1, this.far = void 0 !== n ? n : 1e3
    }

    function ps(e, t) {
        this.array = e, this.stride = t, this.count = void 0 !== e ? e.length / t : 0, this.dynamic = !1, this.updateRange = {
            offset: 0,
            count: -1
        }, this.version = 0
    }

    function ms(e, t, n, r) {
        this.data = e, this.itemSize = t, this.offset = n, this.normalized = !0 === r
    }

    function ys(e) {
        Ur.call(this), this.type = "SpriteMaterial", this.color = new Dr(16777215), this.map = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.setValues(e)
    }
    Object.assign(ls.prototype, sn.prototype), Object.assign(fs.prototype, sn.prototype), Object.assign(hs.prototype, {
        isFogExp2: !0,
        clone: function() {
            return new hs(this.color, this.density)
        },
        toJSON: function() {
            return {
                type: "FogExp2",
                color: this.color.getHex(),
                density: this.density
            }
        }
    }), Object.assign(vs.prototype, {
        isFog: !0,
        clone: function() {
            return new vs(this.color, this.near, this.far)
        },
        toJSON: function() {
            return {
                type: "Fog",
                color: this.color.getHex(),
                near: this.near,
                far: this.far
            }
        }
    }), Object.defineProperty(ps.prototype, "needsUpdate", {
        set: function(e) {
            !0 === e && this.version++
        }
    }), Object.assign(ps.prototype, {
        isInterleavedBuffer: !0,
        onUploadCallback: function() {},
        setDynamic: function(e) {
            return this.dynamic = e, this
        },
        copy: function(e) {
            return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.dynamic = e.dynamic, this
        },
        copyAt: function(e, t, n) {
            e *= this.stride, n *= t.stride;
            for (var r = 0, i = this.stride; r < i; r++) this.array[e + r] = t.array[n + r];
            return this
        },
        set: function(e, t) {
            return void 0 === t && (t = 0), this.array.set(e, t), this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        onUpload: function(e) {
            return this.onUploadCallback = e, this
        }
    }), Object.defineProperties(ms.prototype, {
        count: {
            get: function() {
                return this.data.count
            }
        },
        array: {
            get: function() {
                return this.data.array
            }
        }
    }), Object.assign(ms.prototype, {
        isInterleavedBufferAttribute: !0,
        setX: function(e, t) {
            return this.data.array[e * this.data.stride + this.offset] = t, this
        },
        setY: function(e, t) {
            return this.data.array[e * this.data.stride + this.offset + 1] = t, this
        },
        setZ: function(e, t) {
            return this.data.array[e * this.data.stride + this.offset + 2] = t, this
        },
        setW: function(e, t) {
            return this.data.array[e * this.data.stride + this.offset + 3] = t, this
        },
        getX: function(e) {
            return this.data.array[e * this.data.stride + this.offset]
        },
        getY: function(e) {
            return this.data.array[e * this.data.stride + this.offset + 1]
        },
        getZ: function(e) {
            return this.data.array[e * this.data.stride + this.offset + 2]
        },
        getW: function(e) {
            return this.data.array[e * this.data.stride + this.offset + 3]
        },
        setXY: function(e, t, n) {
            return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = n, this
        },
        setXYZ: function(e, t, n, r) {
            return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = r, this
        },
        setXYZW: function(e, t, n, r, i) {
            return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = r, this.data.array[e + 3] = i, this
        }
    }), ys.prototype = Object.create(Ur.prototype), ys.prototype.constructor = ys, ys.prototype.isSpriteMaterial = !0, ys.prototype.copy = function(e) {
        return Ur.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.rotation = e.rotation, this.sizeAttenuation = e.sizeAttenuation, this
    };
    var gs = new pn,
        xs = new pn,
        bs = new pn,
        ws = new fn,
        Ms = new fn,
        _s = new Rn,
        Ss = new pn,
        Ps = new pn,
        Ts = new pn,
        Es = new fn,
        zs = new fn,
        Ls = new fn;

    function As(e) {
        if (Zn.call(this), this.type = "Sprite", void 0 === as) {
            as = new ui;
            var t = new ps(new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]), 5);
            as.setIndex([0, 1, 2, 0, 2, 3]), as.addAttribute("position", new ms(t, 3, 0, !1)), as.addAttribute("uv", new ms(t, 2, 3, !1))
        }
        this.geometry = as, this.material = void 0 !== e ? e : new ys, this.center = new fn(.5, .5)
    }

    function Cs(e, t, n, r, i, o) {
        ws.subVectors(e, n).addScalar(.5).multiply(r), void 0 !== i ? (Ms.x = o * ws.x - i * ws.y, Ms.y = i * ws.x + o * ws.y) : Ms.copy(ws), e.copy(t), e.x += Ms.x, e.y += Ms.y, e.applyMatrix4(_s)
    }
    As.prototype = Object.assign(Object.create(Zn.prototype), {
        constructor: As,
        isSprite: !0,
        raycast: function(e, t) {
            null === e.camera && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), xs.setFromMatrixScale(this.matrixWorld), _s.copy(e.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld), bs.setFromMatrixPosition(this.modelViewMatrix), e.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && xs.multiplyScalar(-bs.z);
            var n, r, i = this.material.rotation;
            0 !== i && (r = Math.cos(i), n = Math.sin(i));
            var o = this.center;
            Cs(Ss.set(-.5, -.5, 0), bs, o, xs, n, r), Cs(Ps.set(.5, -.5, 0), bs, o, xs, n, r), Cs(Ts.set(.5, .5, 0), bs, o, xs, n, r), Es.set(0, 0), zs.set(1, 0), Ls.set(1, 1);
            var a = e.ray.intersectTriangle(Ss, Ps, Ts, !1, gs);
            if (null !== a || (Cs(Ps.set(-.5, .5, 0), bs, o, xs, n, r), zs.set(0, 1), null !== (a = e.ray.intersectTriangle(Ss, Ts, Ps, !1, gs)))) {
                var s = e.ray.origin.distanceTo(gs);
                s < e.near || s > e.far || t.push({
                    distance: s,
                    point: gs.clone(),
                    uv: Rr.getUV(gs, Ss, Ps, Ts, Es, zs, Ls, new fn),
                    face: null,
                    object: this
                })
            }
        },
        clone: function() {
            return new this.constructor(this.material).copy(this)
        },
        copy: function(e) {
            return Zn.prototype.copy.call(this, e), void 0 !== e.center && this.center.copy(e.center), this
        }
    });
    var Rs = new pn,
        Os = new pn;

    function js() {
        Zn.call(this), this.type = "LOD", Object.defineProperties(this, {
            levels: {
                enumerable: !0,
                value: []
            }
        }), this.autoUpdate = !0
    }

    function Is(e, t) {
        e && e.isGeometry && console.error("THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."), Ei.call(this, e, t), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new Rn, this.bindMatrixInverse = new Rn
    }
    js.prototype = Object.assign(Object.create(Zn.prototype), {
        constructor: js,
        isLOD: !0,
        copy: function(e) {
            Zn.prototype.copy.call(this, e, !1);
            for (var t = e.levels, n = 0, r = t.length; n < r; n++) {
                var i = t[n];
                this.addLevel(i.object.clone(), i.distance)
            }
            return this
        },
        addLevel: function(e, t) {
            void 0 === t && (t = 0), t = Math.abs(t);
            for (var n = this.levels, r = 0; r < n.length && !(t < n[r].distance); r++);
            return n.splice(r, 0, {
                distance: t,
                object: e
            }), this.add(e), this
        },
        getObjectForDistance: function(e) {
            for (var t = this.levels, n = 1, r = t.length; n < r && !(e < t[n].distance); n++);
            return t[n - 1].object
        },
        raycast: function(e, t) {
            Rs.setFromMatrixPosition(this.matrixWorld);
            var n = e.ray.origin.distanceTo(Rs);
            this.getObjectForDistance(n).raycast(e, t)
        },
        update: function(e) {
            var t = this.levels;
            if (t.length > 1) {
                Rs.setFromMatrixPosition(e.matrixWorld), Os.setFromMatrixPosition(this.matrixWorld);
                var n = Rs.distanceTo(Os);
                t[0].object.visible = !0;
                for (var r = 1, i = t.length; r < i && n >= t[r].distance; r++) t[r - 1].object.visible = !1, t[r].object.visible = !0;
                for (; r < i; r++) t[r].object.visible = !1
            }
        },
        toJSON: function(e) {
            var t = Zn.prototype.toJSON.call(this, e);
            t.object.levels = [];
            for (var n = this.levels, r = 0, i = n.length; r < i; r++) {
                var o = n[r];
                t.object.levels.push({
                    object: o.object.uuid,
                    distance: o.distance
                })
            }
            return t
        }
    }), Is.prototype = Object.assign(Object.create(Ei.prototype), {
        constructor: Is,
        isSkinnedMesh: !0,
        bind: function(e, t) {
            this.skeleton = e, void 0 === t && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.getInverse(t)
        },
        pose: function() {
            this.skeleton.pose()
        },
        normalizeSkinWeights: function() {
            for (var e = new Mn, t = this.geometry.attributes.skinWeight, n = 0, r = t.count; n < r; n++) {
                e.x = t.getX(n), e.y = t.getY(n), e.z = t.getZ(n), e.w = t.getW(n);
                var i = 1 / e.manhattanLength();
                i !== 1 / 0 ? e.multiplyScalar(i) : e.set(1, 0, 0, 0), t.setXYZW(n, e.x, e.y, e.z, e.w)
            }
        },
        updateMatrixWorld: function(e) {
            Ei.prototype.updateMatrixWorld.call(this, e), "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
        },
        clone: function() {
            return new this.constructor(this.geometry, this.material).copy(this)
        }
    });
    var Ds = new Rn,
        ks = new Rn;

    function Fs(e, t) {
        if (e = e || [], this.bones = e.slice(0), this.boneMatrices = new Float32Array(16 * this.bones.length), this.frame = -1, void 0 === t) this.calculateInverses();
        else if (this.bones.length === t.length) this.boneInverses = t.slice(0);
        else {
            console.warn("THREE.Skeleton boneInverses is the wrong length."), this.boneInverses = [];
            for (var n = 0, r = this.bones.length; n < r; n++) this.boneInverses.push(new Rn)
        }
    }

    function Gs() {
        Zn.call(this), this.type = "Bone"
    }

    function Ns(e, t, n) {
        Ei.call(this, e, t), this.instanceMatrix = new Vr(new Float32Array(16 * n), 16), this.count = n
    }

    function Bs(e) {
        Ur.call(this), this.type = "LineBasicMaterial", this.color = new Dr(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.setValues(e)
    }
    Object.assign(Fs.prototype, {
        calculateInverses: function() {
            this.boneInverses = [];
            for (var e = 0, t = this.bones.length; e < t; e++) {
                var n = new Rn;
                this.bones[e] && n.getInverse(this.bones[e].matrixWorld), this.boneInverses.push(n)
            }
        },
        pose: function() {
            var e, t, n;
            for (t = 0, n = this.bones.length; t < n; t++)(e = this.bones[t]) && e.matrixWorld.getInverse(this.boneInverses[t]);
            for (t = 0, n = this.bones.length; t < n; t++)(e = this.bones[t]) && (e.parent && e.parent.isBone ? (e.matrix.getInverse(e.parent.matrixWorld), e.matrix.multiply(e.matrixWorld)) : e.matrix.copy(e.matrixWorld), e.matrix.decompose(e.position, e.quaternion, e.scale))
        },
        update: function() {
            for (var e = this.bones, t = this.boneInverses, n = this.boneMatrices, r = this.boneTexture, i = 0, o = e.length; i < o; i++) {
                var a = e[i] ? e[i].matrixWorld : ks;
                Ds.multiplyMatrices(a, t[i]), Ds.toArray(n, 16 * i)
            }
            void 0 !== r && (r.needsUpdate = !0)
        },
        clone: function() {
            return new Fs(this.bones, this.boneInverses)
        },
        getBoneByName: function(e) {
            for (var t = 0, n = this.bones.length; t < n; t++) {
                var r = this.bones[t];
                if (r.name === e) return r
            }
        }
    }), Gs.prototype = Object.assign(Object.create(Zn.prototype), {
        constructor: Gs,
        isBone: !0
    }), Ns.prototype = Object.assign(Object.create(Ei.prototype), {
        constructor: Ns,
        isInstancedMesh: !0,
        raycast: function() {},
        setMatrixAt: function(e, t) {
            t.toArray(this.instanceMatrix.array, 16 * e)
        },
        updateMorphTargets: function() {}
    }), Bs.prototype = Object.create(Ur.prototype), Bs.prototype.constructor = Bs, Bs.prototype.isLineBasicMaterial = !0, Bs.prototype.copy = function(e) {
        return Ur.prototype.copy.call(this, e), this.color.copy(e.color), this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this
    };
    var Us = new pn,
        Hs = new pn,
        Vs = new Rn,
        Ws = new wr,
        Ys = new hr;

    function Xs(e, t, n) {
        1 === n && console.error("THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead."), Zn.call(this), this.type = "Line", this.geometry = void 0 !== e ? e : new ui, this.material = void 0 !== t ? t : new Bs({
            color: 16777215 * Math.random()
        })
    }
    Xs.prototype = Object.assign(Object.create(Zn.prototype), {
        constructor: Xs,
        isLine: !0,
        computeLineDistances: function() {
            var e = this.geometry;
            if (e.isBufferGeometry)
                if (null === e.index) {
                    for (var t = e.attributes.position, n = [0], r = 1, i = t.count; r < i; r++) Us.fromBufferAttribute(t, r - 1), Hs.fromBufferAttribute(t, r), n[r] = n[r - 1], n[r] += Us.distanceTo(Hs);
                    e.addAttribute("lineDistance", new Qr(n, 1))
                } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
            else if (e.isGeometry) {
                var o = e.vertices;
                (n = e.lineDistances)[0] = 0;
                for (r = 1, i = o.length; r < i; r++) n[r] = n[r - 1], n[r] += o[r - 1].distanceTo(o[r])
            }
            return this
        },
        raycast: function(e, t) {
            var n = e.linePrecision,
                r = this.geometry,
                i = this.matrixWorld;
            if (null === r.boundingSphere && r.computeBoundingSphere(), Ys.copy(r.boundingSphere), Ys.applyMatrix4(i), Ys.radius += n, !1 !== e.ray.intersectsSphere(Ys)) {
                Vs.getInverse(i), Ws.copy(e.ray).applyMatrix4(Vs);
                var o = n / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                    a = o * o,
                    s = new pn,
                    c = new pn,
                    u = new pn,
                    l = new pn,
                    f = this && this.isLineSegments ? 2 : 1;
                if (r.isBufferGeometry) {
                    var d = r.index,
                        h = r.attributes.position.array;
                    if (null !== d)
                        for (var v = d.array, p = 0, m = v.length - 1; p < m; p += f) {
                            var y = v[p],
                                g = v[p + 1];
                            if (s.fromArray(h, 3 * y), c.fromArray(h, 3 * g), !(Ws.distanceSqToSegment(s, c, l, u) > a)) l.applyMatrix4(this.matrixWorld), (w = e.ray.origin.distanceTo(l)) < e.near || w > e.far || t.push({
                                distance: w,
                                point: u.clone().applyMatrix4(this.matrixWorld),
                                index: p,
                                face: null,
                                faceIndex: null,
                                object: this
                            })
                        } else
                            for (p = 0, m = h.length / 3 - 1; p < m; p += f) {
                                if (s.fromArray(h, 3 * p), c.fromArray(h, 3 * p + 3), !(Ws.distanceSqToSegment(s, c, l, u) > a)) l.applyMatrix4(this.matrixWorld), (w = e.ray.origin.distanceTo(l)) < e.near || w > e.far || t.push({
                                    distance: w,
                                    point: u.clone().applyMatrix4(this.matrixWorld),
                                    index: p,
                                    face: null,
                                    faceIndex: null,
                                    object: this
                                })
                            }
                } else if (r.isGeometry) {
                    var x = r.vertices,
                        b = x.length;
                    for (p = 0; p < b - 1; p += f) {
                        var w;
                        if (!(Ws.distanceSqToSegment(x[p], x[p + 1], l, u) > a)) l.applyMatrix4(this.matrixWorld), (w = e.ray.origin.distanceTo(l)) < e.near || w > e.far || t.push({
                            distance: w,
                            point: u.clone().applyMatrix4(this.matrixWorld),
                            index: p,
                            face: null,
                            faceIndex: null,
                            object: this
                        })
                    }
                }
            }
        },
        clone: function() {
            return new this.constructor(this.geometry, this.material).copy(this)
        }
    });
    var qs = new pn,
        Ks = new pn;

    function Zs(e, t) {
        Xs.call(this, e, t), this.type = "LineSegments"
    }

    function Js(e, t) {
        Xs.call(this, e, t), this.type = "LineLoop"
    }

    function Qs(e) {
        Ur.call(this), this.type = "PointsMaterial", this.color = new Dr(16777215), this.map = null, this.size = 1, this.sizeAttenuation = !0, this.morphTargets = !1, this.setValues(e)
    }
    Zs.prototype = Object.assign(Object.create(Xs.prototype), {
        constructor: Zs,
        isLineSegments: !0,
        computeLineDistances: function() {
            var e = this.geometry;
            if (e.isBufferGeometry)
                if (null === e.index) {
                    for (var t = e.attributes.position, n = [], r = 0, i = t.count; r < i; r += 2) qs.fromBufferAttribute(t, r), Ks.fromBufferAttribute(t, r + 1), n[r] = 0 === r ? 0 : n[r - 1], n[r + 1] = n[r] + qs.distanceTo(Ks);
                    e.addAttribute("lineDistance", new Qr(n, 1))
                } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
            else if (e.isGeometry) {
                var o = e.vertices;
                for (n = e.lineDistances, r = 0, i = o.length; r < i; r += 2) qs.copy(o[r]), Ks.copy(o[r + 1]), n[r] = 0 === r ? 0 : n[r - 1], n[r + 1] = n[r] + qs.distanceTo(Ks)
            }
            return this
        }
    }), Js.prototype = Object.assign(Object.create(Xs.prototype), {
        constructor: Js,
        isLineLoop: !0
    }), Qs.prototype = Object.create(Ur.prototype), Qs.prototype.constructor = Qs, Qs.prototype.isPointsMaterial = !0, Qs.prototype.copy = function(e) {
        return Ur.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.morphTargets = e.morphTargets, this
    };
    var $s = new Rn,
        ec = new wr,
        tc = new hr,
        nc = new pn;

    function rc(e, t) {
        Zn.call(this), this.type = "Points", this.geometry = void 0 !== e ? e : new ui, this.material = void 0 !== t ? t : new Qs({
            color: 16777215 * Math.random()
        }), this.updateMorphTargets()
    }

    function ic(e, t, n, r, i, o, a) {
        var s = ec.distanceSqToPoint(e);
        if (s < n) {
            var c = new pn;
            ec.closestPointToPoint(e, c), c.applyMatrix4(r);
            var u = i.ray.origin.distanceTo(c);
            if (u < i.near || u > i.far) return;
            o.push({
                distance: u,
                distanceToRay: Math.sqrt(s),
                point: c,
                index: t,
                face: null,
                object: a
            })
        }
    }

    function oc(e, t, n, r, i, o, a, s, c) {
        wn.call(this, e, t, n, r, i, o, a, s, c), this.format = void 0 !== a ? a : He, this.minFilter = void 0 !== o ? o : Pe, this.magFilter = void 0 !== i ? i : Pe, this.generateMipmaps = !1
    }

    function ac(e, t, n, r, i, o, a, s, c, u, l, f) {
        wn.call(this, null, o, a, s, c, u, r, i, l, f), this.image = {
            width: t,
            height: n
        }, this.mipmaps = e, this.flipY = !1, this.generateMipmaps = !1
    }

    function sc(e, t, n, r, i, o, a, s, c) {
        wn.call(this, e, t, n, r, i, o, a, s, c), this.needsUpdate = !0
    }

    function cc(e, t, n, r, i, o, a, s, c, u) {
        if ((u = void 0 !== u ? u : qe) !== qe && u !== Ke) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
        void 0 === n && u === qe && (n = Oe), void 0 === n && u === Ke && (n = Be), wn.call(this, null, r, i, o, a, s, u, n, c), this.image = {
            width: e,
            height: t
        }, this.magFilter = void 0 !== a ? a : be, this.minFilter = void 0 !== s ? s : be, this.flipY = !1, this.generateMipmaps = !1
    }

    function uc(e) {
        ui.call(this), this.type = "WireframeGeometry";
        var t, n, r, i, o, a, s, c, u, l, f = [],
            d = [0, 0],
            h = {},
            v = ["a", "b", "c"];
        if (e && e.isGeometry) {
            var p = e.faces;
            for (t = 0, r = p.length; t < r; t++) {
                var m = p[t];
                for (n = 0; n < 3; n++) s = m[v[n]], c = m[v[(n + 1) % 3]], d[0] = Math.min(s, c), d[1] = Math.max(s, c), void 0 === h[u = d[0] + "," + d[1]] && (h[u] = {
                    index1: d[0],
                    index2: d[1]
                })
            }
            for (u in h) a = h[u], l = e.vertices[a.index1], f.push(l.x, l.y, l.z), l = e.vertices[a.index2], f.push(l.x, l.y, l.z)
        } else if (e && e.isBufferGeometry) {
            var y, g, x, b, w, M, _;
            if (l = new pn, null !== e.index) {
                for (y = e.attributes.position, g = e.index, 0 === (x = e.groups).length && (x = [{
                        start: 0,
                        count: g.count,
                        materialIndex: 0
                    }]), i = 0, o = x.length; i < o; ++i)
                    for (t = w = (b = x[i]).start, r = w + b.count; t < r; t += 3)
                        for (n = 0; n < 3; n++) s = g.getX(t + n), c = g.getX(t + (n + 1) % 3), d[0] = Math.min(s, c), d[1] = Math.max(s, c), void 0 === h[u = d[0] + "," + d[1]] && (h[u] = {
                            index1: d[0],
                            index2: d[1]
                        });
                for (u in h) a = h[u], l.fromBufferAttribute(y, a.index1), f.push(l.x, l.y, l.z), l.fromBufferAttribute(y, a.index2), f.push(l.x, l.y, l.z)
            } else
                for (t = 0, r = (y = e.attributes.position).count / 3; t < r; t++)
                    for (n = 0; n < 3; n++) M = 3 * t + n, l.fromBufferAttribute(y, M), f.push(l.x, l.y, l.z), _ = 3 * t + (n + 1) % 3, l.fromBufferAttribute(y, _), f.push(l.x, l.y, l.z)
        }
        this.addAttribute("position", new Qr(f, 3))
    }

    function lc(e, t, n) {
        ji.call(this), this.type = "ParametricGeometry", this.parameters = {
            func: e,
            slices: t,
            stacks: n
        }, this.fromBufferGeometry(new fc(e, t, n)), this.mergeVertices()
    }

    function fc(e, t, n) {
        ui.call(this), this.type = "ParametricBufferGeometry", this.parameters = {
            func: e,
            slices: t,
            stacks: n
        };
        var r, i, o = [],
            a = [],
            s = [],
            c = [],
            u = new pn,
            l = new pn,
            f = new pn,
            d = new pn,
            h = new pn;
        e.length < 3 && console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");
        var v = t + 1;
        for (r = 0; r <= n; r++) {
            var p = r / n;
            for (i = 0; i <= t; i++) {
                var m = i / t;
                e(m, p, l), a.push(l.x, l.y, l.z), m - 1e-5 >= 0 ? (e(m - 1e-5, p, f), d.subVectors(l, f)) : (e(m + 1e-5, p, f), d.subVectors(f, l)), p - 1e-5 >= 0 ? (e(m, p - 1e-5, f), h.subVectors(l, f)) : (e(m, p + 1e-5, f), h.subVectors(f, l)), u.crossVectors(d, h).normalize(), s.push(u.x, u.y, u.z), c.push(m, p)
            }
        }
        for (r = 0; r < n; r++)
            for (i = 0; i < t; i++) {
                var y = r * v + i,
                    g = r * v + i + 1,
                    x = (r + 1) * v + i + 1,
                    b = (r + 1) * v + i;
                o.push(y, g, b), o.push(g, x, b)
            }
        this.setIndex(o), this.addAttribute("position", new Qr(a, 3)), this.addAttribute("normal", new Qr(s, 3)), this.addAttribute("uv", new Qr(c, 2))
    }

    function dc(e, t, n, r) {
        ji.call(this), this.type = "PolyhedronGeometry", this.parameters = {
            vertices: e,
            indices: t,
            radius: n,
            detail: r
        }, this.fromBufferGeometry(new hc(e, t, n, r)), this.mergeVertices()
    }

    function hc(e, t, n, r) {
        ui.call(this), this.type = "PolyhedronBufferGeometry", this.parameters = {
            vertices: e,
            indices: t,
            radius: n,
            detail: r
        }, n = n || 1;
        var i = [],
            o = [];

        function a(e, t, n, r) {
            var i, o, a = Math.pow(2, r),
                c = [];
            for (i = 0; i <= a; i++) {
                c[i] = [];
                var u = e.clone().lerp(n, i / a),
                    l = t.clone().lerp(n, i / a),
                    f = a - i;
                for (o = 0; o <= f; o++) c[i][o] = 0 === o && i === a ? u : u.clone().lerp(l, o / f)
            }
            for (i = 0; i < a; i++)
                for (o = 0; o < 2 * (a - i) - 1; o++) {
                    var d = Math.floor(o / 2);
                    o % 2 == 0 ? (s(c[i][d + 1]), s(c[i + 1][d]), s(c[i][d])) : (s(c[i][d + 1]), s(c[i + 1][d + 1]), s(c[i + 1][d]))
                }
        }

        function s(e) {
            i.push(e.x, e.y, e.z)
        }

        function c(t, n) {
            var r = 3 * t;
            n.x = e[r + 0], n.y = e[r + 1], n.z = e[r + 2]
        }

        function u(e, t, n, r) {
            r < 0 && 1 === e.x && (o[t] = e.x - 1), 0 === n.x && 0 === n.z && (o[t] = r / 2 / Math.PI + .5)
        }

        function l(e) {
            return Math.atan2(e.z, -e.x)
        }! function(e) {
            for (var n = new pn, r = new pn, i = new pn, o = 0; o < t.length; o += 3) c(t[o + 0], n), c(t[o + 1], r), c(t[o + 2], i), a(n, r, i, e)
        }(r = r || 0),
        function(e) {
            for (var t = new pn, n = 0; n < i.length; n += 3) t.x = i[n + 0], t.y = i[n + 1], t.z = i[n + 2], t.normalize().multiplyScalar(e), i[n + 0] = t.x, i[n + 1] = t.y, i[n + 2] = t.z
        }(n),
        function() {
            for (var e = new pn, t = 0; t < i.length; t += 3) {
                e.x = i[t + 0], e.y = i[t + 1], e.z = i[t + 2];
                var n = l(e) / 2 / Math.PI + .5,
                    r = (a = e, Math.atan2(-a.y, Math.sqrt(a.x * a.x + a.z * a.z)) / Math.PI + .5);
                o.push(n, 1 - r)
            }
            var a;
            (function() {
                for (var e = new pn, t = new pn, n = new pn, r = new pn, a = new fn, s = new fn, c = new fn, f = 0, d = 0; f < i.length; f += 9, d += 6) {
                    e.set(i[f + 0], i[f + 1], i[f + 2]), t.set(i[f + 3], i[f + 4], i[f + 5]), n.set(i[f + 6], i[f + 7], i[f + 8]), a.set(o[d + 0], o[d + 1]), s.set(o[d + 2], o[d + 3]), c.set(o[d + 4], o[d + 5]), r.copy(e).add(t).add(n).divideScalar(3);
                    var h = l(r);
                    u(a, d + 0, e, h), u(s, d + 2, t, h), u(c, d + 4, n, h)
                }
            })(),
            function() {
                for (var e = 0; e < o.length; e += 6) {
                    var t = o[e + 0],
                        n = o[e + 2],
                        r = o[e + 4],
                        i = Math.max(t, n, r),
                        a = Math.min(t, n, r);
                    i > .9 && a < .1 && (t < .2 && (o[e + 0] += 1), n < .2 && (o[e + 2] += 1), r < .2 && (o[e + 4] += 1))
                }
            }()
        }(), this.addAttribute("position", new Qr(i, 3)), this.addAttribute("normal", new Qr(i.slice(), 3)), this.addAttribute("uv", new Qr(o, 2)), 0 === r ? this.computeVertexNormals() : this.normalizeNormals()
    }

    function vc(e, t) {
        ji.call(this), this.type = "TetrahedronGeometry", this.parameters = {
            radius: e,
            detail: t
        }, this.fromBufferGeometry(new pc(e, t)), this.mergeVertices()
    }

    function pc(e, t) {
        hc.call(this, [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], e, t), this.type = "TetrahedronBufferGeometry", this.parameters = {
            radius: e,
            detail: t
        }
    }

    function mc(e, t) {
        ji.call(this), this.type = "OctahedronGeometry", this.parameters = {
            radius: e,
            detail: t
        }, this.fromBufferGeometry(new yc(e, t)), this.mergeVertices()
    }

    function yc(e, t) {
        hc.call(this, [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], e, t), this.type = "OctahedronBufferGeometry", this.parameters = {
            radius: e,
            detail: t
        }
    }

    function gc(e, t) {
        ji.call(this), this.type = "IcosahedronGeometry", this.parameters = {
            radius: e,
            detail: t
        }, this.fromBufferGeometry(new xc(e, t)), this.mergeVertices()
    }

    function xc(e, t) {
        var n = (1 + Math.sqrt(5)) / 2,
            r = [-1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, 0, 0, -1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, n, 0, -1, n, 0, 1, -n, 0, -1, -n, 0, 1];
        hc.call(this, r, [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], e, t), this.type = "IcosahedronBufferGeometry", this.parameters = {
            radius: e,
            detail: t
        }
    }

    function bc(e, t) {
        ji.call(this), this.type = "DodecahedronGeometry", this.parameters = {
            radius: e,
            detail: t
        }, this.fromBufferGeometry(new wc(e, t)), this.mergeVertices()
    }

    function wc(e, t) {
        var n = (1 + Math.sqrt(5)) / 2,
            r = 1 / n,
            i = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -r, -n, 0, -r, n, 0, r, -n, 0, r, n, -r, -n, 0, -r, n, 0, r, -n, 0, r, n, 0, -n, 0, -r, n, 0, -r, -n, 0, r, n, 0, r];
        hc.call(this, i, [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], e, t), this.type = "DodecahedronBufferGeometry", this.parameters = {
            radius: e,
            detail: t
        }
    }

    function Mc(e, t, n, r, i, o) {
        ji.call(this), this.type = "TubeGeometry", this.parameters = {
            path: e,
            tubularSegments: t,
            radius: n,
            radialSegments: r,
            closed: i
        }, void 0 !== o && console.warn("THREE.TubeGeometry: taper has been removed.");
        var a = new _c(e, t, n, r, i);
        this.tangents = a.tangents, this.normals = a.normals, this.binormals = a.binormals, this.fromBufferGeometry(a), this.mergeVertices()
    }

    function _c(e, t, n, r, i) {
        ui.call(this), this.type = "TubeBufferGeometry", this.parameters = {
            path: e,
            tubularSegments: t,
            radius: n,
            radialSegments: r,
            closed: i
        }, t = t || 64, n = n || 1, r = r || 8, i = i || !1;
        var o = e.computeFrenetFrames(t, i);
        this.tangents = o.tangents, this.normals = o.normals, this.binormals = o.binormals;
        var a, s, c = new pn,
            u = new pn,
            l = new fn,
            f = new pn,
            d = [],
            h = [],
            v = [],
            p = [];

        function m(i) {
            f = e.getPointAt(i / t, f);
            var a = o.normals[i],
                l = o.binormals[i];
            for (s = 0; s <= r; s++) {
                var v = s / r * Math.PI * 2,
                    p = Math.sin(v),
                    m = -Math.cos(v);
                u.x = m * a.x + p * l.x, u.y = m * a.y + p * l.y, u.z = m * a.z + p * l.z, u.normalize(), h.push(u.x, u.y, u.z), c.x = f.x + n * u.x, c.y = f.y + n * u.y, c.z = f.z + n * u.z, d.push(c.x, c.y, c.z)
            }
        }! function() {
            for (a = 0; a < t; a++) m(a);
            m(!1 === i ? t : 0),
                function() {
                    for (a = 0; a <= t; a++)
                        for (s = 0; s <= r; s++) l.x = a / t, l.y = s / r, v.push(l.x, l.y)
                }(),
                function() {
                    for (s = 1; s <= t; s++)
                        for (a = 1; a <= r; a++) {
                            var e = (r + 1) * (s - 1) + (a - 1),
                                n = (r + 1) * s + (a - 1),
                                i = (r + 1) * s + a,
                                o = (r + 1) * (s - 1) + a;
                            p.push(e, n, o), p.push(n, i, o)
                        }
                }()
        }(), this.setIndex(p), this.addAttribute("position", new Qr(d, 3)), this.addAttribute("normal", new Qr(h, 3)), this.addAttribute("uv", new Qr(v, 2))
    }

    function Sc(e, t, n, r, i, o, a) {
        ji.call(this), this.type = "TorusKnotGeometry", this.parameters = {
            radius: e,
            tube: t,
            tubularSegments: n,
            radialSegments: r,
            p: i,
            q: o
        }, void 0 !== a && console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."), this.fromBufferGeometry(new Pc(e, t, n, r, i, o)), this.mergeVertices()
    }

    function Pc(e, t, n, r, i, o) {
        ui.call(this), this.type = "TorusKnotBufferGeometry", this.parameters = {
            radius: e,
            tube: t,
            tubularSegments: n,
            radialSegments: r,
            p: i,
            q: o
        }, e = e || 1, t = t || .4, n = Math.floor(n) || 64, r = Math.floor(r) || 8, i = i || 2, o = o || 3;
        var a, s, c = [],
            u = [],
            l = [],
            f = [],
            d = new pn,
            h = new pn,
            v = new pn,
            p = new pn,
            m = new pn,
            y = new pn,
            g = new pn;
        for (a = 0; a <= n; ++a) {
            var x = a / n * i * Math.PI * 2;
            for (E(x, i, o, e, v), E(x + .01, i, o, e, p), y.subVectors(p, v), g.addVectors(p, v), m.crossVectors(y, g), g.crossVectors(m, y), m.normalize(), g.normalize(), s = 0; s <= r; ++s) {
                var b = s / r * Math.PI * 2,
                    w = -t * Math.cos(b),
                    M = t * Math.sin(b);
                d.x = v.x + (w * g.x + M * m.x), d.y = v.y + (w * g.y + M * m.y), d.z = v.z + (w * g.z + M * m.z), u.push(d.x, d.y, d.z), h.subVectors(d, v).normalize(), l.push(h.x, h.y, h.z), f.push(a / n), f.push(s / r)
            }
        }
        for (s = 1; s <= n; s++)
            for (a = 1; a <= r; a++) {
                var _ = (r + 1) * (s - 1) + (a - 1),
                    S = (r + 1) * s + (a - 1),
                    P = (r + 1) * s + a,
                    T = (r + 1) * (s - 1) + a;
                c.push(_, S, T), c.push(S, P, T)
            }

        function E(e, t, n, r, i) {
            var o = Math.cos(e),
                a = Math.sin(e),
                s = n / t * e,
                c = Math.cos(s);
            i.x = r * (2 + c) * .5 * o, i.y = r * (2 + c) * a * .5, i.z = r * Math.sin(s) * .5
        }
        this.setIndex(c), this.addAttribute("position", new Qr(u, 3)), this.addAttribute("normal", new Qr(l, 3)), this.addAttribute("uv", new Qr(f, 2))
    }

    function Tc(e, t, n, r, i) {
        ji.call(this), this.type = "TorusGeometry", this.parameters = {
            radius: e,
            tube: t,
            radialSegments: n,
            tubularSegments: r,
            arc: i
        }, this.fromBufferGeometry(new Ec(e, t, n, r, i)), this.mergeVertices()
    }

    function Ec(e, t, n, r, i) {
        ui.call(this), this.type = "TorusBufferGeometry", this.parameters = {
            radius: e,
            tube: t,
            radialSegments: n,
            tubularSegments: r,
            arc: i
        }, e = e || 1, t = t || .4, n = Math.floor(n) || 8, r = Math.floor(r) || 6, i = i || 2 * Math.PI;
        var o, a, s = [],
            c = [],
            u = [],
            l = [],
            f = new pn,
            d = new pn,
            h = new pn;
        for (o = 0; o <= n; o++)
            for (a = 0; a <= r; a++) {
                var v = a / r * i,
                    p = o / n * Math.PI * 2;
                d.x = (e + t * Math.cos(p)) * Math.cos(v), d.y = (e + t * Math.cos(p)) * Math.sin(v), d.z = t * Math.sin(p), c.push(d.x, d.y, d.z), f.x = e * Math.cos(v), f.y = e * Math.sin(v), h.subVectors(d, f).normalize(), u.push(h.x, h.y, h.z), l.push(a / r), l.push(o / n)
            }
        for (o = 1; o <= n; o++)
            for (a = 1; a <= r; a++) {
                var m = (r + 1) * o + a - 1,
                    y = (r + 1) * (o - 1) + a - 1,
                    g = (r + 1) * (o - 1) + a,
                    x = (r + 1) * o + a;
                s.push(m, y, x), s.push(y, g, x)
            }
        this.setIndex(s), this.addAttribute("position", new Qr(c, 3)), this.addAttribute("normal", new Qr(u, 3)), this.addAttribute("uv", new Qr(l, 2))
    }
    rc.prototype = Object.assign(Object.create(Zn.prototype), {
        constructor: rc,
        isPoints: !0,
        raycast: function(e, t) {
            var n = this.geometry,
                r = this.matrixWorld,
                i = e.params.Points.threshold;
            if (null === n.boundingSphere && n.computeBoundingSphere(), tc.copy(n.boundingSphere), tc.applyMatrix4(r), tc.radius += i, !1 !== e.ray.intersectsSphere(tc)) {
                $s.getInverse(r), ec.copy(e.ray).applyMatrix4($s);
                var o = i / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                    a = o * o;
                if (n.isBufferGeometry) {
                    var s = n.index,
                        c = n.attributes.position.array;
                    if (null !== s)
                        for (var u = s.array, l = 0, f = u.length; l < f; l++) {
                            var d = u[l];
                            nc.fromArray(c, 3 * d), ic(nc, d, a, r, e, t, this)
                        } else {
                            l = 0;
                            for (var h = c.length / 3; l < h; l++) nc.fromArray(c, 3 * l), ic(nc, l, a, r, e, t, this)
                        }
                } else {
                    var v = n.vertices;
                    for (l = 0, h = v.length; l < h; l++) ic(v[l], l, a, r, e, t, this)
                }
            }
        },
        updateMorphTargets: function() {
            var e, t, n, r = this.geometry;
            if (r.isBufferGeometry) {
                var i = r.morphAttributes,
                    o = Object.keys(i);
                if (o.length > 0) {
                    var a = i[o[0]];
                    if (void 0 !== a)
                        for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, e = 0, t = a.length; e < t; e++) n = a[e].name || String(e), this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = e
                }
            } else {
                var s = r.morphTargets;
                void 0 !== s && s.length > 0 && console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
            }
        },
        clone: function() {
            return new this.constructor(this.geometry, this.material).copy(this)
        }
    }), oc.prototype = Object.assign(Object.create(wn.prototype), {
        constructor: oc,
        isVideoTexture: !0,
        update: function() {
            var e = this.image;
            e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
        }
    }), ac.prototype = Object.create(wn.prototype), ac.prototype.constructor = ac, ac.prototype.isCompressedTexture = !0, sc.prototype = Object.create(wn.prototype), sc.prototype.constructor = sc, sc.prototype.isCanvasTexture = !0, cc.prototype = Object.create(wn.prototype), cc.prototype.constructor = cc, cc.prototype.isDepthTexture = !0, uc.prototype = Object.create(ui.prototype), uc.prototype.constructor = uc, lc.prototype = Object.create(ji.prototype), lc.prototype.constructor = lc, fc.prototype = Object.create(ui.prototype), fc.prototype.constructor = fc, dc.prototype = Object.create(ji.prototype), dc.prototype.constructor = dc, hc.prototype = Object.create(ui.prototype), hc.prototype.constructor = hc, vc.prototype = Object.create(ji.prototype), vc.prototype.constructor = vc, pc.prototype = Object.create(hc.prototype), pc.prototype.constructor = pc, mc.prototype = Object.create(ji.prototype), mc.prototype.constructor = mc, yc.prototype = Object.create(hc.prototype), yc.prototype.constructor = yc, gc.prototype = Object.create(ji.prototype), gc.prototype.constructor = gc, xc.prototype = Object.create(hc.prototype), xc.prototype.constructor = xc, bc.prototype = Object.create(ji.prototype), bc.prototype.constructor = bc, wc.prototype = Object.create(hc.prototype), wc.prototype.constructor = wc, Mc.prototype = Object.create(ji.prototype), Mc.prototype.constructor = Mc, _c.prototype = Object.create(ui.prototype), _c.prototype.constructor = _c, _c.prototype.toJSON = function() {
        var e = ui.prototype.toJSON.call(this);
        return e.path = this.parameters.path.toJSON(), e
    }, Sc.prototype = Object.create(ji.prototype), Sc.prototype.constructor = Sc, Pc.prototype = Object.create(ui.prototype), Pc.prototype.constructor = Pc, Tc.prototype = Object.create(ji.prototype), Tc.prototype.constructor = Tc, Ec.prototype = Object.create(ui.prototype), Ec.prototype.constructor = Ec;
    var zc = function(e, t, n) {
        n = n || 2;
        var r, i, o, a, s, c, u, l = t && t.length,
            f = l ? t[0] * n : e.length,
            d = Lc(e, 0, f, n, !0),
            h = [];
        if (!d || d.next === d.prev) return h;
        if (l && (d = function(e, t, n, r) {
                var i, o, a, s, c, u = [];
                for (i = 0, o = t.length; i < o; i++) a = t[i] * r, s = i < o - 1 ? t[i + 1] * r : e.length, (c = Lc(e, a, s, r, !1)) === c.next && (c.steiner = !0), u.push(Gc(c));
                for (u.sort(Dc), i = 0; i < u.length; i++) kc(u[i], n), n = Ac(n, n.next);
                return n
            }(e, t, d, n)), e.length > 80 * n) {
            r = o = e[0], i = a = e[1];
            for (var v = n; v < f; v += n)(s = e[v]) < r && (r = s), (c = e[v + 1]) < i && (i = c), s > o && (o = s), c > a && (a = c);
            u = 0 !== (u = Math.max(o - r, a - i)) ? 1 / u : 0
        }
        return Cc(d, h, n, r, i, u), h
    };

    function Lc(e, t, n, r, i) {
        var o, a;
        if (i === function(e, t, n, r) {
                for (var i = 0, o = t, a = n - r; o < n; o += r) i += (e[a] - e[o]) * (e[o + 1] + e[a + 1]), a = o;
                return i
            }(e, t, n, r) > 0)
            for (o = t; o < n; o += r) a = Xc(o, e[o], e[o + 1], a);
        else
            for (o = n - r; o >= t; o -= r) a = Xc(o, e[o], e[o + 1], a);
        return a && Hc(a, a.next) && (qc(a), a = a.next), a
    }

    function Ac(e, t) {
        if (!e) return e;
        t || (t = e);
        var n, r = e;
        do {
            if (n = !1, r.steiner || !Hc(r, r.next) && 0 !== Uc(r.prev, r, r.next)) r = r.next;
            else {
                if (qc(r), (r = t = r.prev) === r.next) break;
                n = !0
            }
        } while (n || r !== t);
        return t
    }

    function Cc(e, t, n, r, i, o, a) {
        if (e) {
            !a && o && function(e, t, n, r) {
                var i = e;
                do {
                    null === i.z && (i.z = Fc(i.x, i.y, t, n, r)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next
                } while (i !== e);
                i.prevZ.nextZ = null, i.prevZ = null,
                    function(e) {
                        var t, n, r, i, o, a, s, c, u = 1;
                        do {
                            for (n = e, e = null, o = null, a = 0; n;) {
                                for (a++, r = n, s = 0, t = 0; t < u && (s++, r = r.nextZ); t++);
                                for (c = u; s > 0 || c > 0 && r;) 0 !== s && (0 === c || !r || n.z <= r.z) ? (i = n, n = n.nextZ, s--) : (i = r, r = r.nextZ, c--), o ? o.nextZ = i : e = i, i.prevZ = o, o = i;
                                n = r
                            }
                            o.nextZ = null, u *= 2
                        } while (a > 1)
                    }(i)
            }(e, r, i, o);
            for (var s, c, u = e; e.prev !== e.next;)
                if (s = e.prev, c = e.next, o ? Oc(e, r, i, o) : Rc(e)) t.push(s.i / n), t.push(e.i / n), t.push(c.i / n), qc(e), e = c.next, u = c.next;
                else if ((e = c) === u) {
                a ? 1 === a ? Cc(e = jc(e, t, n), t, n, r, i, o, 2) : 2 === a && Ic(e, t, n, r, i, o) : Cc(Ac(e), t, n, r, i, o, 1);
                break
            }
        }
    }

    function Rc(e) {
        var t = e.prev,
            n = e,
            r = e.next;
        if (Uc(t, n, r) >= 0) return !1;
        for (var i = e.next.next; i !== e.prev;) {
            if (Nc(t.x, t.y, n.x, n.y, r.x, r.y, i.x, i.y) && Uc(i.prev, i, i.next) >= 0) return !1;
            i = i.next
        }
        return !0
    }

    function Oc(e, t, n, r) {
        var i = e.prev,
            o = e,
            a = e.next;
        if (Uc(i, o, a) >= 0) return !1;
        for (var s = i.x < o.x ? i.x < a.x ? i.x : a.x : o.x < a.x ? o.x : a.x, c = i.y < o.y ? i.y < a.y ? i.y : a.y : o.y < a.y ? o.y : a.y, u = i.x > o.x ? i.x > a.x ? i.x : a.x : o.x > a.x ? o.x : a.x, l = i.y > o.y ? i.y > a.y ? i.y : a.y : o.y > a.y ? o.y : a.y, f = Fc(s, c, t, n, r), d = Fc(u, l, t, n, r), h = e.prevZ, v = e.nextZ; h && h.z >= f && v && v.z <= d;) {
            if (h !== e.prev && h !== e.next && Nc(i.x, i.y, o.x, o.y, a.x, a.y, h.x, h.y) && Uc(h.prev, h, h.next) >= 0) return !1;
            if (h = h.prevZ, v !== e.prev && v !== e.next && Nc(i.x, i.y, o.x, o.y, a.x, a.y, v.x, v.y) && Uc(v.prev, v, v.next) >= 0) return !1;
            v = v.nextZ
        }
        for (; h && h.z >= f;) {
            if (h !== e.prev && h !== e.next && Nc(i.x, i.y, o.x, o.y, a.x, a.y, h.x, h.y) && Uc(h.prev, h, h.next) >= 0) return !1;
            h = h.prevZ
        }
        for (; v && v.z <= d;) {
            if (v !== e.prev && v !== e.next && Nc(i.x, i.y, o.x, o.y, a.x, a.y, v.x, v.y) && Uc(v.prev, v, v.next) >= 0) return !1;
            v = v.nextZ
        }
        return !0
    }

    function jc(e, t, n) {
        var r = e;
        do {
            var i = r.prev,
                o = r.next.next;
            !Hc(i, o) && Vc(i, r, r.next, o) && Wc(i, o) && Wc(o, i) && (t.push(i.i / n), t.push(r.i / n), t.push(o.i / n), qc(r), qc(r.next), r = e = o), r = r.next
        } while (r !== e);
        return r
    }

    function Ic(e, t, n, r, i, o) {
        var a = e;
        do {
            for (var s = a.next.next; s !== a.prev;) {
                if (a.i !== s.i && Bc(a, s)) {
                    var c = Yc(a, s);
                    return a = Ac(a, a.next), c = Ac(c, c.next), Cc(a, t, n, r, i, o), void Cc(c, t, n, r, i, o)
                }
                s = s.next
            }
            a = a.next
        } while (a !== e)
    }

    function Dc(e, t) {
        return e.x - t.x
    }

    function kc(e, t) {
        if (t = function(e, t) {
                var n, r = t,
                    i = e.x,
                    o = e.y,
                    a = -1 / 0;
                do {
                    if (o <= r.y && o >= r.next.y && r.next.y !== r.y) {
                        var s = r.x + (o - r.y) * (r.next.x - r.x) / (r.next.y - r.y);
                        if (s <= i && s > a) {
                            if (a = s, s === i) {
                                if (o === r.y) return r;
                                if (o === r.next.y) return r.next
                            }
                            n = r.x < r.next.x ? r : r.next
                        }
                    }
                    r = r.next
                } while (r !== t);
                if (!n) return null;
                if (i === a) return n.prev;
                var c, u = n,
                    l = n.x,
                    f = n.y,
                    d = 1 / 0;
                r = n.next;
                for (; r !== u;) i >= r.x && r.x >= l && i !== r.x && Nc(o < f ? i : a, o, l, f, o < f ? a : i, o, r.x, r.y) && ((c = Math.abs(o - r.y) / (i - r.x)) < d || c === d && r.x > n.x) && Wc(r, e) && (n = r, d = c), r = r.next;
                return n
            }(e, t)) {
            var n = Yc(t, e);
            Ac(n, n.next)
        }
    }

    function Fc(e, t, n, r, i) {
        return (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - n) * i) | e << 8)) | e << 4)) | e << 2)) | e << 1)) | (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - r) * i) | t << 8)) | t << 4)) | t << 2)) | t << 1)) << 1
    }

    function Gc(e) {
        var t = e,
            n = e;
        do {
            (t.x < n.x || t.x === n.x && t.y < n.y) && (n = t), t = t.next
        } while (t !== e);
        return n
    }

    function Nc(e, t, n, r, i, o, a, s) {
        return (i - a) * (t - s) - (e - a) * (o - s) >= 0 && (e - a) * (r - s) - (n - a) * (t - s) >= 0 && (n - a) * (o - s) - (i - a) * (r - s) >= 0
    }

    function Bc(e, t) {
        return e.next.i !== t.i && e.prev.i !== t.i && ! function(e, t) {
            var n = e;
            do {
                if (n.i !== e.i && n.next.i !== e.i && n.i !== t.i && n.next.i !== t.i && Vc(n, n.next, e, t)) return !0;
                n = n.next
            } while (n !== e);
            return !1
        }(e, t) && Wc(e, t) && Wc(t, e) && function(e, t) {
            var n = e,
                r = !1,
                i = (e.x + t.x) / 2,
                o = (e.y + t.y) / 2;
            do {
                n.y > o != n.next.y > o && n.next.y !== n.y && i < (n.next.x - n.x) * (o - n.y) / (n.next.y - n.y) + n.x && (r = !r), n = n.next
            } while (n !== e);
            return r
        }(e, t)
    }

    function Uc(e, t, n) {
        return (t.y - e.y) * (n.x - t.x) - (t.x - e.x) * (n.y - t.y)
    }

    function Hc(e, t) {
        return e.x === t.x && e.y === t.y
    }

    function Vc(e, t, n, r) {
        return !!(Hc(e, n) && Hc(t, r) || Hc(e, r) && Hc(n, t)) || Uc(e, t, n) > 0 != Uc(e, t, r) > 0 && Uc(n, r, e) > 0 != Uc(n, r, t) > 0
    }

    function Wc(e, t) {
        return Uc(e.prev, e, e.next) < 0 ? Uc(e, t, e.next) >= 0 && Uc(e, e.prev, t) >= 0 : Uc(e, t, e.prev) < 0 || Uc(e, e.next, t) < 0
    }

    function Yc(e, t) {
        var n = new Kc(e.i, e.x, e.y),
            r = new Kc(t.i, t.x, t.y),
            i = e.next,
            o = t.prev;
        return e.next = t, t.prev = e, n.next = i, i.prev = n, r.next = n, n.prev = r, o.next = r, r.prev = o, r
    }

    function Xc(e, t, n, r) {
        var i = new Kc(e, t, n);
        return r ? (i.next = r.next, i.prev = r, r.next.prev = i, r.next = i) : (i.prev = i, i.next = i), i
    }

    function qc(e) {
        e.next.prev = e.prev, e.prev.next = e.next, e.prevZ && (e.prevZ.nextZ = e.nextZ), e.nextZ && (e.nextZ.prevZ = e.prevZ)
    }

    function Kc(e, t, n) {
        this.i = e, this.x = t, this.y = n, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1
    }
    var Zc = {
        area: function(e) {
            for (var t = e.length, n = 0, r = t - 1, i = 0; i < t; r = i++) n += e[r].x * e[i].y - e[i].x * e[r].y;
            return .5 * n
        },
        isClockWise: function(e) {
            return Zc.area(e) < 0
        },
        triangulateShape: function(e, t) {
            var n = [],
                r = [],
                i = [];
            Jc(e), Qc(n, e);
            var o = e.length;
            t.forEach(Jc);
            for (var a = 0; a < t.length; a++) r.push(o), o += t[a].length, Qc(n, t[a]);
            var s = zc(n, r);
            for (a = 0; a < s.length; a += 3) i.push(s.slice(a, a + 3));
            return i
        }
    };

    function Jc(e) {
        var t = e.length;
        t > 2 && e[t - 1].equals(e[0]) && e.pop()
    }

    function Qc(e, t) {
        for (var n = 0; n < t.length; n++) e.push(t[n].x), e.push(t[n].y)
    }

    function $c(e, t) {
        ji.call(this), this.type = "ExtrudeGeometry", this.parameters = {
            shapes: e,
            options: t
        }, this.fromBufferGeometry(new eu(e, t)), this.mergeVertices()
    }

    function eu(e, t) {
        ui.call(this), this.type = "ExtrudeBufferGeometry", this.parameters = {
            shapes: e,
            options: t
        }, e = Array.isArray(e) ? e : [e];
        for (var n = this, r = [], i = [], o = 0, a = e.length; o < a; o++) {
            s(e[o])
        }

        function s(e) {
            var o = [],
                a = void 0 !== t.curveSegments ? t.curveSegments : 12,
                s = void 0 !== t.steps ? t.steps : 1,
                c = void 0 !== t.depth ? t.depth : 100,
                u = void 0 === t.bevelEnabled || t.bevelEnabled,
                l = void 0 !== t.bevelThickness ? t.bevelThickness : 6,
                f = void 0 !== t.bevelSize ? t.bevelSize : l - 2,
                d = void 0 !== t.bevelOffset ? t.bevelOffset : 0,
                h = void 0 !== t.bevelSegments ? t.bevelSegments : 3,
                v = t.extrudePath,
                p = void 0 !== t.UVGenerator ? t.UVGenerator : tu;
            void 0 !== t.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), c = t.amount);
            var m, y, g, x, b, w, M, _, S = !1;
            v && (m = v.getSpacedPoints(s), S = !0, u = !1, y = v.computeFrenetFrames(s, !1), g = new pn, x = new pn, b = new pn), u || (h = 0, l = 0, f = 0, d = 0);
            var P = e.extractPoints(a),
                T = P.shape,
                E = P.holes;
            if (!Zc.isClockWise(T))
                for (T = T.reverse(), M = 0, _ = E.length; M < _; M++) w = E[M], Zc.isClockWise(w) && (E[M] = w.reverse());
            var z = Zc.triangulateShape(T, E),
                L = T;
            for (M = 0, _ = E.length; M < _; M++) w = E[M], T = T.concat(w);

            function A(e, t, n) {
                return t || console.error("THREE.ExtrudeGeometry: vec does not exist"), t.clone().multiplyScalar(n).add(e)
            }
            var C, R, O, j, I, D, k = T.length,
                F = z.length;

            function G(e, t, n) {
                var r, i, o, a = e.x - t.x,
                    s = e.y - t.y,
                    c = n.x - e.x,
                    u = n.y - e.y,
                    l = a * a + s * s,
                    f = a * u - s * c;
                if (Math.abs(f) > Number.EPSILON) {
                    var d = Math.sqrt(l),
                        h = Math.sqrt(c * c + u * u),
                        v = t.x - s / d,
                        p = t.y + a / d,
                        m = ((n.x - u / h - v) * u - (n.y + c / h - p) * c) / (a * u - s * c),
                        y = (r = v + a * m - e.x) * r + (i = p + s * m - e.y) * i;
                    if (y <= 2) return new fn(r, i);
                    o = Math.sqrt(y / 2)
                } else {
                    var g = !1;
                    a > Number.EPSILON ? c > Number.EPSILON && (g = !0) : a < -Number.EPSILON ? c < -Number.EPSILON && (g = !0) : Math.sign(s) === Math.sign(u) && (g = !0), g ? (r = -s, i = a, o = Math.sqrt(l)) : (r = a, i = s, o = Math.sqrt(l / 2))
                }
                return new fn(r / o, i / o)
            }
            for (var N = [], B = 0, U = L.length, H = U - 1, V = B + 1; B < U; B++, H++, V++) H === U && (H = 0), V === U && (V = 0), N[B] = G(L[B], L[H], L[V]);
            var W, Y, X = [],
                q = N.concat();
            for (M = 0, _ = E.length; M < _; M++) {
                for (w = E[M], W = [], B = 0, H = (U = w.length) - 1, V = B + 1; B < U; B++, H++, V++) H === U && (H = 0), V === U && (V = 0), W[B] = G(w[B], w[H], w[V]);
                X.push(W), q = q.concat(W)
            }
            for (C = 0; C < h; C++) {
                for (O = C / h, j = l * Math.cos(O * Math.PI / 2), R = f * Math.sin(O * Math.PI / 2) + d, B = 0, U = L.length; B < U; B++) Z((I = A(L[B], N[B], R)).x, I.y, -j);
                for (M = 0, _ = E.length; M < _; M++)
                    for (w = E[M], W = X[M], B = 0, U = w.length; B < U; B++) Z((I = A(w[B], W[B], R)).x, I.y, -j)
            }
            for (R = f + d, B = 0; B < k; B++) I = u ? A(T[B], q[B], R) : T[B], S ? (x.copy(y.normals[0]).multiplyScalar(I.x), g.copy(y.binormals[0]).multiplyScalar(I.y), b.copy(m[0]).add(x).add(g), Z(b.x, b.y, b.z)) : Z(I.x, I.y, 0);
            for (Y = 1; Y <= s; Y++)
                for (B = 0; B < k; B++) I = u ? A(T[B], q[B], R) : T[B], S ? (x.copy(y.normals[Y]).multiplyScalar(I.x), g.copy(y.binormals[Y]).multiplyScalar(I.y), b.copy(m[Y]).add(x).add(g), Z(b.x, b.y, b.z)) : Z(I.x, I.y, c / s * Y);
            for (C = h - 1; C >= 0; C--) {
                for (O = C / h, j = l * Math.cos(O * Math.PI / 2), R = f * Math.sin(O * Math.PI / 2) + d, B = 0, U = L.length; B < U; B++) Z((I = A(L[B], N[B], R)).x, I.y, c + j);
                for (M = 0, _ = E.length; M < _; M++)
                    for (w = E[M], W = X[M], B = 0, U = w.length; B < U; B++) I = A(w[B], W[B], R), S ? Z(I.x, I.y + m[s - 1].y, m[s - 1].x + j) : Z(I.x, I.y, c + j)
            }

            function K(e, t) {
                var n, r;
                for (B = e.length; --B >= 0;) {
                    n = B, (r = B - 1) < 0 && (r = e.length - 1);
                    var i = 0,
                        o = s + 2 * h;
                    for (i = 0; i < o; i++) {
                        var a = k * i,
                            c = k * (i + 1);
                        Q(t + n + a, t + r + a, t + r + c, t + n + c)
                    }
                }
            }

            function Z(e, t, n) {
                o.push(e), o.push(t), o.push(n)
            }

            function J(e, t, i) {
                $(e), $(t), $(i);
                var o = r.length / 3,
                    a = p.generateTopUV(n, r, o - 3, o - 2, o - 1);
                ee(a[0]), ee(a[1]), ee(a[2])
            }

            function Q(e, t, i, o) {
                $(e), $(t), $(o), $(t), $(i), $(o);
                var a = r.length / 3,
                    s = p.generateSideWallUV(n, r, a - 6, a - 3, a - 2, a - 1);
                ee(s[0]), ee(s[1]), ee(s[3]), ee(s[1]), ee(s[2]), ee(s[3])
            }

            function $(e) {
                r.push(o[3 * e + 0]), r.push(o[3 * e + 1]), r.push(o[3 * e + 2])
            }

            function ee(e) {
                i.push(e.x), i.push(e.y)
            }! function() {
                var e = r.length / 3;
                if (u) {
                    var t = 0,
                        i = k * t;
                    for (B = 0; B < F; B++) J((D = z[B])[2] + i, D[1] + i, D[0] + i);
                    for (i = k * (t = s + 2 * h), B = 0; B < F; B++) J((D = z[B])[0] + i, D[1] + i, D[2] + i)
                } else {
                    for (B = 0; B < F; B++) J((D = z[B])[2], D[1], D[0]);
                    for (B = 0; B < F; B++) J((D = z[B])[0] + k * s, D[1] + k * s, D[2] + k * s)
                }
                n.addGroup(e, r.length / 3 - e, 0)
            }(),
            function() {
                var e = r.length / 3,
                    t = 0;
                for (K(L, t), t += L.length, M = 0, _ = E.length; M < _; M++) K(w = E[M], t), t += w.length;
                n.addGroup(e, r.length / 3 - e, 1)
            }()
        }
        this.addAttribute("position", new Qr(r, 3)), this.addAttribute("uv", new Qr(i, 2)), this.computeVertexNormals()
    }
    $c.prototype = Object.create(ji.prototype), $c.prototype.constructor = $c, $c.prototype.toJSON = function() {
        var e = ji.prototype.toJSON.call(this);
        return nu(this.parameters.shapes, this.parameters.options, e)
    }, eu.prototype = Object.create(ui.prototype), eu.prototype.constructor = eu, eu.prototype.toJSON = function() {
        var e = ui.prototype.toJSON.call(this);
        return nu(this.parameters.shapes, this.parameters.options, e)
    };
    var tu = {
        generateTopUV: function(e, t, n, r, i) {
            var o = t[3 * n],
                a = t[3 * n + 1],
                s = t[3 * r],
                c = t[3 * r + 1],
                u = t[3 * i],
                l = t[3 * i + 1];
            return [new fn(o, a), new fn(s, c), new fn(u, l)]
        },
        generateSideWallUV: function(e, t, n, r, i, o) {
            var a = t[3 * n],
                s = t[3 * n + 1],
                c = t[3 * n + 2],
                u = t[3 * r],
                l = t[3 * r + 1],
                f = t[3 * r + 2],
                d = t[3 * i],
                h = t[3 * i + 1],
                v = t[3 * i + 2],
                p = t[3 * o],
                m = t[3 * o + 1],
                y = t[3 * o + 2];
            return Math.abs(s - l) < .01 ? [new fn(a, 1 - c), new fn(u, 1 - f), new fn(d, 1 - v), new fn(p, 1 - y)] : [new fn(s, 1 - c), new fn(l, 1 - f), new fn(h, 1 - v), new fn(m, 1 - y)]
        }
    };

    function nu(e, t, n) {
        if (n.shapes = [], Array.isArray(e))
            for (var r = 0, i = e.length; r < i; r++) {
                var o = e[r];
                n.shapes.push(o.uuid)
            } else n.shapes.push(e.uuid);
        return void 0 !== t.extrudePath && (n.options.extrudePath = t.extrudePath.toJSON()), n
    }

    function ru(e, t) {
        ji.call(this), this.type = "TextGeometry", this.parameters = {
            text: e,
            parameters: t
        }, this.fromBufferGeometry(new iu(e, t)), this.mergeVertices()
    }

    function iu(e, t) {
        var n = (t = t || {}).font;
        if (!n || !n.isFont) return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."), new ji;
        var r = n.generateShapes(e, t.size);
        t.depth = void 0 !== t.height ? t.height : 50, void 0 === t.bevelThickness && (t.bevelThickness = 10), void 0 === t.bevelSize && (t.bevelSize = 8), void 0 === t.bevelEnabled && (t.bevelEnabled = !1), eu.call(this, r, t), this.type = "TextBufferGeometry"
    }

    function ou(e, t, n, r, i, o, a) {
        ji.call(this), this.type = "SphereGeometry", this.parameters = {
            radius: e,
            widthSegments: t,
            heightSegments: n,
            phiStart: r,
            phiLength: i,
            thetaStart: o,
            thetaLength: a
        }, this.fromBufferGeometry(new au(e, t, n, r, i, o, a)), this.mergeVertices()
    }

    function au(e, t, n, r, i, o, a) {
        ui.call(this), this.type = "SphereBufferGeometry", this.parameters = {
            radius: e,
            widthSegments: t,
            heightSegments: n,
            phiStart: r,
            phiLength: i,
            thetaStart: o,
            thetaLength: a
        }, e = e || 1, t = Math.max(3, Math.floor(t) || 8), n = Math.max(2, Math.floor(n) || 6), r = void 0 !== r ? r : 0, i = void 0 !== i ? i : 2 * Math.PI, o = void 0 !== o ? o : 0, a = void 0 !== a ? a : Math.PI;
        var s, c, u = Math.min(o + a, Math.PI),
            l = 0,
            f = [],
            d = new pn,
            h = new pn,
            v = [],
            p = [],
            m = [],
            y = [];
        for (c = 0; c <= n; c++) {
            var g = [],
                x = c / n,
                b = 0;
            for (0 == c && 0 == o ? b = .5 / t : c == n && u == Math.PI && (b = -.5 / t), s = 0; s <= t; s++) {
                var w = s / t;
                d.x = -e * Math.cos(r + w * i) * Math.sin(o + x * a), d.y = e * Math.cos(o + x * a), d.z = e * Math.sin(r + w * i) * Math.sin(o + x * a), p.push(d.x, d.y, d.z), h.copy(d).normalize(), m.push(h.x, h.y, h.z), y.push(w + b, 1 - x), g.push(l++)
            }
            f.push(g)
        }
        for (c = 0; c < n; c++)
            for (s = 0; s < t; s++) {
                var M = f[c][s + 1],
                    _ = f[c][s],
                    S = f[c + 1][s],
                    P = f[c + 1][s + 1];
                (0 !== c || o > 0) && v.push(M, _, P), (c !== n - 1 || u < Math.PI) && v.push(_, S, P)
            }
        this.setIndex(v), this.addAttribute("position", new Qr(p, 3)), this.addAttribute("normal", new Qr(m, 3)), this.addAttribute("uv", new Qr(y, 2))
    }

    function su(e, t, n, r, i, o) {
        ji.call(this), this.type = "RingGeometry", this.parameters = {
            innerRadius: e,
            outerRadius: t,
            thetaSegments: n,
            phiSegments: r,
            thetaStart: i,
            thetaLength: o
        }, this.fromBufferGeometry(new cu(e, t, n, r, i, o)), this.mergeVertices()
    }

    function cu(e, t, n, r, i, o) {
        ui.call(this), this.type = "RingBufferGeometry", this.parameters = {
            innerRadius: e,
            outerRadius: t,
            thetaSegments: n,
            phiSegments: r,
            thetaStart: i,
            thetaLength: o
        }, e = e || .5, t = t || 1, i = void 0 !== i ? i : 0, o = void 0 !== o ? o : 2 * Math.PI, n = void 0 !== n ? Math.max(3, n) : 8;
        var a, s, c, u = [],
            l = [],
            f = [],
            d = [],
            h = e,
            v = (t - e) / (r = void 0 !== r ? Math.max(1, r) : 1),
            p = new pn,
            m = new fn;
        for (s = 0; s <= r; s++) {
            for (c = 0; c <= n; c++) a = i + c / n * o, p.x = h * Math.cos(a), p.y = h * Math.sin(a), l.push(p.x, p.y, p.z), f.push(0, 0, 1), m.x = (p.x / t + 1) / 2, m.y = (p.y / t + 1) / 2, d.push(m.x, m.y);
            h += v
        }
        for (s = 0; s < r; s++) {
            var y = s * (n + 1);
            for (c = 0; c < n; c++) {
                var g = a = c + y,
                    x = a + n + 1,
                    b = a + n + 2,
                    w = a + 1;
                u.push(g, x, w), u.push(x, b, w)
            }
        }
        this.setIndex(u), this.addAttribute("position", new Qr(l, 3)), this.addAttribute("normal", new Qr(f, 3)), this.addAttribute("uv", new Qr(d, 2))
    }

    function uu(e, t, n, r) {
        ji.call(this), this.type = "LatheGeometry", this.parameters = {
            points: e,
            segments: t,
            phiStart: n,
            phiLength: r
        }, this.fromBufferGeometry(new lu(e, t, n, r)), this.mergeVertices()
    }

    function lu(e, t, n, r) {
        ui.call(this), this.type = "LatheBufferGeometry", this.parameters = {
            points: e,
            segments: t,
            phiStart: n,
            phiLength: r
        }, t = Math.floor(t) || 12, n = n || 0, r = r || 2 * Math.PI, r = ln.clamp(r, 0, 2 * Math.PI);
        var i, o, a, s = [],
            c = [],
            u = [],
            l = 1 / t,
            f = new pn,
            d = new fn;
        for (o = 0; o <= t; o++) {
            var h = n + o * l * r,
                v = Math.sin(h),
                p = Math.cos(h);
            for (a = 0; a <= e.length - 1; a++) f.x = e[a].x * v, f.y = e[a].y, f.z = e[a].x * p, c.push(f.x, f.y, f.z), d.x = o / t, d.y = a / (e.length - 1), u.push(d.x, d.y)
        }
        for (o = 0; o < t; o++)
            for (a = 0; a < e.length - 1; a++) {
                var m = i = a + o * e.length,
                    y = i + e.length,
                    g = i + e.length + 1,
                    x = i + 1;
                s.push(m, y, x), s.push(y, g, x)
            }
        if (this.setIndex(s), this.addAttribute("position", new Qr(c, 3)), this.addAttribute("uv", new Qr(u, 2)), this.computeVertexNormals(), r === 2 * Math.PI) {
            var b = this.attributes.normal.array,
                w = new pn,
                M = new pn,
                _ = new pn;
            for (i = t * e.length * 3, o = 0, a = 0; o < e.length; o++, a += 3) w.x = b[a + 0], w.y = b[a + 1], w.z = b[a + 2], M.x = b[i + a + 0], M.y = b[i + a + 1], M.z = b[i + a + 2], _.addVectors(w, M).normalize(), b[a + 0] = b[i + a + 0] = _.x, b[a + 1] = b[i + a + 1] = _.y, b[a + 2] = b[i + a + 2] = _.z
        }
    }

    function fu(e, t) {
        ji.call(this), this.type = "ShapeGeometry", "object" == typeof t && (console.warn("THREE.ShapeGeometry: Options parameter has been removed."), t = t.curveSegments), this.parameters = {
            shapes: e,
            curveSegments: t
        }, this.fromBufferGeometry(new du(e, t)), this.mergeVertices()
    }

    function du(e, t) {
        ui.call(this), this.type = "ShapeBufferGeometry", this.parameters = {
            shapes: e,
            curveSegments: t
        }, t = t || 12;
        var n = [],
            r = [],
            i = [],
            o = [],
            a = 0,
            s = 0;
        if (!1 === Array.isArray(e)) u(e);
        else
            for (var c = 0; c < e.length; c++) u(e[c]), this.addGroup(a, s, c), a += s, s = 0;

        function u(e) {
            var a, c, u, l = r.length / 3,
                f = e.extractPoints(t),
                d = f.shape,
                h = f.holes;
            for (!1 === Zc.isClockWise(d) && (d = d.reverse()), a = 0, c = h.length; a < c; a++) u = h[a], !0 === Zc.isClockWise(u) && (h[a] = u.reverse());
            var v = Zc.triangulateShape(d, h);
            for (a = 0, c = h.length; a < c; a++) u = h[a], d = d.concat(u);
            for (a = 0, c = d.length; a < c; a++) {
                var p = d[a];
                r.push(p.x, p.y, 0), i.push(0, 0, 1), o.push(p.x, p.y)
            }
            for (a = 0, c = v.length; a < c; a++) {
                var m = v[a],
                    y = m[0] + l,
                    g = m[1] + l,
                    x = m[2] + l;
                n.push(y, g, x), s += 3
            }
        }
        this.setIndex(n), this.addAttribute("position", new Qr(r, 3)), this.addAttribute("normal", new Qr(i, 3)), this.addAttribute("uv", new Qr(o, 2))
    }

    function hu(e, t) {
        if (t.shapes = [], Array.isArray(e))
            for (var n = 0, r = e.length; n < r; n++) {
                var i = e[n];
                t.shapes.push(i.uuid)
            } else t.shapes.push(e.uuid);
        return t
    }

    function vu(e, t) {
        ui.call(this), this.type = "EdgesGeometry", this.parameters = {
            thresholdAngle: t
        }, t = void 0 !== t ? t : 1;
        var n, r, i, o, a = [],
            s = Math.cos(ln.DEG2RAD * t),
            c = [0, 0],
            u = {},
            l = ["a", "b", "c"];
        e.isBufferGeometry ? (o = new ji).fromBufferGeometry(e) : o = e.clone(), o.mergeVertices(), o.computeFaceNormals();
        for (var f = o.vertices, d = o.faces, h = 0, v = d.length; h < v; h++)
            for (var p = d[h], m = 0; m < 3; m++) n = p[l[m]], r = p[l[(m + 1) % 3]], c[0] = Math.min(n, r), c[1] = Math.max(n, r), void 0 === u[i = c[0] + "," + c[1]] ? u[i] = {
                index1: c[0],
                index2: c[1],
                face1: h,
                face2: void 0
            } : u[i].face2 = h;
        for (i in u) {
            var y = u[i];
            if (void 0 === y.face2 || d[y.face1].normal.dot(d[y.face2].normal) <= s) {
                var g = f[y.index1];
                a.push(g.x, g.y, g.z), g = f[y.index2], a.push(g.x, g.y, g.z)
            }
        }
        this.addAttribute("position", new Qr(a, 3))
    }

    function pu(e, t, n, r, i, o, a, s) {
        ji.call(this), this.type = "CylinderGeometry", this.parameters = {
            radiusTop: e,
            radiusBottom: t,
            height: n,
            radialSegments: r,
            heightSegments: i,
            openEnded: o,
            thetaStart: a,
            thetaLength: s
        }, this.fromBufferGeometry(new mu(e, t, n, r, i, o, a, s)), this.mergeVertices()
    }

    function mu(e, t, n, r, i, o, a, s) {
        ui.call(this), this.type = "CylinderBufferGeometry", this.parameters = {
            radiusTop: e,
            radiusBottom: t,
            height: n,
            radialSegments: r,
            heightSegments: i,
            openEnded: o,
            thetaStart: a,
            thetaLength: s
        };
        var c = this;
        e = void 0 !== e ? e : 1, t = void 0 !== t ? t : 1, n = n || 1, r = Math.floor(r) || 8, i = Math.floor(i) || 1, o = void 0 !== o && o, a = void 0 !== a ? a : 0, s = void 0 !== s ? s : 2 * Math.PI;
        var u = [],
            l = [],
            f = [],
            d = [],
            h = 0,
            v = [],
            p = n / 2,
            m = 0;

        function y(n) {
            var i, o, v, y = new fn,
                g = new pn,
                x = 0,
                b = !0 === n ? e : t,
                w = !0 === n ? 1 : -1;
            for (o = h, i = 1; i <= r; i++) l.push(0, p * w, 0), f.push(0, w, 0), d.push(.5, .5), h++;
            for (v = h, i = 0; i <= r; i++) {
                var M = i / r * s + a,
                    _ = Math.cos(M),
                    S = Math.sin(M);
                g.x = b * S, g.y = p * w, g.z = b * _, l.push(g.x, g.y, g.z), f.push(0, w, 0), y.x = .5 * _ + .5, y.y = .5 * S * w + .5, d.push(y.x, y.y), h++
            }
            for (i = 0; i < r; i++) {
                var P = o + i,
                    T = v + i;
                !0 === n ? u.push(T, T + 1, P) : u.push(T + 1, T, P), x += 3
            }
            c.addGroup(m, x, !0 === n ? 1 : 2), m += x
        }! function() {
            var o, y, g = new pn,
                x = new pn,
                b = 0,
                w = (t - e) / n;
            for (y = 0; y <= i; y++) {
                var M = [],
                    _ = y / i,
                    S = _ * (t - e) + e;
                for (o = 0; o <= r; o++) {
                    var P = o / r,
                        T = P * s + a,
                        E = Math.sin(T),
                        z = Math.cos(T);
                    x.x = S * E, x.y = -_ * n + p, x.z = S * z, l.push(x.x, x.y, x.z), g.set(E, w, z).normalize(), f.push(g.x, g.y, g.z), d.push(P, 1 - _), M.push(h++)
                }
                v.push(M)
            }
            for (o = 0; o < r; o++)
                for (y = 0; y < i; y++) {
                    var L = v[y][o],
                        A = v[y + 1][o],
                        C = v[y + 1][o + 1],
                        R = v[y][o + 1];
                    u.push(L, A, R), u.push(A, C, R), b += 6
                }
            c.addGroup(m, b, 0), m += b
        }(), !1 === o && (e > 0 && y(!0), t > 0 && y(!1)), this.setIndex(u), this.addAttribute("position", new Qr(l, 3)), this.addAttribute("normal", new Qr(f, 3)), this.addAttribute("uv", new Qr(d, 2))
    }

    function yu(e, t, n, r, i, o, a) {
        pu.call(this, 0, e, t, n, r, i, o, a), this.type = "ConeGeometry", this.parameters = {
            radius: e,
            height: t,
            radialSegments: n,
            heightSegments: r,
            openEnded: i,
            thetaStart: o,
            thetaLength: a
        }
    }

    function gu(e, t, n, r, i, o, a) {
        mu.call(this, 0, e, t, n, r, i, o, a), this.type = "ConeBufferGeometry", this.parameters = {
            radius: e,
            height: t,
            radialSegments: n,
            heightSegments: r,
            openEnded: i,
            thetaStart: o,
            thetaLength: a
        }
    }

    function xu(e, t, n, r) {
        ji.call(this), this.type = "CircleGeometry", this.parameters = {
            radius: e,
            segments: t,
            thetaStart: n,
            thetaLength: r
        }, this.fromBufferGeometry(new bu(e, t, n, r)), this.mergeVertices()
    }

    function bu(e, t, n, r) {
        ui.call(this), this.type = "CircleBufferGeometry", this.parameters = {
            radius: e,
            segments: t,
            thetaStart: n,
            thetaLength: r
        }, e = e || 1, t = void 0 !== t ? Math.max(3, t) : 8, n = void 0 !== n ? n : 0, r = void 0 !== r ? r : 2 * Math.PI;
        var i, o, a = [],
            s = [],
            c = [],
            u = [],
            l = new pn,
            f = new fn;
        for (s.push(0, 0, 0), c.push(0, 0, 1), u.push(.5, .5), o = 0, i = 3; o <= t; o++, i += 3) {
            var d = n + o / t * r;
            l.x = e * Math.cos(d), l.y = e * Math.sin(d), s.push(l.x, l.y, l.z), c.push(0, 0, 1), f.x = (s[i] / e + 1) / 2, f.y = (s[i + 1] / e + 1) / 2, u.push(f.x, f.y)
        }
        for (i = 1; i <= t; i++) a.push(i, i + 1, 0);
        this.setIndex(a), this.addAttribute("position", new Qr(s, 3)), this.addAttribute("normal", new Qr(c, 3)), this.addAttribute("uv", new Qr(u, 2))
    }
    ru.prototype = Object.create(ji.prototype), ru.prototype.constructor = ru, iu.prototype = Object.create(eu.prototype), iu.prototype.constructor = iu, ou.prototype = Object.create(ji.prototype), ou.prototype.constructor = ou, au.prototype = Object.create(ui.prototype), au.prototype.constructor = au, su.prototype = Object.create(ji.prototype), su.prototype.constructor = su, cu.prototype = Object.create(ui.prototype), cu.prototype.constructor = cu, uu.prototype = Object.create(ji.prototype), uu.prototype.constructor = uu, lu.prototype = Object.create(ui.prototype), lu.prototype.constructor = lu, fu.prototype = Object.create(ji.prototype), fu.prototype.constructor = fu, fu.prototype.toJSON = function() {
        var e = ji.prototype.toJSON.call(this);
        return hu(this.parameters.shapes, e)
    }, du.prototype = Object.create(ui.prototype), du.prototype.constructor = du, du.prototype.toJSON = function() {
        var e = ui.prototype.toJSON.call(this);
        return hu(this.parameters.shapes, e)
    }, vu.prototype = Object.create(ui.prototype), vu.prototype.constructor = vu, pu.prototype = Object.create(ji.prototype), pu.prototype.constructor = pu, mu.prototype = Object.create(ui.prototype), mu.prototype.constructor = mu, yu.prototype = Object.create(pu.prototype), yu.prototype.constructor = yu, gu.prototype = Object.create(mu.prototype), gu.prototype.constructor = gu, xu.prototype = Object.create(ji.prototype), xu.prototype.constructor = xu, bu.prototype = Object.create(ui.prototype), bu.prototype.constructor = bu;
    var wu = Object.freeze({
        WireframeGeometry: uc,
        ParametricGeometry: lc,
        ParametricBufferGeometry: fc,
        TetrahedronGeometry: vc,
        TetrahedronBufferGeometry: pc,
        OctahedronGeometry: mc,
        OctahedronBufferGeometry: yc,
        IcosahedronGeometry: gc,
        IcosahedronBufferGeometry: xc,
        DodecahedronGeometry: bc,
        DodecahedronBufferGeometry: wc,
        PolyhedronGeometry: dc,
        PolyhedronBufferGeometry: hc,
        TubeGeometry: Mc,
        TubeBufferGeometry: _c,
        TorusKnotGeometry: Sc,
        TorusKnotBufferGeometry: Pc,
        TorusGeometry: Tc,
        TorusBufferGeometry: Ec,
        TextGeometry: ru,
        TextBufferGeometry: iu,
        SphereGeometry: ou,
        SphereBufferGeometry: au,
        RingGeometry: su,
        RingBufferGeometry: cu,
        PlaneGeometry: co,
        PlaneBufferGeometry: uo,
        LatheGeometry: uu,
        LatheBufferGeometry: lu,
        ShapeGeometry: fu,
        ShapeBufferGeometry: du,
        ExtrudeGeometry: $c,
        ExtrudeBufferGeometry: eu,
        EdgesGeometry: vu,
        ConeGeometry: yu,
        ConeBufferGeometry: gu,
        CylinderGeometry: pu,
        CylinderBufferGeometry: mu,
        CircleGeometry: xu,
        CircleBufferGeometry: bu,
        BoxGeometry: Ii,
        BoxBufferGeometry: Di
    });

    function Mu(e) {
        Ur.call(this), this.type = "ShadowMaterial", this.color = new Dr(0), this.transparent = !0, this.setValues(e)
    }

    function _u(e) {
        Ui.call(this, e), this.type = "RawShaderMaterial"
    }

    function Su(e) {
        Ur.call(this), this.defines = {
            STANDARD: ""
        }, this.type = "MeshStandardMaterial", this.color = new Dr(16777215), this.roughness = .5, this.metalness = .5, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Dr(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Ut, this.normalScale = new fn(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e)
    }

    function Pu(e) {
        Su.call(this), this.defines = {
            STANDARD: "",
            PHYSICAL: ""
        }, this.type = "MeshPhysicalMaterial", this.reflectivity = .5, this.clearcoat = 0, this.clearcoatRoughness = 0, this.sheen = null, this.clearcoatNormalScale = new fn(1, 1), this.clearcoatNormalMap = null, this.transparency = 0, this.setValues(e)
    }

    function Tu(e) {
        Ur.call(this), this.type = "MeshPhongMaterial", this.color = new Dr(16777215), this.specular = new Dr(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Dr(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Ut, this.normalScale = new fn(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = ee, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e)
    }

    function Eu(e) {
        Tu.call(this), this.defines = {
            TOON: ""
        }, this.type = "MeshToonMaterial", this.gradientMap = null, this.setValues(e)
    }

    function zu(e) {
        Ur.call(this), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Ut, this.normalScale = new fn(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e)
    }

    function Lu(e) {
        Ur.call(this), this.type = "MeshLambertMaterial", this.color = new Dr(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Dr(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = ee, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e)
    }

    function Au(e) {
        Ur.call(this), this.defines = {
            MATCAP: ""
        }, this.type = "MeshMatcapMaterial", this.color = new Dr(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Ut, this.normalScale = new fn(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e)
    }

    function Cu(e) {
        Bs.call(this), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e)
    }
    Mu.prototype = Object.create(Ur.prototype), Mu.prototype.constructor = Mu, Mu.prototype.isShadowMaterial = !0, Mu.prototype.copy = function(e) {
        return Ur.prototype.copy.call(this, e), this.color.copy(e.color), this
    }, _u.prototype = Object.create(Ui.prototype), _u.prototype.constructor = _u, _u.prototype.isRawShaderMaterial = !0, Su.prototype = Object.create(Ur.prototype), Su.prototype.constructor = Su, Su.prototype.isMeshStandardMaterial = !0, Su.prototype.copy = function(e) {
        return Ur.prototype.copy.call(this, e), this.defines = {
            STANDARD: ""
        }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapIntensity = e.envMapIntensity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this
    }, Pu.prototype = Object.create(Su.prototype), Pu.prototype.constructor = Pu, Pu.prototype.isMeshPhysicalMaterial = !0, Pu.prototype.copy = function(e) {
        return Su.prototype.copy.call(this, e), this.defines = {
            STANDARD: "",
            PHYSICAL: ""
        }, this.reflectivity = e.reflectivity, this.clearcoat = e.clearcoat, this.clearcoatRoughness = e.clearcoatRoughness, e.sheen ? this.sheen = (this.sheen || new Dr).copy(e.sheen) : this.sheen = null, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.transparency = e.transparency, this
    }, Tu.prototype = Object.create(Ur.prototype), Tu.prototype.constructor = Tu, Tu.prototype.isMeshPhongMaterial = !0, Tu.prototype.copy = function(e) {
        return Ur.prototype.copy.call(this, e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this
    }, Eu.prototype = Object.create(Tu.prototype), Eu.prototype.constructor = Eu, Eu.prototype.isMeshToonMaterial = !0, Eu.prototype.copy = function(e) {
        return Tu.prototype.copy.call(this, e), this.gradientMap = e.gradientMap, this
    }, zu.prototype = Object.create(Ur.prototype), zu.prototype.constructor = zu, zu.prototype.isMeshNormalMaterial = !0, zu.prototype.copy = function(e) {
        return Ur.prototype.copy.call(this, e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this
    }, Lu.prototype = Object.create(Ur.prototype), Lu.prototype.constructor = Lu, Lu.prototype.isMeshLambertMaterial = !0, Lu.prototype.copy = function(e) {
        return Ur.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this
    }, Au.prototype = Object.create(Ur.prototype), Au.prototype.constructor = Au, Au.prototype.isMeshMatcapMaterial = !0, Au.prototype.copy = function(e) {
        return Ur.prototype.copy.call(this, e), this.defines = {
            MATCAP: ""
        }, this.color.copy(e.color), this.matcap = e.matcap, this.map = e.map, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this
    }, Cu.prototype = Object.create(Bs.prototype), Cu.prototype.constructor = Cu, Cu.prototype.isLineDashedMaterial = !0, Cu.prototype.copy = function(e) {
        return Bs.prototype.copy.call(this, e), this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this
    };
    var Ru = Object.freeze({
            ShadowMaterial: Mu,
            SpriteMaterial: ys,
            RawShaderMaterial: _u,
            ShaderMaterial: Ui,
            PointsMaterial: Qs,
            MeshPhysicalMaterial: Pu,
            MeshStandardMaterial: Su,
            MeshPhongMaterial: Tu,
            MeshToonMaterial: Eu,
            MeshNormalMaterial: zu,
            MeshLambertMaterial: Lu,
            MeshDepthMaterial: qa,
            MeshDistanceMaterial: Ka,
            MeshBasicMaterial: Hr,
            MeshMatcapMaterial: Au,
            LineDashedMaterial: Cu,
            LineBasicMaterial: Bs,
            Material: Ur
        }),
        Ou = {
            arraySlice: function(e, t, n) {
                return Ou.isTypedArray(e) ? new e.constructor(e.subarray(t, void 0 !== n ? n : e.length)) : e.slice(t, n)
            },
            convertArray: function(e, t, n) {
                return !e || !n && e.constructor === t ? e : "number" == typeof t.BYTES_PER_ELEMENT ? new t(e) : Array.prototype.slice.call(e)
            },
            isTypedArray: function(e) {
                return ArrayBuffer.isView(e) && !(e instanceof DataView)
            },
            getKeyframeOrder: function(e) {
                for (var t = e.length, n = new Array(t), r = 0; r !== t; ++r) n[r] = r;
                return n.sort((function(t, n) {
                    return e[t] - e[n]
                })), n
            },
            sortedArray: function(e, t, n) {
                for (var r = e.length, i = new e.constructor(r), o = 0, a = 0; a !== r; ++o)
                    for (var s = n[o] * t, c = 0; c !== t; ++c) i[a++] = e[s + c];
                return i
            },
            flattenJSON: function(e, t, n, r) {
                for (var i = 1, o = e[0]; void 0 !== o && void 0 === o[r];) o = e[i++];
                if (void 0 !== o) {
                    var a = o[r];
                    if (void 0 !== a)
                        if (Array.isArray(a))
                            do {
                                void 0 !== (a = o[r]) && (t.push(o.time), n.push.apply(n, a)), o = e[i++]
                            } while (void 0 !== o);
                        else if (void 0 !== a.toArray)
                        do {
                            void 0 !== (a = o[r]) && (t.push(o.time), a.toArray(n, n.length)), o = e[i++]
                        } while (void 0 !== o);
                    else
                        do {
                            void 0 !== (a = o[r]) && (t.push(o.time), n.push(a)), o = e[i++]
                        } while (void 0 !== o)
                }
            }
        };

    function ju(e, t, n, r) {
        this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = void 0 !== r ? r : new t.constructor(n), this.sampleValues = t, this.valueSize = n
    }

    function Iu(e, t, n, r) {
        ju.call(this, e, t, n, r), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0
    }

    function Du(e, t, n, r) {
        ju.call(this, e, t, n, r)
    }

    function ku(e, t, n, r) {
        ju.call(this, e, t, n, r)
    }

    function Fu(e, t, n, r) {
        if (void 0 === e) throw new Error("THREE.KeyframeTrack: track name is undefined");
        if (void 0 === t || 0 === t.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
        this.name = e, this.times = Ou.convertArray(t, this.TimeBufferType), this.values = Ou.convertArray(n, this.ValueBufferType), this.setInterpolation(r || this.DefaultInterpolation)
    }

    function Gu(e, t, n) {
        Fu.call(this, e, t, n)
    }

    function Nu(e, t, n, r) {
        Fu.call(this, e, t, n, r)
    }

    function Bu(e, t, n, r) {
        Fu.call(this, e, t, n, r)
    }

    function Uu(e, t, n, r) {
        ju.call(this, e, t, n, r)
    }

    function Hu(e, t, n, r) {
        Fu.call(this, e, t, n, r)
    }

    function Vu(e, t, n, r) {
        Fu.call(this, e, t, n, r)
    }

    function Wu(e, t, n, r) {
        Fu.call(this, e, t, n, r)
    }

    function Yu(e, t, n) {
        this.name = e, this.tracks = n, this.duration = void 0 !== t ? t : -1, this.uuid = ln.generateUUID(), this.duration < 0 && this.resetDuration()
    }

    function Xu(e) {
        if (void 0 === e.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
        var t = function(e) {
            switch (e.toLowerCase()) {
                case "scalar":
                case "double":
                case "float":
                case "number":
                case "integer":
                    return Bu;
                case "vector":
                case "vector2":
                case "vector3":
                case "vector4":
                    return Wu;
                case "color":
                    return Nu;
                case "quaternion":
                    return Hu;
                case "bool":
                case "boolean":
                    return Gu;
                case "string":
                    return Vu
            }
            throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + e)
        }(e.type);
        if (void 0 === e.times) {
            var n = [],
                r = [];
            Ou.flattenJSON(e.keys, n, r, "value"), e.times = n, e.values = r
        }
        return void 0 !== t.parse ? t.parse(e) : new t(e.name, e.times, e.values, e.interpolation)
    }
    Object.assign(ju.prototype, {
            evaluate: function(e) {
                var t = this.parameterPositions,
                    n = this._cachedIndex,
                    r = t[n],
                    i = t[n - 1];
                e: {
                    t: {
                        var o;n: {
                            r: if (!(e < r)) {
                                for (var a = n + 2;;) {
                                    if (void 0 === r) {
                                        if (e < i) break r;
                                        return n = t.length, this._cachedIndex = n, this.afterEnd_(n - 1, e, i)
                                    }
                                    if (n === a) break;
                                    if (i = r, e < (r = t[++n])) break t
                                }
                                o = t.length;
                                break n
                            }if (e >= i) break e;
                            var s = t[1];e < s && (n = 2, i = s);
                            for (a = n - 2;;) {
                                if (void 0 === i) return this._cachedIndex = 0, this.beforeStart_(0, e, r);
                                if (n === a) break;
                                if (r = i, e >= (i = t[--n - 1])) break t
                            }
                            o = n,
                            n = 0
                        }
                        for (; n < o;) {
                            var c = n + o >>> 1;
                            e < t[c] ? o = c : n = c + 1
                        }
                        if (r = t[n], void 0 === (i = t[n - 1])) return this._cachedIndex = 0, this.beforeStart_(0, e, r);
                        if (void 0 === r) return n = t.length, this._cachedIndex = n, this.afterEnd_(n - 1, i, e)
                    }
                    this._cachedIndex = n,
                    this.intervalChanged_(n, i, r)
                }
                return this.interpolate_(n, i, e, r)
            },
            settings: null,
            DefaultSettings_: {},
            getSettings_: function() {
                return this.settings || this.DefaultSettings_
            },
            copySampleValue_: function(e) {
                for (var t = this.resultBuffer, n = this.sampleValues, r = this.valueSize, i = e * r, o = 0; o !== r; ++o) t[o] = n[i + o];
                return t
            },
            interpolate_: function() {
                throw new Error("call to abstract method")
            },
            intervalChanged_: function() {}
        }),
        //!\ DECLARE ALIAS AFTER assign prototype !
        Object.assign(ju.prototype, {
            beforeStart_: ju.prototype.copySampleValue_,
            afterEnd_: ju.prototype.copySampleValue_
        }), Iu.prototype = Object.assign(Object.create(ju.prototype), {
            constructor: Iu,
            DefaultSettings_: {
                endingStart: Tt,
                endingEnd: Tt
            },
            intervalChanged_: function(e, t, n) {
                var r = this.parameterPositions,
                    i = e - 2,
                    o = e + 1,
                    a = r[i],
                    s = r[o];
                if (void 0 === a) switch (this.getSettings_().endingStart) {
                    case Et:
                        i = e, a = 2 * t - n;
                        break;
                    case zt:
                        a = t + r[i = r.length - 2] - r[i + 1];
                        break;
                    default:
                        i = e, a = n
                }
                if (void 0 === s) switch (this.getSettings_().endingEnd) {
                    case Et:
                        o = e, s = 2 * n - t;
                        break;
                    case zt:
                        o = 1, s = n + r[1] - r[0];
                        break;
                    default:
                        o = e - 1, s = t
                }
                var c = .5 * (n - t),
                    u = this.valueSize;
                this._weightPrev = c / (t - a), this._weightNext = c / (s - n), this._offsetPrev = i * u, this._offsetNext = o * u
            },
            interpolate_: function(e, t, n, r) {
                for (var i = this.resultBuffer, o = this.sampleValues, a = this.valueSize, s = e * a, c = s - a, u = this._offsetPrev, l = this._offsetNext, f = this._weightPrev, d = this._weightNext, h = (n - t) / (r - t), v = h * h, p = v * h, m = -f * p + 2 * f * v - f * h, y = (1 + f) * p + (-1.5 - 2 * f) * v + (-.5 + f) * h + 1, g = (-1 - d) * p + (1.5 + d) * v + .5 * h, x = d * p - d * v, b = 0; b !== a; ++b) i[b] = m * o[u + b] + y * o[c + b] + g * o[s + b] + x * o[l + b];
                return i
            }
        }), Du.prototype = Object.assign(Object.create(ju.prototype), {
            constructor: Du,
            interpolate_: function(e, t, n, r) {
                for (var i = this.resultBuffer, o = this.sampleValues, a = this.valueSize, s = e * a, c = s - a, u = (n - t) / (r - t), l = 1 - u, f = 0; f !== a; ++f) i[f] = o[c + f] * l + o[s + f] * u;
                return i
            }
        }), ku.prototype = Object.assign(Object.create(ju.prototype), {
            constructor: ku,
            interpolate_: function(e) {
                return this.copySampleValue_(e - 1)
            }
        }), Object.assign(Fu, {
            toJSON: function(e) {
                var t, n = e.constructor;
                if (void 0 !== n.toJSON) t = n.toJSON(e);
                else {
                    t = {
                        name: e.name,
                        times: Ou.convertArray(e.times, Array),
                        values: Ou.convertArray(e.values, Array)
                    };
                    var r = e.getInterpolation();
                    r !== e.DefaultInterpolation && (t.interpolation = r)
                }
                return t.type = e.ValueTypeName, t
            }
        }), Object.assign(Fu.prototype, {
            constructor: Fu,
            TimeBufferType: Float32Array,
            ValueBufferType: Float32Array,
            DefaultInterpolation: St,
            InterpolantFactoryMethodDiscrete: function(e) {
                return new ku(this.times, this.values, this.getValueSize(), e)
            },
            InterpolantFactoryMethodLinear: function(e) {
                return new Du(this.times, this.values, this.getValueSize(), e)
            },
            InterpolantFactoryMethodSmooth: function(e) {
                return new Iu(this.times, this.values, this.getValueSize(), e)
            },
            setInterpolation: function(e) {
                var t;
                switch (e) {
                    case _t:
                        t = this.InterpolantFactoryMethodDiscrete;
                        break;
                    case St:
                        t = this.InterpolantFactoryMethodLinear;
                        break;
                    case Pt:
                        t = this.InterpolantFactoryMethodSmooth
                }
                if (void 0 === t) {
                    var n = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                    if (void 0 === this.createInterpolant) {
                        if (e === this.DefaultInterpolation) throw new Error(n);
                        this.setInterpolation(this.DefaultInterpolation)
                    }
                    return console.warn("THREE.KeyframeTrack:", n), this
                }
                return this.createInterpolant = t, this
            },
            getInterpolation: function() {
                switch (this.createInterpolant) {
                    case this.InterpolantFactoryMethodDiscrete:
                        return _t;
                    case this.InterpolantFactoryMethodLinear:
                        return St;
                    case this.InterpolantFactoryMethodSmooth:
                        return Pt
                }
            },
            getValueSize: function() {
                return this.values.length / this.times.length
            },
            shift: function(e) {
                if (0 !== e)
                    for (var t = this.times, n = 0, r = t.length; n !== r; ++n) t[n] += e;
                return this
            },
            scale: function(e) {
                if (1 !== e)
                    for (var t = this.times, n = 0, r = t.length; n !== r; ++n) t[n] *= e;
                return this
            },
            trim: function(e, t) {
                for (var n = this.times, r = n.length, i = 0, o = r - 1; i !== r && n[i] < e;) ++i;
                for (; - 1 !== o && n[o] > t;) --o;
                if (++o, 0 !== i || o !== r) {
                    i >= o && (i = (o = Math.max(o, 1)) - 1);
                    var a = this.getValueSize();
                    this.times = Ou.arraySlice(n, i, o), this.values = Ou.arraySlice(this.values, i * a, o * a)
                }
                return this
            },
            validate: function() {
                var e = !0,
                    t = this.getValueSize();
                t - Math.floor(t) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = !1);
                var n = this.times,
                    r = this.values,
                    i = n.length;
                0 === i && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = !1);
                for (var o = null, a = 0; a !== i; a++) {
                    var s = n[a];
                    if ("number" == typeof s && isNaN(s)) {
                        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, a, s), e = !1;
                        break
                    }
                    if (null !== o && o > s) {
                        console.error("THREE.KeyframeTrack: Out of order keys.", this, a, s, o), e = !1;
                        break
                    }
                    o = s
                }
                if (void 0 !== r && Ou.isTypedArray(r)) {
                    a = 0;
                    for (var c = r.length; a !== c; ++a) {
                        var u = r[a];
                        if (isNaN(u)) {
                            console.error("THREE.KeyframeTrack: Value is not a valid number.", this, a, u), e = !1;
                            break
                        }
                    }
                }
                return e
            },
            optimize: function() {
                for (var e = this.times, t = this.values, n = this.getValueSize(), r = this.getInterpolation() === Pt, i = 1, o = e.length - 1, a = 1; a < o; ++a) {
                    var s = !1,
                        c = e[a];
                    if (c !== e[a + 1] && (1 !== a || c !== c[0]))
                        if (r) s = !0;
                        else
                            for (var u = a * n, l = u - n, f = u + n, d = 0; d !== n; ++d) {
                                var h = t[u + d];
                                if (h !== t[l + d] || h !== t[f + d]) {
                                    s = !0;
                                    break
                                }
                            }
                        if (s) {
                            if (a !== i) {
                                e[i] = e[a];
                                var v = a * n,
                                    p = i * n;
                                for (d = 0; d !== n; ++d) t[p + d] = t[v + d]
                            }++i
                        }
                }
                if (o > 0) {
                    e[i] = e[o];
                    for (v = o * n, p = i * n, d = 0; d !== n; ++d) t[p + d] = t[v + d];
                    ++i
                }
                return i !== e.length && (this.times = Ou.arraySlice(e, 0, i), this.values = Ou.arraySlice(t, 0, i * n)), this
            },
            clone: function() {
                var e = Ou.arraySlice(this.times, 0),
                    t = Ou.arraySlice(this.values, 0),
                    n = new(0, this.constructor)(this.name, e, t);
                return n.createInterpolant = this.createInterpolant, n
            }
        }), Gu.prototype = Object.assign(Object.create(Fu.prototype), {
            constructor: Gu,
            ValueTypeName: "bool",
            ValueBufferType: Array,
            DefaultInterpolation: _t,
            InterpolantFactoryMethodLinear: void 0,
            InterpolantFactoryMethodSmooth: void 0
        }), Nu.prototype = Object.assign(Object.create(Fu.prototype), {
            constructor: Nu,
            ValueTypeName: "color"
        }), Bu.prototype = Object.assign(Object.create(Fu.prototype), {
            constructor: Bu,
            ValueTypeName: "number"
        }), Uu.prototype = Object.assign(Object.create(ju.prototype), {
            constructor: Uu,
            interpolate_: function(e, t, n, r) {
                for (var i = this.resultBuffer, o = this.sampleValues, a = this.valueSize, s = e * a, c = (n - t) / (r - t), u = s + a; s !== u; s += 4) dn.slerpFlat(i, 0, o, s - a, o, s, c);
                return i
            }
        }), Hu.prototype = Object.assign(Object.create(Fu.prototype), {
            constructor: Hu,
            ValueTypeName: "quaternion",
            DefaultInterpolation: St,
            InterpolantFactoryMethodLinear: function(e) {
                return new Uu(this.times, this.values, this.getValueSize(), e)
            },
            InterpolantFactoryMethodSmooth: void 0
        }), Vu.prototype = Object.assign(Object.create(Fu.prototype), {
            constructor: Vu,
            ValueTypeName: "string",
            ValueBufferType: Array,
            DefaultInterpolation: _t,
            InterpolantFactoryMethodLinear: void 0,
            InterpolantFactoryMethodSmooth: void 0
        }), Wu.prototype = Object.assign(Object.create(Fu.prototype), {
            constructor: Wu,
            ValueTypeName: "vector"
        }), Object.assign(Yu, {
            parse: function(e) {
                for (var t = [], n = e.tracks, r = 1 / (e.fps || 1), i = 0, o = n.length; i !== o; ++i) t.push(Xu(n[i]).scale(r));
                return new Yu(e.name, e.duration, t)
            },
            toJSON: function(e) {
                for (var t = [], n = e.tracks, r = {
                        name: e.name,
                        duration: e.duration,
                        tracks: t,
                        uuid: e.uuid
                    }, i = 0, o = n.length; i !== o; ++i) t.push(Fu.toJSON(n[i]));
                return r
            },
            CreateFromMorphTargetSequence: function(e, t, n, r) {
                for (var i = t.length, o = [], a = 0; a < i; a++) {
                    var s = [],
                        c = [];
                    s.push((a + i - 1) % i, a, (a + 1) % i), c.push(0, 1, 0);
                    var u = Ou.getKeyframeOrder(s);
                    s = Ou.sortedArray(s, 1, u), c = Ou.sortedArray(c, 1, u), r || 0 !== s[0] || (s.push(i), c.push(c[0])), o.push(new Bu(".morphTargetInfluences[" + t[a].name + "]", s, c).scale(1 / n))
                }
                return new Yu(e, -1, o)
            },
            findByName: function(e, t) {
                var n = e;
                if (!Array.isArray(e)) {
                    var r = e;
                    n = r.geometry && r.geometry.animations || r.animations
                }
                for (var i = 0; i < n.length; i++)
                    if (n[i].name === t) return n[i];
                return null
            },
            CreateClipsFromMorphTargetSequences: function(e, t, n) {
                for (var r = {}, i = /^([\w-]*?)([\d]+)$/, o = 0, a = e.length; o < a; o++) {
                    var s = e[o],
                        c = s.name.match(i);
                    if (c && c.length > 1) {
                        var u = r[f = c[1]];
                        u || (r[f] = u = []), u.push(s)
                    }
                }
                var l = [];
                for (var f in r) l.push(Yu.CreateFromMorphTargetSequence(f, r[f], t, n));
                return l
            },
            parseAnimation: function(e, t) {
                if (!e) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
                for (var n = function(e, t, n, r, i) {
                        if (0 !== n.length) {
                            var o = [],
                                a = [];
                            Ou.flattenJSON(n, o, a, r), 0 !== o.length && i.push(new e(t, o, a))
                        }
                    }, r = [], i = e.name || "default", o = e.length || -1, a = e.fps || 30, s = e.hierarchy || [], c = 0; c < s.length; c++) {
                    var u = s[c].keys;
                    if (u && 0 !== u.length)
                        if (u[0].morphTargets) {
                            for (var l = {}, f = 0; f < u.length; f++)
                                if (u[f].morphTargets)
                                    for (var d = 0; d < u[f].morphTargets.length; d++) l[u[f].morphTargets[d]] = -1;
                            for (var h in l) {
                                var v = [],
                                    p = [];
                                for (d = 0; d !== u[f].morphTargets.length; ++d) {
                                    var m = u[f];
                                    v.push(m.time), p.push(m.morphTarget === h ? 1 : 0)
                                }
                                r.push(new Bu(".morphTargetInfluence[" + h + "]", v, p))
                            }
                            o = l.length * (a || 1)
                        } else {
                            var y = ".bones[" + t[c].name + "]";
                            n(Wu, y + ".position", u, "pos", r), n(Hu, y + ".quaternion", u, "rot", r), n(Wu, y + ".scale", u, "scl", r)
                        }
                }
                return 0 === r.length ? null : new Yu(i, o, r)
            }
        }), Object.assign(Yu.prototype, {
            resetDuration: function() {
                for (var e = 0, t = 0, n = this.tracks.length; t !== n; ++t) {
                    var r = this.tracks[t];
                    e = Math.max(e, r.times[r.times.length - 1])
                }
                return this.duration = e, this
            },
            trim: function() {
                for (var e = 0; e < this.tracks.length; e++) this.tracks[e].trim(0, this.duration);
                return this
            },
            validate: function() {
                for (var e = !0, t = 0; t < this.tracks.length; t++) e = e && this.tracks[t].validate();
                return e
            },
            optimize: function() {
                for (var e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
                return this
            },
            clone: function() {
                for (var e = [], t = 0; t < this.tracks.length; t++) e.push(this.tracks[t].clone());
                return new Yu(this.name, this.duration, e)
            }
        });
    var qu = {
        enabled: !1,
        files: {},
        add: function(e, t) {
            !1 !== this.enabled && (this.files[e] = t)
        },
        get: function(e) {
            if (!1 !== this.enabled) return this.files[e]
        },
        remove: function(e) {
            delete this.files[e]
        },
        clear: function() {
            this.files = {}
        }
    };

    function Ku(e, t, n) {
        var r = this,
            i = !1,
            o = 0,
            a = 0,
            s = void 0,
            c = [];
        this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = n, this.itemStart = function(e) {
            a++, !1 === i && void 0 !== r.onStart && r.onStart(e, o, a), i = !0
        }, this.itemEnd = function(e) {
            o++, void 0 !== r.onProgress && r.onProgress(e, o, a), o === a && (i = !1, void 0 !== r.onLoad && r.onLoad())
        }, this.itemError = function(e) {
            void 0 !== r.onError && r.onError(e)
        }, this.resolveURL = function(e) {
            return s ? s(e) : e
        }, this.setURLModifier = function(e) {
            return s = e, this
        }, this.addHandler = function(e, t) {
            return c.push(e, t), this
        }, this.removeHandler = function(e) {
            var t = c.indexOf(e);
            return -1 !== t && c.splice(t, 2), this
        }, this.getHandler = function(e) {
            for (var t = 0, n = c.length; t < n; t += 2) {
                var r = c[t],
                    i = c[t + 1];
                if (r.test(e)) return i
            }
            return null
        }
    }
    var Zu = new Ku;

    function Ju(e) {
        this.manager = void 0 !== e ? e : Zu, this.crossOrigin = "anonymous", this.path = "", this.resourcePath = ""
    }
    Object.assign(Ju.prototype, {
        load: function() {},
        parse: function() {},
        setCrossOrigin: function(e) {
            return this.crossOrigin = e, this
        },
        setPath: function(e) {
            return this.path = e, this
        },
        setResourcePath: function(e) {
            return this.resourcePath = e, this
        }
    });
    var Qu = {};

    function $u(e) {
        Ju.call(this, e)
    }

    function el(e) {
        Ju.call(this, e)
    }

    function tl(e) {
        Ju.call(this, e)
    }

    function nl(e) {
        Ju.call(this, e)
    }

    function rl(e) {
        Ju.call(this, e)
    }

    function il(e) {
        Ju.call(this, e)
    }

    function ol(e) {
        Ju.call(this, e)
    }

    function al() {
        this.type = "Curve", this.arcLengthDivisions = 200
    }

    function sl(e, t, n, r, i, o, a, s) {
        al.call(this), this.type = "EllipseCurve", this.aX = e || 0, this.aY = t || 0, this.xRadius = n || 1, this.yRadius = r || 1, this.aStartAngle = i || 0, this.aEndAngle = o || 2 * Math.PI, this.aClockwise = a || !1, this.aRotation = s || 0
    }

    function cl(e, t, n, r, i, o) {
        sl.call(this, e, t, n, n, r, i, o), this.type = "ArcCurve"
    }

    function ul() {
        var e = 0,
            t = 0,
            n = 0,
            r = 0;

        function i(i, o, a, s) {
            e = i, t = a, n = -3 * i + 3 * o - 2 * a - s, r = 2 * i - 2 * o + a + s
        }
        return {
            initCatmullRom: function(e, t, n, r, o) {
                i(t, n, o * (n - e), o * (r - t))
            },
            initNonuniformCatmullRom: function(e, t, n, r, o, a, s) {
                var c = (t - e) / o - (n - e) / (o + a) + (n - t) / a,
                    u = (n - t) / a - (r - t) / (a + s) + (r - n) / s;
                i(t, n, c *= a, u *= a)
            },
            calc: function(i) {
                var o = i * i;
                return e + t * i + n * o + r * (o * i)
            }
        }
    }
    $u.prototype = Object.assign(Object.create(Ju.prototype), {
        constructor: $u,
        load: function(e, t, n, r) {
            void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
            var i = this,
                o = qu.get(e);
            if (void 0 !== o) return i.manager.itemStart(e), setTimeout((function() {
                t && t(o), i.manager.itemEnd(e)
            }), 0), o;
            if (void 0 === Qu[e]) {
                var a = e.match(/^data:(.*?)(;base64)?,(.*)$/);
                if (a) {
                    var s = a[1],
                        c = !!a[2],
                        u = a[3];
                    u = decodeURIComponent(u), c && (u = atob(u));
                    try {
                        var l, f = (this.responseType || "").toLowerCase();
                        switch (f) {
                            case "arraybuffer":
                            case "blob":
                                for (var d = new Uint8Array(u.length), h = 0; h < u.length; h++) d[h] = u.charCodeAt(h);
                                l = "blob" === f ? new Blob([d.buffer], {
                                    type: s
                                }) : d.buffer;
                                break;
                            case "document":
                                var v = new DOMParser;
                                l = v.parseFromString(u, s);
                                break;
                            case "json":
                                l = JSON.parse(u);
                                break;
                            default:
                                l = u
                        }
                        setTimeout((function() {
                            t && t(l), i.manager.itemEnd(e)
                        }), 0)
                    } catch (t) {
                        setTimeout((function() {
                            r && r(t), i.manager.itemError(e), i.manager.itemEnd(e)
                        }), 0)
                    }
                } else {
                    Qu[e] = [], Qu[e].push({
                        onLoad: t,
                        onProgress: n,
                        onError: r
                    });
                    var p = new XMLHttpRequest;
                    for (var m in p.open("GET", e, !0), p.addEventListener("load", (function(t) {
                            var n = this.response;
                            qu.add(e, n);
                            var r = Qu[e];
                            if (delete Qu[e], 200 === this.status || 0 === this.status) {
                                0 === this.status && console.warn("THREE.FileLoader: HTTP Status 0 received.");
                                for (var o = 0, a = r.length; o < a; o++) {
                                    (s = r[o]).onLoad && s.onLoad(n)
                                }
                                i.manager.itemEnd(e)
                            } else {
                                for (o = 0, a = r.length; o < a; o++) {
                                    var s;
                                    (s = r[o]).onError && s.onError(t)
                                }
                                i.manager.itemError(e), i.manager.itemEnd(e)
                            }
                        }), !1), p.addEventListener("progress", (function(t) {
                            for (var n = Qu[e], r = 0, i = n.length; r < i; r++) {
                                var o = n[r];
                                o.onProgress && o.onProgress(t)
                            }
                        }), !1), p.addEventListener("error", (function(t) {
                            var n = Qu[e];
                            delete Qu[e];
                            for (var r = 0, o = n.length; r < o; r++) {
                                var a = n[r];
                                a.onError && a.onError(t)
                            }
                            i.manager.itemError(e), i.manager.itemEnd(e)
                        }), !1), p.addEventListener("abort", (function(t) {
                            var n = Qu[e];
                            delete Qu[e];
                            for (var r = 0, o = n.length; r < o; r++) {
                                var a = n[r];
                                a.onError && a.onError(t)
                            }
                            i.manager.itemError(e), i.manager.itemEnd(e)
                        }), !1), void 0 !== this.responseType && (p.responseType = this.responseType), void 0 !== this.withCredentials && (p.withCredentials = this.withCredentials), p.overrideMimeType && p.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain"), this.requestHeader) p.setRequestHeader(m, this.requestHeader[m]);
                    p.send(null)
                }
                return i.manager.itemStart(e), p
            }
            Qu[e].push({
                onLoad: t,
                onProgress: n,
                onError: r
            })
        },
        setResponseType: function(e) {
            return this.responseType = e, this
        },
        setWithCredentials: function(e) {
            return this.withCredentials = e, this
        },
        setMimeType: function(e) {
            return this.mimeType = e, this
        },
        setRequestHeader: function(e) {
            return this.requestHeader = e, this
        }
    }), el.prototype = Object.assign(Object.create(Ju.prototype), {
        constructor: el,
        load: function(e, t, n, r) {
            var i = this,
                o = new $u(i.manager);
            o.setPath(i.path), o.load(e, (function(e) {
                t(i.parse(JSON.parse(e)))
            }), n, r)
        },
        parse: function(e) {
            for (var t = [], n = 0; n < e.length; n++) {
                var r = Yu.parse(e[n]);
                t.push(r)
            }
            return t
        }
    }), tl.prototype = Object.assign(Object.create(Ju.prototype), {
        constructor: tl,
        load: function(e, t, n, r) {
            var i = this,
                o = [],
                a = new ac;
            a.image = o;
            var s = new $u(this.manager);

            function c(c) {
                s.load(e[c], (function(e) {
                    var n = i.parse(e, !0);
                    o[c] = {
                        width: n.width,
                        height: n.height,
                        format: n.format,
                        mipmaps: n.mipmaps
                    }, 6 === (u += 1) && (1 === n.mipmapCount && (a.minFilter = Pe), a.format = n.format, a.needsUpdate = !0, t && t(a))
                }), n, r)
            }
            if (s.setPath(this.path), s.setResponseType("arraybuffer"), Array.isArray(e))
                for (var u = 0, l = 0, f = e.length; l < f; ++l) c(l);
            else s.load(e, (function(e) {
                var n = i.parse(e, !0);
                if (n.isCubemap)
                    for (var r = n.mipmaps.length / n.mipmapCount, s = 0; s < r; s++) {
                        o[s] = {
                            mipmaps: []
                        };
                        for (var c = 0; c < n.mipmapCount; c++) o[s].mipmaps.push(n.mipmaps[s * n.mipmapCount + c]), o[s].format = n.format, o[s].width = n.width, o[s].height = n.height
                    } else a.image.width = n.width, a.image.height = n.height, a.mipmaps = n.mipmaps;
                1 === n.mipmapCount && (a.minFilter = Pe), a.format = n.format, a.needsUpdate = !0, t && t(a)
            }), n, r);
            return a
        }
    }), nl.prototype = Object.assign(Object.create(Ju.prototype), {
        constructor: nl,
        load: function(e, t, n, r) {
            var i = this,
                o = new Ki,
                a = new $u(this.manager);
            return a.setResponseType("arraybuffer"), a.setPath(this.path), a.load(e, (function(e) {
                var n = i.parse(e);
                n && (void 0 !== n.image ? o.image = n.image : void 0 !== n.data && (o.image.width = n.width, o.image.height = n.height, o.image.data = n.data), o.wrapS = void 0 !== n.wrapS ? n.wrapS : ge, o.wrapT = void 0 !== n.wrapT ? n.wrapT : ge, o.magFilter = void 0 !== n.magFilter ? n.magFilter : Pe, o.minFilter = void 0 !== n.minFilter ? n.minFilter : ze, o.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1, void 0 !== n.format && (o.format = n.format), void 0 !== n.type && (o.type = n.type), void 0 !== n.mipmaps && (o.mipmaps = n.mipmaps), 1 === n.mipmapCount && (o.minFilter = Pe), o.needsUpdate = !0, t && t(o, n))
            }), n, r), o
        }
    }), rl.prototype = Object.assign(Object.create(Ju.prototype), {
        constructor: rl,
        load: function(e, t, n, r) {
            void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
            var i = this,
                o = qu.get(e);
            if (void 0 !== o) return i.manager.itemStart(e), setTimeout((function() {
                t && t(o), i.manager.itemEnd(e)
            }), 0), o;
            var a = document.createElementNS("http://www.w3.org/1999/xhtml", "img");

            function s() {
                a.removeEventListener("load", s, !1), a.removeEventListener("error", c, !1), qu.add(e, this), t && t(this), i.manager.itemEnd(e)
            }

            function c(t) {
                a.removeEventListener("load", s, !1), a.removeEventListener("error", c, !1), r && r(t), i.manager.itemError(e), i.manager.itemEnd(e)
            }
            return a.addEventListener("load", s, !1), a.addEventListener("error", c, !1), "data:" !== e.substr(0, 5) && void 0 !== this.crossOrigin && (a.crossOrigin = this.crossOrigin), i.manager.itemStart(e), a.src = e, a
        }
    }), il.prototype = Object.assign(Object.create(Ju.prototype), {
        constructor: il,
        load: function(e, t, n, r) {
            var i = new Mo,
                o = new rl(this.manager);
            o.setCrossOrigin(this.crossOrigin), o.setPath(this.path);
            var a = 0;

            function s(n) {
                o.load(e[n], (function(e) {
                    i.images[n] = e, 6 === ++a && (i.needsUpdate = !0, t && t(i))
                }), void 0, r)
            }
            for (var c = 0; c < e.length; ++c) s(c);
            return i
        }
    }), ol.prototype = Object.assign(Object.create(Ju.prototype), {
        constructor: ol,
        load: function(e, t, n, r) {
            var i = new wn,
                o = new rl(this.manager);
            return o.setCrossOrigin(this.crossOrigin), o.setPath(this.path), o.load(e, (function(n) {
                i.image = n;
                var r = e.search(/\.jpe?g($|\?)/i) > 0 || 0 === e.search(/^data\:image\/jpeg/);
                i.format = r ? He : Ve, i.needsUpdate = !0, void 0 !== t && t(i)
            }), n, r), i
        }
    }), Object.assign(al.prototype, {
        getPoint: function() {
            return console.warn("THREE.Curve: .getPoint() not implemented."), null
        },
        getPointAt: function(e, t) {
            var n = this.getUtoTmapping(e);
            return this.getPoint(n, t)
        },
        getPoints: function(e) {
            void 0 === e && (e = 5);
            for (var t = [], n = 0; n <= e; n++) t.push(this.getPoint(n / e));
            return t
        },
        getSpacedPoints: function(e) {
            void 0 === e && (e = 5);
            for (var t = [], n = 0; n <= e; n++) t.push(this.getPointAt(n / e));
            return t
        },
        getLength: function() {
            var e = this.getLengths();
            return e[e.length - 1]
        },
        getLengths: function(e) {
            if (void 0 === e && (e = this.arcLengthDivisions), this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate) return this.cacheArcLengths;
            this.needsUpdate = !1;
            var t, n, r = [],
                i = this.getPoint(0),
                o = 0;
            for (r.push(0), n = 1; n <= e; n++) o += (t = this.getPoint(n / e)).distanceTo(i), r.push(o), i = t;
            return this.cacheArcLengths = r, r
        },
        updateArcLengths: function() {
            this.needsUpdate = !0, this.getLengths()
        },
        getUtoTmapping: function(e, t) {
            var n, r = this.getLengths(),
                i = 0,
                o = r.length;
            n = t || e * r[o - 1];
            for (var a, s = 0, c = o - 1; s <= c;)
                if ((a = r[i = Math.floor(s + (c - s) / 2)] - n) < 0) s = i + 1;
                else {
                    if (!(a > 0)) {
                        c = i;
                        break
                    }
                    c = i - 1
                }
            if (r[i = c] === n) return i / (o - 1);
            var u = r[i];
            return (i + (n - u) / (r[i + 1] - u)) / (o - 1)
        },
        getTangent: function(e) {
            var t = e - 1e-4,
                n = e + 1e-4;
            t < 0 && (t = 0), n > 1 && (n = 1);
            var r = this.getPoint(t);
            return this.getPoint(n).clone().sub(r).normalize()
        },
        getTangentAt: function(e) {
            var t = this.getUtoTmapping(e);
            return this.getTangent(t)
        },
        computeFrenetFrames: function(e, t) {
            var n, r, i, o = new pn,
                a = [],
                s = [],
                c = [],
                u = new pn,
                l = new Rn;
            for (n = 0; n <= e; n++) r = n / e, a[n] = this.getTangentAt(r), a[n].normalize();
            s[0] = new pn, c[0] = new pn;
            var f = Number.MAX_VALUE,
                d = Math.abs(a[0].x),
                h = Math.abs(a[0].y),
                v = Math.abs(a[0].z);
            for (d <= f && (f = d, o.set(1, 0, 0)), h <= f && (f = h, o.set(0, 1, 0)), v <= f && o.set(0, 0, 1), u.crossVectors(a[0], o).normalize(), s[0].crossVectors(a[0], u), c[0].crossVectors(a[0], s[0]), n = 1; n <= e; n++) s[n] = s[n - 1].clone(), c[n] = c[n - 1].clone(), u.crossVectors(a[n - 1], a[n]), u.length() > Number.EPSILON && (u.normalize(), i = Math.acos(ln.clamp(a[n - 1].dot(a[n]), -1, 1)), s[n].applyMatrix4(l.makeRotationAxis(u, i))), c[n].crossVectors(a[n], s[n]);
            if (!0 === t)
                for (i = Math.acos(ln.clamp(s[0].dot(s[e]), -1, 1)), i /= e, a[0].dot(u.crossVectors(s[0], s[e])) > 0 && (i = -i), n = 1; n <= e; n++) s[n].applyMatrix4(l.makeRotationAxis(a[n], i * n)), c[n].crossVectors(a[n], s[n]);
            return {
                tangents: a,
                normals: s,
                binormals: c
            }
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.arcLengthDivisions = e.arcLengthDivisions, this
        },
        toJSON: function() {
            var e = {
                metadata: {
                    version: 4.5,
                    type: "Curve",
                    generator: "Curve.toJSON"
                }
            };
            return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e
        },
        fromJSON: function(e) {
            return this.arcLengthDivisions = e.arcLengthDivisions, this
        }
    }), sl.prototype = Object.create(al.prototype), sl.prototype.constructor = sl, sl.prototype.isEllipseCurve = !0, sl.prototype.getPoint = function(e, t) {
        for (var n = t || new fn, r = 2 * Math.PI, i = this.aEndAngle - this.aStartAngle, o = Math.abs(i) < Number.EPSILON; i < 0;) i += r;
        for (; i > r;) i -= r;
        i < Number.EPSILON && (i = o ? 0 : r), !0 !== this.aClockwise || o || (i === r ? i = -r : i -= r);
        var a = this.aStartAngle + e * i,
            s = this.aX + this.xRadius * Math.cos(a),
            c = this.aY + this.yRadius * Math.sin(a);
        if (0 !== this.aRotation) {
            var u = Math.cos(this.aRotation),
                l = Math.sin(this.aRotation),
                f = s - this.aX,
                d = c - this.aY;
            s = f * u - d * l + this.aX, c = f * l + d * u + this.aY
        }
        return n.set(s, c)
    }, sl.prototype.copy = function(e) {
        return al.prototype.copy.call(this, e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this
    }, sl.prototype.toJSON = function() {
        var e = al.prototype.toJSON.call(this);
        return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e
    }, sl.prototype.fromJSON = function(e) {
        return al.prototype.fromJSON.call(this, e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this
    }, cl.prototype = Object.create(sl.prototype), cl.prototype.constructor = cl, cl.prototype.isArcCurve = !0;
    var ll = new pn,
        fl = new ul,
        dl = new ul,
        hl = new ul;

    function vl(e, t, n, r) {
        al.call(this), this.type = "CatmullRomCurve3", this.points = e || [], this.closed = t || !1, this.curveType = n || "centripetal", this.tension = r || .5
    }

    function pl(e, t, n, r, i) {
        var o = .5 * (r - t),
            a = .5 * (i - n),
            s = e * e;
        return (2 * n - 2 * r + o + a) * (e * s) + (-3 * n + 3 * r - 2 * o - a) * s + o * e + n
    }

    function ml(e, t, n, r) {
        return function(e, t) {
            var n = 1 - e;
            return n * n * t
        }(e, t) + function(e, t) {
            return 2 * (1 - e) * e * t
        }(e, n) + function(e, t) {
            return e * e * t
        }(e, r)
    }

    function yl(e, t, n, r, i) {
        return function(e, t) {
            var n = 1 - e;
            return n * n * n * t
        }(e, t) + function(e, t) {
            var n = 1 - e;
            return 3 * n * n * e * t
        }(e, n) + function(e, t) {
            return 3 * (1 - e) * e * e * t
        }(e, r) + function(e, t) {
            return e * e * e * t
        }(e, i)
    }

    function gl(e, t, n, r) {
        al.call(this), this.type = "CubicBezierCurve", this.v0 = e || new fn, this.v1 = t || new fn, this.v2 = n || new fn, this.v3 = r || new fn
    }

    function xl(e, t, n, r) {
        al.call(this), this.type = "CubicBezierCurve3", this.v0 = e || new pn, this.v1 = t || new pn, this.v2 = n || new pn, this.v3 = r || new pn
    }

    function bl(e, t) {
        al.call(this), this.type = "LineCurve", this.v1 = e || new fn, this.v2 = t || new fn
    }

    function wl(e, t) {
        al.call(this), this.type = "LineCurve3", this.v1 = e || new pn, this.v2 = t || new pn
    }

    function Ml(e, t, n) {
        al.call(this), this.type = "QuadraticBezierCurve", this.v0 = e || new fn, this.v1 = t || new fn, this.v2 = n || new fn
    }

    function _l(e, t, n) {
        al.call(this), this.type = "QuadraticBezierCurve3", this.v0 = e || new pn, this.v1 = t || new pn, this.v2 = n || new pn
    }

    function Sl(e) {
        al.call(this), this.type = "SplineCurve", this.points = e || []
    }
    vl.prototype = Object.create(al.prototype), vl.prototype.constructor = vl, vl.prototype.isCatmullRomCurve3 = !0, vl.prototype.getPoint = function(e, t) {
        var n, r, i, o, a = t || new pn,
            s = this.points,
            c = s.length,
            u = (c - (this.closed ? 0 : 1)) * e,
            l = Math.floor(u),
            f = u - l;
        if (this.closed ? l += l > 0 ? 0 : (Math.floor(Math.abs(l) / c) + 1) * c : 0 === f && l === c - 1 && (l = c - 2, f = 1), this.closed || l > 0 ? n = s[(l - 1) % c] : (ll.subVectors(s[0], s[1]).add(s[0]), n = ll), r = s[l % c], i = s[(l + 1) % c], this.closed || l + 2 < c ? o = s[(l + 2) % c] : (ll.subVectors(s[c - 1], s[c - 2]).add(s[c - 1]), o = ll), "centripetal" === this.curveType || "chordal" === this.curveType) {
            var d = "chordal" === this.curveType ? .5 : .25,
                h = Math.pow(n.distanceToSquared(r), d),
                v = Math.pow(r.distanceToSquared(i), d),
                p = Math.pow(i.distanceToSquared(o), d);
            v < 1e-4 && (v = 1), h < 1e-4 && (h = v), p < 1e-4 && (p = v), fl.initNonuniformCatmullRom(n.x, r.x, i.x, o.x, h, v, p), dl.initNonuniformCatmullRom(n.y, r.y, i.y, o.y, h, v, p), hl.initNonuniformCatmullRom(n.z, r.z, i.z, o.z, h, v, p)
        } else "catmullrom" === this.curveType && (fl.initCatmullRom(n.x, r.x, i.x, o.x, this.tension), dl.initCatmullRom(n.y, r.y, i.y, o.y, this.tension), hl.initCatmullRom(n.z, r.z, i.z, o.z, this.tension));
        return a.set(fl.calc(f), dl.calc(f), hl.calc(f)), a
    }, vl.prototype.copy = function(e) {
        al.prototype.copy.call(this, e), this.points = [];
        for (var t = 0, n = e.points.length; t < n; t++) {
            var r = e.points[t];
            this.points.push(r.clone())
        }
        return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this
    }, vl.prototype.toJSON = function() {
        var e = al.prototype.toJSON.call(this);
        e.points = [];
        for (var t = 0, n = this.points.length; t < n; t++) {
            var r = this.points[t];
            e.points.push(r.toArray())
        }
        return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e
    }, vl.prototype.fromJSON = function(e) {
        al.prototype.fromJSON.call(this, e), this.points = [];
        for (var t = 0, n = e.points.length; t < n; t++) {
            var r = e.points[t];
            this.points.push((new pn).fromArray(r))
        }
        return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this
    }, gl.prototype = Object.create(al.prototype), gl.prototype.constructor = gl, gl.prototype.isCubicBezierCurve = !0, gl.prototype.getPoint = function(e, t) {
        var n = t || new fn,
            r = this.v0,
            i = this.v1,
            o = this.v2,
            a = this.v3;
        return n.set(yl(e, r.x, i.x, o.x, a.x), yl(e, r.y, i.y, o.y, a.y)), n
    }, gl.prototype.copy = function(e) {
        return al.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this
    }, gl.prototype.toJSON = function() {
        var e = al.prototype.toJSON.call(this);
        return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e
    }, gl.prototype.fromJSON = function(e) {
        return al.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this
    }, xl.prototype = Object.create(al.prototype), xl.prototype.constructor = xl, xl.prototype.isCubicBezierCurve3 = !0, xl.prototype.getPoint = function(e, t) {
        var n = t || new pn,
            r = this.v0,
            i = this.v1,
            o = this.v2,
            a = this.v3;
        return n.set(yl(e, r.x, i.x, o.x, a.x), yl(e, r.y, i.y, o.y, a.y), yl(e, r.z, i.z, o.z, a.z)), n
    }, xl.prototype.copy = function(e) {
        return al.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this
    }, xl.prototype.toJSON = function() {
        var e = al.prototype.toJSON.call(this);
        return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e
    }, xl.prototype.fromJSON = function(e) {
        return al.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this
    }, bl.prototype = Object.create(al.prototype), bl.prototype.constructor = bl, bl.prototype.isLineCurve = !0, bl.prototype.getPoint = function(e, t) {
        var n = t || new fn;
        return 1 === e ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)), n
    }, bl.prototype.getPointAt = function(e, t) {
        return this.getPoint(e, t)
    }, bl.prototype.getTangent = function() {
        return this.v2.clone().sub(this.v1).normalize()
    }, bl.prototype.copy = function(e) {
        return al.prototype.copy.call(this, e), this.v1.copy(e.v1), this.v2.copy(e.v2), this
    }, bl.prototype.toJSON = function() {
        var e = al.prototype.toJSON.call(this);
        return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
    }, bl.prototype.fromJSON = function(e) {
        return al.prototype.fromJSON.call(this, e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    }, wl.prototype = Object.create(al.prototype), wl.prototype.constructor = wl, wl.prototype.isLineCurve3 = !0, wl.prototype.getPoint = function(e, t) {
        var n = t || new pn;
        return 1 === e ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)), n
    }, wl.prototype.getPointAt = function(e, t) {
        return this.getPoint(e, t)
    }, wl.prototype.copy = function(e) {
        return al.prototype.copy.call(this, e), this.v1.copy(e.v1), this.v2.copy(e.v2), this
    }, wl.prototype.toJSON = function() {
        var e = al.prototype.toJSON.call(this);
        return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
    }, wl.prototype.fromJSON = function(e) {
        return al.prototype.fromJSON.call(this, e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    }, Ml.prototype = Object.create(al.prototype), Ml.prototype.constructor = Ml, Ml.prototype.isQuadraticBezierCurve = !0, Ml.prototype.getPoint = function(e, t) {
        var n = t || new fn,
            r = this.v0,
            i = this.v1,
            o = this.v2;
        return n.set(ml(e, r.x, i.x, o.x), ml(e, r.y, i.y, o.y)), n
    }, Ml.prototype.copy = function(e) {
        return al.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this
    }, Ml.prototype.toJSON = function() {
        var e = al.prototype.toJSON.call(this);
        return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
    }, Ml.prototype.fromJSON = function(e) {
        return al.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    }, _l.prototype = Object.create(al.prototype), _l.prototype.constructor = _l, _l.prototype.isQuadraticBezierCurve3 = !0, _l.prototype.getPoint = function(e, t) {
        var n = t || new pn,
            r = this.v0,
            i = this.v1,
            o = this.v2;
        return n.set(ml(e, r.x, i.x, o.x), ml(e, r.y, i.y, o.y), ml(e, r.z, i.z, o.z)), n
    }, _l.prototype.copy = function(e) {
        return al.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this
    }, _l.prototype.toJSON = function() {
        var e = al.prototype.toJSON.call(this);
        return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
    }, _l.prototype.fromJSON = function(e) {
        return al.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    }, Sl.prototype = Object.create(al.prototype), Sl.prototype.constructor = Sl, Sl.prototype.isSplineCurve = !0, Sl.prototype.getPoint = function(e, t) {
        var n = t || new fn,
            r = this.points,
            i = (r.length - 1) * e,
            o = Math.floor(i),
            a = i - o,
            s = r[0 === o ? o : o - 1],
            c = r[o],
            u = r[o > r.length - 2 ? r.length - 1 : o + 1],
            l = r[o > r.length - 3 ? r.length - 1 : o + 2];
        return n.set(pl(a, s.x, c.x, u.x, l.x), pl(a, s.y, c.y, u.y, l.y)), n
    }, Sl.prototype.copy = function(e) {
        al.prototype.copy.call(this, e), this.points = [];
        for (var t = 0, n = e.points.length; t < n; t++) {
            var r = e.points[t];
            this.points.push(r.clone())
        }
        return this
    }, Sl.prototype.toJSON = function() {
        var e = al.prototype.toJSON.call(this);
        e.points = [];
        for (var t = 0, n = this.points.length; t < n; t++) {
            var r = this.points[t];
            e.points.push(r.toArray())
        }
        return e
    }, Sl.prototype.fromJSON = function(e) {
        al.prototype.fromJSON.call(this, e), this.points = [];
        for (var t = 0, n = e.points.length; t < n; t++) {
            var r = e.points[t];
            this.points.push((new fn).fromArray(r))
        }
        return this
    };
    var Pl = Object.freeze({
        ArcCurve: cl,
        CatmullRomCurve3: vl,
        CubicBezierCurve: gl,
        CubicBezierCurve3: xl,
        EllipseCurve: sl,
        LineCurve: bl,
        LineCurve3: wl,
        QuadraticBezierCurve: Ml,
        QuadraticBezierCurve3: _l,
        SplineCurve: Sl
    });

    function Tl() {
        al.call(this), this.type = "CurvePath", this.curves = [], this.autoClose = !1
    }

    function El(e) {
        Tl.call(this), this.type = "Path", this.currentPoint = new fn, e && this.setFromPoints(e)
    }

    function zl(e) {
        El.call(this, e), this.uuid = ln.generateUUID(), this.type = "Shape", this.holes = []
    }

    function Ll(e, t) {
        Zn.call(this), this.type = "Light", this.color = new Dr(e), this.intensity = void 0 !== t ? t : 1, this.receiveShadow = void 0
    }

    function Al(e, t, n) {
        Ll.call(this, e, n), this.type = "HemisphereLight", this.castShadow = void 0, this.position.copy(Zn.DefaultUp), this.updateMatrix(), this.groundColor = new Dr(t)
    }

    function Cl(e) {
        this.camera = e, this.bias = 0, this.radius = 1, this.mapSize = new fn(512, 512), this.map = null, this.mapPass = null, this.matrix = new Rn, this._frustum = new no, this._frameExtents = new fn(1, 1), this._viewportCount = 1, this._viewports = [new Mn(0, 0, 1, 1)]
    }

    function Rl() {
        Cl.call(this, new Vi(50, 1, .5, 500))
    }

    function Ol(e, t, n, r, i, o) {
        Ll.call(this, e, t), this.type = "SpotLight", this.position.copy(Zn.DefaultUp), this.updateMatrix(), this.target = new Zn, Object.defineProperty(this, "power", {
            get: function() {
                return this.intensity * Math.PI
            },
            set: function(e) {
                this.intensity = e / Math.PI
            }
        }), this.distance = void 0 !== n ? n : 0, this.angle = void 0 !== r ? r : Math.PI / 3, this.penumbra = void 0 !== i ? i : 0, this.decay = void 0 !== o ? o : 1, this.shadow = new Rl
    }

    function jl() {
        Cl.call(this, new Vi(90, 1, .5, 500)), this._frameExtents = new fn(4, 2), this._viewportCount = 6, this._viewports = [new Mn(2, 1, 1, 1), new Mn(0, 1, 1, 1), new Mn(3, 1, 1, 1), new Mn(1, 1, 1, 1), new Mn(3, 0, 1, 1), new Mn(1, 0, 1, 1)], this._cubeDirections = [new pn(1, 0, 0), new pn(-1, 0, 0), new pn(0, 0, 1), new pn(0, 0, -1), new pn(0, 1, 0), new pn(0, -1, 0)], this._cubeUps = [new pn(0, 1, 0), new pn(0, 1, 0), new pn(0, 1, 0), new pn(0, 1, 0), new pn(0, 0, 1), new pn(0, 0, -1)]
    }

    function Il(e, t, n, r) {
        Ll.call(this, e, t), this.type = "PointLight", Object.defineProperty(this, "power", {
            get: function() {
                return 4 * this.intensity * Math.PI
            },
            set: function(e) {
                this.intensity = e / (4 * Math.PI)
            }
        }), this.distance = void 0 !== n ? n : 0, this.decay = void 0 !== r ? r : 1, this.shadow = new jl
    }

    function Dl(e, t, n, r, i, o) {
        Hi.call(this), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = void 0 !== e ? e : -1, this.right = void 0 !== t ? t : 1, this.top = void 0 !== n ? n : 1, this.bottom = void 0 !== r ? r : -1, this.near = void 0 !== i ? i : .1, this.far = void 0 !== o ? o : 2e3, this.updateProjectionMatrix()
    }

    function kl() {
        Cl.call(this, new Dl(-5, 5, 5, -5, .5, 500))
    }

    function Fl(e, t) {
        Ll.call(this, e, t), this.type = "DirectionalLight", this.position.copy(Zn.DefaultUp), this.updateMatrix(), this.target = new Zn, this.shadow = new kl
    }

    function Gl(e, t) {
        Ll.call(this, e, t), this.type = "AmbientLight", this.castShadow = void 0
    }

    function Nl(e, t, n, r) {
        Ll.call(this, e, t), this.type = "RectAreaLight", this.width = void 0 !== n ? n : 10, this.height = void 0 !== r ? r : 10
    }

    function Bl(e) {
        Ju.call(this, e), this.textures = {}
    }
    Tl.prototype = Object.assign(Object.create(al.prototype), {
        constructor: Tl,
        add: function(e) {
            this.curves.push(e)
        },
        closePath: function() {
            var e = this.curves[0].getPoint(0),
                t = this.curves[this.curves.length - 1].getPoint(1);
            e.equals(t) || this.curves.push(new bl(t, e))
        },
        getPoint: function(e) {
            for (var t = e * this.getLength(), n = this.getCurveLengths(), r = 0; r < n.length;) {
                if (n[r] >= t) {
                    var i = n[r] - t,
                        o = this.curves[r],
                        a = o.getLength(),
                        s = 0 === a ? 0 : 1 - i / a;
                    return o.getPointAt(s)
                }
                r++
            }
            return null
        },
        getLength: function() {
            var e = this.getCurveLengths();
            return e[e.length - 1]
        },
        updateArcLengths: function() {
            this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths()
        },
        getCurveLengths: function() {
            if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
            for (var e = [], t = 0, n = 0, r = this.curves.length; n < r; n++) t += this.curves[n].getLength(), e.push(t);
            return this.cacheLengths = e, e
        },
        getSpacedPoints: function(e) {
            void 0 === e && (e = 40);
            for (var t = [], n = 0; n <= e; n++) t.push(this.getPoint(n / e));
            return this.autoClose && t.push(t[0]), t
        },
        getPoints: function(e) {
            e = e || 12;
            for (var t, n = [], r = 0, i = this.curves; r < i.length; r++)
                for (var o = i[r], a = o && o.isEllipseCurve ? 2 * e : o && (o.isLineCurve || o.isLineCurve3) ? 1 : o && o.isSplineCurve ? e * o.points.length : e, s = o.getPoints(a), c = 0; c < s.length; c++) {
                    var u = s[c];
                    t && t.equals(u) || (n.push(u), t = u)
                }
            return this.autoClose && n.length > 1 && !n[n.length - 1].equals(n[0]) && n.push(n[0]), n
        },
        copy: function(e) {
            al.prototype.copy.call(this, e), this.curves = [];
            for (var t = 0, n = e.curves.length; t < n; t++) {
                var r = e.curves[t];
                this.curves.push(r.clone())
            }
            return this.autoClose = e.autoClose, this
        },
        toJSON: function() {
            var e = al.prototype.toJSON.call(this);
            e.autoClose = this.autoClose, e.curves = [];
            for (var t = 0, n = this.curves.length; t < n; t++) {
                var r = this.curves[t];
                e.curves.push(r.toJSON())
            }
            return e
        },
        fromJSON: function(e) {
            al.prototype.fromJSON.call(this, e), this.autoClose = e.autoClose, this.curves = [];
            for (var t = 0, n = e.curves.length; t < n; t++) {
                var r = e.curves[t];
                this.curves.push((new Pl[r.type]).fromJSON(r))
            }
            return this
        }
    }), El.prototype = Object.assign(Object.create(Tl.prototype), {
        constructor: El,
        setFromPoints: function(e) {
            this.moveTo(e[0].x, e[0].y);
            for (var t = 1, n = e.length; t < n; t++) this.lineTo(e[t].x, e[t].y)
        },
        moveTo: function(e, t) {
            this.currentPoint.set(e, t)
        },
        lineTo: function(e, t) {
            var n = new bl(this.currentPoint.clone(), new fn(e, t));
            this.curves.push(n), this.currentPoint.set(e, t)
        },
        quadraticCurveTo: function(e, t, n, r) {
            var i = new Ml(this.currentPoint.clone(), new fn(e, t), new fn(n, r));
            this.curves.push(i), this.currentPoint.set(n, r)
        },
        bezierCurveTo: function(e, t, n, r, i, o) {
            var a = new gl(this.currentPoint.clone(), new fn(e, t), new fn(n, r), new fn(i, o));
            this.curves.push(a), this.currentPoint.set(i, o)
        },
        splineThru: function(e) {
            var t = new Sl([this.currentPoint.clone()].concat(e));
            this.curves.push(t), this.currentPoint.copy(e[e.length - 1])
        },
        arc: function(e, t, n, r, i, o) {
            var a = this.currentPoint.x,
                s = this.currentPoint.y;
            this.absarc(e + a, t + s, n, r, i, o)
        },
        absarc: function(e, t, n, r, i, o) {
            this.absellipse(e, t, n, n, r, i, o)
        },
        ellipse: function(e, t, n, r, i, o, a, s) {
            var c = this.currentPoint.x,
                u = this.currentPoint.y;
            this.absellipse(e + c, t + u, n, r, i, o, a, s)
        },
        absellipse: function(e, t, n, r, i, o, a, s) {
            var c = new sl(e, t, n, r, i, o, a, s);
            if (this.curves.length > 0) {
                var u = c.getPoint(0);
                u.equals(this.currentPoint) || this.lineTo(u.x, u.y)
            }
            this.curves.push(c);
            var l = c.getPoint(1);
            this.currentPoint.copy(l)
        },
        copy: function(e) {
            return Tl.prototype.copy.call(this, e), this.currentPoint.copy(e.currentPoint), this
        },
        toJSON: function() {
            var e = Tl.prototype.toJSON.call(this);
            return e.currentPoint = this.currentPoint.toArray(), e
        },
        fromJSON: function(e) {
            return Tl.prototype.fromJSON.call(this, e), this.currentPoint.fromArray(e.currentPoint), this
        }
    }), zl.prototype = Object.assign(Object.create(El.prototype), {
        constructor: zl,
        getPointsHoles: function(e) {
            for (var t = [], n = 0, r = this.holes.length; n < r; n++) t[n] = this.holes[n].getPoints(e);
            return t
        },
        extractPoints: function(e) {
            return {
                shape: this.getPoints(e),
                holes: this.getPointsHoles(e)
            }
        },
        copy: function(e) {
            El.prototype.copy.call(this, e), this.holes = [];
            for (var t = 0, n = e.holes.length; t < n; t++) {
                var r = e.holes[t];
                this.holes.push(r.clone())
            }
            return this
        },
        toJSON: function() {
            var e = El.prototype.toJSON.call(this);
            e.uuid = this.uuid, e.holes = [];
            for (var t = 0, n = this.holes.length; t < n; t++) {
                var r = this.holes[t];
                e.holes.push(r.toJSON())
            }
            return e
        },
        fromJSON: function(e) {
            El.prototype.fromJSON.call(this, e), this.uuid = e.uuid, this.holes = [];
            for (var t = 0, n = e.holes.length; t < n; t++) {
                var r = e.holes[t];
                this.holes.push((new El).fromJSON(r))
            }
            return this
        }
    }), Ll.prototype = Object.assign(Object.create(Zn.prototype), {
        constructor: Ll,
        isLight: !0,
        copy: function(e) {
            return Zn.prototype.copy.call(this, e), this.color.copy(e.color), this.intensity = e.intensity, this
        },
        toJSON: function(e) {
            var t = Zn.prototype.toJSON.call(this, e);
            return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, void 0 !== this.groundColor && (t.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (t.object.distance = this.distance), void 0 !== this.angle && (t.object.angle = this.angle), void 0 !== this.decay && (t.object.decay = this.decay), void 0 !== this.penumbra && (t.object.penumbra = this.penumbra), void 0 !== this.shadow && (t.object.shadow = this.shadow.toJSON()), t
        }
    }), Al.prototype = Object.assign(Object.create(Ll.prototype), {
        constructor: Al,
        isHemisphereLight: !0,
        copy: function(e) {
            return Ll.prototype.copy.call(this, e), this.groundColor.copy(e.groundColor), this
        }
    }), Object.assign(Cl.prototype, {
        _projScreenMatrix: new Rn,
        _lightPositionWorld: new pn,
        _lookTarget: new pn,
        getViewportCount: function() {
            return this._viewportCount
        },
        getFrustum: function() {
            return this._frustum
        },
        updateMatrices: function(e) {
            var t = this.camera,
                n = this.matrix,
                r = this._projScreenMatrix,
                i = this._lookTarget,
                o = this._lightPositionWorld;
            o.setFromMatrixPosition(e.matrixWorld), t.position.copy(o), i.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(i), t.updateMatrixWorld(), r.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromMatrix(r), n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), n.multiply(t.projectionMatrix), n.multiply(t.matrixWorldInverse)
        },
        getViewport: function(e) {
            return this._viewports[e]
        },
        getFrameExtents: function() {
            return this._frameExtents
        },
        copy: function(e) {
            return this.camera = e.camera.clone(), this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        toJSON: function() {
            var e = {};
            return 0 !== this.bias && (e.bias = this.bias), 1 !== this.radius && (e.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e
        }
    }), Rl.prototype = Object.assign(Object.create(Cl.prototype), {
        constructor: Rl,
        isSpotLightShadow: !0,
        updateMatrices: function(e, t, n) {
            var r = this.camera,
                i = 2 * ln.RAD2DEG * e.angle,
                o = this.mapSize.width / this.mapSize.height,
                a = e.distance || r.far;
            i === r.fov && o === r.aspect && a === r.far || (r.fov = i, r.aspect = o, r.far = a, r.updateProjectionMatrix()), Cl.prototype.updateMatrices.call(this, e, t, n)
        }
    }), Ol.prototype = Object.assign(Object.create(Ll.prototype), {
        constructor: Ol,
        isSpotLight: !0,
        copy: function(e) {
            return Ll.prototype.copy.call(this, e), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
        }
    }), jl.prototype = Object.assign(Object.create(Cl.prototype), {
        constructor: jl,
        isPointLightShadow: !0,
        updateMatrices: function(e, t, n) {
            var r = this.camera,
                i = this.matrix,
                o = this._lightPositionWorld,
                a = this._lookTarget,
                s = this._projScreenMatrix;
            o.setFromMatrixPosition(e.matrixWorld), r.position.copy(o), a.copy(r.position), a.add(this._cubeDirections[n]), r.up.copy(this._cubeUps[n]), r.lookAt(a), r.updateMatrixWorld(), i.makeTranslation(-o.x, -o.y, -o.z), s.multiplyMatrices(r.projectionMatrix, r.matrixWorldInverse), this._frustum.setFromMatrix(s)
        }
    }), Il.prototype = Object.assign(Object.create(Ll.prototype), {
        constructor: Il,
        isPointLight: !0,
        copy: function(e) {
            return Ll.prototype.copy.call(this, e), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this
        }
    }), Dl.prototype = Object.assign(Object.create(Hi.prototype), {
        constructor: Dl,
        isOrthographicCamera: !0,
        copy: function(e, t) {
            return Hi.prototype.copy.call(this, e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = null === e.view ? null : Object.assign({}, e.view), this
        },
        setViewOffset: function(e, t, n, r, i, o) {
            null === this.view && (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1
            }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = r, this.view.width = i, this.view.height = o, this.updateProjectionMatrix()
        },
        clearViewOffset: function() {
            null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
        },
        updateProjectionMatrix: function() {
            var e = (this.right - this.left) / (2 * this.zoom),
                t = (this.top - this.bottom) / (2 * this.zoom),
                n = (this.right + this.left) / 2,
                r = (this.top + this.bottom) / 2,
                i = n - e,
                o = n + e,
                a = r + t,
                s = r - t;
            if (null !== this.view && this.view.enabled) {
                var c = this.zoom / (this.view.width / this.view.fullWidth),
                    u = this.zoom / (this.view.height / this.view.fullHeight),
                    l = (this.right - this.left) / this.view.width,
                    f = (this.top - this.bottom) / this.view.height;
                o = (i += l * (this.view.offsetX / c)) + l * (this.view.width / c), s = (a -= f * (this.view.offsetY / u)) - f * (this.view.height / u)
            }
            this.projectionMatrix.makeOrthographic(i, o, a, s, this.near, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix)
        },
        toJSON: function(e) {
            var t = Zn.prototype.toJSON.call(this, e);
            return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, null !== this.view && (t.object.view = Object.assign({}, this.view)), t
        }
    }), kl.prototype = Object.assign(Object.create(Cl.prototype), {
        constructor: kl,
        isDirectionalLightShadow: !0,
        updateMatrices: function(e, t, n) {
            Cl.prototype.updateMatrices.call(this, e, t, n)
        }
    }), Fl.prototype = Object.assign(Object.create(Ll.prototype), {
        constructor: Fl,
        isDirectionalLight: !0,
        copy: function(e) {
            return Ll.prototype.copy.call(this, e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
        }
    }), Gl.prototype = Object.assign(Object.create(Ll.prototype), {
        constructor: Gl,
        isAmbientLight: !0
    }), Nl.prototype = Object.assign(Object.create(Ll.prototype), {
        constructor: Nl,
        isRectAreaLight: !0,
        copy: function(e) {
            return Ll.prototype.copy.call(this, e), this.width = e.width, this.height = e.height, this
        },
        toJSON: function(e) {
            var t = Ll.prototype.toJSON.call(this, e);
            return t.object.width = this.width, t.object.height = this.height, t
        }
    }), Bl.prototype = Object.assign(Object.create(Ju.prototype), {
        constructor: Bl,
        load: function(e, t, n, r) {
            var i = this,
                o = new $u(i.manager);
            o.setPath(i.path), o.load(e, (function(e) {
                t(i.parse(JSON.parse(e)))
            }), n, r)
        },
        parse: function(e) {
            var t = this.textures;

            function n(e) {
                return void 0 === t[e] && console.warn("THREE.MaterialLoader: Undefined texture", e), t[e]
            }
            var r = new Ru[e.type];
            if (void 0 !== e.uuid && (r.uuid = e.uuid), void 0 !== e.name && (r.name = e.name), void 0 !== e.color && r.color.setHex(e.color), void 0 !== e.roughness && (r.roughness = e.roughness), void 0 !== e.metalness && (r.metalness = e.metalness), void 0 !== e.sheen && (r.sheen = (new Dr).setHex(e.sheen)), void 0 !== e.emissive && r.emissive.setHex(e.emissive), void 0 !== e.specular && r.specular.setHex(e.specular), void 0 !== e.shininess && (r.shininess = e.shininess), void 0 !== e.clearcoat && (r.clearcoat = e.clearcoat), void 0 !== e.clearcoatRoughness && (r.clearcoatRoughness = e.clearcoatRoughness), void 0 !== e.vertexColors && (r.vertexColors = e.vertexColors), void 0 !== e.fog && (r.fog = e.fog), void 0 !== e.flatShading && (r.flatShading = e.flatShading), void 0 !== e.blending && (r.blending = e.blending), void 0 !== e.combine && (r.combine = e.combine), void 0 !== e.side && (r.side = e.side), void 0 !== e.opacity && (r.opacity = e.opacity), void 0 !== e.transparent && (r.transparent = e.transparent), void 0 !== e.alphaTest && (r.alphaTest = e.alphaTest), void 0 !== e.depthTest && (r.depthTest = e.depthTest), void 0 !== e.depthWrite && (r.depthWrite = e.depthWrite), void 0 !== e.colorWrite && (r.colorWrite = e.colorWrite), void 0 !== e.stencilWrite && (r.stencilWrite = e.stencilWrite), void 0 !== e.stencilWriteMask && (r.stencilWriteMask = e.stencilWriteMask), void 0 !== e.stencilFunc && (r.stencilFunc = e.stencilFunc), void 0 !== e.stencilRef && (r.stencilRef = e.stencilRef), void 0 !== e.stencilFuncMask && (r.stencilFuncMask = e.stencilFuncMask), void 0 !== e.stencilFail && (r.stencilFail = e.stencilFail), void 0 !== e.stencilZFail && (r.stencilZFail = e.stencilZFail), void 0 !== e.stencilZPass && (r.stencilZPass = e.stencilZPass), void 0 !== e.wireframe && (r.wireframe = e.wireframe), void 0 !== e.wireframeLinewidth && (r.wireframeLinewidth = e.wireframeLinewidth), void 0 !== e.wireframeLinecap && (r.wireframeLinecap = e.wireframeLinecap), void 0 !== e.wireframeLinejoin && (r.wireframeLinejoin = e.wireframeLinejoin), void 0 !== e.rotation && (r.rotation = e.rotation), 1 !== e.linewidth && (r.linewidth = e.linewidth), void 0 !== e.dashSize && (r.dashSize = e.dashSize), void 0 !== e.gapSize && (r.gapSize = e.gapSize), void 0 !== e.scale && (r.scale = e.scale), void 0 !== e.polygonOffset && (r.polygonOffset = e.polygonOffset), void 0 !== e.polygonOffsetFactor && (r.polygonOffsetFactor = e.polygonOffsetFactor), void 0 !== e.polygonOffsetUnits && (r.polygonOffsetUnits = e.polygonOffsetUnits), void 0 !== e.skinning && (r.skinning = e.skinning), void 0 !== e.morphTargets && (r.morphTargets = e.morphTargets), void 0 !== e.morphNormals && (r.morphNormals = e.morphNormals), void 0 !== e.dithering && (r.dithering = e.dithering), void 0 !== e.visible && (r.visible = e.visible), void 0 !== e.toneMapped && (r.toneMapped = e.toneMapped), void 0 !== e.userData && (r.userData = e.userData), void 0 !== e.uniforms)
                for (var i in e.uniforms) {
                    var o = e.uniforms[i];
                    switch (r.uniforms[i] = {}, o.type) {
                        case "t":
                            r.uniforms[i].value = n(o.value);
                            break;
                        case "c":
                            r.uniforms[i].value = (new Dr).setHex(o.value);
                            break;
                        case "v2":
                            r.uniforms[i].value = (new fn).fromArray(o.value);
                            break;
                        case "v3":
                            r.uniforms[i].value = (new pn).fromArray(o.value);
                            break;
                        case "v4":
                            r.uniforms[i].value = (new Mn).fromArray(o.value);
                            break;
                        case "m3":
                            r.uniforms[i].value = (new gn).fromArray(o.value);
                        case "m4":
                            r.uniforms[i].value = (new Rn).fromArray(o.value);
                            break;
                        default:
                            r.uniforms[i].value = o.value
                    }
                }
            if (void 0 !== e.defines && (r.defines = e.defines), void 0 !== e.vertexShader && (r.vertexShader = e.vertexShader), void 0 !== e.fragmentShader && (r.fragmentShader = e.fragmentShader), void 0 !== e.extensions)
                for (var a in e.extensions) r.extensions[a] = e.extensions[a];
            if (void 0 !== e.shading && (r.flatShading = 1 === e.shading), void 0 !== e.size && (r.size = e.size), void 0 !== e.sizeAttenuation && (r.sizeAttenuation = e.sizeAttenuation), void 0 !== e.map && (r.map = n(e.map)), void 0 !== e.matcap && (r.matcap = n(e.matcap)), void 0 !== e.alphaMap && (r.alphaMap = n(e.alphaMap), r.transparent = !0), void 0 !== e.bumpMap && (r.bumpMap = n(e.bumpMap)), void 0 !== e.bumpScale && (r.bumpScale = e.bumpScale), void 0 !== e.normalMap && (r.normalMap = n(e.normalMap)), void 0 !== e.normalMapType && (r.normalMapType = e.normalMapType), void 0 !== e.normalScale) {
                var s = e.normalScale;
                !1 === Array.isArray(s) && (s = [s, s]), r.normalScale = (new fn).fromArray(s)
            }
            return void 0 !== e.displacementMap && (r.displacementMap = n(e.displacementMap)), void 0 !== e.displacementScale && (r.displacementScale = e.displacementScale), void 0 !== e.displacementBias && (r.displacementBias = e.displacementBias), void 0 !== e.roughnessMap && (r.roughnessMap = n(e.roughnessMap)), void 0 !== e.metalnessMap && (r.metalnessMap = n(e.metalnessMap)), void 0 !== e.emissiveMap && (r.emissiveMap = n(e.emissiveMap)), void 0 !== e.emissiveIntensity && (r.emissiveIntensity = e.emissiveIntensity), void 0 !== e.specularMap && (r.specularMap = n(e.specularMap)), void 0 !== e.envMap && (r.envMap = n(e.envMap)), void 0 !== e.envMapIntensity && (r.envMapIntensity = e.envMapIntensity), void 0 !== e.reflectivity && (r.reflectivity = e.reflectivity), void 0 !== e.refractionRatio && (r.refractionRatio = e.refractionRatio), void 0 !== e.lightMap && (r.lightMap = n(e.lightMap)), void 0 !== e.lightMapIntensity && (r.lightMapIntensity = e.lightMapIntensity), void 0 !== e.aoMap && (r.aoMap = n(e.aoMap)), void 0 !== e.aoMapIntensity && (r.aoMapIntensity = e.aoMapIntensity), void 0 !== e.gradientMap && (r.gradientMap = n(e.gradientMap)), void 0 !== e.clearcoatNormalMap && (r.clearcoatNormalMap = n(e.clearcoatNormalMap)), void 0 !== e.clearcoatNormalScale && (r.clearcoatNormalScale = (new fn).fromArray(e.clearcoatNormalScale)), r
        },
        setTextures: function(e) {
            return this.textures = e, this
        }
    });
    var Ul = {
        decodeText: function(e) {
            if ("undefined" != typeof TextDecoder) return (new TextDecoder).decode(e);
            for (var t = "", n = 0, r = e.length; n < r; n++) t += String.fromCharCode(e[n]);
            try {
                return decodeURIComponent(escape(t))
            } catch (e) {
                return t
            }
        },
        extractUrlBase: function(e) {
            var t = e.lastIndexOf("/");
            return -1 === t ? "./" : e.substr(0, t + 1)
        }
    };

    function Hl() {
        ui.call(this), this.type = "InstancedBufferGeometry", this.maxInstancedCount = void 0
    }

    function Vl(e, t, n, r) {
        "number" == typeof n && (r = n, n = !1, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), Vr.call(this, e, t, n), this.meshPerAttribute = r || 1
    }

    function Wl(e) {
        Ju.call(this, e)
    }
    Hl.prototype = Object.assign(Object.create(ui.prototype), {
        constructor: Hl,
        isInstancedBufferGeometry: !0,
        copy: function(e) {
            return ui.prototype.copy.call(this, e), this.maxInstancedCount = e.maxInstancedCount, this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        toJSON: function() {
            var e = ui.prototype.toJSON.call(this);
            return e.maxInstancedCount = this.maxInstancedCount, e.isInstancedBufferGeometry = !0, e
        }
    }), Vl.prototype = Object.assign(Object.create(Vr.prototype), {
        constructor: Vl,
        isInstancedBufferAttribute: !0,
        copy: function(e) {
            return Vr.prototype.copy.call(this, e), this.meshPerAttribute = e.meshPerAttribute, this
        },
        toJSON: function() {
            var e = Vr.prototype.toJSON.call(this);
            return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e
        }
    }), Wl.prototype = Object.assign(Object.create(Ju.prototype), {
        constructor: Wl,
        load: function(e, t, n, r) {
            var i = this,
                o = new $u(i.manager);
            o.setPath(i.path), o.load(e, (function(e) {
                t(i.parse(JSON.parse(e)))
            }), n, r)
        },
        parse: function(e) {
            var t = e.isInstancedBufferGeometry ? new Hl : new ui,
                n = e.data.index;
            if (void 0 !== n) {
                var r = new Yl[n.type](n.array);
                t.setIndex(new Vr(r, 1))
            }
            var i = e.data.attributes;
            for (var o in i) {
                var a = i[o],
                    s = (r = new Yl[a.type](a.array), new(a.isInstancedBufferAttribute ? Vl : Vr)(r, a.itemSize, a.normalized));
                void 0 !== a.name && (s.name = a.name), t.addAttribute(o, s)
            }
            var c = e.data.morphAttributes;
            if (c)
                for (var o in c) {
                    for (var u = c[o], l = [], f = 0, d = u.length; f < d; f++) {
                        a = u[f], s = new Vr(r = new Yl[a.type](a.array), a.itemSize, a.normalized);
                        void 0 !== a.name && (s.name = a.name), l.push(s)
                    }
                    t.morphAttributes[o] = l
                }
            var h = e.data.groups || e.data.drawcalls || e.data.offsets;
            if (void 0 !== h) {
                f = 0;
                for (var v = h.length; f !== v; ++f) {
                    var p = h[f];
                    t.addGroup(p.start, p.count, p.materialIndex)
                }
            }
            var m = e.data.boundingSphere;
            if (void 0 !== m) {
                var y = new pn;
                void 0 !== m.center && y.fromArray(m.center), t.boundingSphere = new hr(y, m.radius)
            }
            return e.name && (t.name = e.name), e.userData && (t.userData = e.userData), t
        }
    });
    var Yl = {
        Int8Array: Int8Array,
        Uint8Array: Uint8Array,
        Uint8ClampedArray: "undefined" != typeof Uint8ClampedArray ? Uint8ClampedArray : Uint8Array,
        Int16Array: Int16Array,
        Uint16Array: Uint16Array,
        Int32Array: Int32Array,
        Uint32Array: Uint32Array,
        Float32Array: Float32Array,
        Float64Array: Float64Array
    };

    function Xl(e) {
        Ju.call(this, e)
    }
    Xl.prototype = Object.assign(Object.create(Ju.prototype), {
        constructor: Xl,
        load: function(e, t, n, r) {
            var i = this,
                o = "" === this.path ? Ul.extractUrlBase(e) : this.path;
            this.resourcePath = this.resourcePath || o;
            var a = new $u(i.manager);
            a.setPath(this.path), a.load(e, (function(n) {
                var o = null;
                try {
                    o = JSON.parse(n)
                } catch (t) {
                    return void 0 !== r && r(t), void console.error("THREE:ObjectLoader: Can't parse " + e + ".", t.message)
                }
                var a = o.metadata;
                void 0 !== a && void 0 !== a.type && "geometry" !== a.type.toLowerCase() ? i.parse(o, t) : console.error("THREE.ObjectLoader: Can't load " + e)
            }), n, r)
        },
        parse: function(e, t) {
            var n = this.parseShape(e.shapes),
                r = this.parseGeometries(e.geometries, n),
                i = this.parseImages(e.images, (function() {
                    void 0 !== t && t(s)
                })),
                o = this.parseTextures(e.textures, i),
                a = this.parseMaterials(e.materials, o),
                s = this.parseObject(e.object, r, a);
            return e.animations && (s.animations = this.parseAnimations(e.animations)), void 0 !== e.images && 0 !== e.images.length || void 0 !== t && t(s), s
        },
        parseShape: function(e) {
            var t = {};
            if (void 0 !== e)
                for (var n = 0, r = e.length; n < r; n++) {
                    var i = (new zl).fromJSON(e[n]);
                    t[i.uuid] = i
                }
            return t
        },
        parseGeometries: function(e, t) {
            var n = {};
            if (void 0 !== e)
                for (var r = new Wl, i = 0, o = e.length; i < o; i++) {
                    var a, s = e[i];
                    switch (s.type) {
                        case "PlaneGeometry":
                        case "PlaneBufferGeometry":
                            a = new wu[s.type](s.width, s.height, s.widthSegments, s.heightSegments);
                            break;
                        case "BoxGeometry":
                        case "BoxBufferGeometry":
                        case "CubeGeometry":
                            a = new wu[s.type](s.width, s.height, s.depth, s.widthSegments, s.heightSegments, s.depthSegments);
                            break;
                        case "CircleGeometry":
                        case "CircleBufferGeometry":
                            a = new wu[s.type](s.radius, s.segments, s.thetaStart, s.thetaLength);
                            break;
                        case "CylinderGeometry":
                        case "CylinderBufferGeometry":
                            a = new wu[s.type](s.radiusTop, s.radiusBottom, s.height, s.radialSegments, s.heightSegments, s.openEnded, s.thetaStart, s.thetaLength);
                            break;
                        case "ConeGeometry":
                        case "ConeBufferGeometry":
                            a = new wu[s.type](s.radius, s.height, s.radialSegments, s.heightSegments, s.openEnded, s.thetaStart, s.thetaLength);
                            break;
                        case "SphereGeometry":
                        case "SphereBufferGeometry":
                            a = new wu[s.type](s.radius, s.widthSegments, s.heightSegments, s.phiStart, s.phiLength, s.thetaStart, s.thetaLength);
                            break;
                        case "DodecahedronGeometry":
                        case "DodecahedronBufferGeometry":
                        case "IcosahedronGeometry":
                        case "IcosahedronBufferGeometry":
                        case "OctahedronGeometry":
                        case "OctahedronBufferGeometry":
                        case "TetrahedronGeometry":
                        case "TetrahedronBufferGeometry":
                            a = new wu[s.type](s.radius, s.detail);
                            break;
                        case "RingGeometry":
                        case "RingBufferGeometry":
                            a = new wu[s.type](s.innerRadius, s.outerRadius, s.thetaSegments, s.phiSegments, s.thetaStart, s.thetaLength);
                            break;
                        case "TorusGeometry":
                        case "TorusBufferGeometry":
                            a = new wu[s.type](s.radius, s.tube, s.radialSegments, s.tubularSegments, s.arc);
                            break;
                        case "TorusKnotGeometry":
                        case "TorusKnotBufferGeometry":
                            a = new wu[s.type](s.radius, s.tube, s.tubularSegments, s.radialSegments, s.p, s.q);
                            break;
                        case "TubeGeometry":
                        case "TubeBufferGeometry":
                            a = new wu[s.type]((new Pl[s.path.type]).fromJSON(s.path), s.tubularSegments, s.radius, s.radialSegments, s.closed);
                            break;
                        case "LatheGeometry":
                        case "LatheBufferGeometry":
                            a = new wu[s.type](s.points, s.segments, s.phiStart, s.phiLength);
                            break;
                        case "PolyhedronGeometry":
                        case "PolyhedronBufferGeometry":
                            a = new wu[s.type](s.vertices, s.indices, s.radius, s.details);
                            break;
                        case "ShapeGeometry":
                        case "ShapeBufferGeometry":
                            for (var c = [], u = 0, l = s.shapes.length; u < l; u++) {
                                var f = t[s.shapes[u]];
                                c.push(f)
                            }
                            a = new wu[s.type](c, s.curveSegments);
                            break;
                        case "ExtrudeGeometry":
                        case "ExtrudeBufferGeometry":
                            for (c = [], u = 0, l = s.shapes.length; u < l; u++) {
                                f = t[s.shapes[u]];
                                c.push(f)
                            }
                            var d = s.options.extrudePath;
                            void 0 !== d && (s.options.extrudePath = (new Pl[d.type]).fromJSON(d)), a = new wu[s.type](c, s.options);
                            break;
                        case "BufferGeometry":
                        case "InstancedBufferGeometry":
                            a = r.parse(s);
                            break;
                        case "Geometry":
                            if ("THREE" in window && "LegacyJSONLoader" in THREE) a = (new THREE.LegacyJSONLoader).parse(s, this.resourcePath).geometry;
                            else console.error('THREE.ObjectLoader: You have to import LegacyJSONLoader in order load geometry data of type "Geometry".');
                            break;
                        default:
                            console.warn('THREE.ObjectLoader: Unsupported geometry type "' + s.type + '"');
                            continue
                    }
                    a.uuid = s.uuid, void 0 !== s.name && (a.name = s.name), !0 === a.isBufferGeometry && void 0 !== s.userData && (a.userData = s.userData), n[s.uuid] = a
                }
            return n
        },
        parseMaterials: function(e, t) {
            var n = {},
                r = {};
            if (void 0 !== e) {
                var i = new Bl;
                i.setTextures(t);
                for (var o = 0, a = e.length; o < a; o++) {
                    var s = e[o];
                    if ("MultiMaterial" === s.type) {
                        for (var c = [], u = 0; u < s.materials.length; u++) {
                            var l = s.materials[u];
                            void 0 === n[l.uuid] && (n[l.uuid] = i.parse(l)), c.push(n[l.uuid])
                        }
                        r[s.uuid] = c
                    } else void 0 === n[s.uuid] && (n[s.uuid] = i.parse(s)), r[s.uuid] = n[s.uuid]
                }
            }
            return r
        },
        parseAnimations: function(e) {
            for (var t = [], n = 0; n < e.length; n++) {
                var r = e[n],
                    i = Yu.parse(r);
                void 0 !== r.uuid && (i.uuid = r.uuid), t.push(i)
            }
            return t
        },
        parseImages: function(e, t) {
            var n = this,
                r = {};

            function i(e) {
                return n.manager.itemStart(e), o.load(e, (function() {
                    n.manager.itemEnd(e)
                }), void 0, (function() {
                    n.manager.itemError(e), n.manager.itemEnd(e)
                }))
            }
            if (void 0 !== e && e.length > 0) {
                var o = new rl(new Ku(t));
                o.setCrossOrigin(this.crossOrigin);
                for (var a = 0, s = e.length; a < s; a++) {
                    var c = e[a],
                        u = c.url;
                    if (Array.isArray(u)) {
                        r[c.uuid] = [];
                        for (var l = 0, f = u.length; l < f; l++) {
                            var d = u[l],
                                h = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(d) ? d : n.resourcePath + d;
                            r[c.uuid].push(i(h))
                        }
                    } else {
                        h = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(c.url) ? c.url : n.resourcePath + c.url;
                        r[c.uuid] = i(h)
                    }
                }
            }
            return r
        },
        parseTextures: function(e, t) {
            function n(e, t) {
                return "number" == typeof e ? e : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", e), t[e])
            }
            var r = {};
            if (void 0 !== e)
                for (var i = 0, o = e.length; i < o; i++) {
                    var a, s = e[i];
                    void 0 === s.image && console.warn('THREE.ObjectLoader: No "image" specified for', s.uuid), void 0 === t[s.image] && console.warn("THREE.ObjectLoader: Undefined image", s.image), (a = Array.isArray(t[s.image]) ? new Mo(t[s.image]) : new wn(t[s.image])).needsUpdate = !0, a.uuid = s.uuid, void 0 !== s.name && (a.name = s.name), void 0 !== s.mapping && (a.mapping = n(s.mapping, Kl)), void 0 !== s.offset && a.offset.fromArray(s.offset), void 0 !== s.repeat && a.repeat.fromArray(s.repeat), void 0 !== s.center && a.center.fromArray(s.center), void 0 !== s.rotation && (a.rotation = s.rotation), void 0 !== s.wrap && (a.wrapS = n(s.wrap[0], Zl), a.wrapT = n(s.wrap[1], Zl)), void 0 !== s.format && (a.format = s.format), void 0 !== s.type && (a.type = s.type), void 0 !== s.encoding && (a.encoding = s.encoding), void 0 !== s.minFilter && (a.minFilter = n(s.minFilter, Jl)), void 0 !== s.magFilter && (a.magFilter = n(s.magFilter, Jl)), void 0 !== s.anisotropy && (a.anisotropy = s.anisotropy), void 0 !== s.flipY && (a.flipY = s.flipY), void 0 !== s.premultiplyAlpha && (a.premultiplyAlpha = s.premultiplyAlpha), void 0 !== s.unpackAlignment && (a.unpackAlignment = s.unpackAlignment), r[s.uuid] = a
                }
            return r
        },
        parseObject: function(e, t, n) {
            var r;

            function i(e) {
                return void 0 === t[e] && console.warn("THREE.ObjectLoader: Undefined geometry", e), t[e]
            }

            function o(e) {
                if (void 0 !== e) {
                    if (Array.isArray(e)) {
                        for (var t = [], r = 0, i = e.length; r < i; r++) {
                            var o = e[r];
                            void 0 === n[o] && console.warn("THREE.ObjectLoader: Undefined material", o), t.push(n[o])
                        }
                        return t
                    }
                    return void 0 === n[e] && console.warn("THREE.ObjectLoader: Undefined material", e), n[e]
                }
            }
            switch (e.type) {
                case "Scene":
                    r = new Jn, void 0 !== e.background && Number.isInteger(e.background) && (r.background = new Dr(e.background)), void 0 !== e.fog && ("Fog" === e.fog.type ? r.fog = new vs(e.fog.color, e.fog.near, e.fog.far) : "FogExp2" === e.fog.type && (r.fog = new hs(e.fog.color, e.fog.density)));
                    break;
                case "PerspectiveCamera":
                    r = new Vi(e.fov, e.aspect, e.near, e.far), void 0 !== e.focus && (r.focus = e.focus), void 0 !== e.zoom && (r.zoom = e.zoom), void 0 !== e.filmGauge && (r.filmGauge = e.filmGauge), void 0 !== e.filmOffset && (r.filmOffset = e.filmOffset), void 0 !== e.view && (r.view = Object.assign({}, e.view));
                    break;
                case "OrthographicCamera":
                    r = new Dl(e.left, e.right, e.top, e.bottom, e.near, e.far), void 0 !== e.zoom && (r.zoom = e.zoom), void 0 !== e.view && (r.view = Object.assign({}, e.view));
                    break;
                case "AmbientLight":
                    r = new Gl(e.color, e.intensity);
                    break;
                case "DirectionalLight":
                    r = new Fl(e.color, e.intensity);
                    break;
                case "PointLight":
                    r = new Il(e.color, e.intensity, e.distance, e.decay);
                    break;
                case "RectAreaLight":
                    r = new Nl(e.color, e.intensity, e.width, e.height);
                    break;
                case "SpotLight":
                    r = new Ol(e.color, e.intensity, e.distance, e.angle, e.penumbra, e.decay);
                    break;
                case "HemisphereLight":
                    r = new Al(e.color, e.groundColor, e.intensity);
                    break;
                case "SkinnedMesh":
                    console.warn("THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.");
                case "Mesh":
                    var a = i(e.geometry),
                        s = o(e.material);
                    r = a.bones && a.bones.length > 0 ? new Is(a, s) : new Ei(a, s), void 0 !== e.drawMode && r.setDrawMode(e.drawMode);
                    break;
                case "LOD":
                    r = new js;
                    break;
                case "Line":
                    r = new Xs(i(e.geometry), o(e.material), e.mode);
                    break;
                case "LineLoop":
                    r = new Js(i(e.geometry), o(e.material));
                    break;
                case "LineSegments":
                    r = new Zs(i(e.geometry), o(e.material));
                    break;
                case "PointCloud":
                case "Points":
                    r = new rc(i(e.geometry), o(e.material));
                    break;
                case "Sprite":
                    r = new As(o(e.material));
                    break;
                case "Group":
                    r = new is;
                    break;
                default:
                    r = new Zn
            }
            if (r.uuid = e.uuid, void 0 !== e.name && (r.name = e.name), void 0 !== e.matrix ? (r.matrix.fromArray(e.matrix), void 0 !== e.matrixAutoUpdate && (r.matrixAutoUpdate = e.matrixAutoUpdate), r.matrixAutoUpdate && r.matrix.decompose(r.position, r.quaternion, r.scale)) : (void 0 !== e.position && r.position.fromArray(e.position), void 0 !== e.rotation && r.rotation.fromArray(e.rotation), void 0 !== e.quaternion && r.quaternion.fromArray(e.quaternion), void 0 !== e.scale && r.scale.fromArray(e.scale)), void 0 !== e.castShadow && (r.castShadow = e.castShadow), void 0 !== e.receiveShadow && (r.receiveShadow = e.receiveShadow), e.shadow && (void 0 !== e.shadow.bias && (r.shadow.bias = e.shadow.bias), void 0 !== e.shadow.radius && (r.shadow.radius = e.shadow.radius), void 0 !== e.shadow.mapSize && r.shadow.mapSize.fromArray(e.shadow.mapSize), void 0 !== e.shadow.camera && (r.shadow.camera = this.parseObject(e.shadow.camera))), void 0 !== e.visible && (r.visible = e.visible), void 0 !== e.frustumCulled && (r.frustumCulled = e.frustumCulled), void 0 !== e.renderOrder && (r.renderOrder = e.renderOrder), void 0 !== e.userData && (r.userData = e.userData), void 0 !== e.layers && (r.layers.mask = e.layers), void 0 !== e.children)
                for (var c = e.children, u = 0; u < c.length; u++) r.add(this.parseObject(c[u], t, n));
            if ("LOD" === e.type)
                for (var l = e.levels, f = 0; f < l.length; f++) {
                    var d = l[f],
                        h = r.getObjectByProperty("uuid", d.object);
                    void 0 !== h && r.addLevel(h, d.distance)
                }
            return r
        }
    });
    var ql, Kl = {
            UVMapping: ue,
            CubeReflectionMapping: le,
            CubeRefractionMapping: fe,
            EquirectangularReflectionMapping: de,
            EquirectangularRefractionMapping: he,
            SphericalReflectionMapping: ve,
            CubeUVReflectionMapping: pe,
            CubeUVRefractionMapping: me
        },
        Zl = {
            RepeatWrapping: ye,
            ClampToEdgeWrapping: ge,
            MirroredRepeatWrapping: xe
        },
        Jl = {
            NearestFilter: be,
            NearestMipmapNearestFilter: we,
            NearestMipmapLinearFilter: _e,
            LinearFilter: Pe,
            LinearMipmapNearestFilter: Te,
            LinearMipmapLinearFilter: ze
        };

    function Ql(e) {
        "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), Ju.call(this, e), this.options = void 0
    }

    function $l() {
        this.type = "ShapePath", this.color = new Dr, this.subPaths = [], this.currentPath = null
    }

    function ef(e) {
        this.type = "Font", this.data = e
    }

    function tf(e, t, n, r, i) {
        var o = i.glyphs[e] || i.glyphs["?"];
        if (o) {
            var a, s, c, u, l, f, d, h, v = new $l;
            if (o.o)
                for (var p = o._cachedOutline || (o._cachedOutline = o.o.split(" ")), m = 0, y = p.length; m < y;) {
                    switch (p[m++]) {
                        case "m":
                            a = p[m++] * t + n, s = p[m++] * t + r, v.moveTo(a, s);
                            break;
                        case "l":
                            a = p[m++] * t + n, s = p[m++] * t + r, v.lineTo(a, s);
                            break;
                        case "q":
                            c = p[m++] * t + n, u = p[m++] * t + r, l = p[m++] * t + n, f = p[m++] * t + r, v.quadraticCurveTo(l, f, c, u);
                            break;
                        case "b":
                            c = p[m++] * t + n, u = p[m++] * t + r, l = p[m++] * t + n, f = p[m++] * t + r, d = p[m++] * t + n, h = p[m++] * t + r, v.bezierCurveTo(l, f, d, h, c, u)
                    }
                }
            return {
                offsetX: o.ha * t,
                path: v
            }
        }
        console.error('THREE.Font: character "' + e + '" does not exists in font family ' + i.familyName + ".")
    }

    function nf(e) {
        Ju.call(this, e)
    }
    Ql.prototype = Object.assign(Object.create(Ju.prototype), {
        constructor: Ql,
        setOptions: function(e) {
            return this.options = e, this
        },
        load: function(e, t, n, r) {
            void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
            var i = this,
                o = qu.get(e);
            if (void 0 !== o) return i.manager.itemStart(e), setTimeout((function() {
                t && t(o), i.manager.itemEnd(e)
            }), 0), o;
            fetch(e).then((function(e) {
                return e.blob()
            })).then((function(e) {
                return void 0 === i.options ? createImageBitmap(e) : createImageBitmap(e, i.options)
            })).then((function(n) {
                qu.add(e, n), t && t(n), i.manager.itemEnd(e)
            })).catch((function(t) {
                r && r(t), i.manager.itemError(e), i.manager.itemEnd(e)
            })), i.manager.itemStart(e)
        }
    }), Object.assign($l.prototype, {
        moveTo: function(e, t) {
            this.currentPath = new El, this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, t)
        },
        lineTo: function(e, t) {
            this.currentPath.lineTo(e, t)
        },
        quadraticCurveTo: function(e, t, n, r) {
            this.currentPath.quadraticCurveTo(e, t, n, r)
        },
        bezierCurveTo: function(e, t, n, r, i, o) {
            this.currentPath.bezierCurveTo(e, t, n, r, i, o)
        },
        splineThru: function(e) {
            this.currentPath.splineThru(e)
        },
        toShapes: function(e, t) {
            function n(e) {
                for (var t = [], n = 0, r = e.length; n < r; n++) {
                    var i = e[n],
                        o = new zl;
                    o.curves = i.curves, t.push(o)
                }
                return t
            }

            function r(e, t) {
                for (var n = t.length, r = !1, i = n - 1, o = 0; o < n; i = o++) {
                    var a = t[i],
                        s = t[o],
                        c = s.x - a.x,
                        u = s.y - a.y;
                    if (Math.abs(u) > Number.EPSILON) {
                        if (u < 0 && (a = t[o], c = -c, s = t[i], u = -u), e.y < a.y || e.y > s.y) continue;
                        if (e.y === a.y) {
                            if (e.x === a.x) return !0
                        } else {
                            var l = u * (e.x - a.x) - c * (e.y - a.y);
                            if (0 === l) return !0;
                            if (l < 0) continue;
                            r = !r
                        }
                    } else {
                        if (e.y !== a.y) continue;
                        if (s.x <= e.x && e.x <= a.x || a.x <= e.x && e.x <= s.x) return !0
                    }
                }
                return r
            }
            var i = Zc.isClockWise,
                o = this.subPaths;
            if (0 === o.length) return [];
            if (!0 === t) return n(o);
            var a, s, c, u = [];
            if (1 === o.length) return s = o[0], (c = new zl).curves = s.curves, u.push(c), u;
            var l = !i(o[0].getPoints());
            l = e ? !l : l;
            var f, d, h = [],
                v = [],
                p = [],
                m = 0;
            v[m] = void 0, p[m] = [];
            for (var y = 0, g = o.length; y < g; y++) a = i(f = (s = o[y]).getPoints()), (a = e ? !a : a) ? (!l && v[m] && m++, v[m] = {
                s: new zl,
                p: f
            }, v[m].s.curves = s.curves, l && m++, p[m] = []) : p[m].push({
                h: s,
                p: f[0]
            });
            if (!v[0]) return n(o);
            if (v.length > 1) {
                for (var x = !1, b = [], w = 0, M = v.length; w < M; w++) h[w] = [];
                for (w = 0, M = v.length; w < M; w++)
                    for (var _ = p[w], S = 0; S < _.length; S++) {
                        for (var P = _[S], T = !0, E = 0; E < v.length; E++) r(P.p, v[E].p) && (w !== E && b.push({
                            froms: w,
                            tos: E,
                            hole: S
                        }), T ? (T = !1, h[E].push(P)) : x = !0);
                        T && h[w].push(P)
                    }
                b.length > 0 && (x || (p = h))
            }
            y = 0;
            for (var z = v.length; y < z; y++) {
                c = v[y].s, u.push(c);
                for (var L = 0, A = (d = p[y]).length; L < A; L++) c.holes.push(d[L].h)
            }
            return u
        }
    }), Object.assign(ef.prototype, {
        isFont: !0,
        generateShapes: function(e, t) {
            void 0 === t && (t = 100);
            for (var n = [], r = function(e, t, n) {
                    for (var r = Array.from ? Array.from(e) : String(e).split(""), i = t / n.resolution, o = (n.boundingBox.yMax - n.boundingBox.yMin + n.underlineThickness) * i, a = [], s = 0, c = 0, u = 0; u < r.length; u++) {
                        var l = r[u];
                        if ("\n" === l) s = 0, c -= o;
                        else {
                            var f = tf(l, i, s, c, n);
                            s += f.offsetX, a.push(f.path)
                        }
                    }
                    return a
                }(e, t, this.data), i = 0, o = r.length; i < o; i++) Array.prototype.push.apply(n, r[i].toShapes());
            return n
        }
    }), nf.prototype = Object.assign(Object.create(Ju.prototype), {
        constructor: nf,
        load: function(e, t, n, r) {
            var i = this,
                o = new $u(this.manager);
            o.setPath(this.path), o.load(e, (function(e) {
                var n;
                try {
                    n = JSON.parse(e)
                } catch (t) {
                    console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), n = JSON.parse(e.substring(65, e.length - 2))
                }
                var r = i.parse(n);
                t && t(r)
            }), n, r)
        },
        parse: function(e) {
            return new ef(e)
        }
    });
    var rf = {
        getContext: function() {
            return void 0 === ql && (ql = new(window.AudioContext || window.webkitAudioContext)), ql
        },
        setContext: function(e) {
            ql = e
        }
    };

    function of(e) {
        Ju.call(this, e)
    }

    function af() {
        this.coefficients = [];
        for (var e = 0; e < 9; e++) this.coefficients.push(new pn)
    }

    function sf(e, t) {
        Ll.call(this, void 0, t), this.sh = void 0 !== e ? e : new af
    }

    function cf(e, t, n) {
        sf.call(this, void 0, n);
        var r = (new Dr).set(e),
            i = (new Dr).set(t),
            o = new pn(r.r, r.g, r.b),
            a = new pn(i.r, i.g, i.b),
            s = Math.sqrt(Math.PI),
            c = s * Math.sqrt(.75);
        this.sh.coefficients[0].copy(o).add(a).multiplyScalar(s), this.sh.coefficients[1].copy(o).sub(a).multiplyScalar(c)
    }

    function uf(e, t) {
        sf.call(this, void 0, t);
        var n = (new Dr).set(e);
        this.sh.coefficients[0].set(n.r, n.g, n.b).multiplyScalar(2 * Math.sqrt(Math.PI))
    }
    of.prototype = Object.assign(Object.create(Ju.prototype), {
        constructor: of,
        load: function(e, t, n, r) {
            var i = new $u(this.manager);
            i.setResponseType("arraybuffer"), i.setPath(this.path), i.load(e, (function(e) {
                var n = e.slice(0);
                rf.getContext().decodeAudioData(n, (function(e) {
                    t(e)
                }))
            }), n, r)
        }
    }), Object.assign(af.prototype, {
        isSphericalHarmonics3: !0,
        set: function(e) {
            for (var t = 0; t < 9; t++) this.coefficients[t].copy(e[t]);
            return this
        },
        zero: function() {
            for (var e = 0; e < 9; e++) this.coefficients[e].set(0, 0, 0);
            return this
        },
        getAt: function(e, t) {
            var n = e.x,
                r = e.y,
                i = e.z,
                o = this.coefficients;
            return t.copy(o[0]).multiplyScalar(.282095), t.addScale(o[1], .488603 * r), t.addScale(o[2], .488603 * i), t.addScale(o[3], .488603 * n), t.addScale(o[4], n * r * 1.092548), t.addScale(o[5], r * i * 1.092548), t.addScale(o[6], .315392 * (3 * i * i - 1)), t.addScale(o[7], n * i * 1.092548), t.addScale(o[8], .546274 * (n * n - r * r)), t
        },
        getIrradianceAt: function(e, t) {
            var n = e.x,
                r = e.y,
                i = e.z,
                o = this.coefficients;
            return t.copy(o[0]).multiplyScalar(.886227), t.addScale(o[1], 1.023328 * r), t.addScale(o[2], 1.023328 * i), t.addScale(o[3], 1.023328 * n), t.addScale(o[4], .858086 * n * r), t.addScale(o[5], .858086 * r * i), t.addScale(o[6], .743125 * i * i - .247708), t.addScale(o[7], .858086 * n * i), t.addScale(o[8], .429043 * (n * n - r * r)), t
        },
        add: function(e) {
            for (var t = 0; t < 9; t++) this.coefficients[t].add(e.coefficients[t]);
            return this
        },
        scale: function(e) {
            for (var t = 0; t < 9; t++) this.coefficients[t].multiplyScalar(e);
            return this
        },
        lerp: function(e, t) {
            for (var n = 0; n < 9; n++) this.coefficients[n].lerp(e.coefficients[n], t);
            return this
        },
        equals: function(e) {
            for (var t = 0; t < 9; t++)
                if (!this.coefficients[t].equals(e.coefficients[t])) return !1;
            return !0
        },
        copy: function(e) {
            return this.set(e.coefficients)
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        fromArray: function(e, t) {
            void 0 === t && (t = 0);
            for (var n = this.coefficients, r = 0; r < 9; r++) n[r].fromArray(e, t + 3 * r);
            return this
        },
        toArray: function(e, t) {
            void 0 === e && (e = []), void 0 === t && (t = 0);
            for (var n = this.coefficients, r = 0; r < 9; r++) n[r].toArray(e, t + 3 * r);
            return e
        }
    }), Object.assign(af, {
        getBasisAt: function(e, t) {
            var n = e.x,
                r = e.y,
                i = e.z;
            t[0] = .282095, t[1] = .488603 * r, t[2] = .488603 * i, t[3] = .488603 * n, t[4] = 1.092548 * n * r, t[5] = 1.092548 * r * i, t[6] = .315392 * (3 * i * i - 1), t[7] = 1.092548 * n * i, t[8] = .546274 * (n * n - r * r)
        }
    }), sf.prototype = Object.assign(Object.create(Ll.prototype), {
        constructor: sf,
        isLightProbe: !0,
        copy: function(e) {
            return Ll.prototype.copy.call(this, e), this.sh.copy(e.sh), this.intensity = e.intensity, this
        },
        toJSON: function(e) {
            return Ll.prototype.toJSON.call(this, e)
        }
    }), cf.prototype = Object.assign(Object.create(sf.prototype), {
        constructor: cf,
        isHemisphereLightProbe: !0,
        copy: function(e) {
            return sf.prototype.copy.call(this, e), this
        },
        toJSON: function(e) {
            return sf.prototype.toJSON.call(this, e)
        }
    }), uf.prototype = Object.assign(Object.create(sf.prototype), {
        constructor: uf,
        isAmbientLightProbe: !0,
        copy: function(e) {
            return sf.prototype.copy.call(this, e), this
        },
        toJSON: function(e) {
            return sf.prototype.toJSON.call(this, e)
        }
    });
    var lf = new Rn,
        ff = new Rn;

    function df() {
        this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new Vi, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new Vi, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = {
            focus: null,
            fov: null,
            aspect: null,
            near: null,
            far: null,
            zoom: null,
            eyeSep: null
        }
    }

    function hf(e) {
        this.autoStart = void 0 === e || e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1
    }
    Object.assign(df.prototype, {
        update: function(e) {
            var t = this._cache;
            if (t.focus !== e.focus || t.fov !== e.fov || t.aspect !== e.aspect * this.aspect || t.near !== e.near || t.far !== e.far || t.zoom !== e.zoom || t.eyeSep !== this.eyeSep) {
                t.focus = e.focus, t.fov = e.fov, t.aspect = e.aspect * this.aspect, t.near = e.near, t.far = e.far, t.zoom = e.zoom, t.eyeSep = this.eyeSep;
                var n, r, i = e.projectionMatrix.clone(),
                    o = t.eyeSep / 2,
                    a = o * t.near / t.focus,
                    s = t.near * Math.tan(ln.DEG2RAD * t.fov * .5) / t.zoom;
                ff.elements[12] = -o, lf.elements[12] = o, n = -s * t.aspect + a, r = s * t.aspect + a, i.elements[0] = 2 * t.near / (r - n), i.elements[8] = (r + n) / (r - n), this.cameraL.projectionMatrix.copy(i), n = -s * t.aspect - a, r = s * t.aspect - a, i.elements[0] = 2 * t.near / (r - n), i.elements[8] = (r + n) / (r - n), this.cameraR.projectionMatrix.copy(i)
            }
            this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(ff), this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(lf)
        }
    }), Object.assign(hf.prototype, {
        start: function() {
            this.startTime = ("undefined" == typeof performance ? Date : performance).now(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0
        },
        stop: function() {
            this.getElapsedTime(), this.running = !1, this.autoStart = !1
        },
        getElapsedTime: function() {
            return this.getDelta(), this.elapsedTime
        },
        getDelta: function() {
            var e = 0;
            if (this.autoStart && !this.running) return this.start(), 0;
            if (this.running) {
                var t = ("undefined" == typeof performance ? Date : performance).now();
                e = (t - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e
            }
            return e
        }
    });
    var vf = new pn,
        pf = new dn,
        mf = new pn,
        yf = new pn;

    function gf() {
        Zn.call(this), this.type = "AudioListener", this.context = rf.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new hf
    }

    function xf(e) {
        Zn.call(this), this.type = "Audio", this.listener = e, this.context = e.context, this.gain = this.context.createGain(), this.gain.connect(e.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.startTime = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.sourceType = "empty", this.filters = []
    }
    gf.prototype = Object.assign(Object.create(Zn.prototype), {
        constructor: gf,
        getInput: function() {
            return this.gain
        },
        removeFilter: function() {
            return null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this
        },
        getFilter: function() {
            return this.filter
        },
        setFilter: function(e) {
            return null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = e, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this
        },
        getMasterVolume: function() {
            return this.gain.gain.value
        },
        setMasterVolume: function(e) {
            return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this
        },
        updateMatrixWorld: function(e) {
            Zn.prototype.updateMatrixWorld.call(this, e);
            var t = this.context.listener,
                n = this.up;
            if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(vf, pf, mf), yf.set(0, 0, -1).applyQuaternion(pf), t.positionX) {
                var r = this.context.currentTime + this.timeDelta;
                t.positionX.linearRampToValueAtTime(vf.x, r), t.positionY.linearRampToValueAtTime(vf.y, r), t.positionZ.linearRampToValueAtTime(vf.z, r), t.forwardX.linearRampToValueAtTime(yf.x, r), t.forwardY.linearRampToValueAtTime(yf.y, r), t.forwardZ.linearRampToValueAtTime(yf.z, r), t.upX.linearRampToValueAtTime(n.x, r), t.upY.linearRampToValueAtTime(n.y, r), t.upZ.linearRampToValueAtTime(n.z, r)
            } else t.setPosition(vf.x, vf.y, vf.z), t.setOrientation(yf.x, yf.y, yf.z, n.x, n.y, n.z)
        }
    }), xf.prototype = Object.assign(Object.create(Zn.prototype), {
        constructor: xf,
        getOutput: function() {
            return this.gain
        },
        setNodeSource: function(e) {
            return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = e, this.connect(), this
        },
        setMediaElementSource: function(e) {
            return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e), this.connect(), this
        },
        setMediaStreamSource: function(e) {
            return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(e), this.connect(), this
        },
        setBuffer: function(e) {
            return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), this
        },
        play: function() {
            if (!0 !== this.isPlaying) {
                if (!1 !== this.hasPlaybackControl) {
                    var e = this.context.createBufferSource();
                    return e.buffer = this.buffer, e.loop = this.loop, e.onended = this.onEnded.bind(this), this.startTime = this.context.currentTime, e.start(this.startTime, this.offset, this.duration), this.isPlaying = !0, this.source = e, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect()
                }
                console.warn("THREE.Audio: this Audio has no playback control.")
            } else console.warn("THREE.Audio: Audio is already playing.")
        },
        pause: function() {
            if (!1 !== this.hasPlaybackControl) return !0 === this.isPlaying && (this.source.stop(), this.source.onended = null, this.offset += (this.context.currentTime - this.startTime) * this.playbackRate, this.isPlaying = !1), this;
            console.warn("THREE.Audio: this Audio has no playback control.")
        },
        stop: function() {
            if (!1 !== this.hasPlaybackControl) return this.source.stop(), this.source.onended = null, this.offset = 0, this.isPlaying = !1, this;
            console.warn("THREE.Audio: this Audio has no playback control.")
        },
        connect: function() {
            if (this.filters.length > 0) {
                this.source.connect(this.filters[0]);
                for (var e = 1, t = this.filters.length; e < t; e++) this.filters[e - 1].connect(this.filters[e]);
                this.filters[this.filters.length - 1].connect(this.getOutput())
            } else this.source.connect(this.getOutput());
            return this
        },
        disconnect: function() {
            if (this.filters.length > 0) {
                this.source.disconnect(this.filters[0]);
                for (var e = 1, t = this.filters.length; e < t; e++) this.filters[e - 1].disconnect(this.filters[e]);
                this.filters[this.filters.length - 1].disconnect(this.getOutput())
            } else this.source.disconnect(this.getOutput());
            return this
        },
        getFilters: function() {
            return this.filters
        },
        setFilters: function(e) {
            return e || (e = []), !0 === this.isPlaying ? (this.disconnect(), this.filters = e, this.connect()) : this.filters = e, this
        },
        setDetune: function(e) {
            if (this.detune = e, void 0 !== this.source.detune) return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this
        },
        getDetune: function() {
            return this.detune
        },
        getFilter: function() {
            return this.getFilters()[0]
        },
        setFilter: function(e) {
            return this.setFilters(e ? [e] : [])
        },
        setPlaybackRate: function(e) {
            if (!1 !== this.hasPlaybackControl) return this.playbackRate = e, !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this;
            console.warn("THREE.Audio: this Audio has no playback control.")
        },
        getPlaybackRate: function() {
            return this.playbackRate
        },
        onEnded: function() {
            this.isPlaying = !1
        },
        getLoop: function() {
            return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop
        },
        setLoop: function(e) {
            if (!1 !== this.hasPlaybackControl) return this.loop = e, !0 === this.isPlaying && (this.source.loop = this.loop), this;
            console.warn("THREE.Audio: this Audio has no playback control.")
        },
        getVolume: function() {
            return this.gain.gain.value
        },
        setVolume: function(e) {
            return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this
        }
    });
    var bf = new pn,
        wf = new dn,
        Mf = new pn,
        _f = new pn;

    function Sf(e) {
        xf.call(this, e), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain)
    }

    function Pf(e, t) {
        this.analyser = e.context.createAnalyser(), this.analyser.fftSize = void 0 !== t ? t : 2048, this.data = new Uint8Array(this.analyser.frequencyBinCount), e.getOutput().connect(this.analyser)
    }

    function Tf(e, t, n) {
        this.binding = e, this.valueSize = n;
        var r, i = Float64Array;
        switch (t) {
            case "quaternion":
                r = this._slerp;
                break;
            case "string":
            case "bool":
                i = Array, r = this._select;
                break;
            default:
                r = this._lerp
        }
        this.buffer = new i(4 * n), this._mixBufferRegion = r, this.cumulativeWeight = 0, this.useCount = 0, this.referenceCount = 0
    }
    Sf.prototype = Object.assign(Object.create(xf.prototype), {
        constructor: Sf,
        getOutput: function() {
            return this.panner
        },
        getRefDistance: function() {
            return this.panner.refDistance
        },
        setRefDistance: function(e) {
            return this.panner.refDistance = e, this
        },
        getRolloffFactor: function() {
            return this.panner.rolloffFactor
        },
        setRolloffFactor: function(e) {
            return this.panner.rolloffFactor = e, this
        },
        getDistanceModel: function() {
            return this.panner.distanceModel
        },
        setDistanceModel: function(e) {
            return this.panner.distanceModel = e, this
        },
        getMaxDistance: function() {
            return this.panner.maxDistance
        },
        setMaxDistance: function(e) {
            return this.panner.maxDistance = e, this
        },
        setDirectionalCone: function(e, t, n) {
            return this.panner.coneInnerAngle = e, this.panner.coneOuterAngle = t, this.panner.coneOuterGain = n, this
        },
        updateMatrixWorld: function(e) {
            if (Zn.prototype.updateMatrixWorld.call(this, e), !0 !== this.hasPlaybackControl || !1 !== this.isPlaying) {
                this.matrixWorld.decompose(bf, wf, Mf), _f.set(0, 0, 1).applyQuaternion(wf);
                var t = this.panner;
                if (t.positionX) {
                    var n = this.context.currentTime + this.listener.timeDelta;
                    t.positionX.linearRampToValueAtTime(bf.x, n), t.positionY.linearRampToValueAtTime(bf.y, n), t.positionZ.linearRampToValueAtTime(bf.z, n), t.orientationX.linearRampToValueAtTime(_f.x, n), t.orientationY.linearRampToValueAtTime(_f.y, n), t.orientationZ.linearRampToValueAtTime(_f.z, n)
                } else t.setPosition(bf.x, bf.y, bf.z), t.setOrientation(_f.x, _f.y, _f.z)
            }
        }
    }), Object.assign(Pf.prototype, {
        getFrequencyData: function() {
            return this.analyser.getByteFrequencyData(this.data), this.data
        },
        getAverageFrequency: function() {
            for (var e = 0, t = this.getFrequencyData(), n = 0; n < t.length; n++) e += t[n];
            return e / t.length
        }
    }), Object.assign(Tf.prototype, {
        accumulate: function(e, t) {
            var n = this.buffer,
                r = this.valueSize,
                i = e * r + r,
                o = this.cumulativeWeight;
            if (0 === o) {
                for (var a = 0; a !== r; ++a) n[i + a] = n[a];
                o = t
            } else {
                var s = t / (o += t);
                this._mixBufferRegion(n, i, 0, s, r)
            }
            this.cumulativeWeight = o
        },
        apply: function(e) {
            var t = this.valueSize,
                n = this.buffer,
                r = e * t + t,
                i = this.cumulativeWeight,
                o = this.binding;
            if (this.cumulativeWeight = 0, i < 1) {
                var a = 3 * t;
                this._mixBufferRegion(n, r, a, 1 - i, t)
            }
            for (var s = t, c = t + t; s !== c; ++s)
                if (n[s] !== n[s + t]) {
                    o.setValue(n, r);
                    break
                }
        },
        saveOriginalState: function() {
            var e = this.binding,
                t = this.buffer,
                n = this.valueSize,
                r = 3 * n;
            e.getValue(t, r);
            for (var i = n, o = r; i !== o; ++i) t[i] = t[r + i % n];
            this.cumulativeWeight = 0
        },
        restoreOriginalState: function() {
            var e = 3 * this.valueSize;
            this.binding.setValue(this.buffer, e)
        },
        _select: function(e, t, n, r, i) {
            if (r >= .5)
                for (var o = 0; o !== i; ++o) e[t + o] = e[n + o]
        },
        _slerp: function(e, t, n, r) {
            dn.slerpFlat(e, t, e, t, e, n, r)
        },
        _lerp: function(e, t, n, r, i) {
            for (var o = 1 - r, a = 0; a !== i; ++a) {
                var s = t + a;
                e[s] = e[s] * o + e[n + a] * r
            }
        }
    });
    var Ef = new RegExp("[\\[\\]\\.:\\/]", "g"),
        zf = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]",
        Lf = /((?:WC+[\/:])*)/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
        Af = /(WCOD+)?/.source.replace("WCOD", zf),
        Cf = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
        Rf = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
        Of = new RegExp("^" + Lf + Af + Cf + Rf + "$"),
        jf = ["material", "materials", "bones"];

    function If(e, t, n) {
        var r = n || Df.parseTrackName(t);
        this._targetGroup = e, this._bindings = e.subscribe_(t, r)
    }

    function Df(e, t, n) {
        this.path = t, this.parsedPath = n || Df.parseTrackName(t), this.node = Df.findNode(e, this.parsedPath.nodeName) || e, this.rootNode = e
    }

    function kf() {
        this.uuid = ln.generateUUID(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
        var e = {};
        this._indicesByUUID = e;
        for (var t = 0, n = arguments.length; t !== n; ++t) e[arguments[t].uuid] = t;
        this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
        var r = this;
        this.stats = {
            objects: {get total() {
                    return r._objects.length
                },
                get inUse() {
                    return this.total - r.nCachedObjects_
                }
            },
            get bindingsPerObject() {
                return r._bindings.length
            }
        }
    }

    function Ff(e, t, n) {
        this._mixer = e, this._clip = t, this._localRoot = n || null;
        for (var r = t.tracks, i = r.length, o = new Array(i), a = {
                endingStart: Tt,
                endingEnd: Tt
            }, s = 0; s !== i; ++s) {
            var c = r[s].createInterpolant(null);
            o[s] = c, c.settings = a
        }
        this._interpolantSettings = a, this._interpolants = o, this._propertyBindings = new Array(i), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = wt, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0
    }

    function Gf(e) {
        this._root = e, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1
    }

    function Nf(e) {
        "string" == typeof e && (console.warn("THREE.Uniform: Type parameter is no longer needed."), e = arguments[1]), this.value = e
    }

    function Bf(e, t, n) {
        ps.call(this, e, t), this.meshPerAttribute = n || 1
    }

    function Uf(e, t, n, r) {
        this.ray = new wr(e, t), this.near = n || 0, this.far = r || 1 / 0, this.camera = null, this.params = {
            Mesh: {},
            Line: {},
            LOD: {},
            Points: {
                threshold: 1
            },
            Sprite: {}
        }, Object.defineProperties(this.params, {
            PointCloud: {
                get: function() {
                    return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."), this.Points
                }
            }
        })
    }

    function Hf(e, t) {
        return e.distance - t.distance
    }

    function Vf(e, t, n, r) {
        if (!1 !== e.visible && (e.raycast(t, n), !0 === r))
            for (var i = e.children, o = 0, a = i.length; o < a; o++) Vf(i[o], t, n, !0)
    }

    function Wf(e, t, n) {
        return this.radius = void 0 !== e ? e : 1, this.phi = void 0 !== t ? t : 0, this.theta = void 0 !== n ? n : 0, this
    }

    function Yf(e, t, n) {
        return this.radius = void 0 !== e ? e : 1, this.theta = void 0 !== t ? t : 0, this.y = void 0 !== n ? n : 0, this
    }
    Object.assign(If.prototype, {
            getValue: function(e, t) {
                this.bind();
                var n = this._targetGroup.nCachedObjects_,
                    r = this._bindings[n];
                void 0 !== r && r.getValue(e, t)
            },
            setValue: function(e, t) {
                for (var n = this._bindings, r = this._targetGroup.nCachedObjects_, i = n.length; r !== i; ++r) n[r].setValue(e, t)
            },
            bind: function() {
                for (var e = this._bindings, t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t) e[t].bind()
            },
            unbind: function() {
                for (var e = this._bindings, t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t) e[t].unbind()
            }
        }), Object.assign(Df, {
            Composite: If,
            create: function(e, t, n) {
                return e && e.isAnimationObjectGroup ? new Df.Composite(e, t, n) : new Df(e, t, n)
            },
            sanitizeNodeName: function(e) {
                return e.replace(/\s/g, "_").replace(Ef, "")
            },
            parseTrackName: function(e) {
                var t = Of.exec(e);
                if (!t) throw new Error("PropertyBinding: Cannot parse trackName: " + e);
                var n = {
                        nodeName: t[2],
                        objectName: t[3],
                        objectIndex: t[4],
                        propertyName: t[5],
                        propertyIndex: t[6]
                    },
                    r = n.nodeName && n.nodeName.lastIndexOf(".");
                if (void 0 !== r && -1 !== r) {
                    var i = n.nodeName.substring(r + 1); - 1 !== jf.indexOf(i) && (n.nodeName = n.nodeName.substring(0, r), n.objectName = i)
                }
                if (null === n.propertyName || 0 === n.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
                return n
            },
            findNode: function(e, t) {
                if (!t || "" === t || "root" === t || "." === t || -1 === t || t === e.name || t === e.uuid) return e;
                if (e.skeleton) {
                    var n = e.skeleton.getBoneByName(t);
                    if (void 0 !== n) return n
                }
                if (e.children) {
                    var r = function(e) {
                            for (var n = 0; n < e.length; n++) {
                                var i = e[n];
                                if (i.name === t || i.uuid === t) return i;
                                var o = r(i.children);
                                if (o) return o
                            }
                            return null
                        },
                        i = r(e.children);
                    if (i) return i
                }
                return null
            }
        }), Object.assign(Df.prototype, {
            _getValue_unavailable: function() {},
            _setValue_unavailable: function() {},
            BindingType: {
                Direct: 0,
                EntireArray: 1,
                ArrayElement: 2,
                HasFromToArray: 3
            },
            Versioning: {
                None: 0,
                NeedsUpdate: 1,
                MatrixWorldNeedsUpdate: 2
            },
            GetterByBindingType: [function(e, t) {
                e[t] = this.node[this.propertyName]
            }, function(e, t) {
                for (var n = this.resolvedProperty, r = 0, i = n.length; r !== i; ++r) e[t++] = n[r]
            }, function(e, t) {
                e[t] = this.resolvedProperty[this.propertyIndex]
            }, function(e, t) {
                this.resolvedProperty.toArray(e, t)
            }],
            SetterByBindingTypeAndVersioning: [
                [function(e, t) {
                    this.targetObject[this.propertyName] = e[t]
                }, function(e, t) {
                    this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = !0
                }, function(e, t) {
                    this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0
                }],
                [function(e, t) {
                    for (var n = this.resolvedProperty, r = 0, i = n.length; r !== i; ++r) n[r] = e[t++]
                }, function(e, t) {
                    for (var n = this.resolvedProperty, r = 0, i = n.length; r !== i; ++r) n[r] = e[t++];
                    this.targetObject.needsUpdate = !0
                }, function(e, t) {
                    for (var n = this.resolvedProperty, r = 0, i = n.length; r !== i; ++r) n[r] = e[t++];
                    this.targetObject.matrixWorldNeedsUpdate = !0
                }],
                [function(e, t) {
                    this.resolvedProperty[this.propertyIndex] = e[t]
                }, function(e, t) {
                    this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0
                }, function(e, t) {
                    this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0
                }],
                [function(e, t) {
                    this.resolvedProperty.fromArray(e, t)
                }, function(e, t) {
                    this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0
                }, function(e, t) {
                    this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0
                }]
            ],
            getValue: function(e, t) {
                this.bind(), this.getValue(e, t)
            },
            setValue: function(e, t) {
                this.bind(), this.setValue(e, t)
            },
            bind: function() {
                var e = this.node,
                    t = this.parsedPath,
                    n = t.objectName,
                    r = t.propertyName,
                    i = t.propertyIndex;
                if (e || (e = Df.findNode(this.rootNode, t.nodeName) || this.rootNode, this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, e) {
                    if (n) {
                        var o = t.objectIndex;
                        switch (n) {
                            case "materials":
                                if (!e.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                                if (!e.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                                e = e.material.materials;
                                break;
                            case "bones":
                                if (!e.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                                e = e.skeleton.bones;
                                for (var a = 0; a < e.length; a++)
                                    if (e[a].name === o) {
                                        o = a;
                                        break
                                    }
                                break;
                            default:
                                if (void 0 === e[n]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                                e = e[n]
                        }
                        if (void 0 !== o) {
                            if (void 0 === e[o]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
                            e = e[o]
                        }
                    }
                    var s = e[r];
                    if (void 0 !== s) {
                        var c = this.Versioning.None;
                        this.targetObject = e, void 0 !== e.needsUpdate ? c = this.Versioning.NeedsUpdate : void 0 !== e.matrixWorldNeedsUpdate && (c = this.Versioning.MatrixWorldNeedsUpdate);
                        var u = this.BindingType.Direct;
                        if (void 0 !== i) {
                            if ("morphTargetInfluences" === r) {
                                if (!e.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                                if (e.geometry.isBufferGeometry) {
                                    if (!e.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                                    for (a = 0; a < this.node.geometry.morphAttributes.position.length; a++)
                                        if (e.geometry.morphAttributes.position[a].name === i) {
                                            i = a;
                                            break
                                        }
                                } else {
                                    if (!e.geometry.morphTargets) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.", this);
                                    for (a = 0; a < this.node.geometry.morphTargets.length; a++)
                                        if (e.geometry.morphTargets[a].name === i) {
                                            i = a;
                                            break
                                        }
                                }
                            }
                            u = this.BindingType.ArrayElement, this.resolvedProperty = s, this.propertyIndex = i
                        } else void 0 !== s.fromArray && void 0 !== s.toArray ? (u = this.BindingType.HasFromToArray, this.resolvedProperty = s) : Array.isArray(s) ? (u = this.BindingType.EntireArray, this.resolvedProperty = s) : this.propertyName = r;
                        this.getValue = this.GetterByBindingType[u], this.setValue = this.SetterByBindingTypeAndVersioning[u][c]
                    } else {
                        var l = t.nodeName;
                        console.error("THREE.PropertyBinding: Trying to update property for track: " + l + "." + r + " but it wasn't found.", e)
                    }
                } else console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.")
            },
            unbind: function() {
                this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
            }
        }),
        //!\ DECLARE ALIAS AFTER assign prototype !
        Object.assign(Df.prototype, {
            _getValue_unbound: Df.prototype.getValue,
            _setValue_unbound: Df.prototype.setValue
        }), Object.assign(kf.prototype, {
            isAnimationObjectGroup: !0,
            add: function() {
                for (var e = this._objects, t = e.length, n = this.nCachedObjects_, r = this._indicesByUUID, i = this._paths, o = this._parsedPaths, a = this._bindings, s = a.length, c = void 0, u = 0, l = arguments.length; u !== l; ++u) {
                    var f = arguments[u],
                        d = f.uuid,
                        h = r[d];
                    if (void 0 === h) {
                        h = t++, r[d] = h, e.push(f);
                        for (var v = 0, p = s; v !== p; ++v) a[v].push(new Df(f, i[v], o[v]))
                    } else if (h < n) {
                        c = e[h];
                        var m = --n,
                            y = e[m];
                        r[y.uuid] = h, e[h] = y, r[d] = m, e[m] = f;
                        for (v = 0, p = s; v !== p; ++v) {
                            var g = a[v],
                                x = g[m],
                                b = g[h];
                            g[h] = x, void 0 === b && (b = new Df(f, i[v], o[v])), g[m] = b
                        }
                    } else e[h] !== c && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
                }
                this.nCachedObjects_ = n
            },
            remove: function() {
                for (var e = this._objects, t = this.nCachedObjects_, n = this._indicesByUUID, r = this._bindings, i = r.length, o = 0, a = arguments.length; o !== a; ++o) {
                    var s = arguments[o],
                        c = s.uuid,
                        u = n[c];
                    if (void 0 !== u && u >= t) {
                        var l = t++,
                            f = e[l];
                        n[f.uuid] = u, e[u] = f, n[c] = l, e[l] = s;
                        for (var d = 0, h = i; d !== h; ++d) {
                            var v = r[d],
                                p = v[l],
                                m = v[u];
                            v[u] = p, v[l] = m
                        }
                    }
                }
                this.nCachedObjects_ = t
            },
            uncache: function() {
                for (var e = this._objects, t = e.length, n = this.nCachedObjects_, r = this._indicesByUUID, i = this._bindings, o = i.length, a = 0, s = arguments.length; a !== s; ++a) {
                    var c = arguments[a],
                        u = c.uuid,
                        l = r[u];
                    if (void 0 !== l)
                        if (delete r[u], l < n) {
                            var f = --n,
                                d = e[f],
                                h = e[g = --t];
                            r[d.uuid] = l, e[l] = d, r[h.uuid] = f, e[f] = h, e.pop();
                            for (var v = 0, p = o; v !== p; ++v) {
                                var m = (x = i[v])[f],
                                    y = x[g];
                                x[l] = m, x[f] = y, x.pop()
                            }
                        } else {
                            var g;
                            r[(h = e[g = --t]).uuid] = l, e[l] = h, e.pop();
                            for (v = 0, p = o; v !== p; ++v) {
                                var x;
                                (x = i[v])[l] = x[g], x.pop()
                            }
                        }
                }
                this.nCachedObjects_ = n
            },
            subscribe_: function(e, t) {
                var n = this._bindingsIndicesByPath,
                    r = n[e],
                    i = this._bindings;
                if (void 0 !== r) return i[r];
                var o = this._paths,
                    a = this._parsedPaths,
                    s = this._objects,
                    c = s.length,
                    u = this.nCachedObjects_,
                    l = new Array(c);
                r = i.length, n[e] = r, o.push(e), a.push(t), i.push(l);
                for (var f = u, d = s.length; f !== d; ++f) {
                    var h = s[f];
                    l[f] = new Df(h, e, t)
                }
                return l
            },
            unsubscribe_: function(e) {
                var t = this._bindingsIndicesByPath,
                    n = t[e];
                if (void 0 !== n) {
                    var r = this._paths,
                        i = this._parsedPaths,
                        o = this._bindings,
                        a = o.length - 1,
                        s = o[a];
                    t[e[a]] = n, o[n] = s, o.pop(), i[n] = i[a], i.pop(), r[n] = r[a], r.pop()
                }
            }
        }), Object.assign(Ff.prototype, {
            play: function() {
                return this._mixer._activateAction(this), this
            },
            stop: function() {
                return this._mixer._deactivateAction(this), this.reset()
            },
            reset: function() {
                return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping()
            },
            isRunning: function() {
                return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
            },
            isScheduled: function() {
                return this._mixer._isActiveAction(this)
            },
            startAt: function(e) {
                return this._startTime = e, this
            },
            setLoop: function(e, t) {
                return this.loop = e, this.repetitions = t, this
            },
            setEffectiveWeight: function(e) {
                return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading()
            },
            getEffectiveWeight: function() {
                return this._effectiveWeight
            },
            fadeIn: function(e) {
                return this._scheduleFading(e, 0, 1)
            },
            fadeOut: function(e) {
                return this._scheduleFading(e, 1, 0)
            },
            crossFadeFrom: function(e, t, n) {
                if (e.fadeOut(t), this.fadeIn(t), n) {
                    var r = this._clip.duration,
                        i = e._clip.duration,
                        o = i / r,
                        a = r / i;
                    e.warp(1, o, t), this.warp(a, 1, t)
                }
                return this
            },
            crossFadeTo: function(e, t, n) {
                return e.crossFadeFrom(this, t, n)
            },
            stopFading: function() {
                var e = this._weightInterpolant;
                return null !== e && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this
            },
            setEffectiveTimeScale: function(e) {
                return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping()
            },
            getEffectiveTimeScale: function() {
                return this._effectiveTimeScale
            },
            setDuration: function(e) {
                return this.timeScale = this._clip.duration / e, this.stopWarping()
            },
            syncWith: function(e) {
                return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping()
            },
            halt: function(e) {
                return this.warp(this._effectiveTimeScale, 0, e)
            },
            warp: function(e, t, n) {
                var r = this._mixer,
                    i = r.time,
                    o = this._timeScaleInterpolant,
                    a = this.timeScale;
                null === o && (o = r._lendControlInterpolant(), this._timeScaleInterpolant = o);
                var s = o.parameterPositions,
                    c = o.sampleValues;
                return s[0] = i, s[1] = i + n, c[0] = e / a, c[1] = t / a, this
            },
            stopWarping: function() {
                var e = this._timeScaleInterpolant;
                return null !== e && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this
            },
            getMixer: function() {
                return this._mixer
            },
            getClip: function() {
                return this._clip
            },
            getRoot: function() {
                return this._localRoot || this._mixer._root
            },
            _update: function(e, t, n, r) {
                if (this.enabled) {
                    var i = this._startTime;
                    if (null !== i) {
                        var o = (e - i) * n;
                        if (o < 0 || 0 === n) return;
                        this._startTime = null, t = n * o
                    }
                    t *= this._updateTimeScale(e);
                    var a = this._updateTime(t),
                        s = this._updateWeight(e);
                    if (s > 0)
                        for (var c = this._interpolants, u = this._propertyBindings, l = 0, f = c.length; l !== f; ++l) c[l].evaluate(a), u[l].accumulate(r, s)
                } else this._updateWeight(e)
            },
            _updateWeight: function(e) {
                var t = 0;
                if (this.enabled) {
                    t = this.weight;
                    var n = this._weightInterpolant;
                    if (null !== n) {
                        var r = n.evaluate(e)[0];
                        t *= r, e > n.parameterPositions[1] && (this.stopFading(), 0 === r && (this.enabled = !1))
                    }
                }
                return this._effectiveWeight = t, t
            },
            _updateTimeScale: function(e) {
                var t = 0;
                if (!this.paused) {
                    t = this.timeScale;
                    var n = this._timeScaleInterpolant;
                    if (null !== n) t *= n.evaluate(e)[0], e > n.parameterPositions[1] && (this.stopWarping(), 0 === t ? this.paused = !0 : this.timeScale = t)
                }
                return this._effectiveTimeScale = t, t
            },
            _updateTime: function(e) {
                var t = this.time + e,
                    n = this._clip.duration,
                    r = this.loop,
                    i = this._loopCount,
                    o = r === Mt;
                if (0 === e) return -1 === i ? t : o && 1 == (1 & i) ? n - t : t;
                if (r === bt) {
                    -1 === i && (this._loopCount = 0, this._setEndings(!0, !0, !1));
                    e: {
                        if (t >= n) t = n;
                        else {
                            if (!(t < 0)) {
                                this.time = t;
                                break e
                            }
                            t = 0
                        }
                        this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                        this.time = t,
                        this._mixer.dispatchEvent({
                            type: "finished",
                            action: this,
                            direction: e < 0 ? -1 : 1
                        })
                    }
                } else {
                    if (-1 === i && (e >= 0 ? (i = 0, this._setEndings(!0, 0 === this.repetitions, o)) : this._setEndings(0 === this.repetitions, !0, o)), t >= n || t < 0) {
                        var a = Math.floor(t / n);
                        t -= n * a, i += Math.abs(a);
                        var s = this.repetitions - i;
                        if (s <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, t = e > 0 ? n : 0, this.time = t, this._mixer.dispatchEvent({
                            type: "finished",
                            action: this,
                            direction: e > 0 ? 1 : -1
                        });
                        else {
                            if (1 === s) {
                                var c = e < 0;
                                this._setEndings(c, !c, o)
                            } else this._setEndings(!1, !1, o);
                            this._loopCount = i, this.time = t, this._mixer.dispatchEvent({
                                type: "loop",
                                action: this,
                                loopDelta: a
                            })
                        }
                    } else this.time = t;
                    if (o && 1 == (1 & i)) return n - t
                }
                return t
            },
            _setEndings: function(e, t, n) {
                var r = this._interpolantSettings;
                n ? (r.endingStart = Et, r.endingEnd = Et) : (r.endingStart = e ? this.zeroSlopeAtStart ? Et : Tt : zt, r.endingEnd = t ? this.zeroSlopeAtEnd ? Et : Tt : zt)
            },
            _scheduleFading: function(e, t, n) {
                var r = this._mixer,
                    i = r.time,
                    o = this._weightInterpolant;
                null === o && (o = r._lendControlInterpolant(), this._weightInterpolant = o);
                var a = o.parameterPositions,
                    s = o.sampleValues;
                return a[0] = i, s[0] = t, a[1] = i + e, s[1] = n, this
            }
        }), Gf.prototype = Object.assign(Object.create(sn.prototype), {
            constructor: Gf,
            _bindAction: function(e, t) {
                var n = e._localRoot || this._root,
                    r = e._clip.tracks,
                    i = r.length,
                    o = e._propertyBindings,
                    a = e._interpolants,
                    s = n.uuid,
                    c = this._bindingsByRootAndName,
                    u = c[s];
                void 0 === u && (u = {}, c[s] = u);
                for (var l = 0; l !== i; ++l) {
                    var f = r[l],
                        d = f.name,
                        h = u[d];
                    if (void 0 !== h) o[l] = h;
                    else {
                        if (void 0 !== (h = o[l])) {
                            null === h._cacheIndex && (++h.referenceCount, this._addInactiveBinding(h, s, d));
                            continue
                        }
                        var v = t && t._propertyBindings[l].binding.parsedPath;
                        ++(h = new Tf(Df.create(n, d, v), f.ValueTypeName, f.getValueSize())).referenceCount, this._addInactiveBinding(h, s, d), o[l] = h
                    }
                    a[l].resultBuffer = h.buffer
                }
            },
            _activateAction: function(e) {
                if (!this._isActiveAction(e)) {
                    if (null === e._cacheIndex) {
                        var t = (e._localRoot || this._root).uuid,
                            n = e._clip.uuid,
                            r = this._actionsByClip[n];
                        this._bindAction(e, r && r.knownActions[0]), this._addInactiveAction(e, n, t)
                    }
                    for (var i = e._propertyBindings, o = 0, a = i.length; o !== a; ++o) {
                        var s = i[o];
                        0 == s.useCount++ && (this._lendBinding(s), s.saveOriginalState())
                    }
                    this._lendAction(e)
                }
            },
            _deactivateAction: function(e) {
                if (this._isActiveAction(e)) {
                    for (var t = e._propertyBindings, n = 0, r = t.length; n !== r; ++n) {
                        var i = t[n];
                        0 == --i.useCount && (i.restoreOriginalState(), this._takeBackBinding(i))
                    }
                    this._takeBackAction(e)
                }
            },
            _initMemoryManager: function() {
                this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
                var e = this;
                this.stats = {
                    actions: {get total() {
                            return e._actions.length
                        },
                        get inUse() {
                            return e._nActiveActions
                        }
                    },
                    bindings: {get total() {
                            return e._bindings.length
                        },
                        get inUse() {
                            return e._nActiveBindings
                        }
                    },
                    controlInterpolants: {get total() {
                            return e._controlInterpolants.length
                        },
                        get inUse() {
                            return e._nActiveControlInterpolants
                        }
                    }
                }
            },
            _isActiveAction: function(e) {
                var t = e._cacheIndex;
                return null !== t && t < this._nActiveActions
            },
            _addInactiveAction: function(e, t, n) {
                var r = this._actions,
                    i = this._actionsByClip,
                    o = i[t];
                if (void 0 === o) o = {
                    knownActions: [e],
                    actionByRoot: {}
                }, e._byClipCacheIndex = 0, i[t] = o;
                else {
                    var a = o.knownActions;
                    e._byClipCacheIndex = a.length, a.push(e)
                }
                e._cacheIndex = r.length, r.push(e), o.actionByRoot[n] = e
            },
            _removeInactiveAction: function(e) {
                var t = this._actions,
                    n = t[t.length - 1],
                    r = e._cacheIndex;
                n._cacheIndex = r, t[r] = n, t.pop(), e._cacheIndex = null;
                var i = e._clip.uuid,
                    o = this._actionsByClip,
                    a = o[i],
                    s = a.knownActions,
                    c = s[s.length - 1],
                    u = e._byClipCacheIndex;
                c._byClipCacheIndex = u, s[u] = c, s.pop(), e._byClipCacheIndex = null, delete a.actionByRoot[(e._localRoot || this._root).uuid], 0 === s.length && delete o[i], this._removeInactiveBindingsForAction(e)
            },
            _removeInactiveBindingsForAction: function(e) {
                for (var t = e._propertyBindings, n = 0, r = t.length; n !== r; ++n) {
                    var i = t[n];
                    0 == --i.referenceCount && this._removeInactiveBinding(i)
                }
            },
            _lendAction: function(e) {
                var t = this._actions,
                    n = e._cacheIndex,
                    r = this._nActiveActions++,
                    i = t[r];
                e._cacheIndex = r, t[r] = e, i._cacheIndex = n, t[n] = i
            },
            _takeBackAction: function(e) {
                var t = this._actions,
                    n = e._cacheIndex,
                    r = --this._nActiveActions,
                    i = t[r];
                e._cacheIndex = r, t[r] = e, i._cacheIndex = n, t[n] = i
            },
            _addInactiveBinding: function(e, t, n) {
                var r = this._bindingsByRootAndName,
                    i = r[t],
                    o = this._bindings;
                void 0 === i && (i = {}, r[t] = i), i[n] = e, e._cacheIndex = o.length, o.push(e)
            },
            _removeInactiveBinding: function(e) {
                var t = this._bindings,
                    n = e.binding,
                    r = n.rootNode.uuid,
                    i = n.path,
                    o = this._bindingsByRootAndName,
                    a = o[r],
                    s = t[t.length - 1],
                    c = e._cacheIndex;
                s._cacheIndex = c, t[c] = s, t.pop(), delete a[i], 0 === Object.keys(a).length && delete o[r]
            },
            _lendBinding: function(e) {
                var t = this._bindings,
                    n = e._cacheIndex,
                    r = this._nActiveBindings++,
                    i = t[r];
                e._cacheIndex = r, t[r] = e, i._cacheIndex = n, t[n] = i
            },
            _takeBackBinding: function(e) {
                var t = this._bindings,
                    n = e._cacheIndex,
                    r = --this._nActiveBindings,
                    i = t[r];
                e._cacheIndex = r, t[r] = e, i._cacheIndex = n, t[n] = i
            },
            _lendControlInterpolant: function() {
                var e = this._controlInterpolants,
                    t = this._nActiveControlInterpolants++,
                    n = e[t];
                return void 0 === n && ((n = new Du(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer)).__cacheIndex = t, e[t] = n), n
            },
            _takeBackControlInterpolant: function(e) {
                var t = this._controlInterpolants,
                    n = e.__cacheIndex,
                    r = --this._nActiveControlInterpolants,
                    i = t[r];
                e.__cacheIndex = r, t[r] = e, i.__cacheIndex = n, t[n] = i
            },
            _controlInterpolantsResultBuffer: new Float32Array(1),
            clipAction: function(e, t) {
                var n = t || this._root,
                    r = n.uuid,
                    i = "string" == typeof e ? Yu.findByName(n, e) : e,
                    o = null !== i ? i.uuid : e,
                    a = this._actionsByClip[o],
                    s = null;
                if (void 0 !== a) {
                    var c = a.actionByRoot[r];
                    if (void 0 !== c) return c;
                    s = a.knownActions[0], null === i && (i = s._clip)
                }
                if (null === i) return null;
                var u = new Ff(this, i, t);
                return this._bindAction(u, s), this._addInactiveAction(u, o, r), u
            },
            existingAction: function(e, t) {
                var n = t || this._root,
                    r = n.uuid,
                    i = "string" == typeof e ? Yu.findByName(n, e) : e,
                    o = i ? i.uuid : e,
                    a = this._actionsByClip[o];
                return void 0 !== a && a.actionByRoot[r] || null
            },
            stopAllAction: function() {
                var e = this._actions,
                    t = this._nActiveActions,
                    n = this._bindings,
                    r = this._nActiveBindings;
                this._nActiveActions = 0, this._nActiveBindings = 0;
                for (var i = 0; i !== t; ++i) e[i].reset();
                for (i = 0; i !== r; ++i) n[i].useCount = 0;
                return this
            },
            update: function(e) {
                e *= this.timeScale;
                for (var t = this._actions, n = this._nActiveActions, r = this.time += e, i = Math.sign(e), o = this._accuIndex ^= 1, a = 0; a !== n; ++a) {
                    t[a]._update(r, e, i, o)
                }
                var s = this._bindings,
                    c = this._nActiveBindings;
                for (a = 0; a !== c; ++a) s[a].apply(o);
                return this
            },
            setTime: function(e) {
                this.time = 0;
                for (var t = 0; t < this._actions.length; t++) this._actions[t].time = 0;
                return this.update(e)
            },
            getRoot: function() {
                return this._root
            },
            uncacheClip: function(e) {
                var t = this._actions,
                    n = e.uuid,
                    r = this._actionsByClip,
                    i = r[n];
                if (void 0 !== i) {
                    for (var o = i.knownActions, a = 0, s = o.length; a !== s; ++a) {
                        var c = o[a];
                        this._deactivateAction(c);
                        var u = c._cacheIndex,
                            l = t[t.length - 1];
                        c._cacheIndex = null, c._byClipCacheIndex = null, l._cacheIndex = u, t[u] = l, t.pop(), this._removeInactiveBindingsForAction(c)
                    }
                    delete r[n]
                }
            },
            uncacheRoot: function(e) {
                var t = e.uuid,
                    n = this._actionsByClip;
                for (var r in n) {
                    var i = n[r].actionByRoot[t];
                    void 0 !== i && (this._deactivateAction(i), this._removeInactiveAction(i))
                }
                var o = this._bindingsByRootAndName[t];
                if (void 0 !== o)
                    for (var a in o) {
                        var s = o[a];
                        s.restoreOriginalState(), this._removeInactiveBinding(s)
                    }
            },
            uncacheAction: function(e, t) {
                var n = this.existingAction(e, t);
                null !== n && (this._deactivateAction(n), this._removeInactiveAction(n))
            }
        }), Nf.prototype.clone = function() {
            return new Nf(void 0 === this.value.clone ? this.value : this.value.clone())
        }, Bf.prototype = Object.assign(Object.create(ps.prototype), {
            constructor: Bf,
            isInstancedInterleavedBuffer: !0,
            copy: function(e) {
                return ps.prototype.copy.call(this, e), this.meshPerAttribute = e.meshPerAttribute, this
            }
        }), Object.assign(Uf.prototype, {
            linePrecision: 1,
            set: function(e, t) {
                this.ray.set(e, t)
            },
            setFromCamera: function(e, t) {
                t && t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, .5).unproject(t).sub(this.ray.origin).normalize(), this.camera = t) : t && t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld), this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type.")
            },
            intersectObject: function(e, t, n) {
                var r = n || [];
                return Vf(e, this, r, t), r.sort(Hf), r
            },
            intersectObjects: function(e, t, n) {
                var r = n || [];
                if (!1 === Array.isArray(e)) return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."), r;
                for (var i = 0, o = e.length; i < o; i++) Vf(e[i], this, r, t);
                return r.sort(Hf), r
            }
        }), Object.assign(Wf.prototype, {
            set: function(e, t, n) {
                return this.radius = e, this.phi = t, this.theta = n, this
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(e) {
                return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this
            },
            makeSafe: function() {
                return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this
            },
            setFromVector3: function(e) {
                return this.setFromCartesianCoords(e.x, e.y, e.z)
            },
            setFromCartesianCoords: function(e, t, n) {
                return this.radius = Math.sqrt(e * e + t * t + n * n), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, n), this.phi = Math.acos(ln.clamp(t / this.radius, -1, 1))), this
            }
        }), Object.assign(Yf.prototype, {
            set: function(e, t, n) {
                return this.radius = e, this.theta = t, this.y = n, this
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(e) {
                return this.radius = e.radius, this.theta = e.theta, this.y = e.y, this
            },
            setFromVector3: function(e) {
                return this.setFromCartesianCoords(e.x, e.y, e.z)
            },
            setFromCartesianCoords: function(e, t, n) {
                return this.radius = Math.sqrt(e * e + n * n), this.theta = Math.atan2(e, n), this.y = t, this
            }
        });
    var Xf = new fn;

    function qf(e, t) {
        this.min = void 0 !== e ? e : new fn(1 / 0, 1 / 0), this.max = void 0 !== t ? t : new fn(-1 / 0, -1 / 0)
    }
    Object.assign(qf.prototype, {
        set: function(e, t) {
            return this.min.copy(e), this.max.copy(t), this
        },
        setFromPoints: function(e) {
            this.makeEmpty();
            for (var t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
            return this
        },
        setFromCenterAndSize: function(e, t) {
            var n = Xf.copy(t).multiplyScalar(.5);
            return this.min.copy(e).sub(n), this.max.copy(e).add(n), this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.min.copy(e.min), this.max.copy(e.max), this
        },
        makeEmpty: function() {
            return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this
        },
        isEmpty: function() {
            return this.max.x < this.min.x || this.max.y < this.min.y
        },
        getCenter: function(e) {
            return void 0 === e && (console.warn("THREE.Box2: .getCenter() target is now required"), e = new fn), this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
        },
        getSize: function(e) {
            return void 0 === e && (console.warn("THREE.Box2: .getSize() target is now required"), e = new fn), this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min)
        },
        expandByPoint: function(e) {
            return this.min.min(e), this.max.max(e), this
        },
        expandByVector: function(e) {
            return this.min.sub(e), this.max.add(e), this
        },
        expandByScalar: function(e) {
            return this.min.addScalar(-e), this.max.addScalar(e), this
        },
        containsPoint: function(e) {
            return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y)
        },
        containsBox: function(e) {
            return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y
        },
        getParameter: function(e, t) {
            return void 0 === t && (console.warn("THREE.Box2: .getParameter() target is now required"), t = new fn), t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y))
        },
        intersectsBox: function(e) {
            return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y)
        },
        clampPoint: function(e, t) {
            return void 0 === t && (console.warn("THREE.Box2: .clampPoint() target is now required"), t = new fn), t.copy(e).clamp(this.min, this.max)
        },
        distanceToPoint: function(e) {
            return Xf.copy(e).clamp(this.min, this.max).sub(e).length()
        },
        intersect: function(e) {
            return this.min.max(e.min), this.max.min(e.max), this
        },
        union: function(e) {
            return this.min.min(e.min), this.max.max(e.max), this
        },
        translate: function(e) {
            return this.min.add(e), this.max.add(e), this
        },
        equals: function(e) {
            return e.min.equals(this.min) && e.max.equals(this.max)
        }
    });
    var Kf = new pn,
        Zf = new pn;

    function Jf(e, t) {
        this.start = void 0 !== e ? e : new pn, this.end = void 0 !== t ? t : new pn
    }

    function Qf(e) {
        Zn.call(this), this.material = e, this.render = function() {}
    }
    Object.assign(Jf.prototype, {
        set: function(e, t) {
            return this.start.copy(e), this.end.copy(t), this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.start.copy(e.start), this.end.copy(e.end), this
        },
        getCenter: function(e) {
            return void 0 === e && (console.warn("THREE.Line3: .getCenter() target is now required"), e = new pn), e.addVectors(this.start, this.end).multiplyScalar(.5)
        },
        delta: function(e) {
            return void 0 === e && (console.warn("THREE.Line3: .delta() target is now required"), e = new pn), e.subVectors(this.end, this.start)
        },
        distanceSq: function() {
            return this.start.distanceToSquared(this.end)
        },
        distance: function() {
            return this.start.distanceTo(this.end)
        },
        at: function(e, t) {
            return void 0 === t && (console.warn("THREE.Line3: .at() target is now required"), t = new pn), this.delta(t).multiplyScalar(e).add(this.start)
        },
        closestPointToPointParameter: function(e, t) {
            Kf.subVectors(e, this.start), Zf.subVectors(this.end, this.start);
            var n = Zf.dot(Zf),
                r = Zf.dot(Kf) / n;
            return t && (r = ln.clamp(r, 0, 1)), r
        },
        closestPointToPoint: function(e, t, n) {
            var r = this.closestPointToPointParameter(e, t);
            return void 0 === n && (console.warn("THREE.Line3: .closestPointToPoint() target is now required"), n = new pn), this.delta(n).multiplyScalar(r).add(this.start)
        },
        applyMatrix4: function(e) {
            return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this
        },
        equals: function(e) {
            return e.start.equals(this.start) && e.end.equals(this.end)
        }
    }), Qf.prototype = Object.create(Zn.prototype), Qf.prototype.constructor = Qf, Qf.prototype.isImmediateRenderObject = !0;
    var $f = new pn,
        ed = new pn,
        td = new gn,
        nd = ["a", "b", "c"];

    function rd(e, t, n, r) {
        this.object = e, this.size = void 0 !== t ? t : 1;
        var i = void 0 !== n ? n : 16711680,
            o = void 0 !== r ? r : 1,
            a = 0,
            s = this.object.geometry;
        s && s.isGeometry ? a = 3 * s.faces.length : s && s.isBufferGeometry && (a = s.attributes.normal.count);
        var c = new ui,
            u = new Qr(2 * a * 3, 3);
        c.addAttribute("position", u), Zs.call(this, c, new Bs({
            color: i,
            linewidth: o
        })), this.matrixAutoUpdate = !1, this.update()
    }
    rd.prototype = Object.create(Zs.prototype), rd.prototype.constructor = rd, rd.prototype.update = function() {
        this.object.updateMatrixWorld(!0), td.getNormalMatrix(this.object.matrixWorld);
        var e = this.object.matrixWorld,
            t = this.geometry.attributes.position,
            n = this.object.geometry;
        if (n && n.isGeometry)
            for (var r = n.vertices, i = n.faces, o = 0, a = 0, s = i.length; a < s; a++)
                for (var c = i[a], u = 0, l = c.vertexNormals.length; u < l; u++) {
                    var f = r[c[nd[u]]],
                        d = c.vertexNormals[u];
                    $f.copy(f).applyMatrix4(e), ed.copy(d).applyMatrix3(td).normalize().multiplyScalar(this.size).add($f), t.setXYZ(o, $f.x, $f.y, $f.z), o += 1, t.setXYZ(o, ed.x, ed.y, ed.z), o += 1
                } else if (n && n.isBufferGeometry) {
                    var h = n.attributes.position,
                        v = n.attributes.normal;
                    for (o = 0, u = 0, l = h.count; u < l; u++) $f.set(h.getX(u), h.getY(u), h.getZ(u)).applyMatrix4(e), ed.set(v.getX(u), v.getY(u), v.getZ(u)), ed.applyMatrix3(td).normalize().multiplyScalar(this.size).add($f), t.setXYZ(o, $f.x, $f.y, $f.z), o += 1, t.setXYZ(o, ed.x, ed.y, ed.z), o += 1
                }
        t.needsUpdate = !0
    };
    var id = new pn;

    function od(e, t) {
        Zn.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = t;
        for (var n = new ui, r = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1], i = 0, o = 1; i < 32; i++, o++) {
            var a = i / 32 * Math.PI * 2,
                s = o / 32 * Math.PI * 2;
            r.push(Math.cos(a), Math.sin(a), 1, Math.cos(s), Math.sin(s), 1)
        }
        n.addAttribute("position", new Qr(r, 3));
        var c = new Bs({
            fog: !1
        });
        this.cone = new Zs(n, c), this.add(this.cone), this.update()
    }
    od.prototype = Object.create(Zn.prototype), od.prototype.constructor = od, od.prototype.dispose = function() {
        this.cone.geometry.dispose(), this.cone.material.dispose()
    }, od.prototype.update = function() {
        this.light.updateMatrixWorld();
        var e = this.light.distance ? this.light.distance : 1e3,
            t = e * Math.tan(this.light.angle);
        this.cone.scale.set(t, t, e), id.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(id), void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
    };
    var ad = new pn,
        sd = new Rn,
        cd = new Rn;

    function ud(e) {
        for (var t = function e(t) {
                var n = [];
                t && t.isBone && n.push(t);
                for (var r = 0; r < t.children.length; r++) n.push.apply(n, e(t.children[r]));
                return n
            }(e), n = new ui, r = [], i = [], o = new Dr(0, 0, 1), a = new Dr(0, 1, 0), s = 0; s < t.length; s++) {
            var c = t[s];
            c.parent && c.parent.isBone && (r.push(0, 0, 0), r.push(0, 0, 0), i.push(o.r, o.g, o.b), i.push(a.r, a.g, a.b))
        }
        n.addAttribute("position", new Qr(r, 3)), n.addAttribute("color", new Qr(i, 3));
        var u = new Bs({
            vertexColors: _,
            depthTest: !1,
            depthWrite: !1,
            transparent: !0
        });
        Zs.call(this, n, u), this.root = e, this.bones = t, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1
    }

    function ld(e, t, n) {
        this.light = e, this.light.updateMatrixWorld(), this.color = n;
        var r = new au(t, 4, 2),
            i = new Hr({
                wireframe: !0,
                fog: !1
            });
        Ei.call(this, r, i), this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update()
    }

    function fd(e, t) {
        this.type = "RectAreaLightHelper", this.light = e, this.color = t;
        var n = new ui;
        n.addAttribute("position", new Qr([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], 3)), n.computeBoundingSphere();
        var r = new Bs({
            fog: !1
        });
        Xs.call(this, n, r);
        var i = new ui;
        i.addAttribute("position", new Qr([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], 3)), i.computeBoundingSphere(), this.add(new Ei(i, new Hr({
            side: y,
            fog: !1
        }))), this.update()
    }
    ud.prototype = Object.create(Zs.prototype), ud.prototype.constructor = ud, ud.prototype.updateMatrixWorld = function(e) {
        var t = this.bones,
            n = this.geometry,
            r = n.getAttribute("position");
        cd.getInverse(this.root.matrixWorld);
        for (var i = 0, o = 0; i < t.length; i++) {
            var a = t[i];
            a.parent && a.parent.isBone && (sd.multiplyMatrices(cd, a.matrixWorld), ad.setFromMatrixPosition(sd), r.setXYZ(o, ad.x, ad.y, ad.z), sd.multiplyMatrices(cd, a.parent.matrixWorld), ad.setFromMatrixPosition(sd), r.setXYZ(o + 1, ad.x, ad.y, ad.z), o += 2)
        }
        n.getAttribute("position").needsUpdate = !0, Zn.prototype.updateMatrixWorld.call(this, e)
    }, ld.prototype = Object.create(Ei.prototype), ld.prototype.constructor = ld, ld.prototype.dispose = function() {
        this.geometry.dispose(), this.material.dispose()
    }, ld.prototype.update = function() {
        void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color)
    }, fd.prototype = Object.create(Xs.prototype), fd.prototype.constructor = fd, fd.prototype.update = function() {
        if (this.scale.set(.5 * this.light.width, .5 * this.light.height, 1), void 0 !== this.color) this.material.color.set(this.color), this.children[0].material.color.set(this.color);
        else {
            this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
            var e = this.material.color,
                t = Math.max(e.r, e.g, e.b);
            t > 1 && e.multiplyScalar(1 / t), this.children[0].material.color.copy(this.material.color)
        }
    }, fd.prototype.dispose = function() {
        this.geometry.dispose(), this.material.dispose(), this.children[0].geometry.dispose(), this.children[0].material.dispose()
    };
    var dd = new pn,
        hd = new Dr,
        vd = new Dr;

    function pd(e, t, n) {
        Zn.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = n;
        var r = new yc(t);
        r.rotateY(.5 * Math.PI), this.material = new Hr({
            wireframe: !0,
            fog: !1
        }), void 0 === this.color && (this.material.vertexColors = _);
        var i = r.getAttribute("position"),
            o = new Float32Array(3 * i.count);
        r.addAttribute("color", new Vr(o, 3)), this.add(new Ei(r, this.material)), this.update()
    }

    function md(e, t) {
        this.lightProbe = e, this.size = t;
        var n = {
                GAMMA_OUTPUT: ""
            },
            r = new Ui({
                defines: n,
                uniforms: {
                    sh: {
                        value: this.lightProbe.sh.coefficients
                    },
                    intensity: {
                        value: this.lightProbe.intensity
                    }
                },
                vertexShader: ["varying vec3 vNormal;", "void main() {", "\tvNormal = normalize( normalMatrix * normal );", "\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
                fragmentShader: ["#define RECIPROCAL_PI 0.318309886", "vec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {", "\t// matrix is assumed to be orthogonal", "\treturn normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );", "}", "vec3 linearToOutput( in vec3 a ) {", "\t#ifdef GAMMA_OUTPUT", "\t\treturn pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );", "\t#else", "\t\treturn a;", "\t#endif", "}", "// source: https://graphics.stanford.edu/papers/envmap/envmap.pdf", "vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {", "\t// normal is assumed to have unit length", "\tfloat x = normal.x, y = normal.y, z = normal.z;", "\t// band 0", "\tvec3 result = shCoefficients[ 0 ] * 0.886227;", "\t// band 1", "\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;", "\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;", "\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;", "\t// band 2", "\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;", "\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;", "\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );", "\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;", "\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );", "\treturn result;", "}", "uniform vec3 sh[ 9 ]; // sh coefficients", "uniform float intensity; // light probe intensity", "varying vec3 vNormal;", "void main() {", "\tvec3 normal = normalize( vNormal );", "\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );", "\tvec3 irradiance = shGetIrradianceAt( worldNormal, sh );", "\tvec3 outgoingLight = RECIPROCAL_PI * irradiance * intensity;", "\toutgoingLight = linearToOutput( outgoingLight );", "\tgl_FragColor = vec4( outgoingLight, 1.0 );", "}"].join("\n")
            }),
            i = new au(1, 32, 16);
        Ei.call(this, i, r), this.onBeforeRender()
    }

    function yd(e, t, n, r) {
        e = e || 10, t = t || 10, n = new Dr(void 0 !== n ? n : 4473924), r = new Dr(void 0 !== r ? r : 8947848);
        for (var i = t / 2, o = e / t, a = e / 2, s = [], c = [], u = 0, l = 0, f = -a; u <= t; u++, f += o) {
            s.push(-a, 0, f, a, 0, f), s.push(f, 0, -a, f, 0, a);
            var d = u === i ? n : r;
            d.toArray(c, l), l += 3, d.toArray(c, l), l += 3, d.toArray(c, l), l += 3, d.toArray(c, l), l += 3
        }
        var h = new ui;
        h.addAttribute("position", new Qr(s, 3)), h.addAttribute("color", new Qr(c, 3));
        var v = new Bs({
            vertexColors: _
        });
        Zs.call(this, h, v)
    }

    function gd(e, t, n, r, i, o) {
        e = e || 10, t = t || 16, n = n || 8, r = r || 64, i = new Dr(void 0 !== i ? i : 4473924), o = new Dr(void 0 !== o ? o : 8947848);
        var a, s, c, u, l, f, d, h = [],
            v = [];
        for (u = 0; u <= t; u++) c = u / t * (2 * Math.PI), a = Math.sin(c) * e, s = Math.cos(c) * e, h.push(0, 0, 0), h.push(a, 0, s), d = 1 & u ? i : o, v.push(d.r, d.g, d.b), v.push(d.r, d.g, d.b);
        for (u = 0; u <= n; u++)
            for (d = 1 & u ? i : o, f = e - e / n * u, l = 0; l < r; l++) c = l / r * (2 * Math.PI), a = Math.sin(c) * f, s = Math.cos(c) * f, h.push(a, 0, s), v.push(d.r, d.g, d.b), c = (l + 1) / r * (2 * Math.PI), a = Math.sin(c) * f, s = Math.cos(c) * f, h.push(a, 0, s), v.push(d.r, d.g, d.b);
        var p = new ui;
        p.addAttribute("position", new Qr(h, 3)), p.addAttribute("color", new Qr(v, 3));
        var m = new Bs({
            vertexColors: _
        });
        Zs.call(this, p, m)
    }

    function xd(e, t, n, r) {
        this.audio = e, this.range = t || 1, this.divisionsInnerAngle = n || 16, this.divisionsOuterAngle = r || 2;
        var i = new ui,
            o = this.divisionsInnerAngle + 2 * this.divisionsOuterAngle,
            a = new Float32Array(3 * (3 * o + 3));
        i.addAttribute("position", new Vr(a, 3));
        var s = new Bs({
                color: 65280
            }),
            c = new Bs({
                color: 16776960
            });
        Xs.call(this, i, [c, s]), this.update()
    }
    pd.prototype = Object.create(Zn.prototype), pd.prototype.constructor = pd, pd.prototype.dispose = function() {
        this.children[0].geometry.dispose(), this.children[0].material.dispose()
    }, pd.prototype.update = function() {
        var e = this.children[0];
        if (void 0 !== this.color) this.material.color.set(this.color);
        else {
            var t = e.geometry.getAttribute("color");
            hd.copy(this.light.color), vd.copy(this.light.groundColor);
            for (var n = 0, r = t.count; n < r; n++) {
                var i = n < r / 2 ? hd : vd;
                t.setXYZ(n, i.r, i.g, i.b)
            }
            t.needsUpdate = !0
        }
        e.lookAt(dd.setFromMatrixPosition(this.light.matrixWorld).negate())
    }, md.prototype = Object.create(Ei.prototype), md.prototype.constructor = md, md.prototype.dispose = function() {
        this.geometry.dispose(), this.material.dispose()
    }, md.prototype.onBeforeRender = function() {
        this.position.copy(this.lightProbe.position), this.scale.set(1, 1, 1).multiplyScalar(this.size), this.material.uniforms.intensity.value = this.lightProbe.intensity
    }, yd.prototype = Object.assign(Object.create(Zs.prototype), {
        constructor: yd,
        copy: function(e) {
            return Zs.prototype.copy.call(this, e), this.geometry.copy(e.geometry), this.material.copy(e.material), this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        }
    }), gd.prototype = Object.create(Zs.prototype), gd.prototype.constructor = gd, xd.prototype = Object.create(Xs.prototype), xd.prototype.constructor = xd, xd.prototype.update = function() {
        var e, t, n = this.audio,
            r = this.range,
            i = this.divisionsInnerAngle,
            o = this.divisionsOuterAngle,
            a = ln.degToRad(n.panner.coneInnerAngle),
            s = ln.degToRad(n.panner.coneOuterAngle),
            c = a / 2,
            u = s / 2,
            l = 0,
            f = 0,
            d = this.geometry,
            h = d.attributes.position;

        function v(n, i, o, a) {
            var s = (i - n) / o;
            for (h.setXYZ(l, 0, 0, 0), f++, e = n; e < i; e += s) t = l + f, h.setXYZ(t, Math.sin(e) * r, 0, Math.cos(e) * r), h.setXYZ(t + 1, Math.sin(Math.min(e + s, i)) * r, 0, Math.cos(Math.min(e + s, i)) * r), h.setXYZ(t + 2, 0, 0, 0), f += 3;
            d.addGroup(l, f, a), l += f, f = 0
        }
        d.clearGroups(), v(-u, -c, o, 0), v(-c, c, i, 1), v(c, u, o, 0), h.needsUpdate = !0, a === s && (this.material[0].visible = !1)
    }, xd.prototype.dispose = function() {
        this.geometry.dispose(), this.material[0].dispose(), this.material[1].dispose()
    };
    var bd = new pn,
        wd = new pn,
        Md = new gn;

    function _d(e, t, n, r) {
        this.object = e, this.size = void 0 !== t ? t : 1;
        var i = void 0 !== n ? n : 16776960,
            o = void 0 !== r ? r : 1,
            a = 0,
            s = this.object.geometry;
        s && s.isGeometry ? a = s.faces.length : console.warn("THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.");
        var c = new ui,
            u = new Qr(2 * a * 3, 3);
        c.addAttribute("position", u), Zs.call(this, c, new Bs({
            color: i,
            linewidth: o
        })), this.matrixAutoUpdate = !1, this.update()
    }
    _d.prototype = Object.create(Zs.prototype), _d.prototype.constructor = _d, _d.prototype.update = function() {
        this.object.updateMatrixWorld(!0), Md.getNormalMatrix(this.object.matrixWorld);
        for (var e = this.object.matrixWorld, t = this.geometry.attributes.position, n = this.object.geometry, r = n.vertices, i = n.faces, o = 0, a = 0, s = i.length; a < s; a++) {
            var c = i[a],
                u = c.normal;
            bd.copy(r[c.a]).add(r[c.b]).add(r[c.c]).divideScalar(3).applyMatrix4(e), wd.copy(u).applyMatrix3(Md).normalize().multiplyScalar(this.size).add(bd), t.setXYZ(o, bd.x, bd.y, bd.z), o += 1, t.setXYZ(o, wd.x, wd.y, wd.z), o += 1
        }
        t.needsUpdate = !0
    };
    var Sd = new pn,
        Pd = new pn,
        Td = new pn;

    function Ed(e, t, n) {
        Zn.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = n, void 0 === t && (t = 1);
        var r = new ui;
        r.addAttribute("position", new Qr([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0], 3));
        var i = new Bs({
            fog: !1
        });
        this.lightPlane = new Xs(r, i), this.add(this.lightPlane), (r = new ui).addAttribute("position", new Qr([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new Xs(r, i), this.add(this.targetLine), this.update()
    }
    Ed.prototype = Object.create(Zn.prototype), Ed.prototype.constructor = Ed, Ed.prototype.dispose = function() {
        this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose()
    }, Ed.prototype.update = function() {
        Sd.setFromMatrixPosition(this.light.matrixWorld), Pd.setFromMatrixPosition(this.light.target.matrixWorld), Td.subVectors(Pd, Sd), this.lightPlane.lookAt(Pd), void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(Pd), this.targetLine.scale.z = Td.length()
    };
    var zd = new pn,
        Ld = new Hi;

    function Ad(e) {
        var t = new ui,
            n = new Bs({
                color: 16777215,
                vertexColors: M
            }),
            r = [],
            i = [],
            o = {},
            a = new Dr(16755200),
            s = new Dr(16711680),
            c = new Dr(43775),
            u = new Dr(16777215),
            l = new Dr(3355443);

        function f(e, t, n) {
            d(e, n), d(t, n)
        }

        function d(e, t) {
            r.push(0, 0, 0), i.push(t.r, t.g, t.b), void 0 === o[e] && (o[e] = []), o[e].push(r.length / 3 - 1)
        }
        f("n1", "n2", a), f("n2", "n4", a), f("n4", "n3", a), f("n3", "n1", a), f("f1", "f2", a), f("f2", "f4", a), f("f4", "f3", a), f("f3", "f1", a), f("n1", "f1", a), f("n2", "f2", a), f("n3", "f3", a), f("n4", "f4", a), f("p", "n1", s), f("p", "n2", s), f("p", "n3", s), f("p", "n4", s), f("u1", "u2", c), f("u2", "u3", c), f("u3", "u1", c), f("c", "t", u), f("p", "c", l), f("cn1", "cn2", l), f("cn3", "cn4", l), f("cf1", "cf2", l), f("cf3", "cf4", l), t.addAttribute("position", new Qr(r, 3)), t.addAttribute("color", new Qr(i, 3)), Zs.call(this, t, n), this.camera = e, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = o, this.update()
    }

    function Cd(e, t, n, r, i, o, a) {
        zd.set(i, o, a).unproject(r);
        var s = t[e];
        if (void 0 !== s)
            for (var c = n.getAttribute("position"), u = 0, l = s.length; u < l; u++) c.setXYZ(s[u], zd.x, zd.y, zd.z)
    }
    Ad.prototype = Object.create(Zs.prototype), Ad.prototype.constructor = Ad, Ad.prototype.update = function() {
        var e = this.geometry,
            t = this.pointMap;
        Ld.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), Cd("c", t, e, Ld, 0, 0, -1), Cd("t", t, e, Ld, 0, 0, 1), Cd("n1", t, e, Ld, -1, -1, -1), Cd("n2", t, e, Ld, 1, -1, -1), Cd("n3", t, e, Ld, -1, 1, -1), Cd("n4", t, e, Ld, 1, 1, -1), Cd("f1", t, e, Ld, -1, -1, 1), Cd("f2", t, e, Ld, 1, -1, 1), Cd("f3", t, e, Ld, -1, 1, 1), Cd("f4", t, e, Ld, 1, 1, 1), Cd("u1", t, e, Ld, .7, 1.1, -1), Cd("u2", t, e, Ld, -.7, 1.1, -1), Cd("u3", t, e, Ld, 0, 2, -1), Cd("cf1", t, e, Ld, -1, 0, 1), Cd("cf2", t, e, Ld, 1, 0, 1), Cd("cf3", t, e, Ld, 0, -1, 1), Cd("cf4", t, e, Ld, 0, 1, 1), Cd("cn1", t, e, Ld, -1, 0, -1), Cd("cn2", t, e, Ld, 1, 0, -1), Cd("cn3", t, e, Ld, 0, -1, -1), Cd("cn4", t, e, Ld, 0, 1, -1), e.getAttribute("position").needsUpdate = !0
    };
    var Rd = new lr;

    function Od(e, t) {
        this.object = e, void 0 === t && (t = 16776960);
        var n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
            r = new Float32Array(24),
            i = new ui;
        i.setIndex(new Vr(n, 1)), i.addAttribute("position", new Vr(r, 3)), Zs.call(this, i, new Bs({
            color: t
        })), this.matrixAutoUpdate = !1, this.update()
    }

    function jd(e, t) {
        this.type = "Box3Helper", this.box = e, t = t || 16776960;
        var n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
            r = new ui;
        r.setIndex(new Vr(n, 1)), r.addAttribute("position", new Qr([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3)), Zs.call(this, r, new Bs({
            color: t
        })), this.geometry.computeBoundingSphere()
    }

    function Id(e, t, n) {
        this.type = "PlaneHelper", this.plane = e, this.size = void 0 === t ? 1 : t;
        var r = void 0 !== n ? n : 16776960,
            i = new ui;
        i.addAttribute("position", new Qr([1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0], 3)), i.computeBoundingSphere(), Xs.call(this, i, new Bs({
            color: r
        }));
        var o = new ui;
        o.addAttribute("position", new Qr([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], 3)), o.computeBoundingSphere(), this.add(new Ei(o, new Hr({
            color: r,
            opacity: .2,
            transparent: !0,
            depthWrite: !1
        })))
    }
    Od.prototype = Object.create(Zs.prototype), Od.prototype.constructor = Od, Od.prototype.update = function(e) {
        if (void 0 !== e && console.warn("THREE.BoxHelper: .update() has no longer arguments."), void 0 !== this.object && Rd.setFromObject(this.object), !Rd.isEmpty()) {
            var t = Rd.min,
                n = Rd.max,
                r = this.geometry.attributes.position,
                i = r.array;
            i[0] = n.x, i[1] = n.y, i[2] = n.z, i[3] = t.x, i[4] = n.y, i[5] = n.z, i[6] = t.x, i[7] = t.y, i[8] = n.z, i[9] = n.x, i[10] = t.y, i[11] = n.z, i[12] = n.x, i[13] = n.y, i[14] = t.z, i[15] = t.x, i[16] = n.y, i[17] = t.z, i[18] = t.x, i[19] = t.y, i[20] = t.z, i[21] = n.x, i[22] = t.y, i[23] = t.z, r.needsUpdate = !0, this.geometry.computeBoundingSphere()
        }
    }, Od.prototype.setFromObject = function(e) {
        return this.object = e, this.update(), this
    }, Od.prototype.copy = function(e) {
        return Zs.prototype.copy.call(this, e), this.object = e.object, this
    }, Od.prototype.clone = function() {
        return (new this.constructor).copy(this)
    }, jd.prototype = Object.create(Zs.prototype), jd.prototype.constructor = jd, jd.prototype.updateMatrixWorld = function(e) {
        var t = this.box;
        t.isEmpty() || (t.getCenter(this.position), t.getSize(this.scale), this.scale.multiplyScalar(.5), Zn.prototype.updateMatrixWorld.call(this, e))
    }, Id.prototype = Object.create(Xs.prototype), Id.prototype.constructor = Id, Id.prototype.updateMatrixWorld = function(e) {
        var t = -this.plane.constant;
        Math.abs(t) < 1e-8 && (t = 1e-8), this.scale.set(.5 * this.size, .5 * this.size, t), this.children[0].material.side = t < 0 ? y : m, this.lookAt(this.plane.normal), Zn.prototype.updateMatrixWorld.call(this, e)
    };
    var Dd, kd, Fd = new pn;

    function Gd(e, t, n, r, i, o) {
        Zn.call(this), void 0 === e && (e = new pn(0, 0, 1)), void 0 === t && (t = new pn(0, 0, 0)), void 0 === n && (n = 1), void 0 === r && (r = 16776960), void 0 === i && (i = .2 * n), void 0 === o && (o = .2 * i), void 0 === Dd && ((Dd = new ui).addAttribute("position", new Qr([0, 0, 0, 0, 1, 0], 3)), (kd = new mu(0, .5, 1, 5, 1)).translate(0, -.5, 0)), this.position.copy(t), this.line = new Xs(Dd, new Bs({
            color: r
        })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new Ei(kd, new Hr({
            color: r
        })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(e), this.setLength(n, i, o)
    }

    function Nd(e) {
        var t = [0, 0, 0, e = e || 1, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e],
            n = new ui;
        n.addAttribute("position", new Qr(t, 3)), n.addAttribute("color", new Qr([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], 3));
        var r = new Bs({
            vertexColors: _
        });
        Zs.call(this, n, r)
    }

    function Bd(e, t, n, r, i, o, a) {
        return console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."), new Nr(e, t, n, i, o, a)
    }
    Gd.prototype = Object.create(Zn.prototype), Gd.prototype.constructor = Gd, Gd.prototype.setDirection = function(e) {
        if (e.y > .99999) this.quaternion.set(0, 0, 0, 1);
        else if (e.y < -.99999) this.quaternion.set(1, 0, 0, 0);
        else {
            Fd.set(e.z, 0, -e.x).normalize();
            var t = Math.acos(e.y);
            this.quaternion.setFromAxisAngle(Fd, t)
        }
    }, Gd.prototype.setLength = function(e, t, n) {
        void 0 === t && (t = .2 * e), void 0 === n && (n = .2 * t), this.line.scale.set(1, Math.max(1e-4, e - t), 1), this.line.updateMatrix(), this.cone.scale.set(n, t, n), this.cone.position.y = e, this.cone.updateMatrix()
    }, Gd.prototype.setColor = function(e) {
        this.line.material.color.set(e), this.cone.material.color.set(e)
    }, Gd.prototype.copy = function(e) {
        return Zn.prototype.copy.call(this, e, !1), this.line.copy(e.line), this.cone.copy(e.cone), this
    }, Gd.prototype.clone = function() {
        return (new this.constructor).copy(this)
    }, Nd.prototype = Object.create(Zs.prototype), Nd.prototype.constructor = Nd;
    var Ud = 0,
        Hd = 1;

    function Vd(e) {
        return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."), e
    }

    function Wd(e) {
        return void 0 === e && (e = []), console.warn("THREE.MultiMaterial has been removed. Use an Array instead."), e.isMultiMaterial = !0, e.materials = e, e.clone = function() {
            return e.slice()
        }, e
    }

    function Yd(e, t) {
        return console.warn("THREE.PointCloud has been renamed to THREE.Points."), new rc(e, t)
    }

    function Xd(e) {
        return console.warn("THREE.Particle has been renamed to THREE.Sprite."), new As(e)
    }

    function qd(e, t) {
        return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."), new rc(e, t)
    }

    function Kd(e) {
        return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."), new Qs(e)
    }

    function Zd(e) {
        return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."), new Qs(e)
    }

    function Jd(e) {
        return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."), new Qs(e)
    }

    function Qd(e, t, n) {
        return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."), new pn(e, t, n)
    }

    function $d(e, t) {
        return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead."), new Vr(e, t).setDynamic(!0)
    }

    function eh(e, t) {
        return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."), new Wr(e, t)
    }

    function th(e, t) {
        return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."), new Yr(e, t)
    }

    function nh(e, t) {
        return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."), new Xr(e, t)
    }

    function rh(e, t) {
        return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."), new qr(e, t)
    }

    function ih(e, t) {
        return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."), new Kr(e, t)
    }

    function oh(e, t) {
        return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."), new Zr(e, t)
    }

    function ah(e, t) {
        return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."), new Jr(e, t)
    }

    function sh(e, t) {
        return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."), new Qr(e, t)
    }

    function ch(e, t) {
        return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."), new $r(e, t)
    }

    function uh(e) {
        console.warn("THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), vl.call(this, e), this.type = "catmullrom", this.closed = !0
    }

    function lh(e) {
        console.warn("THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), vl.call(this, e), this.type = "catmullrom"
    }

    function fh(e) {
        console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."), vl.call(this, e), this.type = "catmullrom"
    }

    function dh(e) {
        return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."), new Nd(e)
    }

    function hh(e, t) {
        return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."), new Od(e, t)
    }

    function vh(e, t) {
        return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."), new Zs(new vu(e.geometry), new Bs({
            color: void 0 !== t ? t : 16777215
        }))
    }

    function ph(e, t) {
        return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."), new Zs(new uc(e.geometry), new Bs({
            color: void 0 !== t ? t : 16777215
        }))
    }

    function mh(e) {
        return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."), new $u(e)
    }

    function yh(e) {
        return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."), new nl(e)
    }
    al.create = function(e, t) {
        return console.log("THREE.Curve.create() has been deprecated"), e.prototype = Object.create(al.prototype), e.prototype.constructor = e, e.prototype.getPoint = t, e
    }, Object.assign(Tl.prototype, {
        createPointsGeometry: function(e) {
            console.warn("THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
            var t = this.getPoints(e);
            return this.createGeometry(t)
        },
        createSpacedPointsGeometry: function(e) {
            console.warn("THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
            var t = this.getSpacedPoints(e);
            return this.createGeometry(t)
        },
        createGeometry: function(e) {
            console.warn("THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
            for (var t = new ji, n = 0, r = e.length; n < r; n++) {
                var i = e[n];
                t.vertices.push(new pn(i.x, i.y, i.z || 0))
            }
            return t
        }
    }), Object.assign(El.prototype, {
        fromPoints: function(e) {
            console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(e)
        }
    }), uh.prototype = Object.create(vl.prototype), lh.prototype = Object.create(vl.prototype), fh.prototype = Object.create(vl.prototype), Object.assign(fh.prototype, {
        initFromArray: function() {
            console.error("THREE.Spline: .initFromArray() has been removed.")
        },
        getControlPointsArray: function() {
            console.error("THREE.Spline: .getControlPointsArray() has been removed.")
        },
        reparametrizeByArcLength: function() {
            console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.")
        }
    }), yd.prototype.setColors = function() {
        console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")
    }, ud.prototype.update = function() {
        console.error("THREE.SkeletonHelper: update() no longer needs to be called.")
    }, Object.assign(Ju.prototype, {
        extractUrlBase: function(e) {
            return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), Ul.extractUrlBase(e)
        }
    }), Ju.Handlers = {
        add: function() {
            console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")
        },
        get: function() {
            console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")
        }
    }, Object.assign(Xl.prototype, {
        setTexturePath: function(e) {
            return console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."), this.setResourcePath(e)
        }
    }), Object.assign(qf.prototype, {
        center: function(e) {
            return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(e)
        },
        empty: function() {
            return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty()
        },
        isIntersectionBox: function(e) {
            return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e)
        },
        size: function(e) {
            return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(e)
        }
    }), Object.assign(lr.prototype, {
        center: function(e) {
            return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(e)
        },
        empty: function() {
            return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty()
        },
        isIntersectionBox: function(e) {
            return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e)
        },
        isIntersectionSphere: function(e) {
            return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(e)
        },
        size: function(e) {
            return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(e)
        }
    }), Jf.prototype.center = function(e) {
        return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."), this.getCenter(e)
    }, Object.assign(ln, {
        random16: function() {
            return console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."), Math.random()
        },
        nearestPowerOfTwo: function(e) {
            return console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."), ln.floorPowerOfTwo(e)
        },
        nextPowerOfTwo: function(e) {
            return console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."), ln.ceilPowerOfTwo(e)
        }
    }), Object.assign(gn.prototype, {
        flattenToArrayOffset: function(e, t) {
            return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(e, t)
        },
        multiplyVector3: function(e) {
            return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), e.applyMatrix3(this)
        },
        multiplyVector3Array: function() {
            console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")
        },
        applyToBuffer: function(e) {
            return console.warn("THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."), this.applyToBufferAttribute(e)
        },
        applyToVector3Array: function() {
            console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")
        }
    }), Object.assign(Rn.prototype, {
        extractPosition: function(e) {
            return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(e)
        },
        flattenToArrayOffset: function(e, t) {
            return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(e, t)
        },
        getPosition: function() {
            return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), (new pn).setFromMatrixColumn(this, 3)
        },
        setRotationFromQuaternion: function(e) {
            return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(e)
        },
        multiplyToArray: function() {
            console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")
        },
        multiplyVector3: function(e) {
            return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this)
        },
        multiplyVector4: function(e) {
            return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this)
        },
        multiplyVector3Array: function() {
            console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")
        },
        rotateAxis: function(e) {
            console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), e.transformDirection(this)
        },
        crossVector: function(e) {
            return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this)
        },
        translate: function() {
            console.error("THREE.Matrix4: .translate() has been removed.")
        },
        rotateX: function() {
            console.error("THREE.Matrix4: .rotateX() has been removed.")
        },
        rotateY: function() {
            console.error("THREE.Matrix4: .rotateY() has been removed.")
        },
        rotateZ: function() {
            console.error("THREE.Matrix4: .rotateZ() has been removed.")
        },
        rotateByAxis: function() {
            console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
        },
        applyToBuffer: function(e) {
            return console.warn("THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."), this.applyToBufferAttribute(e)
        },
        applyToVector3Array: function() {
            console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")
        },
        makeFrustum: function(e, t, n, r, i, o) {
            return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(e, t, r, n, i, o)
        }
    }), $i.prototype.isIntersectionLine = function(e) {
        return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(e)
    }, dn.prototype.multiplyVector3 = function(e) {
        return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), e.applyQuaternion(this)
    }, Object.assign(wr.prototype, {
        isIntersectionBox: function(e) {
            return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e)
        },
        isIntersectionPlane: function(e) {
            return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(e)
        },
        isIntersectionSphere: function(e) {
            return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(e)
        }
    }), Object.assign(Rr.prototype, {
        area: function() {
            return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea()
        },
        barycoordFromPoint: function(e, t) {
            return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(e, t)
        },
        midpoint: function(e) {
            return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(e)
        },
        normal: function(e) {
            return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(e)
        },
        plane: function(e) {
            return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(e)
        }
    }), Object.assign(Rr, {
        barycoordFromPoint: function(e, t, n, r, i) {
            return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), Rr.getBarycoord(e, t, n, r, i)
        },
        normal: function(e, t, n, r) {
            return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), Rr.getNormal(e, t, n, r)
        }
    }), Object.assign(zl.prototype, {
        extractAllPoints: function(e) {
            return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(e)
        },
        extrude: function(e) {
            return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new $c(this, e)
        },
        makeGeometry: function(e) {
            return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new fu(this, e)
        }
    }), Object.assign(fn.prototype, {
        fromAttribute: function(e, t, n) {
            return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, n)
        },
        distanceToManhattan: function(e) {
            return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(e)
        },
        lengthManhattan: function() {
            return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
        }
    }), Object.assign(pn.prototype, {
        setEulerFromRotationMatrix: function() {
            console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
        },
        setEulerFromQuaternion: function() {
            console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
        },
        getPositionFromMatrix: function(e) {
            return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(e)
        },
        getScaleFromMatrix: function(e) {
            return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(e)
        },
        getColumnFromMatrix: function(e, t) {
            return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(t, e)
        },
        applyProjection: function(e) {
            return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(e)
        },
        fromAttribute: function(e, t, n) {
            return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, n)
        },
        distanceToManhattan: function(e) {
            return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(e)
        },
        lengthManhattan: function() {
            return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
        }
    }), Object.assign(Mn.prototype, {
        fromAttribute: function(e, t, n) {
            return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, n)
        },
        lengthManhattan: function() {
            return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
        }
    }), Object.assign(ji.prototype, {
        computeTangents: function() {
            console.error("THREE.Geometry: .computeTangents() has been removed.")
        },
        computeLineDistances: function() {
            console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.")
        }
    }), Object.assign(Zn.prototype, {
        getChildByName: function(e) {
            return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(e)
        },
        renderDepth: function() {
            console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
        },
        translate: function(e, t) {
            return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(t, e)
        },
        getWorldRotation: function() {
            console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")
        }
    }), Object.defineProperties(Zn.prototype, {
        eulerOrder: {
            get: function() {
                return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order
            },
            set: function(e) {
                console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = e
            }
        },
        useQuaternion: {
            get: function() {
                console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
            },
            set: function() {
                console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
            }
        }
    }), Object.defineProperties(js.prototype, {
        objects: {
            get: function() {
                return console.warn("THREE.LOD: .objects has been renamed to .levels."), this.levels
            }
        }
    }), Object.defineProperty(Fs.prototype, "useVertexTexture", {
        get: function() {
            console.warn("THREE.Skeleton: useVertexTexture has been removed.")
        },
        set: function() {
            console.warn("THREE.Skeleton: useVertexTexture has been removed.")
        }
    }), Is.prototype.initBones = function() {
        console.error("THREE.SkinnedMesh: initBones() has been removed.")
    }, Object.defineProperty(al.prototype, "__arcLengthDivisions", {
        get: function() {
            return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions
        },
        set: function(e) {
            console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions = e
        }
    }), Vi.prototype.setLens = function(e, t) {
        console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== t && (this.filmGauge = t), this.setFocalLength(e)
    }, Object.defineProperties(Ll.prototype, {
        onlyShadow: {
            set: function() {
                console.warn("THREE.Light: .onlyShadow has been removed.")
            }
        },
        shadowCameraFov: {
            set: function(e) {
                console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = e
            }
        },
        shadowCameraLeft: {
            set: function(e) {
                console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = e
            }
        },
        shadowCameraRight: {
            set: function(e) {
                console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = e
            }
        },
        shadowCameraTop: {
            set: function(e) {
                console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = e
            }
        },
        shadowCameraBottom: {
            set: function(e) {
                console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = e
            }
        },
        shadowCameraNear: {
            set: function(e) {
                console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = e
            }
        },
        shadowCameraFar: {
            set: function(e) {
                console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = e
            }
        },
        shadowCameraVisible: {
            set: function() {
                console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")
            }
        },
        shadowBias: {
            set: function(e) {
                console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = e
            }
        },
        shadowDarkness: {
            set: function() {
                console.warn("THREE.Light: .shadowDarkness has been removed.")
            }
        },
        shadowMapWidth: {
            set: function(e) {
                console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = e
            }
        },
        shadowMapHeight: {
            set: function(e) {
                console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = e
            }
        }
    }), Object.defineProperties(Vr.prototype, {
        length: {
            get: function() {
                return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length
            }
        }
    }), Object.assign(Vr.prototype, {
        copyIndicesArray: function() {
            console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")
        },
        setArray: function(e) {
            return console.warn("THREE.BufferAttribute: .setArray has been deprecated. Use BufferGeometry .setAttribute to replace/resize attribute buffers"), this.count = void 0 !== e ? e.length / this.itemSize : 0, this.array = e, this
        }
    }), Object.assign(ui.prototype, {
        addIndex: function(e) {
            console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(e)
        },
        addDrawCall: function(e, t, n) {
            void 0 !== n && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(e, t)
        },
        clearDrawCalls: function() {
            console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups()
        },
        computeTangents: function() {
            console.warn("THREE.BufferGeometry: .computeTangents() has been removed.")
        },
        computeOffsets: function() {
            console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
        }
    }), Object.defineProperties(ui.prototype, {
        drawcalls: {
            get: function() {
                return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups
            }
        },
        offsets: {
            get: function() {
                return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups
            }
        }
    }), Object.assign(ps.prototype, {
        setArray: function(e) {
            return console.warn("THREE.InterleavedBuffer: .setArray has been deprecated. Use BufferGeometry .setAttribute to replace/resize attribute buffers"), this.count = void 0 !== e ? e.length / this.stride : 0, this.array = e, this
        }
    }), Object.assign(eu.prototype, {
        getArrays: function() {
            console.error("THREE.ExtrudeBufferGeometry: .getArrays() has been removed.")
        },
        addShapeList: function() {
            console.error("THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.")
        },
        addShape: function() {
            console.error("THREE.ExtrudeBufferGeometry: .addShape() has been removed.")
        }
    }), Object.defineProperties(Nf.prototype, {
        dynamic: {
            set: function() {
                console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.")
            }
        },
        onUpdate: {
            value: function() {
                return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this
            }
        }
    }), Object.defineProperties(Ur.prototype, {
        wrapAround: {
            get: function() {
                console.warn("THREE.Material: .wrapAround has been removed.")
            },
            set: function() {
                console.warn("THREE.Material: .wrapAround has been removed.")
            }
        },
        overdraw: {
            get: function() {
                console.warn("THREE.Material: .overdraw has been removed.")
            },
            set: function() {
                console.warn("THREE.Material: .overdraw has been removed.")
            }
        },
        wrapRGB: {
            get: function() {
                return console.warn("THREE.Material: .wrapRGB has been removed."), new Dr
            }
        },
        shading: {
            get: function() {
                console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.")
            },
            set: function(e) {
                console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = e === x
            }
        },
        stencilMask: {
            get: function() {
                return console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask
            },
            set: function(e) {
                console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask = e
            }
        }
    }), Object.defineProperties(Tu.prototype, {
        metal: {
            get: function() {
                return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."), !1
            },
            set: function() {
                console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead")
            }
        }
    }), Object.defineProperties(Ui.prototype, {
        derivatives: {
            get: function() {
                return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives
            },
            set: function(e) {
                console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = e
            }
        }
    }), Object.assign(ds.prototype, {
        clearTarget: function(e, t, n, r) {
            console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(e), this.clear(t, n, r)
        },
        animate: function(e) {
            console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(e)
        },
        getCurrentRenderTarget: function() {
            return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget()
        },
        getMaxAnisotropy: function() {
            return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy()
        },
        getPrecision: function() {
            return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision
        },
        resetGLState: function() {
            return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset()
        },
        supportsFloatTextures: function() {
            return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float")
        },
        supportsHalfFloatTextures: function() {
            return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float")
        },
        supportsStandardDerivatives: function() {
            return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives")
        },
        supportsCompressedTextureS3TC: function() {
            return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc")
        },
        supportsCompressedTexturePVRTC: function() {
            return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc")
        },
        supportsBlendMinMax: function() {
            return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax")
        },
        supportsVertexTextures: function() {
            return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures
        },
        supportsInstancedArrays: function() {
            return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays")
        },
        enableScissorTest: function(e) {
            console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(e)
        },
        initMaterial: function() {
            console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
        },
        addPrePlugin: function() {
            console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
        },
        addPostPlugin: function() {
            console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
        },
        updateShadowMap: function() {
            console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
        },
        setFaceCulling: function() {
            console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")
        },
        allocTextureUnit: function() {
            console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")
        },
        setTexture: function() {
            console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")
        },
        setTexture2D: function() {
            console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")
        },
        setTextureCube: function() {
            console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")
        },
        getActiveMipMapLevel: function() {
            return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."), this.getActiveMipmapLevel()
        }
    }), Object.defineProperties(ds.prototype, {
        shadowMapEnabled: {
            get: function() {
                return this.shadowMap.enabled
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = e
            }
        },
        shadowMapType: {
            get: function() {
                return this.shadowMap.type
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = e
            }
        },
        shadowMapCullFace: {
            get: function() {
                console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
            },
            set: function() {
                console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
            }
        },
        context: {
            get: function() {
                return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."), this.getContext()
            }
        }
    }), Object.defineProperties(Qa.prototype, {
        cullFace: {
            get: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
            },
            set: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
            }
        },
        renderReverseSided: {
            get: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
            },
            set: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
            }
        },
        renderSingleSided: {
            get: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
            },
            set: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
            }
        }
    }), Object.defineProperties(qi.prototype, {
        activeCubeFace: {
            set: function() {
                console.warn("THREE.WebGLRenderTargetCube: .activeCubeFace has been removed. It is now the second parameter of WebGLRenderer.setRenderTarget().")
            }
        },
        activeMipMapLevel: {
            set: function() {
                console.warn("THREE.WebGLRenderTargetCube: .activeMipMapLevel has been removed. It is now the third parameter of WebGLRenderer.setRenderTarget().")
            }
        }
    }), Object.defineProperties(_n.prototype, {
        wrapS: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = e
            }
        },
        wrapT: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = e
            }
        },
        magFilter: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = e
            }
        },
        minFilter: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = e
            }
        },
        anisotropy: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = e
            }
        },
        offset: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = e
            }
        },
        repeat: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = e
            }
        },
        format: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = e
            }
        },
        type: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = e
            }
        },
        generateMipmaps: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = e
            }
        }
    }), Object.defineProperties(ls.prototype, {
        standing: {
            set: function() {
                console.warn("THREE.WebVRManager: .standing has been removed.")
            }
        },
        userHeight: {
            set: function() {
                console.warn("THREE.WebVRManager: .userHeight has been removed.")
            }
        }
    }), xf.prototype.load = function(e) {
        console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
        var t = this;
        return (new of).load(e, (function(e) {
            t.setBuffer(e)
        })), this
    }, Pf.prototype.getData = function() {
        return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."), this.getFrequencyData()
    }, Xi.prototype.updateCubeMap = function(e, t) {
        return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(e, t)
    };
    var gh = {
        merge: function(e, t, n) {
            var r;
            console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead."), t.isMesh && (t.matrixAutoUpdate && t.updateMatrix(), r = t.matrix, t = t.geometry), e.merge(t, r, n)
        },
        center: function(e) {
            return console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."), e.center()
        }
    };

    function xh() {
        console.error("THREE.CanvasRenderer has been removed")
    }

    function bh() {
        console.error("THREE.JSONLoader has been removed.")
    }
    xn.crossOrigin = void 0, xn.loadTexture = function(e, t, n, r) {
        console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
        var i = new ol;
        i.setCrossOrigin(this.crossOrigin);
        var o = i.load(e, n, void 0, r);
        return t && (o.mapping = t), o
    }, xn.loadTextureCube = function(e, t, n, r) {
        console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
        var i = new il;
        i.setCrossOrigin(this.crossOrigin);
        var o = i.load(e, n, void 0, r);
        return t && (o.mapping = t), o
    }, xn.loadCompressedTexture = function() {
        console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
    }, xn.loadCompressedTextureCube = function() {
        console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
    };
    var wh = {
        createMultiMaterialObject: function() {
            console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
        },
        detach: function() {
            console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
        },
        attach: function() {
            console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
        }
    };

    function Mh() {
        console.error("THREE.LensFlare has been moved to /examples/js/objects/Lensflare.js")
    }
    "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
        detail: {
            revision: r
        }
    }))
}, function(e, t) {
    e.exports = {
        degrees: function(e) {
            return e / Math.PI * 180
        },
        radians: function(e) {
            return e * Math.PI / 180
        },
        clamp: function(e, t, n) {
            return Math.min(Math.max(e, t), n)
        },
        mix: function(e, t, n) {
            return e * (1 - n) + t * n
        },
        step: function(e, t) {
            return t >= e ? 1 : 0
        },
        smoothstep: function(e, t, n) {
            if (!(e >= t)) {
                var r = Math.min(Math.max((n - e) / (t - e), 0), 1);
                return r * r * (3 - 2 * r)
            }
        },
        spherical: function(e, t, n) {
            return [Math.cos(e) * Math.cos(t) * n, Math.sin(e) * n, Math.cos(e) * Math.sin(t) * n]
        },
        randomArbitrary: function(e, t) {
            return Math.random() * (t - e) + e
        },
        randomInt: function(e, t) {
            return Math.floor(Math.random() * (t - e + 1)) + e
        }
    }
}, function(e, t, n) {
    var r = n(5),
        i = n(11),
        o = n(21),
        a = n(18),
        s = n(24),
        c = function(e, t, n) {
            var u, l, f, d, h = e & c.F,
                v = e & c.G,
                p = e & c.S,
                m = e & c.P,
                y = e & c.B,
                g = v ? r : p ? r[t] || (r[t] = {}) : (r[t] || {}).prototype,
                x = v ? i : i[t] || (i[t] = {}),
                b = x.prototype || (x.prototype = {});
            for (u in v && (n = t), n) f = ((l = !h && g && void 0 !== g[u]) ? g : n)[u], d = y && l ? s(f, r) : m && "function" == typeof f ? s(Function.call, f) : f, g && a(g, u, f, e & c.U), x[u] != f && o(x, u, d), m && b[u] != f && (b[u] = f)
        };
    r.core = i, c.F = 1, c.G = 2, c.S = 4, c.P = 8, c.B = 16, c.W = 32, c.U = 64, c.R = 128, e.exports = c
}, function(e, t) {
    e.exports = function(e, t) {
        var n;
        return function(r) {
            clearTimeout(n), n = setTimeout((function() {
                e(r)
            }), t)
        }
    }
}, function(e, t, n) {
    "use strict";
    n.r(t);
    var r = new(n(0).TextureLoader);
    t.default = function(e) {
        return new Promise((function(t, n) {
            r.load(e, t, null, n)
        }))
    }
}, function(e, t) {
    var n = e.exports = "undefined" != typeof window && window.Math == Math ? window : "undefined" != typeof self && self.Math == Math ? self : Function("return this")();
    "number" == typeof __g && (__g = n)
}, function(e, t) {
    e.exports = function(e) {
        try {
            return !!e()
        } catch (e) {
            return !0
        }
    }
}, function(e, t, n) {
    var r = n(8);
    e.exports = function(e) {
        if (!r(e)) throw TypeError(e + " is not an object!");
        return e
    }
}, function(e, t) {
    e.exports = function(e) {
        return "object" == typeof e ? null !== e : "function" == typeof e
    }
}, function(e, t, n) {
    var r = n(58)("wks"),
        i = n(37),
        o = n(5).Symbol,
        a = "function" == typeof o;
    (e.exports = function(e) {
        return r[e] || (r[e] = a && o[e] || (a ? o : i)("Symbol." + e))
    }).store = r
}, function(e, t, n) {
    var r = n(26),
        i = Math.min;
    e.exports = function(e) {
        return e > 0 ? i(r(e), 9007199254740991) : 0
    }
}, function(e, t) {
    var n = e.exports = {
        version: "2.6.9"
    };
    "number" == typeof __e && (__e = n)
}, function(e, t) {
    e.exports = function(e) {
        return new Promise((function(t) {
            setTimeout(t, e)
        }))
    }
}, function(e, t, n) {
    e.exports = !n(6)((function() {
        return 7 != Object.defineProperty({}, "a", {
            get: function() {
                return 7
            }
        }).a
    }))
}, function(e, t, n) {
    var r = n(7),
        i = n(112),
        o = n(34),
        a = Object.defineProperty;
    t.f = n(13) ? Object.defineProperty : function(e, t, n) {
        if (r(e), t = o(t, !0), r(n), i) try {
            return a(e, t, n)
        } catch (e) {}
        if ("get" in n || "set" in n) throw TypeError("Accessors not supported!");
        return "value" in n && (e[t] = n.value), e
    }
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = function(e) {
        e.x = e.x / document.body.clientWidth * 2 - 1, e.y = -e.y / window.innerHeight * 2 + 1
    }
}, function(e, t, n) {
    var r = n(0);
    e.exports = {
        getRandomInt: function(e, t) {
            return Math.floor(Math.random() * (t - e)) + e
        },
        getDegree: function(e) {
            return e / Math.PI * 180
        },
        getRadian: function(e) {
            return e * Math.PI / 180
        },
        getPolarCoord: function(e, t, n) {
            var i = Math.cos(e) * Math.cos(t) * n,
                o = Math.cos(e) * Math.sin(t) * n,
                a = Math.sin(e) * n;
            return new r.Vector3(i, a, o)
        }
    }
}, function(e, t, n) {
    var r = n(31);
    e.exports = function(e) {
        return Object(r(e))
    }
}, function(e, t, n) {
    var r = n(5),
        i = n(21),
        o = n(20),
        a = n(37)("src"),
        s = n(160),
        c = ("" + s).split("toString");
    n(11).inspectSource = function(e) {
        return s.call(e)
    }, (e.exports = function(e, t, n, s) {
        var u = "function" == typeof n;
        u && (o(n, "name") || i(n, "name", t)), e[t] !== n && (u && (o(n, a) || i(n, a, e[t] ? "" + e[t] : c.join(String(t)))), e === r ? e[t] = n : s ? e[t] ? e[t] = n : i(e, t, n) : (delete e[t], i(e, t, n)))
    })(Function.prototype, "toString", (function() {
        return "function" == typeof this && this[a] || s.call(this)
    }))
}, function(e, t, n) {
    var r = n(2),
        i = n(6),
        o = n(31),
        a = /"/g,
        s = function(e, t, n, r) {
            var i = String(o(e)),
                s = "<" + t;
            return "" !== n && (s += " " + n + '="' + String(r).replace(a, "&quot;") + '"'), s + ">" + i + "</" + t + ">"
        };
    e.exports = function(e, t) {
        var n = {};
        n[e] = t(s), r(r.P + r.F * i((function() {
            var t = "" [e]('"');
            return t !== t.toLowerCase() || t.split('"').length > 3
        })), "String", n)
    }
}, function(e, t) {
    var n = {}.hasOwnProperty;
    e.exports = function(e, t) {
        return n.call(e, t)
    }
}, function(e, t, n) {
    var r = n(14),
        i = n(36);
    e.exports = n(13) ? function(e, t, n) {
        return r.f(e, t, i(1, n))
    } : function(e, t, n) {
        return e[t] = n, e
    }
}, function(e, t, n) {
    var r = n(54),
        i = n(31);
    e.exports = function(e) {
        return r(i(e))
    }
}, function(e, t, n) {
    "use strict";
    var r = n(6);
    e.exports = function(e, t) {
        return !!e && r((function() {
            t ? e.call(null, (function() {}), 1) : e.call(null)
        }))
    }
}, function(e, t, n) {
    var r = n(25);
    e.exports = function(e, t, n) {
        if (r(e), void 0 === t) return e;
        switch (n) {
            case 1:
                return function(n) {
                    return e.call(t, n)
                };
            case 2:
                return function(n, r) {
                    return e.call(t, n, r)
                };
            case 3:
                return function(n, r, i) {
                    return e.call(t, n, r, i)
                }
        }
        return function() {
            return e.apply(t, arguments)
        }
    }
}, function(e, t) {
    e.exports = function(e) {
        if ("function" != typeof e) throw TypeError(e + " is not a function!");
        return e
    }
}, function(e, t) {
    var n = Math.ceil,
        r = Math.floor;
    e.exports = function(e) {
        return isNaN(e = +e) ? 0 : (e > 0 ? r : n)(e)
    }
}, function(e, t, n) {
    var r = n(55),
        i = n(36),
        o = n(22),
        a = n(34),
        s = n(20),
        c = n(112),
        u = Object.getOwnPropertyDescriptor;
    t.f = n(13) ? u : function(e, t) {
        if (e = o(e), t = a(t, !0), c) try {
            return u(e, t)
        } catch (e) {}
        if (s(e, t)) return i(!r.f.call(e, t), e[t])
    }
}, function(e, t, n) {
    var r = n(2),
        i = n(11),
        o = n(6);
    e.exports = function(e, t) {
        var n = (i.Object || {})[e] || Object[e],
            a = {};
        a[e] = t(n), r(r.S + r.F * o((function() {
            n(1)
        })), "Object", a)
    }
}, function(e, t, n) {
    var r = n(24),
        i = n(54),
        o = n(17),
        a = n(10),
        s = n(128);
    e.exports = function(e, t) {
        var n = 1 == e,
            c = 2 == e,
            u = 3 == e,
            l = 4 == e,
            f = 6 == e,
            d = 5 == e || f,
            h = t || s;
        return function(t, s, v) {
            for (var p, m, y = o(t), g = i(y), x = r(s, v, 3), b = a(g.length), w = 0, M = n ? h(t, b) : c ? h(t, 0) : void 0; b > w; w++)
                if ((d || w in g) && (m = x(p = g[w], w, y), e))
                    if (n) M[w] = m;
                    else if (m) switch (e) {
                case 3:
                    return !0;
                case 5:
                    return p;
                case 6:
                    return w;
                case 2:
                    M.push(p)
            } else if (l) return !1;
            return f ? -1 : u || l ? l : M
        }
    }
}, function(e, t) {
    var n = {}.toString;
    e.exports = function(e) {
        return n.call(e).slice(8, -1)
    }
}, function(e, t) {
    e.exports = function(e) {
        if (null == e) throw TypeError("Can't call method on  " + e);
        return e
    }
}, function(e, t, n) {
    "use strict";
    if (n(13)) {
        var r = n(38),
            i = n(5),
            o = n(6),
            a = n(2),
            s = n(69),
            c = n(100),
            u = n(24),
            l = n(52),
            f = n(36),
            d = n(21),
            h = n(53),
            v = n(26),
            p = n(10),
            m = n(139),
            y = n(40),
            g = n(34),
            x = n(20),
            b = n(56),
            w = n(8),
            M = n(17),
            _ = n(92),
            S = n(41),
            P = n(43),
            T = n(42).f,
            E = n(94),
            z = n(37),
            L = n(9),
            A = n(29),
            C = n(59),
            R = n(57),
            O = n(96),
            j = n(50),
            I = n(62),
            D = n(51),
            k = n(95),
            F = n(130),
            G = n(14),
            N = n(27),
            B = G.f,
            U = N.f,
            H = i.RangeError,
            V = i.TypeError,
            W = i.Uint8Array,
            Y = Array.prototype,
            X = c.ArrayBuffer,
            q = c.DataView,
            K = A(0),
            Z = A(2),
            J = A(3),
            Q = A(4),
            $ = A(5),
            ee = A(6),
            te = C(!0),
            ne = C(!1),
            re = O.values,
            ie = O.keys,
            oe = O.entries,
            ae = Y.lastIndexOf,
            se = Y.reduce,
            ce = Y.reduceRight,
            ue = Y.join,
            le = Y.sort,
            fe = Y.slice,
            de = Y.toString,
            he = Y.toLocaleString,
            ve = L("iterator"),
            pe = L("toStringTag"),
            me = z("typed_constructor"),
            ye = z("def_constructor"),
            ge = s.CONSTR,
            xe = s.TYPED,
            be = s.VIEW,
            we = A(1, (function(e, t) {
                return Te(R(e, e[ye]), t)
            })),
            Me = o((function() {
                return 1 === new W(new Uint16Array([1]).buffer)[0]
            })),
            _e = !!W && !!W.prototype.set && o((function() {
                new W(1).set({})
            })),
            Se = function(e, t) {
                var n = v(e);
                if (n < 0 || n % t) throw H("Wrong offset!");
                return n
            },
            Pe = function(e) {
                if (w(e) && xe in e) return e;
                throw V(e + " is not a typed array!")
            },
            Te = function(e, t) {
                if (!(w(e) && me in e)) throw V("It is not a typed array constructor!");
                return new e(t)
            },
            Ee = function(e, t) {
                return ze(R(e, e[ye]), t)
            },
            ze = function(e, t) {
                for (var n = 0, r = t.length, i = Te(e, r); r > n;) i[n] = t[n++];
                return i
            },
            Le = function(e, t, n) {
                B(e, t, {
                    get: function() {
                        return this._d[n]
                    }
                })
            },
            Ae = function(e) {
                var t, n, r, i, o, a, s = M(e),
                    c = arguments.length,
                    l = c > 1 ? arguments[1] : void 0,
                    f = void 0 !== l,
                    d = E(s);
                if (null != d && !_(d)) {
                    for (a = d.call(s), r = [], t = 0; !(o = a.next()).done; t++) r.push(o.value);
                    s = r
                }
                for (f && c > 2 && (l = u(l, arguments[2], 2)), t = 0, n = p(s.length), i = Te(this, n); n > t; t++) i[t] = f ? l(s[t], t) : s[t];
                return i
            },
            Ce = function() {
                for (var e = 0, t = arguments.length, n = Te(this, t); t > e;) n[e] = arguments[e++];
                return n
            },
            Re = !!W && o((function() {
                he.call(new W(1))
            })),
            Oe = function() {
                return he.apply(Re ? fe.call(Pe(this)) : Pe(this), arguments)
            },
            je = {
                copyWithin: function(e, t) {
                    return F.call(Pe(this), e, t, arguments.length > 2 ? arguments[2] : void 0)
                },
                every: function(e) {
                    return Q(Pe(this), e, arguments.length > 1 ? arguments[1] : void 0)
                },
                fill: function(e) {
                    return k.apply(Pe(this), arguments)
                },
                filter: function(e) {
                    return Ee(this, Z(Pe(this), e, arguments.length > 1 ? arguments[1] : void 0))
                },
                find: function(e) {
                    return $(Pe(this), e, arguments.length > 1 ? arguments[1] : void 0)
                },
                findIndex: function(e) {
                    return ee(Pe(this), e, arguments.length > 1 ? arguments[1] : void 0)
                },
                forEach: function(e) {
                    K(Pe(this), e, arguments.length > 1 ? arguments[1] : void 0)
                },
                indexOf: function(e) {
                    return ne(Pe(this), e, arguments.length > 1 ? arguments[1] : void 0)
                },
                includes: function(e) {
                    return te(Pe(this), e, arguments.length > 1 ? arguments[1] : void 0)
                },
                join: function(e) {
                    return ue.apply(Pe(this), arguments)
                },
                lastIndexOf: function(e) {
                    return ae.apply(Pe(this), arguments)
                },
                map: function(e) {
                    return we(Pe(this), e, arguments.length > 1 ? arguments[1] : void 0)
                },
                reduce: function(e) {
                    return se.apply(Pe(this), arguments)
                },
                reduceRight: function(e) {
                    return ce.apply(Pe(this), arguments)
                },
                reverse: function() {
                    for (var e, t = Pe(this).length, n = Math.floor(t / 2), r = 0; r < n;) e = this[r], this[r++] = this[--t], this[t] = e;
                    return this
                },
                some: function(e) {
                    return J(Pe(this), e, arguments.length > 1 ? arguments[1] : void 0)
                },
                sort: function(e) {
                    return le.call(Pe(this), e)
                },
                subarray: function(e, t) {
                    var n = Pe(this),
                        r = n.length,
                        i = y(e, r);
                    return new(R(n, n[ye]))(n.buffer, n.byteOffset + i * n.BYTES_PER_ELEMENT, p((void 0 === t ? r : y(t, r)) - i))
                }
            },
            Ie = function(e, t) {
                return Ee(this, fe.call(Pe(this), e, t))
            },
            De = function(e) {
                Pe(this);
                var t = Se(arguments[1], 1),
                    n = this.length,
                    r = M(e),
                    i = p(r.length),
                    o = 0;
                if (i + t > n) throw H("Wrong length!");
                for (; o < i;) this[t + o] = r[o++]
            },
            ke = {
                entries: function() {
                    return oe.call(Pe(this))
                },
                keys: function() {
                    return ie.call(Pe(this))
                },
                values: function() {
                    return re.call(Pe(this))
                }
            },
            Fe = function(e, t) {
                return w(e) && e[xe] && "symbol" != typeof t && t in e && String(+t) == String(t)
            },
            Ge = function(e, t) {
                return Fe(e, t = g(t, !0)) ? f(2, e[t]) : U(e, t)
            },
            Ne = function(e, t, n) {
                return !(Fe(e, t = g(t, !0)) && w(n) && x(n, "value")) || x(n, "get") || x(n, "set") || n.configurable || x(n, "writable") && !n.writable || x(n, "enumerable") && !n.enumerable ? B(e, t, n) : (e[t] = n.value, e)
            };
        ge || (N.f = Ge, G.f = Ne), a(a.S + a.F * !ge, "Object", {
            getOwnPropertyDescriptor: Ge,
            defineProperty: Ne
        }), o((function() {
            de.call({})
        })) && (de = he = function() {
            return ue.call(this)
        });
        var Be = h({}, je);
        h(Be, ke), d(Be, ve, ke.values), h(Be, {
            slice: Ie,
            set: De,
            constructor: function() {},
            toString: de,
            toLocaleString: Oe
        }), Le(Be, "buffer", "b"), Le(Be, "byteOffset", "o"), Le(Be, "byteLength", "l"), Le(Be, "length", "e"), B(Be, pe, {
            get: function() {
                return this[xe]
            }
        }), e.exports = function(e, t, n, c) {
            var u = e + ((c = !!c) ? "Clamped" : "") + "Array",
                f = "get" + e,
                h = "set" + e,
                v = i[u],
                y = v || {},
                g = v && P(v),
                x = !v || !s.ABV,
                M = {},
                _ = v && v.prototype,
                E = function(e, n) {
                    B(e, n, {
                        get: function() {
                            return function(e, n) {
                                var r = e._d;
                                return r.v[f](n * t + r.o, Me)
                            }(this, n)
                        },
                        set: function(e) {
                            return function(e, n, r) {
                                var i = e._d;
                                c && (r = (r = Math.round(r)) < 0 ? 0 : r > 255 ? 255 : 255 & r), i.v[h](n * t + i.o, r, Me)
                            }(this, n, e)
                        },
                        enumerable: !0
                    })
                };
            x ? (v = n((function(e, n, r, i) {
                l(e, v, u, "_d");
                var o, a, s, c, f = 0,
                    h = 0;
                if (w(n)) {
                    if (!(n instanceof X || "ArrayBuffer" == (c = b(n)) || "SharedArrayBuffer" == c)) return xe in n ? ze(v, n) : Ae.call(v, n);
                    o = n, h = Se(r, t);
                    var y = n.byteLength;
                    if (void 0 === i) {
                        if (y % t) throw H("Wrong length!");
                        if ((a = y - h) < 0) throw H("Wrong length!")
                    } else if ((a = p(i) * t) + h > y) throw H("Wrong length!");
                    s = a / t
                } else s = m(n), o = new X(a = s * t);
                for (d(e, "_d", {
                        b: o,
                        o: h,
                        l: a,
                        e: s,
                        v: new q(o)
                    }); f < s;) E(e, f++)
            })), _ = v.prototype = S(Be), d(_, "constructor", v)) : o((function() {
                v(1)
            })) && o((function() {
                new v(-1)
            })) && I((function(e) {
                new v, new v(null), new v(1.5), new v(e)
            }), !0) || (v = n((function(e, n, r, i) {
                var o;
                return l(e, v, u), w(n) ? n instanceof X || "ArrayBuffer" == (o = b(n)) || "SharedArrayBuffer" == o ? void 0 !== i ? new y(n, Se(r, t), i) : void 0 !== r ? new y(n, Se(r, t)) : new y(n) : xe in n ? ze(v, n) : Ae.call(v, n) : new y(m(n))
            })), K(g !== Function.prototype ? T(y).concat(T(g)) : T(y), (function(e) {
                e in v || d(v, e, y[e])
            })), v.prototype = _, r || (_.constructor = v));
            var z = _[ve],
                L = !!z && ("values" == z.name || null == z.name),
                A = ke.values;
            d(v, me, !0), d(_, xe, u), d(_, be, !0), d(_, ye, v), (c ? new v(1)[pe] == u : pe in _) || B(_, pe, {
                get: function() {
                    return u
                }
            }), M[u] = v, a(a.G + a.W + a.F * (v != y), M), a(a.S, u, {
                BYTES_PER_ELEMENT: t
            }), a(a.S + a.F * o((function() {
                y.of.call(v, 1)
            })), u, {
                from: Ae,
                of: Ce
            }), "BYTES_PER_ELEMENT" in _ || d(_, "BYTES_PER_ELEMENT", t), a(a.P, u, je), D(u), a(a.P + a.F * _e, u, {
                set: De
            }), a(a.P + a.F * !L, u, ke), r || _.toString == de || (_.toString = de), a(a.P + a.F * o((function() {
                new v(1).slice()
            })), u, {
                slice: Ie
            }), a(a.P + a.F * (o((function() {
                return [1, 2].toLocaleString() != new v([1, 2]).toLocaleString()
            })) || !o((function() {
                _.toLocaleString.call([1, 2])
            }))), u, {
                toLocaleString: Oe
            }), j[u] = L ? z : A, r || L || d(_, ve, A)
        }
    } else e.exports = function() {}
}, function(e, t, n) {
    var r, i = n(0),
        o = n(16),
        a = n(46);
    e.exports = (((r = function(e, t, n, r) {
        i.PerspectiveCamera.call(this, e, t, n, r), this.force = {
            position: new a,
            look: new a
        }, this.up.set(0, 1, 0)
    }).prototype = Object.create(i.PerspectiveCamera.prototype)).constructor = r, r.prototype.updatePosition = function() {
        this.position.copy(this.force.position.velocity)
    }, r.prototype.updateLook = function() {
        this.lookAt(this.force.look.velocity.x, this.force.look.velocity.y, this.force.look.velocity.z)
    }, r.prototype.reset = function() {
        this.setPolarCoord(), this.lookAtCenter()
    }, r.prototype.resize = function(e, t) {
        this.aspect = e / t, this.updateProjectionMatrix()
    }, r.prototype.setPolarCoord = function(e, t, n) {
        this.force.position.anchor.copy(o.getPolarCoord(e, t, n))
    }, r.prototype.lookAtCenter = function() {
        this.lookAt(0, 0, 0)
    }, r)
}, function(e, t, n) {
    var r = n(8);
    e.exports = function(e, t) {
        if (!r(e)) return e;
        var n, i;
        if (t && "function" == typeof(n = e.toString) && !r(i = n.call(e))) return i;
        if ("function" == typeof(n = e.valueOf) && !r(i = n.call(e))) return i;
        if (!t && "function" == typeof(n = e.toString) && !r(i = n.call(e))) return i;
        throw TypeError("Can't convert object to primitive value")
    }
}, function(e, t, n) {
    var r = n(37)("meta"),
        i = n(8),
        o = n(20),
        a = n(14).f,
        s = 0,
        c = Object.isExtensible || function() {
            return !0
        },
        u = !n(6)((function() {
            return c(Object.preventExtensions({}))
        })),
        l = function(e) {
            a(e, r, {
                value: {
                    i: "O" + ++s,
                    w: {}
                }
            })
        },
        f = e.exports = {
            KEY: r,
            NEED: !1,
            fastKey: function(e, t) {
                if (!i(e)) return "symbol" == typeof e ? e : ("string" == typeof e ? "S" : "P") + e;
                if (!o(e, r)) {
                    if (!c(e)) return "F";
                    if (!t) return "E";
                    l(e)
                }
                return e[r].i
            },
            getWeak: function(e, t) {
                if (!o(e, r)) {
                    if (!c(e)) return !0;
                    if (!t) return !1;
                    l(e)
                }
                return e[r].w
            },
            onFreeze: function(e) {
                return u && f.NEED && c(e) && !o(e, r) && l(e), e
            }
        }
}, function(e, t) {
    e.exports = function(e, t) {
        return {
            enumerable: !(1 & e),
            configurable: !(2 & e),
            writable: !(4 & e),
            value: t
        }
    }
}, function(e, t) {
    var n = 0,
        r = Math.random();
    e.exports = function(e) {
        return "Symbol(".concat(void 0 === e ? "" : e, ")_", (++n + r).toString(36))
    }
}, function(e, t) {
    e.exports = !1
}, function(e, t, n) {
    var r = n(114),
        i = n(79);
    e.exports = Object.keys || function(e) {
        return r(e, i)
    }
}, function(e, t, n) {
    var r = n(26),
        i = Math.max,
        o = Math.min;
    e.exports = function(e, t) {
        return (e = r(e)) < 0 ? i(e + t, 0) : o(e, t)
    }
}, function(e, t, n) {
    var r = n(7),
        i = n(115),
        o = n(79),
        a = n(78)("IE_PROTO"),
        s = function() {},
        c = function() {
            var e, t = n(76)("iframe"),
                r = o.length;
            for (t.style.display = "none", n(80).appendChild(t), t.src = "javascript:", (e = t.contentWindow.document).open(), e.write("<script>document.F=Object<\/script>"), e.close(), c = e.F; r--;) delete c.prototype[o[r]];
            return c()
        };
    e.exports = Object.create || function(e, t) {
        var n;
        return null !== e ? (s.prototype = r(e), n = new s, s.prototype = null, n[a] = e) : n = c(), void 0 === t ? n : i(n, t)
    }
}, function(e, t, n) {
    var r = n(114),
        i = n(79).concat("length", "prototype");
    t.f = Object.getOwnPropertyNames || function(e) {
        return r(e, i)
    }
}, function(e, t, n) {
    var r = n(20),
        i = n(17),
        o = n(78)("IE_PROTO"),
        a = Object.prototype;
    e.exports = Object.getPrototypeOf || function(e) {
        return e = i(e), r(e, o) ? e[o] : "function" == typeof e.constructor && e instanceof e.constructor ? e.constructor.prototype : e instanceof Object ? a : null
    }
}, function(e, t, n) {
    var r = n(9)("unscopables"),
        i = Array.prototype;
    null == i[r] && n(21)(i, r, {}), e.exports = function(e) {
        i[r][e] = !0
    }
}, function(e, t, n) {
    var r = n(8);
    e.exports = function(e, t) {
        if (!r(e) || e._t !== t) throw TypeError("Incompatible receiver, " + t + " required!");
        return e
    }
}, function(e, t, n) {
    var r, i = n(0);
    n(16);
    e.exports = ((r = function() {
        this.velocity = new i.Vector3, this.acceleration = new i.Vector3, this.anchor = new i.Vector3, this.mass = 1
    }).prototype.updateVelocity = function() {
        this.acceleration.divideScalar(this.mass), this.velocity.add(this.acceleration)
    }, r.prototype.applyForce = function(e) {
        this.acceleration.add(e)
    }, r.prototype.applyFriction = function(e, t) {
        var n = this.acceleration.clone();
        t || (t = 1), n.multiplyScalar(-1), n.normalize(), n.multiplyScalar(e), this.applyForce(n)
    }, r.prototype.applyDrag = function(e) {
        var t = this.acceleration.clone();
        t.multiplyScalar(-1), t.normalize(), t.multiplyScalar(this.acceleration.length() * e), this.applyForce(t)
    }, r.prototype.applyHook = function(e, t) {
        var n = this.velocity.clone().sub(this.anchor),
            r = n.length() - e;
        n.normalize(), n.multiplyScalar(-1 * t * r), this.applyForce(n)
    }, r)
}, function(e, t, n) {
    "use strict";
    n.r(t);
    var r = n(0);
    n(373);
    var i = new r.OBJLoader;
    t.default = function(e) {
        return new Promise((function(t, n) {
            i.load(e, t, null, n)
        }))
    }
}, function(e, t, n) {
    var r = n(14).f,
        i = n(20),
        o = n(9)("toStringTag");
    e.exports = function(e, t, n) {
        e && !i(e = n ? e : e.prototype, o) && r(e, o, {
            configurable: !0,
            value: t
        })
    }
}, function(e, t, n) {
    var r = n(2),
        i = n(31),
        o = n(6),
        a = n(82),
        s = "[" + a + "]",
        c = RegExp("^" + s + s + "*"),
        u = RegExp(s + s + "*$"),
        l = function(e, t, n) {
            var i = {},
                s = o((function() {
                    return !!a[e]() || "​" != "​" [e]()
                })),
                c = i[e] = s ? t(f) : a[e];
            n && (i[n] = c), r(r.P + r.F * s, "String", i)
        },
        f = l.trim = function(e, t) {
            return e = String(i(e)), 1 & t && (e = e.replace(c, "")), 2 & t && (e = e.replace(u, "")), e
        };
    e.exports = l
}, function(e, t) {
    e.exports = {}
}, function(e, t, n) {
    "use strict";
    var r = n(5),
        i = n(14),
        o = n(13),
        a = n(9)("species");
    e.exports = function(e) {
        var t = r[e];
        o && t && !t[a] && i.f(t, a, {
            configurable: !0,
            get: function() {
                return this
            }
        })
    }
}, function(e, t) {
    e.exports = function(e, t, n, r) {
        if (!(e instanceof t) || void 0 !== r && r in e) throw TypeError(n + ": incorrect invocation!");
        return e
    }
}, function(e, t, n) {
    var r = n(18);
    e.exports = function(e, t, n) {
        for (var i in t) r(e, i, t[i], n);
        return e
    }
}, function(e, t, n) {
    var r = n(30);
    e.exports = Object("z").propertyIsEnumerable(0) ? Object : function(e) {
        return "String" == r(e) ? e.split("") : Object(e)
    }
}, function(e, t) {
    t.f = {}.propertyIsEnumerable
}, function(e, t, n) {
    var r = n(30),
        i = n(9)("toStringTag"),
        o = "Arguments" == r(function() {
            return arguments
        }());
    e.exports = function(e) {
        var t, n, a;
        return void 0 === e ? "Undefined" : null === e ? "Null" : "string" == typeof(n = function(e, t) {
            try {
                return e[t]
            } catch (e) {}
        }(t = Object(e), i)) ? n : o ? r(t) : "Object" == (a = r(t)) && "function" == typeof t.callee ? "Arguments" : a
    }
}, function(e, t, n) {
    var r = n(7),
        i = n(25),
        o = n(9)("species");
    e.exports = function(e, t) {
        var n, a = r(e).constructor;
        return void 0 === a || null == (n = r(a)[o]) ? t : i(n)
    }
}, function(e, t, n) {
    var r = n(11),
        i = n(5),
        o = i["__core-js_shared__"] || (i["__core-js_shared__"] = {});
    (e.exports = function(e, t) {
        return o[e] || (o[e] = void 0 !== t ? t : {})
    })("versions", []).push({
        version: r.version,
        mode: n(38) ? "pure" : "global",
        copyright: "© 2019 Denis Pushkarev (zloirock.ru)"
    })
}, function(e, t, n) {
    var r = n(22),
        i = n(10),
        o = n(40);
    e.exports = function(e) {
        return function(t, n, a) {
            var s, c = r(t),
                u = i(c.length),
                l = o(a, u);
            if (e && n != n) {
                for (; u > l;)
                    if ((s = c[l++]) != s) return !0
            } else
                for (; u > l; l++)
                    if ((e || l in c) && c[l] === n) return e || l || 0;
            return !e && -1
        }
    }
}, function(e, t) {
    t.f = Object.getOwnPropertySymbols
}, function(e, t, n) {
    var r = n(30);
    e.exports = Array.isArray || function(e) {
        return "Array" == r(e)
    }
}, function(e, t, n) {
    var r = n(9)("iterator"),
        i = !1;
    try {
        var o = [7][r]();
        o.return = function() {
            i = !0
        }, Array.from(o, (function() {
            throw 2
        }))
    } catch (e) {}
    e.exports = function(e, t) {
        if (!t && !i) return !1;
        var n = !1;
        try {
            var o = [7],
                a = o[r]();
            a.next = function() {
                return {
                    done: n = !0
                }
            }, o[r] = function() {
                return a
            }, e(o)
        } catch (e) {}
        return n
    }
}, function(e, t, n) {
    "use strict";
    var r = n(7);
    e.exports = function() {
        var e = r(this),
            t = "";
        return e.global && (t += "g"), e.ignoreCase && (t += "i"), e.multiline && (t += "m"), e.unicode && (t += "u"), e.sticky && (t += "y"), t
    }
}, function(e, t, n) {
    "use strict";
    var r = n(56),
        i = RegExp.prototype.exec;
    e.exports = function(e, t) {
        var n = e.exec;
        if ("function" == typeof n) {
            var o = n.call(e, t);
            if ("object" != typeof o) throw new TypeError("RegExp exec method returned something other than an Object or null");
            return o
        }
        if ("RegExp" !== r(e)) throw new TypeError("RegExp#exec called on incompatible receiver");
        return i.call(e, t)
    }
}, function(e, t, n) {
    "use strict";
    n(132);
    var r = n(18),
        i = n(21),
        o = n(6),
        a = n(31),
        s = n(9),
        c = n(97),
        u = s("species"),
        l = !o((function() {
            var e = /./;
            return e.exec = function() {
                var e = [];
                return e.groups = {
                    a: "7"
                }, e
            }, "7" !== "".replace(e, "$<a>")
        })),
        f = function() {
            var e = /(?:)/,
                t = e.exec;
            e.exec = function() {
                return t.apply(this, arguments)
            };
            var n = "ab".split(e);
            return 2 === n.length && "a" === n[0] && "b" === n[1]
        }();
    e.exports = function(e, t, n) {
        var d = s(e),
            h = !o((function() {
                var t = {};
                return t[d] = function() {
                    return 7
                }, 7 != "" [e](t)
            })),
            v = h ? !o((function() {
                var t = !1,
                    n = /a/;
                return n.exec = function() {
                    return t = !0, null
                }, "split" === e && (n.constructor = {}, n.constructor[u] = function() {
                    return n
                }), n[d](""), !t
            })) : void 0;
        if (!h || !v || "replace" === e && !l || "split" === e && !f) {
            var p = /./ [d],
                m = n(a, d, "" [e], (function(e, t, n, r, i) {
                    return t.exec === c ? h && !i ? {
                        done: !0,
                        value: p.call(t, n, r)
                    } : {
                        done: !0,
                        value: e.call(n, t, r)
                    } : {
                        done: !1
                    }
                })),
                y = m[0],
                g = m[1];
            r(String.prototype, e, y), i(RegExp.prototype, d, 2 == t ? function(e, t) {
                return g.call(e, this, t)
            } : function(e) {
                return g.call(e, this)
            })
        }
    }
}, function(e, t, n) {
    var r = n(24),
        i = n(127),
        o = n(92),
        a = n(7),
        s = n(10),
        c = n(94),
        u = {},
        l = {};
    (t = e.exports = function(e, t, n, f, d) {
        var h, v, p, m, y = d ? function() {
                return e
            } : c(e),
            g = r(n, f, t ? 2 : 1),
            x = 0;
        if ("function" != typeof y) throw TypeError(e + " is not iterable!");
        if (o(y)) {
            for (h = s(e.length); h > x; x++)
                if ((m = t ? g(a(v = e[x])[0], v[1]) : g(e[x])) === u || m === l) return m
        } else
            for (p = y.call(e); !(v = p.next()).done;)
                if ((m = i(p, g, v.value, t)) === u || m === l) return m
    }).BREAK = u, t.RETURN = l
}, function(e, t, n) {
    var r = n(5).navigator;
    e.exports = r && r.userAgent || ""
}, function(e, t, n) {
    "use strict";
    var r = n(5),
        i = n(2),
        o = n(18),
        a = n(53),
        s = n(35),
        c = n(66),
        u = n(52),
        l = n(8),
        f = n(6),
        d = n(62),
        h = n(48),
        v = n(83);
    e.exports = function(e, t, n, p, m, y) {
        var g = r[e],
            x = g,
            b = m ? "set" : "add",
            w = x && x.prototype,
            M = {},
            _ = function(e) {
                var t = w[e];
                o(w, e, "delete" == e ? function(e) {
                    return !(y && !l(e)) && t.call(this, 0 === e ? 0 : e)
                } : "has" == e ? function(e) {
                    return !(y && !l(e)) && t.call(this, 0 === e ? 0 : e)
                } : "get" == e ? function(e) {
                    return y && !l(e) ? void 0 : t.call(this, 0 === e ? 0 : e)
                } : "add" == e ? function(e) {
                    return t.call(this, 0 === e ? 0 : e), this
                } : function(e, n) {
                    return t.call(this, 0 === e ? 0 : e, n), this
                })
            };
        if ("function" == typeof x && (y || w.forEach && !f((function() {
                (new x).entries().next()
            })))) {
            var S = new x,
                P = S[b](y ? {} : -0, 1) != S,
                T = f((function() {
                    S.has(1)
                })),
                E = d((function(e) {
                    new x(e)
                })),
                z = !y && f((function() {
                    for (var e = new x, t = 5; t--;) e[b](t, t);
                    return !e.has(-0)
                }));
            E || ((x = t((function(t, n) {
                u(t, x, e);
                var r = v(new g, t, x);
                return null != n && c(n, m, r[b], r), r
            }))).prototype = w, w.constructor = x), (T || z) && (_("delete"), _("has"), m && _("get")), (z || P) && _(b), y && w.clear && delete w.clear
        } else x = p.getConstructor(t, e, m, b), a(x.prototype, n), s.NEED = !0;
        return h(x, e), M[e] = x, i(i.G + i.W + i.F * (x != g), M), y || p.setStrong(x, e, m), x
    }
}, function(e, t, n) {
    for (var r, i = n(5), o = n(21), a = n(37), s = a("typed_array"), c = a("view"), u = !(!i.ArrayBuffer || !i.DataView), l = u, f = 0, d = "Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array".split(","); f < 9;)(r = i[d[f++]]) ? (o(r.prototype, s, !0), o(r.prototype, c, !0)) : l = !1;
    e.exports = {
        ABV: u,
        CONSTR: l,
        TYPED: s,
        VIEW: c
    }
}, function(e, t, n) {
    "use strict";
    n.r(t);
    var r = n(75);
    t.default = {
        updateVelocity: function(e, t, n) {
            r.vec3.scale(t, t, 1 / n), r.vec3.add(e, e, t)
        },
        applyFriction: function(e, t, n) {
            var i = [0, 0, 0];
            r.vec3.scale(i, e, -1);
            r.vec3.normalize(i, i), r.vec3.scale(i, i, t), r.vec3.add(e, e, i)
        },
        applyDrag: function(e, t) {
            var n = [0, 0, 0];
            r.vec3.scale(n, e, -1), r.vec3.normalize(n, n), r.vec3.scale(n, n, r.vec3.length(e) * t), r.vec3.add(e, e, n)
        },
        applyHook: function(e, t, n, i, o) {
            var a = [0, 0, 0];
            r.vec3.sub(a, e, n);
            var s = r.vec3.length(a) - i;
            r.vec3.normalize(a, a), r.vec3.scale(a, a, -1 * o * s), r.vec3.add(t, t, a)
        }
    }
}, function(e, t, n) {
    n(0), n(16);
    var r, i = n(46);
    e.exports = (((r = function() {
        this.size = 0, this.time = 0, this.is_active = !1, i.call(this)
    }).prototype = Object.create(i.prototype)).constructor = r, r.prototype.init = function(e) {
        this.velocity = e.clone(), this.anchor = e.clone(), this.acceleration.set(0, 0, 0), this.time = 0
    }, r.prototype.activate = function() {
        this.is_active = !0
    }, r.prototype.inactivate = function() {
        this.is_active = !1
    }, r)
}, function(e, t, n) {
    var r, i = n(0),
        o = (n(16), n(46));
    e.exports = (((r = function() {
        this.geometry = new i.BufferGeometry, this.material = null, this.obj, o.call(this)
    }).prototype = Object.create(o.prototype)).constructor = r, r.prototype.init = function(e) {
        this.material = new i.ShaderMaterial({
            uniforms: {
                color: {
                    type: "c",
                    value: new i.Color(16777215)
                },
                texture: {
                    type: "t",
                    value: e.texture
                }
            },
            vertexShader: e.vs,
            fragmentShader: e.fs,
            transparent: !0,
            depthWrite: !1,
            blending: e.blending
        }), this.geometry.addAttribute("position", new i.BufferAttribute(e.positions, 3)), this.geometry.addAttribute("customColor", new i.BufferAttribute(e.colors, 3)), this.geometry.addAttribute("vertexOpacity", new i.BufferAttribute(e.opacities, 1)), this.geometry.addAttribute("size", new i.BufferAttribute(e.sizes, 1)), this.obj = new i.Points(this.geometry, this.material), e.scene.add(this.obj)
    }, r.prototype.updatePoints = function() {
        this.obj.position.copy(this.velocity), this.obj.geometry.attributes.position.needsUpdate = !0, this.obj.geometry.attributes.vertexOpacity.needsUpdate = !0, this.obj.geometry.attributes.size.needsUpdate = !0, this.obj.geometry.attributes.customColor.needsUpdate = !0
    }, r)
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nattribute vec3 customColor;\nattribute float vertexOpacity;\nattribute float size;\n\nvarying vec3 vColor;\nvarying float fOpacity;\n\nvoid main() {\n  vColor = customColor;\n  fOpacity = vertexOpacity;\n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  gl_PointSize = size * (300.0 / length(mvPosition.xyz));\n  gl_Position = projectionMatrix * mvPosition;\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nuniform vec3 color;\nuniform sampler2D texture;\n\nvarying vec3 vColor;\nvarying float fOpacity;\n\nvoid main() {\n  gl_FragColor = vec4(color * vColor, fOpacity);\n  gl_FragColor = gl_FragColor * texture2D(texture, gl_PointCoord);\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t);
    var r = {};
    n.r(r), n.d(r, "EPSILON", (function() {
        return h
    })), n.d(r, "ARRAY_TYPE", (function() {
        return v
    })), n.d(r, "RANDOM", (function() {
        return p
    })), n.d(r, "setMatrixArrayType", (function() {
        return m
    })), n.d(r, "toRadian", (function() {
        return g
    })), n.d(r, "equals", (function() {
        return x
    }));
    var i = {};
    n.r(i), n.d(i, "create", (function() {
        return b
    })), n.d(i, "clone", (function() {
        return w
    })), n.d(i, "copy", (function() {
        return M
    })), n.d(i, "identity", (function() {
        return _
    })), n.d(i, "fromValues", (function() {
        return S
    })), n.d(i, "set", (function() {
        return P
    })), n.d(i, "transpose", (function() {
        return T
    })), n.d(i, "invert", (function() {
        return E
    })), n.d(i, "adjoint", (function() {
        return z
    })), n.d(i, "determinant", (function() {
        return L
    })), n.d(i, "multiply", (function() {
        return A
    })), n.d(i, "rotate", (function() {
        return C
    })), n.d(i, "scale", (function() {
        return R
    })), n.d(i, "fromRotation", (function() {
        return O
    })), n.d(i, "fromScaling", (function() {
        return j
    })), n.d(i, "str", (function() {
        return I
    })), n.d(i, "frob", (function() {
        return D
    })), n.d(i, "LDU", (function() {
        return k
    })), n.d(i, "add", (function() {
        return F
    })), n.d(i, "subtract", (function() {
        return G
    })), n.d(i, "exactEquals", (function() {
        return N
    })), n.d(i, "equals", (function() {
        return B
    })), n.d(i, "multiplyScalar", (function() {
        return U
    })), n.d(i, "multiplyScalarAndAdd", (function() {
        return H
    })), n.d(i, "mul", (function() {
        return V
    })), n.d(i, "sub", (function() {
        return W
    }));
    var o = {};
    n.r(o), n.d(o, "create", (function() {
        return Y
    })), n.d(o, "clone", (function() {
        return X
    })), n.d(o, "copy", (function() {
        return q
    })), n.d(o, "identity", (function() {
        return K
    })), n.d(o, "fromValues", (function() {
        return Z
    })), n.d(o, "set", (function() {
        return J
    })), n.d(o, "invert", (function() {
        return Q
    })), n.d(o, "determinant", (function() {
        return $
    })), n.d(o, "multiply", (function() {
        return ee
    })), n.d(o, "rotate", (function() {
        return te
    })), n.d(o, "scale", (function() {
        return ne
    })), n.d(o, "translate", (function() {
        return re
    })), n.d(o, "fromRotation", (function() {
        return ie
    })), n.d(o, "fromScaling", (function() {
        return oe
    })), n.d(o, "fromTranslation", (function() {
        return ae
    })), n.d(o, "str", (function() {
        return se
    })), n.d(o, "frob", (function() {
        return ce
    })), n.d(o, "add", (function() {
        return ue
    })), n.d(o, "subtract", (function() {
        return le
    })), n.d(o, "multiplyScalar", (function() {
        return fe
    })), n.d(o, "multiplyScalarAndAdd", (function() {
        return de
    })), n.d(o, "exactEquals", (function() {
        return he
    })), n.d(o, "equals", (function() {
        return ve
    })), n.d(o, "mul", (function() {
        return pe
    })), n.d(o, "sub", (function() {
        return me
    }));
    var a = {};
    n.r(a), n.d(a, "create", (function() {
        return ye
    })), n.d(a, "fromMat4", (function() {
        return ge
    })), n.d(a, "clone", (function() {
        return xe
    })), n.d(a, "copy", (function() {
        return be
    })), n.d(a, "fromValues", (function() {
        return we
    })), n.d(a, "set", (function() {
        return Me
    })), n.d(a, "identity", (function() {
        return _e
    })), n.d(a, "transpose", (function() {
        return Se
    })), n.d(a, "invert", (function() {
        return Pe
    })), n.d(a, "adjoint", (function() {
        return Te
    })), n.d(a, "determinant", (function() {
        return Ee
    })), n.d(a, "multiply", (function() {
        return ze
    })), n.d(a, "translate", (function() {
        return Le
    })), n.d(a, "rotate", (function() {
        return Ae
    })), n.d(a, "scale", (function() {
        return Ce
    })), n.d(a, "fromTranslation", (function() {
        return Re
    })), n.d(a, "fromRotation", (function() {
        return Oe
    })), n.d(a, "fromScaling", (function() {
        return je
    })), n.d(a, "fromMat2d", (function() {
        return Ie
    })), n.d(a, "fromQuat", (function() {
        return De
    })), n.d(a, "normalFromMat4", (function() {
        return ke
    })), n.d(a, "projection", (function() {
        return Fe
    })), n.d(a, "str", (function() {
        return Ge
    })), n.d(a, "frob", (function() {
        return Ne
    })), n.d(a, "add", (function() {
        return Be
    })), n.d(a, "subtract", (function() {
        return Ue
    })), n.d(a, "multiplyScalar", (function() {
        return He
    })), n.d(a, "multiplyScalarAndAdd", (function() {
        return Ve
    })), n.d(a, "exactEquals", (function() {
        return We
    })), n.d(a, "equals", (function() {
        return Ye
    })), n.d(a, "mul", (function() {
        return Xe
    })), n.d(a, "sub", (function() {
        return qe
    }));
    var s = {};
    n.r(s), n.d(s, "create", (function() {
        return Ke
    })), n.d(s, "clone", (function() {
        return Ze
    })), n.d(s, "copy", (function() {
        return Je
    })), n.d(s, "fromValues", (function() {
        return Qe
    })), n.d(s, "set", (function() {
        return $e
    })), n.d(s, "identity", (function() {
        return et
    })), n.d(s, "transpose", (function() {
        return tt
    })), n.d(s, "invert", (function() {
        return nt
    })), n.d(s, "adjoint", (function() {
        return rt
    })), n.d(s, "determinant", (function() {
        return it
    })), n.d(s, "multiply", (function() {
        return ot
    })), n.d(s, "translate", (function() {
        return at
    })), n.d(s, "scale", (function() {
        return st
    })), n.d(s, "rotate", (function() {
        return ct
    })), n.d(s, "rotateX", (function() {
        return ut
    })), n.d(s, "rotateY", (function() {
        return lt
    })), n.d(s, "rotateZ", (function() {
        return ft
    })), n.d(s, "fromTranslation", (function() {
        return dt
    })), n.d(s, "fromScaling", (function() {
        return ht
    })), n.d(s, "fromRotation", (function() {
        return vt
    })), n.d(s, "fromXRotation", (function() {
        return pt
    })), n.d(s, "fromYRotation", (function() {
        return mt
    })), n.d(s, "fromZRotation", (function() {
        return yt
    })), n.d(s, "fromRotationTranslation", (function() {
        return gt
    })), n.d(s, "fromQuat2", (function() {
        return xt
    })), n.d(s, "getTranslation", (function() {
        return bt
    })), n.d(s, "getScaling", (function() {
        return wt
    })), n.d(s, "getRotation", (function() {
        return Mt
    })), n.d(s, "fromRotationTranslationScale", (function() {
        return _t
    })), n.d(s, "fromRotationTranslationScaleOrigin", (function() {
        return St
    })), n.d(s, "fromQuat", (function() {
        return Pt
    })), n.d(s, "frustum", (function() {
        return Tt
    })), n.d(s, "perspective", (function() {
        return Et
    })), n.d(s, "perspectiveFromFieldOfView", (function() {
        return zt
    })), n.d(s, "ortho", (function() {
        return Lt
    })), n.d(s, "lookAt", (function() {
        return At
    })), n.d(s, "targetTo", (function() {
        return Ct
    })), n.d(s, "str", (function() {
        return Rt
    })), n.d(s, "frob", (function() {
        return Ot
    })), n.d(s, "add", (function() {
        return jt
    })), n.d(s, "subtract", (function() {
        return It
    })), n.d(s, "multiplyScalar", (function() {
        return Dt
    })), n.d(s, "multiplyScalarAndAdd", (function() {
        return kt
    })), n.d(s, "exactEquals", (function() {
        return Ft
    })), n.d(s, "equals", (function() {
        return Gt
    })), n.d(s, "mul", (function() {
        return Nt
    })), n.d(s, "sub", (function() {
        return Bt
    }));
    var c = {};
    n.r(c), n.d(c, "create", (function() {
        return Ut
    })), n.d(c, "clone", (function() {
        return Ht
    })), n.d(c, "length", (function() {
        return Vt
    })), n.d(c, "fromValues", (function() {
        return Wt
    })), n.d(c, "copy", (function() {
        return Yt
    })), n.d(c, "set", (function() {
        return Xt
    })), n.d(c, "add", (function() {
        return qt
    })), n.d(c, "subtract", (function() {
        return Kt
    })), n.d(c, "multiply", (function() {
        return Zt
    })), n.d(c, "divide", (function() {
        return Jt
    })), n.d(c, "ceil", (function() {
        return Qt
    })), n.d(c, "floor", (function() {
        return $t
    })), n.d(c, "min", (function() {
        return en
    })), n.d(c, "max", (function() {
        return tn
    })), n.d(c, "round", (function() {
        return nn
    })), n.d(c, "scale", (function() {
        return rn
    })), n.d(c, "scaleAndAdd", (function() {
        return on
    })), n.d(c, "distance", (function() {
        return an
    })), n.d(c, "squaredDistance", (function() {
        return sn
    })), n.d(c, "squaredLength", (function() {
        return cn
    })), n.d(c, "negate", (function() {
        return un
    })), n.d(c, "inverse", (function() {
        return ln
    })), n.d(c, "normalize", (function() {
        return fn
    })), n.d(c, "dot", (function() {
        return dn
    })), n.d(c, "cross", (function() {
        return hn
    })), n.d(c, "lerp", (function() {
        return vn
    })), n.d(c, "hermite", (function() {
        return pn
    })), n.d(c, "bezier", (function() {
        return mn
    })), n.d(c, "random", (function() {
        return yn
    })), n.d(c, "transformMat4", (function() {
        return gn
    })), n.d(c, "transformMat3", (function() {
        return xn
    })), n.d(c, "transformQuat", (function() {
        return bn
    })), n.d(c, "rotateX", (function() {
        return wn
    })), n.d(c, "rotateY", (function() {
        return Mn
    })), n.d(c, "rotateZ", (function() {
        return _n
    })), n.d(c, "angle", (function() {
        return Sn
    })), n.d(c, "zero", (function() {
        return Pn
    })), n.d(c, "str", (function() {
        return Tn
    })), n.d(c, "exactEquals", (function() {
        return En
    })), n.d(c, "equals", (function() {
        return zn
    })), n.d(c, "sub", (function() {
        return An
    })), n.d(c, "mul", (function() {
        return Cn
    })), n.d(c, "div", (function() {
        return Rn
    })), n.d(c, "dist", (function() {
        return On
    })), n.d(c, "sqrDist", (function() {
        return jn
    })), n.d(c, "len", (function() {
        return In
    })), n.d(c, "sqrLen", (function() {
        return Dn
    })), n.d(c, "forEach", (function() {
        return kn
    }));
    var u = {};
    n.r(u), n.d(u, "create", (function() {
        return Fn
    })), n.d(u, "clone", (function() {
        return Gn
    })), n.d(u, "fromValues", (function() {
        return Nn
    })), n.d(u, "copy", (function() {
        return Bn
    })), n.d(u, "set", (function() {
        return Un
    })), n.d(u, "add", (function() {
        return Hn
    })), n.d(u, "subtract", (function() {
        return Vn
    })), n.d(u, "multiply", (function() {
        return Wn
    })), n.d(u, "divide", (function() {
        return Yn
    })), n.d(u, "ceil", (function() {
        return Xn
    })), n.d(u, "floor", (function() {
        return qn
    })), n.d(u, "min", (function() {
        return Kn
    })), n.d(u, "max", (function() {
        return Zn
    })), n.d(u, "round", (function() {
        return Jn
    })), n.d(u, "scale", (function() {
        return Qn
    })), n.d(u, "scaleAndAdd", (function() {
        return $n
    })), n.d(u, "distance", (function() {
        return er
    })), n.d(u, "squaredDistance", (function() {
        return tr
    })), n.d(u, "length", (function() {
        return nr
    })), n.d(u, "squaredLength", (function() {
        return rr
    })), n.d(u, "negate", (function() {
        return ir
    })), n.d(u, "inverse", (function() {
        return or
    })), n.d(u, "normalize", (function() {
        return ar
    })), n.d(u, "dot", (function() {
        return sr
    })), n.d(u, "cross", (function() {
        return cr
    })), n.d(u, "lerp", (function() {
        return ur
    })), n.d(u, "random", (function() {
        return lr
    })), n.d(u, "transformMat4", (function() {
        return fr
    })), n.d(u, "transformQuat", (function() {
        return dr
    })), n.d(u, "zero", (function() {
        return hr
    })), n.d(u, "str", (function() {
        return vr
    })), n.d(u, "exactEquals", (function() {
        return pr
    })), n.d(u, "equals", (function() {
        return mr
    })), n.d(u, "sub", (function() {
        return yr
    })), n.d(u, "mul", (function() {
        return gr
    })), n.d(u, "div", (function() {
        return xr
    })), n.d(u, "dist", (function() {
        return br
    })), n.d(u, "sqrDist", (function() {
        return wr
    })), n.d(u, "len", (function() {
        return Mr
    })), n.d(u, "sqrLen", (function() {
        return _r
    })), n.d(u, "forEach", (function() {
        return Sr
    }));
    var l = {};
    n.r(l), n.d(l, "create", (function() {
        return Pr
    })), n.d(l, "identity", (function() {
        return Tr
    })), n.d(l, "setAxisAngle", (function() {
        return Er
    })), n.d(l, "getAxisAngle", (function() {
        return zr
    })), n.d(l, "getAngle", (function() {
        return Lr
    })), n.d(l, "multiply", (function() {
        return Ar
    })), n.d(l, "rotateX", (function() {
        return Cr
    })), n.d(l, "rotateY", (function() {
        return Rr
    })), n.d(l, "rotateZ", (function() {
        return Or
    })), n.d(l, "calculateW", (function() {
        return jr
    })), n.d(l, "exp", (function() {
        return Ir
    })), n.d(l, "ln", (function() {
        return Dr
    })), n.d(l, "pow", (function() {
        return kr
    })), n.d(l, "slerp", (function() {
        return Fr
    })), n.d(l, "random", (function() {
        return Gr
    })), n.d(l, "invert", (function() {
        return Nr
    })), n.d(l, "conjugate", (function() {
        return Br
    })), n.d(l, "fromMat3", (function() {
        return Ur
    })), n.d(l, "fromEuler", (function() {
        return Hr
    })), n.d(l, "str", (function() {
        return Vr
    })), n.d(l, "clone", (function() {
        return Jr
    })), n.d(l, "fromValues", (function() {
        return Qr
    })), n.d(l, "copy", (function() {
        return $r
    })), n.d(l, "set", (function() {
        return ei
    })), n.d(l, "add", (function() {
        return ti
    })), n.d(l, "mul", (function() {
        return ni
    })), n.d(l, "scale", (function() {
        return ri
    })), n.d(l, "dot", (function() {
        return ii
    })), n.d(l, "lerp", (function() {
        return oi
    })), n.d(l, "length", (function() {
        return ai
    })), n.d(l, "len", (function() {
        return si
    })), n.d(l, "squaredLength", (function() {
        return ci
    })), n.d(l, "sqrLen", (function() {
        return ui
    })), n.d(l, "normalize", (function() {
        return li
    })), n.d(l, "exactEquals", (function() {
        return fi
    })), n.d(l, "equals", (function() {
        return di
    })), n.d(l, "rotationTo", (function() {
        return hi
    })), n.d(l, "sqlerp", (function() {
        return vi
    })), n.d(l, "setAxes", (function() {
        return pi
    }));
    var f = {};
    n.r(f), n.d(f, "create", (function() {
        return mi
    })), n.d(f, "clone", (function() {
        return yi
    })), n.d(f, "fromValues", (function() {
        return gi
    })), n.d(f, "fromRotationTranslationValues", (function() {
        return xi
    })), n.d(f, "fromRotationTranslation", (function() {
        return bi
    })), n.d(f, "fromTranslation", (function() {
        return wi
    })), n.d(f, "fromRotation", (function() {
        return Mi
    })), n.d(f, "fromMat4", (function() {
        return _i
    })), n.d(f, "copy", (function() {
        return Si
    })), n.d(f, "identity", (function() {
        return Pi
    })), n.d(f, "set", (function() {
        return Ti
    })), n.d(f, "getReal", (function() {
        return Ei
    })), n.d(f, "getDual", (function() {
        return zi
    })), n.d(f, "setReal", (function() {
        return Li
    })), n.d(f, "setDual", (function() {
        return Ai
    })), n.d(f, "getTranslation", (function() {
        return Ci
    })), n.d(f, "translate", (function() {
        return Ri
    })), n.d(f, "rotateX", (function() {
        return Oi
    })), n.d(f, "rotateY", (function() {
        return ji
    })), n.d(f, "rotateZ", (function() {
        return Ii
    })), n.d(f, "rotateByQuatAppend", (function() {
        return Di
    })), n.d(f, "rotateByQuatPrepend", (function() {
        return ki
    })), n.d(f, "rotateAroundAxis", (function() {
        return Fi
    })), n.d(f, "add", (function() {
        return Gi
    })), n.d(f, "multiply", (function() {
        return Ni
    })), n.d(f, "mul", (function() {
        return Bi
    })), n.d(f, "scale", (function() {
        return Ui
    })), n.d(f, "dot", (function() {
        return Hi
    })), n.d(f, "lerp", (function() {
        return Vi
    })), n.d(f, "invert", (function() {
        return Wi
    })), n.d(f, "conjugate", (function() {
        return Yi
    })), n.d(f, "length", (function() {
        return Xi
    })), n.d(f, "len", (function() {
        return qi
    })), n.d(f, "squaredLength", (function() {
        return Ki
    })), n.d(f, "sqrLen", (function() {
        return Zi
    })), n.d(f, "normalize", (function() {
        return Ji
    })), n.d(f, "str", (function() {
        return Qi
    })), n.d(f, "exactEquals", (function() {
        return $i
    })), n.d(f, "equals", (function() {
        return eo
    }));
    var d = {};
    n.r(d), n.d(d, "create", (function() {
        return to
    })), n.d(d, "clone", (function() {
        return no
    })), n.d(d, "fromValues", (function() {
        return ro
    })), n.d(d, "copy", (function() {
        return io
    })), n.d(d, "set", (function() {
        return oo
    })), n.d(d, "add", (function() {
        return ao
    })), n.d(d, "subtract", (function() {
        return so
    })), n.d(d, "multiply", (function() {
        return co
    })), n.d(d, "divide", (function() {
        return uo
    })), n.d(d, "ceil", (function() {
        return lo
    })), n.d(d, "floor", (function() {
        return fo
    })), n.d(d, "min", (function() {
        return ho
    })), n.d(d, "max", (function() {
        return vo
    })), n.d(d, "round", (function() {
        return po
    })), n.d(d, "scale", (function() {
        return mo
    })), n.d(d, "scaleAndAdd", (function() {
        return yo
    })), n.d(d, "distance", (function() {
        return go
    })), n.d(d, "squaredDistance", (function() {
        return xo
    })), n.d(d, "length", (function() {
        return bo
    })), n.d(d, "squaredLength", (function() {
        return wo
    })), n.d(d, "negate", (function() {
        return Mo
    })), n.d(d, "inverse", (function() {
        return _o
    })), n.d(d, "normalize", (function() {
        return So
    })), n.d(d, "dot", (function() {
        return Po
    })), n.d(d, "cross", (function() {
        return To
    })), n.d(d, "lerp", (function() {
        return Eo
    })), n.d(d, "random", (function() {
        return zo
    })), n.d(d, "transformMat2", (function() {
        return Lo
    })), n.d(d, "transformMat2d", (function() {
        return Ao
    })), n.d(d, "transformMat3", (function() {
        return Co
    })), n.d(d, "transformMat4", (function() {
        return Ro
    })), n.d(d, "rotate", (function() {
        return Oo
    })), n.d(d, "angle", (function() {
        return jo
    })), n.d(d, "zero", (function() {
        return Io
    })), n.d(d, "str", (function() {
        return Do
    })), n.d(d, "exactEquals", (function() {
        return ko
    })), n.d(d, "equals", (function() {
        return Fo
    })), n.d(d, "len", (function() {
        return Go
    })), n.d(d, "sub", (function() {
        return No
    })), n.d(d, "mul", (function() {
        return Bo
    })), n.d(d, "div", (function() {
        return Uo
    })), n.d(d, "dist", (function() {
        return Ho
    })), n.d(d, "sqrDist", (function() {
        return Vo
    })), n.d(d, "sqrLen", (function() {
        return Wo
    })), n.d(d, "forEach", (function() {
        return Yo
    }));
    var h = 1e-6,
        v = "undefined" != typeof Float32Array ? Float32Array : Array,
        p = Math.random;

    function m(e) {
        v = e
    }
    var y = Math.PI / 180;

    function g(e) {
        return e * y
    }

    function x(e, t) {
        return Math.abs(e - t) <= h * Math.max(1, Math.abs(e), Math.abs(t))
    }

    function b() {
        var e = new v(4);
        return v != Float32Array && (e[1] = 0, e[2] = 0), e[0] = 1, e[3] = 1, e
    }

    function w(e) {
        var t = new v(4);
        return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t
    }

    function M(e, t) {
        return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e
    }

    function _(e) {
        return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 1, e
    }

    function S(e, t, n, r) {
        var i = new v(4);
        return i[0] = e, i[1] = t, i[2] = n, i[3] = r, i
    }

    function P(e, t, n, r, i) {
        return e[0] = t, e[1] = n, e[2] = r, e[3] = i, e
    }

    function T(e, t) {
        if (e === t) {
            var n = t[1];
            e[1] = t[2], e[2] = n
        } else e[0] = t[0], e[1] = t[2], e[2] = t[1], e[3] = t[3];
        return e
    }

    function E(e, t) {
        var n = t[0],
            r = t[1],
            i = t[2],
            o = t[3],
            a = n * o - i * r;
        return a ? (a = 1 / a, e[0] = o * a, e[1] = -r * a, e[2] = -i * a, e[3] = n * a, e) : null
    }

    function z(e, t) {
        var n = t[0];
        return e[0] = t[3], e[1] = -t[1], e[2] = -t[2], e[3] = n, e
    }

    function L(e) {
        return e[0] * e[3] - e[2] * e[1]
    }

    function A(e, t, n) {
        var r = t[0],
            i = t[1],
            o = t[2],
            a = t[3],
            s = n[0],
            c = n[1],
            u = n[2],
            l = n[3];
        return e[0] = r * s + o * c, e[1] = i * s + a * c, e[2] = r * u + o * l, e[3] = i * u + a * l, e
    }

    function C(e, t, n) {
        var r = t[0],
            i = t[1],
            o = t[2],
            a = t[3],
            s = Math.sin(n),
            c = Math.cos(n);
        return e[0] = r * c + o * s, e[1] = i * c + a * s, e[2] = r * -s + o * c, e[3] = i * -s + a * c, e
    }

    function R(e, t, n) {
        var r = t[0],
            i = t[1],
            o = t[2],
            a = t[3],
            s = n[0],
            c = n[1];
        return e[0] = r * s, e[1] = i * s, e[2] = o * c, e[3] = a * c, e
    }

    function O(e, t) {
        var n = Math.sin(t),
            r = Math.cos(t);
        return e[0] = r, e[1] = n, e[2] = -n, e[3] = r, e
    }

    function j(e, t) {
        return e[0] = t[0], e[1] = 0, e[2] = 0, e[3] = t[1], e
    }

    function I(e) {
        return "mat2(" + e[0] + ", " + e[1] + ", " + e[2] + ", " + e[3] + ")"
    }

    function D(e) {
        return Math.hypot(e[0], e[1], e[2], e[3])
    }

    function k(e, t, n, r) {
        return e[2] = r[2] / r[0], n[0] = r[0], n[1] = r[1], n[3] = r[3] - e[2] * n[1], [e, t, n]
    }

    function F(e, t, n) {
        return e[0] = t[0] + n[0], e[1] = t[1] + n[1], e[2] = t[2] + n[2], e[3] = t[3] + n[3], e
    }

    function G(e, t, n) {
        return e[0] = t[0] - n[0], e[1] = t[1] - n[1], e[2] = t[2] - n[2], e[3] = t[3] - n[3], e
    }

    function N(e, t) {
        return e[0] === t[0] && e[1] === t[1] && e[2] === t[2] && e[3] === t[3]
    }

    function B(e, t) {
        var n = e[0],
            r = e[1],
            i = e[2],
            o = e[3],
            a = t[0],
            s = t[1],
            c = t[2],
            u = t[3];
        return Math.abs(n - a) <= h * Math.max(1, Math.abs(n), Math.abs(a)) && Math.abs(r - s) <= h * Math.max(1, Math.abs(r), Math.abs(s)) && Math.abs(i - c) <= h * Math.max(1, Math.abs(i), Math.abs(c)) && Math.abs(o - u) <= h * Math.max(1, Math.abs(o), Math.abs(u))
    }

    function U(e, t, n) {
        return e[0] = t[0] * n, e[1] = t[1] * n, e[2] = t[2] * n, e[3] = t[3] * n, e
    }

    function H(e, t, n, r) {
        return e[0] = t[0] + n[0] * r, e[1] = t[1] + n[1] * r, e[2] = t[2] + n[2] * r, e[3] = t[3] + n[3] * r, e
    }
    Math.hypot || (Math.hypot = function() {
        for (var e = 0, t = arguments.length; t--;) e += arguments[t] * arguments[t];
        return Math.sqrt(e)
    });
    var V = A,
        W = G;

    function Y() {
        var e = new v(6);
        return v != Float32Array && (e[1] = 0, e[2] = 0, e[4] = 0, e[5] = 0), e[0] = 1, e[3] = 1, e
    }

    function X(e) {
        var t = new v(6);
        return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t
    }

    function q(e, t) {
        return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e
    }

    function K(e) {
        return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 1, e[4] = 0, e[5] = 0, e
    }

    function Z(e, t, n, r, i, o) {
        var a = new v(6);
        return a[0] = e, a[1] = t, a[2] = n, a[3] = r, a[4] = i, a[5] = o, a
    }

    function J(e, t, n, r, i, o, a) {
        return e[0] = t, e[1] = n, e[2] = r, e[3] = i, e[4] = o, e[5] = a, e
    }

    function Q(e, t) {
        var n = t[0],
            r = t[1],
            i = t[2],
            o = t[3],
            a = t[4],
            s = t[5],
            c = n * o - r * i;
        return c ? (c = 1 / c, e[0] = o * c, e[1] = -r * c, e[2] = -i * c, e[3] = n * c, e[4] = (i * s - o * a) * c, e[5] = (r * a - n * s) * c, e) : null
    }

    function $(e) {
        return e[0] * e[3] - e[1] * e[2]
    }

    function ee(e, t, n) {
        var r = t[0],
            i = t[1],
            o = t[2],
            a = t[3],
            s = t[4],
            c = t[5],
            u = n[0],
            l = n[1],
            f = n[2],
            d = n[3],
            h = n[4],
            v = n[5];
        return e[0] = r * u + o * l, e[1] = i * u + a * l, e[2] = r * f + o * d, e[3] = i * f + a * d, e[4] = r * h + o * v + s, e[5] = i * h + a * v + c, e
    }

    function te(e, t, n) {
        var r = t[0],
            i = t[1],
            o = t[2],
            a = t[3],
            s = t[4],
            c = t[5],
            u = Math.sin(n),
            l = Math.cos(n);
        return e[0] = r * l + o * u, e[1] = i * l + a * u, e[2] = r * -u + o * l, e[3] = i * -u + a * l, e[4] = s, e[5] = c, e
    }

    function ne(e, t, n) {
        var r = t[0],
            i = t[1],
            o = t[2],
            a = t[3],
            s = t[4],
            c = t[5],
            u = n[0],
            l = n[1];
        return e[0] = r * u, e[1] = i * u, e[2] = o * l, e[3] = a * l, e[4] = s, e[5] = c, e
    }

    function re(e, t, n) {
        var r = t[0],
            i = t[1],
            o = t[2],
            a = t[3],
            s = t[4],
            c = t[5],
            u = n[0],
            l = n[1];
        return e[0] = r, e[1] = i, e[2] = o, e[3] = a, e[4] = r * u + o * l + s, e[5] = i * u + a * l + c, e
    }

    function ie(e, t) {
        var n = Math.sin(t),
            r = Math.cos(t);
        return e[0] = r, e[1] = n, e[2] = -n, e[3] = r, e[4] = 0, e[5] = 0, e
    }

    function oe(e, t) {
        return e[0] = t[0], e[1] = 0, e[2] = 0, e[3] = t[1], e[4] = 0, e[5] = 0, e
    }

    function ae(e, t) {
        return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 1, e[4] = t[0], e[5] = t[1], e
    }

    function se(e) {
        return "mat2d(" + e[0] + ", " + e[1] + ", " + e[2] + ", " + e[3] + ", " + e[4] + ", " + e[5] + ")"
    }

    function ce(e) {
        return Math.hypot(e[0], e[1], e[2], e[3], e[4], e[5], 1)
    }

    function ue(e, t, n) {
        return e[0] = t[0] + n[0], e[1] = t[1] + n[1], e[2] = t[2] + n[2], e[3] = t[3] + n[3], e[4] = t[4] + n[4], e[5] = t[5] + n[5], e
    }

    function le(e, t, n) {
        return e[0] = t[0] - n[0], e[1] = t[1] - n[1], e[2] = t[2] - n[2], e[3] = t[3] - n[3], e[4] = t[4] - n[4], e[5] = t[5] - n[5], e
    }

    function fe(e, t, n) {
        return e[0] = t[0] * n, e[1] = t[1] * n, e[2] = t[2] * n, e[3] = t[3] * n, e[4] = t[4] * n, e[5] = t[5] * n, e
    }

    function de(e, t, n, r) {
        return e[0] = t[0] + n[0] * r, e[1] = t[1] + n[1] * r, e[2] = t[2] + n[2] * r, e[3] = t[3] + n[3] * r, e[4] = t[4] + n[4] * r, e[5] = t[5] + n[5] * r, e
    }

    function he(e, t) {
        return e[0] === t[0] && e[1] === t[1] && e[2] === t[2] && e[3] === t[3] && e[4] === t[4] && e[5] === t[5]
    }

    function ve(e, t) {
        var n = e[0],
            r = e[1],
            i = e[2],
            o = e[3],
            a = e[4],
            s = e[5],
            c = t[0],
            u = t[1],
            l = t[2],
            f = t[3],
            d = t[4],
            v = t[5];
        return Math.abs(n - c) <= h * Math.max(1, Math.abs(n), Math.abs(c)) && Math.abs(r - u) <= h * Math.max(1, Math.abs(r), Math.abs(u)) && Math.abs(i - l) <= h * Math.max(1, Math.abs(i), Math.abs(l)) && Math.abs(o - f) <= h * Math.max(1, Math.abs(o), Math.abs(f)) && Math.abs(a - d) <= h * Math.max(1, Math.abs(a), Math.abs(d)) && Math.abs(s - v) <= h * Math.max(1, Math.abs(s), Math.abs(v))
    }
    var pe = ee,
        me = le;

    function ye() {
        var e = new v(9);
        return v != Float32Array && (e[1] = 0, e[2] = 0, e[3] = 0, e[5] = 0, e[6] = 0, e[7] = 0), e[0] = 1, e[4] = 1, e[8] = 1, e
    }

    function ge(e, t) {
        return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[4], e[4] = t[5], e[5] = t[6], e[6] = t[8], e[7] = t[9], e[8] = t[10], e
    }

    function xe(e) {
        var t = new v(9);
        return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], t
    }

    function be(e, t) {
        return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e
    }

    function we(e, t, n, r, i, o, a, s, c) {
        var u = new v(9);
        return u[0] = e, u[1] = t, u[2] = n, u[3] = r, u[4] = i, u[5] = o, u[6] = a, u[7] = s, u[8] = c, u
    }

    function Me(e, t, n, r, i, o, a, s, c, u) {
        return e[0] = t, e[1] = n, e[2] = r, e[3] = i, e[4] = o, e[5] = a, e[6] = s, e[7] = c, e[8] = u, e
    }

    function _e(e) {
        return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 1, e[5] = 0, e[6] = 0, e[7] = 0, e[8] = 1, e
    }

    function Se(e, t) {
        if (e === t) {
            var n = t[1],
                r = t[2],
                i = t[5];
            e[1] = t[3], e[2] = t[6], e[3] = n, e[5] = t[7], e[6] = r, e[7] = i
        } else e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8];
        return e
    }

    function Pe(e, t) {
        var n = t[0],
            r = t[1],
            i = t[2],
            o = t[3],
            a = t[4],
            s = t[5],
            c = t[6],
            u = t[7],
            l = t[8],
            f = l * a - s * u,
            d = -l * o + s * c,
            h = u * o - a * c,
            v = n * f + r * d + i * h;
        return v ? (v = 1 / v, e[0] = f * v, e[1] = (-l * r + i * u) * v, e[2] = (s * r - i * a) * v, e[3] = d * v, e[4] = (l * n - i * c) * v, e[5] = (-s * n + i * o) * v, e[6] = h * v, e[7] = (-u * n + r * c) * v, e[8] = (a * n - r * o) * v, e) : null
    }

    function Te(e, t) {
        var n = t[0],
            r = t[1],
            i = t[2],
            o = t[3],
            a = t[4],
            s = t[5],
            c = t[6],
            u = t[7],
            l = t[8];
        return e[0] = a * l - s * u, e[1] = i * u - r * l, e[2] = r * s - i * a, e[3] = s * c - o * l, e[4] = n * l - i * c, e[5] = i * o - n * s, e[6] = o * u - a * c, e[7] = r * c - n * u, e[8] = n * a - r * o, e
    }

    function Ee(e) {
        var t = e[0],
            n = e[1],
            r = e[2],
            i = e[3],
            o = e[4],
            a = e[5],
            s = e[6],
            c = e[7],
            u = e[8];
        return t * (u * o - a * c) + n * (-u * i + a * s) + r * (c * i - o * s)
    }

    function ze(e, t, n) {
        var r = t[0],
            i = t[1],
            o = t[2],
            a = t[3],
            s = t[4],
            c = t[5],
            u = t[6],
            l = t[7],
            f = t[8],
            d = n[0],
            h = n[1],
            v = n[2],
            p = n[3],
            m = n[4],
            y = n[5],
            g = n[6],
            x = n[7],
            b = n[8];
        return e[0] = d * r + h * a + v * u, e[1] = d * i + h * s + v * l, e[2] = d * o + h * c + v * f, e[3] = p * r + m * a + y * u, e[4] = p * i + m * s + y * l, e[5] = p * o + m * c + y * f, e[6] = g * r + x * a + b * u, e[7] = g * i + x * s + b * l, e[8] = g * o + x * c + b * f, e
    }

    function Le(e, t, n) {
        var r = t[0],
            i = t[1],
            o = t[2],
            a = t[3],
            s = t[4],
            c = t[5],
            u = t[6],
            l = t[7],
            f = t[8],
            d = n[0],
            h = n[1];
        return e[0] = r, e[1] = i, e[2] = o, e[3] = a, e[4] = s, e[5] = c, e[6] = d * r + h * a + u, e[7] = d * i + h * s + l, e[8] = d * o + h * c + f, e
    }

    function Ae(e, t, n) {
        var r = t[0],
            i = t[1],
            o = t[2],
            a = t[3],
            s = t[4],
            c = t[5],
            u = t[6],
            l = t[7],
            f = t[8],
            d = Math.sin(n),
            h = Math.cos(n);
        return e[0] = h * r + d * a, e[1] = h * i + d * s, e[2] = h * o + d * c, e[3] = h * a - d * r, e[4] = h * s - d * i, e[5] = h * c - d * o, e[6] = u, e[7] = l, e[8] = f, e
    }

    function Ce(e, t, n) {
        var r = n[0],
            i = n[1];
        return e[0] = r * t[0], e[1] = r * t[1], e[2] = r * t[2], e[3] = i * t[3], e[4] = i * t[4], e[5] = i * t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e
    }

    function Re(e, t) {
        return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 1, e[5] = 0, e[6] = t[0], e[7] = t[1], e[8] = 1, e
    }

    function Oe(e, t) {
        var n = Math.sin(t),
            r = Math.cos(t);
        return e[0] = r, e[1] = n, e[2] = 0, e[3] = -n, e[4] = r, e[5] = 0, e[6] = 0, e[7] = 0, e[8] = 1, e
    }

    function je(e, t) {
        return e[0] = t[0], e[1] = 0, e[2] = 0, e[3] = 0, e[4] = t[1], e[5] = 0, e[6] = 0, e[7] = 0, e[8] = 1, e
    }

    function Ie(e, t) {
        return e[0] = t[0], e[1] = t[1], e[2] = 0, e[3] = t[2], e[4] = t[3], e[5] = 0, e[6] = t[4], e[7] = t[5], e[8] = 1, e
    }

    function De(e, t) {
        var n = t[0],
            r = t[1],
            i = t[2],
            o = t[3],
            a = n + n,
            s = r + r,
            c = i + i,
            u = n * a,
            l = r * a,
            f = r * s,
            d = i * a,
            h = i * s,
            v = i * c,
            p = o * a,
            m = o * s,
            y = o * c;
        return e[0] = 1 - f - v, e[3] = l - y, e[6] = d + m, e[1] = l + y, e[4] = 1 - u - v, e[7] = h - p, e[2] = d - m, e[5] = h + p, e[8] = 1 - u - f, e
    }

    function ke(e, t) {
        var n = t[0],
            r = t[1],
            i = t[2],
            o = t[3],
            a = t[4],
            s = t[5],
            c = t[6],
            u = t[7],
            l = t[8],
            f = t[9],
            d = t[10],
            h = t[11],
            v = t[12],
            p = t[13],
            m = t[14],
            y = t[15],
            g = n * s - r * a,
            x = n * c - i * a,
            b = n * u - o * a,
            w = r * c - i * s,
            M = r * u - o * s,
            _ = i * u - o * c,
            S = l * p - f * v,
            P = l * m - d * v,
            T = l * y - h * v,
            E = f * m - d * p,
            z = f * y - h * p,
            L = d * y - h * m,
            A = g * L - x * z + b * E + w * T - M * P + _ * S;
        return A ? (A = 1 / A, e[0] = (s * L - c * z + u * E) * A, e[1] = (c * T - a * L - u * P) * A, e[2] = (a * z - s * T + u * S) * A, e[3] = (i * z - r * L - o * E) * A, e[4] = (n * L - i * T + o * P) * A, e[5] = (r * T - n * z - o * S) * A, e[6] = (p * _ - m * M + y * w) * A, e[7] = (m * b - v * _ - y * x) * A, e[8] = (v * M - p * b + y * g) * A, e) : null
    }

    function Fe(e, t, n) {
        return e[0] = 2 / t, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = -2 / n, e[5] = 0, e[6] = -1, e[7] = 1, e[8] = 1, e
    }

    function Ge(e) {
        return "mat3(" + e[0] + ", " + e[1] + ", " + e[2] + ", " + e[3] + ", " + e[4] + ", " + e[5] + ", " + e[6] + ", " + e[7] + ", " + e[8] + ")"
    }

    function Ne(e) {
        return Math.hypot(e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8])
    }

    function Be(e, t, n) {
        return e[0] = t[0] + n[0], e[1] = t[1] + n[1], e[2] = t[2] + n[2], e[3] = t[3] + n[3], e[4] = t[4] + n[4], e[5] = t[5] + n[5], e[6] = t[6] + n[6], e[7] = t[7] + n[7], e[8] = t[8] + n[8], e
    }

    function Ue(e, t, n) {
        return e[0] = t[0] - n[0], e[1] = t[1] - n[1], e[2] = t[2] - n[2], e[3] = t[3] - n[3], e[4] = t[4] - n[4], e[5] = t[5] - n[5], e[6] = t[6] - n[6], e[7] = t[7] - n[7], e[8] = t[8] - n[8], e
    }

    function He(e, t, n) {
        return e[0] = t[0] * n, e[1] = t[1] * n, e[2] = t[2] * n, e[3] = t[3] * n, e[4] = t[4] * n, e[5] = t[5] * n, e[6] = t[6] * n, e[7] = t[7] * n, e[8] = t[8] * n, e
    }

    function Ve(e, t, n, r) {
        return e[0] = t[0] + n[0] * r, e[1] = t[1] + n[1] * r, e[2] = t[2] + n[2] * r, e[3] = t[3] + n[3] * r, e[4] = t[4] + n[4] * r, e[5] = t[5] + n[5] * r, e[6] = t[6] + n[6] * r, e[7] = t[7] + n[7] * r, e[8] = t[8] + n[8] * r, e
    }

    function We(e, t) {
        return e[0] === t[0] && e[1] === t[1] && e[2] === t[2] && e[3] === t[3] && e[4] === t[4] && e[5] === t[5] && e[6] === t[6] && e[7] === t[7] && e[8] === t[8]
    }

    function Ye(e, t) {
        var n = e[0],
            r = e[1],
            i = e[2],
            o = e[3],
            a = e[4],
            s = e[5],
            c = e[6],
            u = e[7],
            l = e[8],
            f = t[0],
            d = t[1],
            v = t[2],
            p = t[3],
            m = t[4],
            y = t[5],
            g = t[6],
            x = t[7],
            b = t[8];
        return Math.abs(n - f) <= h * Math.max(1, Math.abs(n), Math.abs(f)) && Math.abs(r - d) <= h * Math.max(1, Math.abs(r), Math.abs(d)) && Math.abs(i - v) <= h * Math.max(1, Math.abs(i), Math.abs(v)) && Math.abs(o - p) <= h * Math.max(1, Math.abs(o), Math.abs(p)) && Math.abs(a - m) <= h * Math.max(1, Math.abs(a), Math.abs(m)) && Math.abs(s - y) <= h * Math.max(1, Math.abs(s), Math.abs(y)) && Math.abs(c - g) <= h * Math.max(1, Math.abs(c), Math.abs(g)) && Math.abs(u - x) <= h * Math.max(1, Math.abs(u), Math.abs(x)) && Math.abs(l - b) <= h * Math.max(1, Math.abs(l), Math.abs(b))
    }
    var Xe = ze,
        qe = Ue;

    function Ke() {
        var e = new v(16);
        return v != Float32Array && (e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0), e[0] = 1, e[5] = 1, e[10] = 1, e[15] = 1, e
    }

    function Ze(e) {
        var t = new v(16);
        return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], t[9] = e[9], t[10] = e[10], t[11] = e[11], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15], t
    }

    function Je(e, t) {
        return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15], e
    }

    function Qe(e, t, n, r, i, o, a, s, c, u, l, f, d, h, p, m) {
        var y = new v(16);
        return y[0] = e, y[1] = t, y[2] = n, y[3] = r, y[4] = i, y[5] = o, y[6] = a, y[7] = s, y[8] = c, y[9] = u, y[10] = l, y[11] = f, y[12] = d, y[13] = h, y[14] = p, y[15] = m, y
    }

    function $e(e, t, n, r, i, o, a, s, c, u, l, f, d, h, v, p, m) {
        return e[0] = t, e[1] = n, e[2] = r, e[3] = i, e[4] = o, e[5] = a, e[6] = s, e[7] = c, e[8] = u, e[9] = l, e[10] = f, e[11] = d, e[12] = h, e[13] = v, e[14] = p, e[15] = m, e
    }

    function et(e) {
        return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = 1, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 1, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e
    }

    function tt(e, t) {
        if (e === t) {
            var n = t[1],
                r = t[2],
                i = t[3],
                o = t[6],
                a = t[7],
                s = t[11];
            e[1] = t[4], e[2] = t[8], e[3] = t[12], e[4] = n, e[6] = t[9], e[7] = t[13], e[8] = r, e[9] = o, e[11] = t[14], e[12] = i, e[13] = a, e[14] = s
        } else e[0] = t[0], e[1] = t[4], e[2] = t[8], e[3] = t[12], e[4] = t[1], e[5] = t[5], e[6] = t[9], e[7] = t[13], e[8] = t[2], e[9] = t[6], e[10] = t[10], e[11] = t[14], e[12] = t[3], e[13] = t[7], e[14] = t[11], e[15] = t[15];
        return e
    }

    function nt(e, t) {
        var n = t[0],
            r = t[1],
            i = t[2],
            o = t[3],
            a = t[4],
            s = t[5],
            c = t[6],
            u = t[7],
            l = t[8],
            f = t[9],
            d = t[10],
            h = t[11],
            v = t[12],
            p = t[13],
            m = t[14],
            y = t[15],
            g = n * s - r * a,
            x = n * c - i * a,
            b = n * u - o * a,
            w = r * c - i * s,
            M = r * u - o * s,
            _ = i * u - o * c,
            S = l * p - f * v,
            P = l * m - d * v,
            T = l * y - h * v,
            E = f * m - d * p,
            z = f * y - h * p,
            L = d * y - h * m,
            A = g * L - x * z + b * E + w * T - M * P + _ * S;
        return A ? (A = 1 / A, e[0] = (s * L - c * z + u * E) * A, e[1] = (i * z - r * L - o * E) * A, e[2] = (p * _ - m * M + y * w) * A, e[3] = (d * M - f * _ - h * w) * A, e[4] = (c * T - a * L - u * P) * A, e[5] = (n * L - i * T + o * P) * A, e[6] = (m * b - v * _ - y * x) * A, e[7] = (l * _ - d * b + h * x) * A, e[8] = (a * z - s * T + u * S) * A, e[9] = (r * T - n * z - o * S) * A, e[10] = (v * M - p * b + y * g) * A, e[11] = (f * b - l * M - h * g) * A, e[12] = (s * P - a * E - c * S) * A, e[13] = (n * E - r * P + i * S) * A, e[14] = (p * x - v * w - m * g) * A, e[15] = (l * w - f * x + d * g) * A, e) : null
    }

    function rt(e, t) {
        var n = t[0],
            r = t[1],
            i = t[2],
            o = t[3],
            a = t[4],
            s = t[5],
            c = t[6],
            u = t[7],
            l = t[8],
            f = t[9],
            d = t[10],
            h = t[11],
            v = t[12],
            p = t[13],
            m = t[14],
            y = t[15];
        return e[0] = s * (d * y - h * m) - f * (c * y - u * m) + p * (c * h - u * d), e[1] = -(r * (d * y - h * m) - f * (i * y - o * m) + p * (i * h - o * d)), e[2] = r * (c * y - u * m) - s * (i * y - o * m) + p * (i * u - o * c), e[3] = -(r * (c * h - u * d) - s * (i * h - o * d) + f * (i * u - o * c)), e[4] = -(a * (d * y - h * m) - l * (c * y - u * m) + v * (c * h - u * d)), e[5] = n * (d * y - h * m) - l * (i * y - o * m) + v * (i * h - o * d), e[6] = -(n * (c * y - u * m) - a * (i * y - o * m) + v * (i * u - o * c)), e[7] = n * (c * h - u * d) - a * (i * h - o * d) + l * (i * u - o * c), e[8] = a * (f * y - h * p) - l * (s * y - u * p) + v * (s * h - u * f), e[9] = -(n * (f * y - h * p) - l * (r * y - o * p) + v * (r * h - o * f)), e[10] = n * (s * y - u * p) - a * (r * y - o * p) + v * (r * u - o * s), e[11] = -(n * (s * h - u * f) - a * (r * h - o * f) + l * (r * u - o * s)), e[12] = -(a * (f * m - d * p) - l * (s * m - c * p) + v * (s * d - c * f)), e[13] = n * (f * m - d * p) - l * (r * m - i * p) + v * (r * d - i * f), e[14] = -(n * (s * m - c * p) - a * (r * m - i * p) + v * (r * c - i * s)), e[15] = n * (s * d - c * f) - a * (r * d - i * f) + l * (r * c - i * s), e
    }

    function it(e) {
        var t = e[0],
            n = e[1],
            r = e[2],
            i = e[3],
            o = e[4],
            a = e[5],
            s = e[6],
            c = e[7],
            u = e[8],
            l = e[9],
            f = e[10],
            d = e[11],
            h = e[12],
            v = e[13],
            p = e[14],
            m = e[15];
        return (t * a - n * o) * (f * m - d * p) - (t * s - r * o) * (l * m - d * v) + (t * c - i * o) * (l * p - f * v) + (n * s - r * a) * (u * m - d * h) - (n * c - i * a) * (u * p - f * h) + (r * c - i * s) * (u * v - l * h)
    }

    function ot(e, t, n) {
        var r = t[0],
            i = t[1],
            o = t[2],
            a = t[3],
            s = t[4],
            c = t[5],
            u = t[6],
            l = t[7],
            f = t[8],
            d = t[9],
            h = t[10],
            v = t[11],
            p = t[12],
            m = t[13],
            y = t[14],
            g = t[15],
            x = n[0],
            b = n[1],
            w = n[2],
            M = n[3];
        return e[0] = x * r + b * s + w * f + M * p, e[1] = x * i + b * c + w * d + M * m, e[2] = x * o + b * u + w * h + M * y, e[3] = x * a + b * l + w * v + M * g, x = n[4], b = n[5], w = n[6], M = n[7], e[4] = x * r + b * s + w * f + M * p, e[5] = x * i + b * c + w * d + M * m, e[6] = x * o + b * u + w * h + M * y, e[7] = x * a + b * l + w * v + M * g, x = n[8], b = n[9], w = n[10], M = n[11], e[8] = x * r + b * s + w * f + M * p, e[9] = x * i + b * c + w * d + M * m, e[10] = x * o + b * u + w * h + M * y, e[11] = x * a + b * l + w * v + M * g, x = n[12], b = n[13], w = n[14], M = n[15], e[12] = x * r + b * s + w * f + M * p, e[13] = x * i + b * c + w * d + M * m, e[14] = x * o + b * u + w * h + M * y, e[15] = x * a + b * l + w * v + M * g, e
    }

    function at(e, t, n) {
        var r, i, o, a, s, c, u, l, f, d, h, v, p = n[0],
            m = n[1],
            y = n[2];
        return t === e ? (e[12] = t[0] * p + t[4] * m + t[8] * y + t[12], e[13] = t[1] * p + t[5] * m + t[9] * y + t[13], e[14] = t[2] * p + t[6] * m + t[10] * y + t[14], e[15] = t[3] * p + t[7] * m + t[11] * y + t[15]) : (r = t[0], i = t[1], o = t[2], a = t[3], s = t[4], c = t[5], u = t[6], l = t[7], f = t[8], d = t[9], h = t[10], v = t[11], e[0] = r, e[1] = i, e[2] = o, e[3] = a, e[4] = s, e[5] = c, e[6] = u, e[7] = l, e[8] = f, e[9] = d, e[10] = h, e[11] = v, e[12] = r * p + s * m + f * y + t[12], e[13] = i * p + c * m + d * y + t[13], e[14] = o * p + u * m + h * y + t[14], e[15] = a * p + l * m + v * y + t[15]), e
    }

    function st(e, t, n) {
        var r = n[0],
            i = n[1],
            o = n[2];
        return e[0] = t[0] * r, e[1] = t[1] * r, e[2] = t[2] * r, e[3] = t[3] * r, e[4] = t[4] * i, e[5] = t[5] * i, e[6] = t[6] * i, e[7] = t[7] * i, e[8] = t[8] * o, e[9] = t[9] * o, e[10] = t[10] * o, e[11] = t[11] * o, e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15], e
    }

    function ct(e, t, n, r) {
        var i, o, a, s, c, u, l, f, d, v, p, m, y, g, x, b, w, M, _, S, P, T, E, z, L = r[0],
            A = r[1],
            C = r[2],
            R = Math.hypot(L, A, C);
        return R < h ? null : (L *= R = 1 / R, A *= R, C *= R, i = Math.sin(n), a = 1 - (o = Math.cos(n)), s = t[0], c = t[1], u = t[2], l = t[3], f = t[4], d = t[5], v = t[6], p = t[7], m = t[8], y = t[9], g = t[10], x = t[11], b = L * L * a + o, w = A * L * a + C * i, M = C * L * a - A * i, _ = L * A * a - C * i, S = A * A * a + o, P = C * A * a + L * i, T = L * C * a + A * i, E = A * C * a - L * i, z = C * C * a + o, e[0] = s * b + f * w + m * M, e[1] = c * b + d * w + y * M, e[2] = u * b + v * w + g * M, e[3] = l * b + p * w + x * M, e[4] = s * _ + f * S + m * P, e[5] = c * _ + d * S + y * P, e[6] = u * _ + v * S + g * P, e[7] = l * _ + p * S + x * P, e[8] = s * T + f * E + m * z, e[9] = c * T + d * E + y * z, e[10] = u * T + v * E + g * z, e[11] = l * T + p * E + x * z, t !== e && (e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15]), e)
    }

    function ut(e, t, n) {
        var r = Math.sin(n),
            i = Math.cos(n),
            o = t[4],
            a = t[5],
            s = t[6],
            c = t[7],
            u = t[8],
            l = t[9],
            f = t[10],
            d = t[11];
        return t !== e && (e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15]), e[4] = o * i + u * r, e[5] = a * i + l * r, e[6] = s * i + f * r, e[7] = c * i + d * r, e[8] = u * i - o * r, e[9] = l * i - a * r, e[10] = f * i - s * r, e[11] = d * i - c * r, e
    }

    function lt(e, t, n) {
        var r = Math.sin(n),
            i = Math.cos(n),
            o = t[0],
            a = t[1],
            s = t[2],
            c = t[3],
            u = t[8],
            l = t[9],
            f = t[10],
            d = t[11];
        return t !== e && (e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15]), e[0] = o * i - u * r, e[1] = a * i - l * r, e[2] = s * i - f * r, e[3] = c * i - d * r, e[8] = o * r + u * i, e[9] = a * r + l * i, e[10] = s * r + f * i, e[11] = c * r + d * i, e
    }

    function ft(e, t, n) {
        var r = Math.sin(n),
            i = Math.cos(n),
            o = t[0],
            a = t[1],
            s = t[2],
            c = t[3],
            u = t[4],
            l = t[5],
            f = t[6],
            d = t[7];
        return t !== e && (e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15]), e[0] = o * i + u * r, e[1] = a * i + l * r, e[2] = s * i + f * r, e[3] = c * i + d * r, e[4] = u * i - o * r, e[5] = l * i - a * r, e[6] = f * i - s * r, e[7] = d * i - c * r, e
    }

    function dt(e, t) {
        return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = 1, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 1, e[11] = 0, e[12] = t[0], e[13] = t[1], e[14] = t[2], e[15] = 1, e
    }

    function ht(e, t) {
        return e[0] = t[0], e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = t[1], e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = t[2], e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e
    }

    function vt(e, t, n) {
        var r, i, o, a = n[0],
            s = n[1],
            c = n[2],
            u = Math.hypot(a, s, c);
        return u < h ? null : (a *= u = 1 / u, s *= u, c *= u, r = Math.sin(t), o = 1 - (i = Math.cos(t)), e[0] = a * a * o + i, e[1] = s * a * o + c * r, e[2] = c * a * o - s * r, e[3] = 0, e[4] = a * s * o - c * r, e[5] = s * s * o + i, e[6] = c * s * o + a * r, e[7] = 0, e[8] = a * c * o + s * r, e[9] = s * c * o - a * r, e[10] = c * c * o + i, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e)
    }

    function pt(e, t) {
        var n = Math.sin(t),
            r = Math.cos(t);
        return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = r, e[6] = n, e[7] = 0, e[8] = 0, e[9] = -n, e[10] = r, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e
    }

    function mt(e, t) {
        var n = Math.sin(t),
            r = Math.cos(t);
        return e[0] = r, e[1] = 0, e[2] = -n, e[3] = 0, e[4] = 0, e[5] = 1, e[6] = 0, e[7] = 0, e[8] = n, e[9] = 0, e[10] = r, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e
    }

    function yt(e, t) {
        var n = Math.sin(t),
            r = Math.cos(t);
        return e[0] = r, e[1] = n, e[2] = 0, e[3] = 0, e[4] = -n, e[5] = r, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 1, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e
    }

    function gt(e, t, n) {
        var r = t[0],
            i = t[1],
            o = t[2],
            a = t[3],
            s = r + r,
            c = i + i,
            u = o + o,
            l = r * s,
            f = r * c,
            d = r * u,
            h = i * c,
            v = i * u,
            p = o * u,
            m = a * s,
            y = a * c,
            g = a * u;
        return e[0] = 1 - (h + p), e[1] = f + g, e[2] = d - y, e[3] = 0, e[4] = f - g, e[5] = 1 - (l + p), e[6] = v + m, e[7] = 0, e[8] = d + y, e[9] = v - m, e[10] = 1 - (l + h), e[11] = 0, e[12] = n[0], e[13] = n[1], e[14] = n[2], e[15] = 1, e
    }

    function xt(e, t) {
        var n = new v(3),
            r = -t[0],
            i = -t[1],
            o = -t[2],
            a = t[3],
            s = t[4],
            c = t[5],
            u = t[6],
            l = t[7],
            f = r * r + i * i + o * o + a * a;
        return f > 0 ? (n[0] = 2 * (s * a + l * r + c * o - u * i) / f, n[1] = 2 * (c * a + l * i + u * r - s * o) / f, n[2] = 2 * (u * a + l * o + s * i - c * r) / f) : (n[0] = 2 * (s * a + l * r + c * o - u * i), n[1] = 2 * (c * a + l * i + u * r - s * o), n[2] = 2 * (u * a + l * o + s * i - c * r)), gt(e, t, n), e
    }

    function bt(e, t) {
        return e[0] = t[12], e[1] = t[13], e[2] = t[14], e
    }

    function wt(e, t) {
        var n = t[0],
            r = t[1],
            i = t[2],
            o = t[4],
            a = t[5],
            s = t[6],
            c = t[8],
            u = t[9],
            l = t[10];
        return e[0] = Math.hypot(n, r, i), e[1] = Math.hypot(o, a, s), e[2] = Math.hypot(c, u, l), e
    }

    function Mt(e, t) {
        var n = new v(3);
        wt(n, t);
        var r = 1 / n[0],
            i = 1 / n[1],
            o = 1 / n[2],
            a = t[0] * r,
            s = t[1] * i,
            c = t[2] * o,
            u = t[4] * r,
            l = t[5] * i,
            f = t[6] * o,
            d = t[8] * r,
            h = t[9] * i,
            p = t[10] * o,
            m = a + l + p,
            y = 0;
        return m > 0 ? (y = 2 * Math.sqrt(m + 1), e[3] = .25 * y, e[0] = (f - h) / y, e[1] = (d - c) / y, e[2] = (s - u) / y) : a > l && a > p ? (y = 2 * Math.sqrt(1 + a - l - p), e[3] = (f - h) / y, e[0] = .25 * y, e[1] = (s + u) / y, e[2] = (d + c) / y) : l > p ? (y = 2 * Math.sqrt(1 + l - a - p), e[3] = (d - c) / y, e[0] = (s + u) / y, e[1] = .25 * y, e[2] = (f + h) / y) : (y = 2 * Math.sqrt(1 + p - a - l), e[3] = (s - u) / y, e[0] = (d + c) / y, e[1] = (f + h) / y, e[2] = .25 * y), e
    }

    function _t(e, t, n, r) {
        var i = t[0],
            o = t[1],
            a = t[2],
            s = t[3],
            c = i + i,
            u = o + o,
            l = a + a,
            f = i * c,
            d = i * u,
            h = i * l,
            v = o * u,
            p = o * l,
            m = a * l,
            y = s * c,
            g = s * u,
            x = s * l,
            b = r[0],
            w = r[1],
            M = r[2];
        return e[0] = (1 - (v + m)) * b, e[1] = (d + x) * b, e[2] = (h - g) * b, e[3] = 0, e[4] = (d - x) * w, e[5] = (1 - (f + m)) * w, e[6] = (p + y) * w, e[7] = 0, e[8] = (h + g) * M, e[9] = (p - y) * M, e[10] = (1 - (f + v)) * M, e[11] = 0, e[12] = n[0], e[13] = n[1], e[14] = n[2], e[15] = 1, e
    }

    function St(e, t, n, r, i) {
        var o = t[0],
            a = t[1],
            s = t[2],
            c = t[3],
            u = o + o,
            l = a + a,
            f = s + s,
            d = o * u,
            h = o * l,
            v = o * f,
            p = a * l,
            m = a * f,
            y = s * f,
            g = c * u,
            x = c * l,
            b = c * f,
            w = r[0],
            M = r[1],
            _ = r[2],
            S = i[0],
            P = i[1],
            T = i[2],
            E = (1 - (p + y)) * w,
            z = (h + b) * w,
            L = (v - x) * w,
            A = (h - b) * M,
            C = (1 - (d + y)) * M,
            R = (m + g) * M,
            O = (v + x) * _,
            j = (m - g) * _,
            I = (1 - (d + p)) * _;
        return e[0] = E, e[1] = z, e[2] = L, e[3] = 0, e[4] = A, e[5] = C, e[6] = R, e[7] = 0, e[8] = O, e[9] = j, e[10] = I, e[11] = 0, e[12] = n[0] + S - (E * S + A * P + O * T), e[13] = n[1] + P - (z * S + C * P + j * T), e[14] = n[2] + T - (L * S + R * P + I * T), e[15] = 1, e
    }

    function Pt(e, t) {
        var n = t[0],
            r = t[1],
            i = t[2],
            o = t[3],
            a = n + n,
            s = r + r,
            c = i + i,
            u = n * a,
            l = r * a,
            f = r * s,
            d = i * a,
            h = i * s,
            v = i * c,
            p = o * a,
            m = o * s,
            y = o * c;
        return e[0] = 1 - f - v, e[1] = l + y, e[2] = d - m, e[3] = 0, e[4] = l - y, e[5] = 1 - u - v, e[6] = h + p, e[7] = 0, e[8] = d + m, e[9] = h - p, e[10] = 1 - u - f, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e
    }

    function Tt(e, t, n, r, i, o, a) {
        var s = 1 / (n - t),
            c = 1 / (i - r),
            u = 1 / (o - a);
        return e[0] = 2 * o * s, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = 2 * o * c, e[6] = 0, e[7] = 0, e[8] = (n + t) * s, e[9] = (i + r) * c, e[10] = (a + o) * u, e[11] = -1, e[12] = 0, e[13] = 0, e[14] = a * o * 2 * u, e[15] = 0, e
    }

    function Et(e, t, n, r, i) {
        var o, a = 1 / Math.tan(t / 2);
        return e[0] = a / n, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = a, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[11] = -1, e[12] = 0, e[13] = 0, e[15] = 0, null != i && i !== 1 / 0 ? (o = 1 / (r - i), e[10] = (i + r) * o, e[14] = 2 * i * r * o) : (e[10] = -1, e[14] = -2 * r), e
    }

    function zt(e, t, n, r) {
        var i = Math.tan(t.upDegrees * Math.PI / 180),
            o = Math.tan(t.downDegrees * Math.PI / 180),
            a = Math.tan(t.leftDegrees * Math.PI / 180),
            s = Math.tan(t.rightDegrees * Math.PI / 180),
            c = 2 / (a + s),
            u = 2 / (i + o);
        return e[0] = c, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = u, e[6] = 0, e[7] = 0, e[8] = -(a - s) * c * .5, e[9] = (i - o) * u * .5, e[10] = r / (n - r), e[11] = -1, e[12] = 0, e[13] = 0, e[14] = r * n / (n - r), e[15] = 0, e
    }

    function Lt(e, t, n, r, i, o, a) {
        var s = 1 / (t - n),
            c = 1 / (r - i),
            u = 1 / (o - a);
        return e[0] = -2 * s, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = -2 * c, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 2 * u, e[11] = 0, e[12] = (t + n) * s, e[13] = (i + r) * c, e[14] = (a + o) * u, e[15] = 1, e
    }

    function At(e, t, n, r) {
        var i, o, a, s, c, u, l, f, d, v, p = t[0],
            m = t[1],
            y = t[2],
            g = r[0],
            x = r[1],
            b = r[2],
            w = n[0],
            M = n[1],
            _ = n[2];
        return Math.abs(p - w) < h && Math.abs(m - M) < h && Math.abs(y - _) < h ? et(e) : (l = p - w, f = m - M, d = y - _, i = x * (d *= v = 1 / Math.hypot(l, f, d)) - b * (f *= v), o = b * (l *= v) - g * d, a = g * f - x * l, (v = Math.hypot(i, o, a)) ? (i *= v = 1 / v, o *= v, a *= v) : (i = 0, o = 0, a = 0), s = f * a - d * o, c = d * i - l * a, u = l * o - f * i, (v = Math.hypot(s, c, u)) ? (s *= v = 1 / v, c *= v, u *= v) : (s = 0, c = 0, u = 0), e[0] = i, e[1] = s, e[2] = l, e[3] = 0, e[4] = o, e[5] = c, e[6] = f, e[7] = 0, e[8] = a, e[9] = u, e[10] = d, e[11] = 0, e[12] = -(i * p + o * m + a * y), e[13] = -(s * p + c * m + u * y), e[14] = -(l * p + f * m + d * y), e[15] = 1, e)
    }

    function Ct(e, t, n, r) {
        var i = t[0],
            o = t[1],
            a = t[2],
            s = r[0],
            c = r[1],
            u = r[2],
            l = i - n[0],
            f = o - n[1],
            d = a - n[2],
            h = l * l + f * f + d * d;
        h > 0 && (l *= h = 1 / Math.sqrt(h), f *= h, d *= h);
        var v = c * d - u * f,
            p = u * l - s * d,
            m = s * f - c * l;
        return (h = v * v + p * p + m * m) > 0 && (v *= h = 1 / Math.sqrt(h), p *= h, m *= h), e[0] = v, e[1] = p, e[2] = m, e[3] = 0, e[4] = f * m - d * p, e[5] = d * v - l * m, e[6] = l * p - f * v, e[7] = 0, e[8] = l, e[9] = f, e[10] = d, e[11] = 0, e[12] = i, e[13] = o, e[14] = a, e[15] = 1, e
    }

    function Rt(e) {
        return "mat4(" + e[0] + ", " + e[1] + ", " + e[2] + ", " + e[3] + ", " + e[4] + ", " + e[5] + ", " + e[6] + ", " + e[7] + ", " + e[8] + ", " + e[9] + ", " + e[10] + ", " + e[11] + ", " + e[12] + ", " + e[13] + ", " + e[14] + ", " + e[15] + ")"
    }

    function Ot(e) {
        return Math.hypot(e[0], e[1], e[3], e[4], e[5], e[6], e[7], e[8], e[9], e[10], e[11], e[12], e[13], e[14], e[15])
    }

    function jt(e, t, n) {
        return e[0] = t[0] + n[0], e[1] = t[1] + n[1], e[2] = t[2] + n[2], e[3] = t[3] + n[3], e[4] = t[4] + n[4], e[5] = t[5] + n[5], e[6] = t[6] + n[6], e[7] = t[7] + n[7], e[8] = t[8] + n[8], e[9] = t[9] + n[9], e[10] = t[10] + n[10], e[11] = t[11] + n[11], e[12] = t[12] + n[12], e[13] = t[13] + n[13], e[14] = t[14] + n[14], e[15] = t[15] + n[15], e
    }

    function It(e, t, n) {
        return e[0] = t[0] - n[0], e[1] = t[1] - n[1], e[2] = t[2] - n[2], e[3] = t[3] - n[3], e[4] = t[4] - n[4], e[5] = t[5] - n[5], e[6] = t[6] - n[6], e[7] = t[7] - n[7], e[8] = t[8] - n[8], e[9] = t[9] - n[9], e[10] = t[10] - n[10], e[11] = t[11] - n[11], e[12] = t[12] - n[12], e[13] = t[13] - n[13], e[14] = t[14] - n[14], e[15] = t[15] - n[15], e
    }

    function Dt(e, t, n) {
        return e[0] = t[0] * n, e[1] = t[1] * n, e[2] = t[2] * n, e[3] = t[3] * n, e[4] = t[4] * n, e[5] = t[5] * n, e[6] = t[6] * n, e[7] = t[7] * n, e[8] = t[8] * n, e[9] = t[9] * n, e[10] = t[10] * n, e[11] = t[11] * n, e[12] = t[12] * n, e[13] = t[13] * n, e[14] = t[14] * n, e[15] = t[15] * n, e
    }

    function kt(e, t, n, r) {
        return e[0] = t[0] + n[0] * r, e[1] = t[1] + n[1] * r, e[2] = t[2] + n[2] * r, e[3] = t[3] + n[3] * r, e[4] = t[4] + n[4] * r, e[5] = t[5] + n[5] * r, e[6] = t[6] + n[6] * r, e[7] = t[7] + n[7] * r, e[8] = t[8] + n[8] * r, e[9] = t[9] + n[9] * r, e[10] = t[10] + n[10] * r, e[11] = t[11] + n[11] * r, e[12] = t[12] + n[12] * r, e[13] = t[13] + n[13] * r, e[14] = t[14] + n[14] * r, e[15] = t[15] + n[15] * r, e
    }

    function Ft(e, t) {
        return e[0] === t[0] && e[1] === t[1] && e[2] === t[2] && e[3] === t[3] && e[4] === t[4] && e[5] === t[5] && e[6] === t[6] && e[7] === t[7] && e[8] === t[8] && e[9] === t[9] && e[10] === t[10] && e[11] === t[11] && e[12] === t[12] && e[13] === t[13] && e[14] === t[14] && e[15] === t[15]
    }

    function Gt(e, t) {
        var n = e[0],
            r = e[1],
            i = e[2],
            o = e[3],
            a = e[4],
            s = e[5],
            c = e[6],
            u = e[7],
            l = e[8],
            f = e[9],
            d = e[10],
            v = e[11],
            p = e[12],
            m = e[13],
            y = e[14],
            g = e[15],
            x = t[0],
            b = t[1],
            w = t[2],
            M = t[3],
            _ = t[4],
            S = t[5],
            P = t[6],
            T = t[7],
            E = t[8],
            z = t[9],
            L = t[10],
            A = t[11],
            C = t[12],
            R = t[13],
            O = t[14],
            j = t[15];
        return Math.abs(n - x) <= h * Math.max(1, Math.abs(n), Math.abs(x)) && Math.abs(r - b) <= h * Math.max(1, Math.abs(r), Math.abs(b)) && Math.abs(i - w) <= h * Math.max(1, Math.abs(i), Math.abs(w)) && Math.abs(o - M) <= h * Math.max(1, Math.abs(o), Math.abs(M)) && Math.abs(a - _) <= h * Math.max(1, Math.abs(a), Math.abs(_)) && Math.abs(s - S) <= h * Math.max(1, Math.abs(s), Math.abs(S)) && Math.abs(c - P) <= h * Math.max(1, Math.abs(c), Math.abs(P)) && Math.abs(u - T) <= h * Math.max(1, Math.abs(u), Math.abs(T)) && Math.abs(l - E) <= h * Math.max(1, Math.abs(l), Math.abs(E)) && Math.abs(f - z) <= h * Math.max(1, Math.abs(f), Math.abs(z)) && Math.abs(d - L) <= h * Math.max(1, Math.abs(d), Math.abs(L)) && Math.abs(v - A) <= h * Math.max(1, Math.abs(v), Math.abs(A)) && Math.abs(p - C) <= h * Math.max(1, Math.abs(p), Math.abs(C)) && Math.abs(m - R) <= h * Math.max(1, Math.abs(m), Math.abs(R)) && Math.abs(y - O) <= h * Math.max(1, Math.abs(y), Math.abs(O)) && Math.abs(g - j) <= h * Math.max(1, Math.abs(g), Math.abs(j))
    }
    var Nt = ot,
        Bt = It;

    function Ut() {
        var e = new v(3);
        return v != Float32Array && (e[0] = 0, e[1] = 0, e[2] = 0), e
    }

    function Ht(e) {
        var t = new v(3);
        return t[0] = e[0], t[1] = e[1], t[2] = e[2], t
    }

    function Vt(e) {
        var t = e[0],
            n = e[1],
            r = e[2];
        return Math.hypot(t, n, r)
    }

    function Wt(e, t, n) {
        var r = new v(3);
        return r[0] = e, r[1] = t, r[2] = n, r
    }

    function Yt(e, t) {
        return e[0] = t[0], e[1] = t[1], e[2] = t[2], e
    }

    function Xt(e, t, n, r) {
        return e[0] = t, e[1] = n, e[2] = r, e
    }

    function qt(e, t, n) {
        return e[0] = t[0] + n[0], e[1] = t[1] + n[1], e[2] = t[2] + n[2], e
    }

    function Kt(e, t, n) {
        return e[0] = t[0] - n[0], e[1] = t[1] - n[1], e[2] = t[2] - n[2], e
    }

    function Zt(e, t, n) {
        return e[0] = t[0] * n[0], e[1] = t[1] * n[1], e[2] = t[2] * n[2], e
    }

    function Jt(e, t, n) {
        return e[0] = t[0] / n[0], e[1] = t[1] / n[1], e[2] = t[2] / n[2], e
    }

    function Qt(e, t) {
        return e[0] = Math.ceil(t[0]), e[1] = Math.ceil(t[1]), e[2] = Math.ceil(t[2]), e
    }

    function $t(e, t) {
        return e[0] = Math.floor(t[0]), e[1] = Math.floor(t[1]), e[2] = Math.floor(t[2]), e
    }

    function en(e, t, n) {
        return e[0] = Math.min(t[0], n[0]), e[1] = Math.min(t[1], n[1]), e[2] = Math.min(t[2], n[2]), e
    }

    function tn(e, t, n) {
        return e[0] = Math.max(t[0], n[0]), e[1] = Math.max(t[1], n[1]), e[2] = Math.max(t[2], n[2]), e
    }

    function nn(e, t) {
        return e[0] = Math.round(t[0]), e[1] = Math.round(t[1]), e[2] = Math.round(t[2]), e
    }

    function rn(e, t, n) {
        return e[0] = t[0] * n, e[1] = t[1] * n, e[2] = t[2] * n, e
    }

    function on(e, t, n, r) {
        return e[0] = t[0] + n[0] * r, e[1] = t[1] + n[1] * r, e[2] = t[2] + n[2] * r, e
    }

    function an(e, t) {
        var n = t[0] - e[0],
            r = t[1] - e[1],
            i = t[2] - e[2];
        return Math.hypot(n, r, i)
    }

    function sn(e, t) {
        var n = t[0] - e[0],
            r = t[1] - e[1],
            i = t[2] - e[2];
        return n * n + r * r + i * i
    }

    function cn(e) {
        var t = e[0],
            n = e[1],
            r = e[2];
        return t * t + n * n + r * r
    }

    function un(e, t) {
        return e[0] = -t[0], e[1] = -t[1], e[2] = -t[2], e
    }

    function ln(e, t) {
        return e[0] = 1 / t[0], e[1] = 1 / t[1], e[2] = 1 / t[2], e
    }

    function fn(e, t) {
        var n = t[0],
            r = t[1],
            i = t[2],
            o = n * n + r * r + i * i;
        return o > 0 && (o = 1 / Math.sqrt(o)), e[0] = t[0] * o, e[1] = t[1] * o, e[2] = t[2] * o, e
    }

    function dn(e, t) {
        return e[0] * t[0] + e[1] * t[1] + e[2] * t[2]
    }

    function hn(e, t, n) {
        var r = t[0],
            i = t[1],
            o = t[2],
            a = n[0],
            s = n[1],
            c = n[2];
        return e[0] = i * c - o * s, e[1] = o * a - r * c, e[2] = r * s - i * a, e
    }

    function vn(e, t, n, r) {
        var i = t[0],
            o = t[1],
            a = t[2];
        return e[0] = i + r * (n[0] - i), e[1] = o + r * (n[1] - o), e[2] = a + r * (n[2] - a), e
    }

    function pn(e, t, n, r, i, o) {
        var a = o * o,
            s = a * (2 * o - 3) + 1,
            c = a * (o - 2) + o,
            u = a * (o - 1),
            l = a * (3 - 2 * o);
        return e[0] = t[0] * s + n[0] * c + r[0] * u + i[0] * l, e[1] = t[1] * s + n[1] * c + r[1] * u + i[1] * l, e[2] = t[2] * s + n[2] * c + r[2] * u + i[2] * l, e
    }

    function mn(e, t, n, r, i, o) {
        var a = 1 - o,
            s = a * a,
            c = o * o,
            u = s * a,
            l = 3 * o * s,
            f = 3 * c * a,
            d = c * o;
        return e[0] = t[0] * u + n[0] * l + r[0] * f + i[0] * d, e[1] = t[1] * u + n[1] * l + r[1] * f + i[1] * d, e[2] = t[2] * u + n[2] * l + r[2] * f + i[2] * d, e
    }

    function yn(e, t) {
        t = t || 1;
        var n = 2 * p() * Math.PI,
            r = 2 * p() - 1,
            i = Math.sqrt(1 - r * r) * t;
        return e[0] = Math.cos(n) * i, e[1] = Math.sin(n) * i, e[2] = r * t, e
    }

    function gn(e, t, n) {
        var r = t[0],
            i = t[1],
            o = t[2],
            a = n[3] * r + n[7] * i + n[11] * o + n[15];
        return a = a || 1, e[0] = (n[0] * r + n[4] * i + n[8] * o + n[12]) / a, e[1] = (n[1] * r + n[5] * i + n[9] * o + n[13]) / a, e[2] = (n[2] * r + n[6] * i + n[10] * o + n[14]) / a, e
    }

    function xn(e, t, n) {
        var r = t[0],
            i = t[1],
            o = t[2];
        return e[0] = r * n[0] + i * n[3] + o * n[6], e[1] = r * n[1] + i * n[4] + o * n[7], e[2] = r * n[2] + i * n[5] + o * n[8], e
    }

    function bn(e, t, n) {
        var r = n[0],
            i = n[1],
            o = n[2],
            a = n[3],
            s = t[0],
            c = t[1],
            u = t[2],
            l = i * u - o * c,
            f = o * s - r * u,
            d = r * c - i * s,
            h = i * d - o * f,
            v = o * l - r * d,
            p = r * f - i * l,
            m = 2 * a;
        return l *= m, f *= m, d *= m, h *= 2, v *= 2, p *= 2, e[0] = s + l + h, e[1] = c + f + v, e[2] = u + d + p, e
    }

    function wn(e, t, n, r) {
        var i = [],
            o = [];
        return i[0] = t[0] - n[0], i[1] = t[1] - n[1], i[2] = t[2] - n[2], o[0] = i[0], o[1] = i[1] * Math.cos(r) - i[2] * Math.sin(r), o[2] = i[1] * Math.sin(r) + i[2] * Math.cos(r), e[0] = o[0] + n[0], e[1] = o[1] + n[1], e[2] = o[2] + n[2], e
    }

    function Mn(e, t, n, r) {
        var i = [],
            o = [];
        return i[0] = t[0] - n[0], i[1] = t[1] - n[1], i[2] = t[2] - n[2], o[0] = i[2] * Math.sin(r) + i[0] * Math.cos(r), o[1] = i[1], o[2] = i[2] * Math.cos(r) - i[0] * Math.sin(r), e[0] = o[0] + n[0], e[1] = o[1] + n[1], e[2] = o[2] + n[2], e
    }

    function _n(e, t, n, r) {
        var i = [],
            o = [];
        return i[0] = t[0] - n[0], i[1] = t[1] - n[1], i[2] = t[2] - n[2], o[0] = i[0] * Math.cos(r) - i[1] * Math.sin(r), o[1] = i[0] * Math.sin(r) + i[1] * Math.cos(r), o[2] = i[2], e[0] = o[0] + n[0], e[1] = o[1] + n[1], e[2] = o[2] + n[2], e
    }

    function Sn(e, t) {
        var n = Wt(e[0], e[1], e[2]),
            r = Wt(t[0], t[1], t[2]);
        fn(n, n), fn(r, r);
        var i = dn(n, r);
        return i > 1 ? 0 : i < -1 ? Math.PI : Math.acos(i)
    }

    function Pn(e) {
        return e[0] = 0, e[1] = 0, e[2] = 0, e
    }

    function Tn(e) {
        return "vec3(" + e[0] + ", " + e[1] + ", " + e[2] + ")"
    }

    function En(e, t) {
        return e[0] === t[0] && e[1] === t[1] && e[2] === t[2]
    }

    function zn(e, t) {
        var n = e[0],
            r = e[1],
            i = e[2],
            o = t[0],
            a = t[1],
            s = t[2];
        return Math.abs(n - o) <= h * Math.max(1, Math.abs(n), Math.abs(o)) && Math.abs(r - a) <= h * Math.max(1, Math.abs(r), Math.abs(a)) && Math.abs(i - s) <= h * Math.max(1, Math.abs(i), Math.abs(s))
    }
    var Ln, An = Kt,
        Cn = Zt,
        Rn = Jt,
        On = an,
        jn = sn,
        In = Vt,
        Dn = cn,
        kn = (Ln = Ut(), function(e, t, n, r, i, o) {
            var a, s;
            for (t || (t = 3), n || (n = 0), s = r ? Math.min(r * t + n, e.length) : e.length, a = n; a < s; a += t) Ln[0] = e[a], Ln[1] = e[a + 1], Ln[2] = e[a + 2], i(Ln, Ln, o), e[a] = Ln[0], e[a + 1] = Ln[1], e[a + 2] = Ln[2];
            return e
        });

    function Fn() {
        var e = new v(4);
        return v != Float32Array && (e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 0), e
    }

    function Gn(e) {
        var t = new v(4);
        return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t
    }

    function Nn(e, t, n, r) {
        var i = new v(4);
        return i[0] = e, i[1] = t, i[2] = n, i[3] = r, i
    }

    function Bn(e, t) {
        return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e
    }

    function Un(e, t, n, r, i) {
        return e[0] = t, e[1] = n, e[2] = r, e[3] = i, e
    }

    function Hn(e, t, n) {
        return e[0] = t[0] + n[0], e[1] = t[1] + n[1], e[2] = t[2] + n[2], e[3] = t[3] + n[3], e
    }

    function Vn(e, t, n) {
        return e[0] = t[0] - n[0], e[1] = t[1] - n[1], e[2] = t[2] - n[2], e[3] = t[3] - n[3], e
    }

    function Wn(e, t, n) {
        return e[0] = t[0] * n[0], e[1] = t[1] * n[1], e[2] = t[2] * n[2], e[3] = t[3] * n[3], e
    }

    function Yn(e, t, n) {
        return e[0] = t[0] / n[0], e[1] = t[1] / n[1], e[2] = t[2] / n[2], e[3] = t[3] / n[3], e
    }

    function Xn(e, t) {
        return e[0] = Math.ceil(t[0]), e[1] = Math.ceil(t[1]), e[2] = Math.ceil(t[2]), e[3] = Math.ceil(t[3]), e
    }

    function qn(e, t) {
        return e[0] = Math.floor(t[0]), e[1] = Math.floor(t[1]), e[2] = Math.floor(t[2]), e[3] = Math.floor(t[3]), e
    }

    function Kn(e, t, n) {
        return e[0] = Math.min(t[0], n[0]), e[1] = Math.min(t[1], n[1]), e[2] = Math.min(t[2], n[2]), e[3] = Math.min(t[3], n[3]), e
    }

    function Zn(e, t, n) {
        return e[0] = Math.max(t[0], n[0]), e[1] = Math.max(t[1], n[1]), e[2] = Math.max(t[2], n[2]), e[3] = Math.max(t[3], n[3]), e
    }

    function Jn(e, t) {
        return e[0] = Math.round(t[0]), e[1] = Math.round(t[1]), e[2] = Math.round(t[2]), e[3] = Math.round(t[3]), e
    }

    function Qn(e, t, n) {
        return e[0] = t[0] * n, e[1] = t[1] * n, e[2] = t[2] * n, e[3] = t[3] * n, e
    }

    function $n(e, t, n, r) {
        return e[0] = t[0] + n[0] * r, e[1] = t[1] + n[1] * r, e[2] = t[2] + n[2] * r, e[3] = t[3] + n[3] * r, e
    }

    function er(e, t) {
        var n = t[0] - e[0],
            r = t[1] - e[1],
            i = t[2] - e[2],
            o = t[3] - e[3];
        return Math.hypot(n, r, i, o)
    }

    function tr(e, t) {
        var n = t[0] - e[0],
            r = t[1] - e[1],
            i = t[2] - e[2],
            o = t[3] - e[3];
        return n * n + r * r + i * i + o * o
    }

    function nr(e) {
        var t = e[0],
            n = e[1],
            r = e[2],
            i = e[3];
        return Math.hypot(t, n, r, i)
    }

    function rr(e) {
        var t = e[0],
            n = e[1],
            r = e[2],
            i = e[3];
        return t * t + n * n + r * r + i * i
    }

    function ir(e, t) {
        return e[0] = -t[0], e[1] = -t[1], e[2] = -t[2], e[3] = -t[3], e
    }

    function or(e, t) {
        return e[0] = 1 / t[0], e[1] = 1 / t[1], e[2] = 1 / t[2], e[3] = 1 / t[3], e
    }

    function ar(e, t) {
        var n = t[0],
            r = t[1],
            i = t[2],
            o = t[3],
            a = n * n + r * r + i * i + o * o;
        return a > 0 && (a = 1 / Math.sqrt(a)), e[0] = n * a, e[1] = r * a, e[2] = i * a, e[3] = o * a, e
    }

    function sr(e, t) {
        return e[0] * t[0] + e[1] * t[1] + e[2] * t[2] + e[3] * t[3]
    }

    function cr(e, t, n, r) {
        var i = n[0] * r[1] - n[1] * r[0],
            o = n[0] * r[2] - n[2] * r[0],
            a = n[0] * r[3] - n[3] * r[0],
            s = n[1] * r[2] - n[2] * r[1],
            c = n[1] * r[3] - n[3] * r[1],
            u = n[2] * r[3] - n[3] * r[2],
            l = t[0],
            f = t[1],
            d = t[2],
            h = t[3];
        return e[0] = f * u - d * c + h * s, e[1] = -l * u + d * a - h * o, e[2] = l * c - f * a + h * i, e[3] = -l * s + f * o - d * i, e
    }

    function ur(e, t, n, r) {
        var i = t[0],
            o = t[1],
            a = t[2],
            s = t[3];
        return e[0] = i + r * (n[0] - i), e[1] = o + r * (n[1] - o), e[2] = a + r * (n[2] - a), e[3] = s + r * (n[3] - s), e
    }

    function lr(e, t) {
        var n, r, i, o, a, s;
        t = t || 1;
        do {
            a = (n = 2 * p() - 1) * n + (r = 2 * p() - 1) * r
        } while (a >= 1);
        do {
            s = (i = 2 * p() - 1) * i + (o = 2 * p() - 1) * o
        } while (s >= 1);
        var c = Math.sqrt((1 - a) / s);
        return e[0] = t * n, e[1] = t * r, e[2] = t * i * c, e[3] = t * o * c, e
    }

    function fr(e, t, n) {
        var r = t[0],
            i = t[1],
            o = t[2],
            a = t[3];
        return e[0] = n[0] * r + n[4] * i + n[8] * o + n[12] * a, e[1] = n[1] * r + n[5] * i + n[9] * o + n[13] * a, e[2] = n[2] * r + n[6] * i + n[10] * o + n[14] * a, e[3] = n[3] * r + n[7] * i + n[11] * o + n[15] * a, e
    }

    function dr(e, t, n) {
        var r = t[0],
            i = t[1],
            o = t[2],
            a = n[0],
            s = n[1],
            c = n[2],
            u = n[3],
            l = u * r + s * o - c * i,
            f = u * i + c * r - a * o,
            d = u * o + a * i - s * r,
            h = -a * r - s * i - c * o;
        return e[0] = l * u + h * -a + f * -c - d * -s, e[1] = f * u + h * -s + d * -a - l * -c, e[2] = d * u + h * -c + l * -s - f * -a, e[3] = t[3], e
    }

    function hr(e) {
        return e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 0, e
    }

    function vr(e) {
        return "vec4(" + e[0] + ", " + e[1] + ", " + e[2] + ", " + e[3] + ")"
    }

    function pr(e, t) {
        return e[0] === t[0] && e[1] === t[1] && e[2] === t[2] && e[3] === t[3]
    }

    function mr(e, t) {
        var n = e[0],
            r = e[1],
            i = e[2],
            o = e[3],
            a = t[0],
            s = t[1],
            c = t[2],
            u = t[3];
        return Math.abs(n - a) <= h * Math.max(1, Math.abs(n), Math.abs(a)) && Math.abs(r - s) <= h * Math.max(1, Math.abs(r), Math.abs(s)) && Math.abs(i - c) <= h * Math.max(1, Math.abs(i), Math.abs(c)) && Math.abs(o - u) <= h * Math.max(1, Math.abs(o), Math.abs(u))
    }
    var yr = Vn,
        gr = Wn,
        xr = Yn,
        br = er,
        wr = tr,
        Mr = nr,
        _r = rr,
        Sr = function() {
            var e = Fn();
            return function(t, n, r, i, o, a) {
                var s, c;
                for (n || (n = 4), r || (r = 0), c = i ? Math.min(i * n + r, t.length) : t.length, s = r; s < c; s += n) e[0] = t[s], e[1] = t[s + 1], e[2] = t[s + 2], e[3] = t[s + 3], o(e, e, a), t[s] = e[0], t[s + 1] = e[1], t[s + 2] = e[2], t[s + 3] = e[3];
                return t
            }
        }();

    function Pr() {
        var e = new v(4);
        return v != Float32Array && (e[0] = 0, e[1] = 0, e[2] = 0), e[3] = 1, e
    }

    function Tr(e) {
        return e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 1, e
    }

    function Er(e, t, n) {
        n *= .5;
        var r = Math.sin(n);
        return e[0] = r * t[0], e[1] = r * t[1], e[2] = r * t[2], e[3] = Math.cos(n), e
    }

    function zr(e, t) {
        var n = 2 * Math.acos(t[3]),
            r = Math.sin(n / 2);
        return r > h ? (e[0] = t[0] / r, e[1] = t[1] / r, e[2] = t[2] / r) : (e[0] = 1, e[1] = 0, e[2] = 0), n
    }

    function Lr(e, t) {
        var n = ii(e, t);
        return Math.acos(2 * n * n - 1)
    }

    function Ar(e, t, n) {
        var r = t[0],
            i = t[1],
            o = t[2],
            a = t[3],
            s = n[0],
            c = n[1],
            u = n[2],
            l = n[3];
        return e[0] = r * l + a * s + i * u - o * c, e[1] = i * l + a * c + o * s - r * u, e[2] = o * l + a * u + r * c - i * s, e[3] = a * l - r * s - i * c - o * u, e
    }

    function Cr(e, t, n) {
        n *= .5;
        var r = t[0],
            i = t[1],
            o = t[2],
            a = t[3],
            s = Math.sin(n),
            c = Math.cos(n);
        return e[0] = r * c + a * s, e[1] = i * c + o * s, e[2] = o * c - i * s, e[3] = a * c - r * s, e
    }

    function Rr(e, t, n) {
        n *= .5;
        var r = t[0],
            i = t[1],
            o = t[2],
            a = t[3],
            s = Math.sin(n),
            c = Math.cos(n);
        return e[0] = r * c - o * s, e[1] = i * c + a * s, e[2] = o * c + r * s, e[3] = a * c - i * s, e
    }

    function Or(e, t, n) {
        n *= .5;
        var r = t[0],
            i = t[1],
            o = t[2],
            a = t[3],
            s = Math.sin(n),
            c = Math.cos(n);
        return e[0] = r * c + i * s, e[1] = i * c - r * s, e[2] = o * c + a * s, e[3] = a * c - o * s, e
    }

    function jr(e, t) {
        var n = t[0],
            r = t[1],
            i = t[2];
        return e[0] = n, e[1] = r, e[2] = i, e[3] = Math.sqrt(Math.abs(1 - n * n - r * r - i * i)), e
    }

    function Ir(e, t) {
        var n = t[0],
            r = t[1],
            i = t[2],
            o = t[3],
            a = Math.sqrt(n * n + r * r + i * i),
            s = Math.exp(o),
            c = a > 0 ? s * Math.sin(a) / a : 0;
        return e[0] = n * c, e[1] = r * c, e[2] = i * c, e[3] = s * Math.cos(a), e
    }

    function Dr(e, t) {
        var n = t[0],
            r = t[1],
            i = t[2],
            o = t[3],
            a = Math.sqrt(n * n + r * r + i * i),
            s = a > 0 ? Math.atan2(a, o) / a : 0;
        return e[0] = n * s, e[1] = r * s, e[2] = i * s, e[3] = .5 * Math.log(n * n + r * r + i * i + o * o), e
    }

    function kr(e, t, n) {
        return Dr(e, t), ri(e, e, n), Ir(e, e), e
    }

    function Fr(e, t, n, r) {
        var i, o, a, s, c, u = t[0],
            l = t[1],
            f = t[2],
            d = t[3],
            v = n[0],
            p = n[1],
            m = n[2],
            y = n[3];
        return (o = u * v + l * p + f * m + d * y) < 0 && (o = -o, v = -v, p = -p, m = -m, y = -y), 1 - o > h ? (i = Math.acos(o), a = Math.sin(i), s = Math.sin((1 - r) * i) / a, c = Math.sin(r * i) / a) : (s = 1 - r, c = r), e[0] = s * u + c * v, e[1] = s * l + c * p, e[2] = s * f + c * m, e[3] = s * d + c * y, e
    }

    function Gr(e) {
        var t = p(),
            n = p(),
            r = p(),
            i = Math.sqrt(1 - t),
            o = Math.sqrt(t);
        return e[0] = i * Math.sin(2 * Math.PI * n), e[1] = i * Math.cos(2 * Math.PI * n), e[2] = o * Math.sin(2 * Math.PI * r), e[3] = o * Math.cos(2 * Math.PI * r), e
    }

    function Nr(e, t) {
        var n = t[0],
            r = t[1],
            i = t[2],
            o = t[3],
            a = n * n + r * r + i * i + o * o,
            s = a ? 1 / a : 0;
        return e[0] = -n * s, e[1] = -r * s, e[2] = -i * s, e[3] = o * s, e
    }

    function Br(e, t) {
        return e[0] = -t[0], e[1] = -t[1], e[2] = -t[2], e[3] = t[3], e
    }

    function Ur(e, t) {
        var n, r = t[0] + t[4] + t[8];
        if (r > 0) n = Math.sqrt(r + 1), e[3] = .5 * n, n = .5 / n, e[0] = (t[5] - t[7]) * n, e[1] = (t[6] - t[2]) * n, e[2] = (t[1] - t[3]) * n;
        else {
            var i = 0;
            t[4] > t[0] && (i = 1), t[8] > t[3 * i + i] && (i = 2);
            var o = (i + 1) % 3,
                a = (i + 2) % 3;
            n = Math.sqrt(t[3 * i + i] - t[3 * o + o] - t[3 * a + a] + 1), e[i] = .5 * n, n = .5 / n, e[3] = (t[3 * o + a] - t[3 * a + o]) * n, e[o] = (t[3 * o + i] + t[3 * i + o]) * n, e[a] = (t[3 * a + i] + t[3 * i + a]) * n
        }
        return e
    }

    function Hr(e, t, n, r) {
        var i = .5 * Math.PI / 180;
        t *= i, n *= i, r *= i;
        var o = Math.sin(t),
            a = Math.cos(t),
            s = Math.sin(n),
            c = Math.cos(n),
            u = Math.sin(r),
            l = Math.cos(r);
        return e[0] = o * c * l - a * s * u, e[1] = a * s * l + o * c * u, e[2] = a * c * u - o * s * l, e[3] = a * c * l + o * s * u, e
    }

    function Vr(e) {
        return "quat(" + e[0] + ", " + e[1] + ", " + e[2] + ", " + e[3] + ")"
    }
    var Wr, Yr, Xr, qr, Kr, Zr, Jr = Gn,
        Qr = Nn,
        $r = Bn,
        ei = Un,
        ti = Hn,
        ni = Ar,
        ri = Qn,
        ii = sr,
        oi = ur,
        ai = nr,
        si = ai,
        ci = rr,
        ui = ci,
        li = ar,
        fi = pr,
        di = mr,
        hi = (Wr = Ut(), Yr = Wt(1, 0, 0), Xr = Wt(0, 1, 0), function(e, t, n) {
            var r = dn(t, n);
            return r < -.999999 ? (hn(Wr, Yr, t), In(Wr) < 1e-6 && hn(Wr, Xr, t), fn(Wr, Wr), Er(e, Wr, Math.PI), e) : r > .999999 ? (e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 1, e) : (hn(Wr, t, n), e[0] = Wr[0], e[1] = Wr[1], e[2] = Wr[2], e[3] = 1 + r, li(e, e))
        }),
        vi = (qr = Pr(), Kr = Pr(), function(e, t, n, r, i, o) {
            return Fr(qr, t, i, o), Fr(Kr, n, r, o), Fr(e, qr, Kr, 2 * o * (1 - o)), e
        }),
        pi = (Zr = ye(), function(e, t, n, r) {
            return Zr[0] = n[0], Zr[3] = n[1], Zr[6] = n[2], Zr[1] = r[0], Zr[4] = r[1], Zr[7] = r[2], Zr[2] = -t[0], Zr[5] = -t[1], Zr[8] = -t[2], li(e, Ur(e, Zr))
        });

    function mi() {
        var e = new v(8);
        return v != Float32Array && (e[0] = 0, e[1] = 0, e[2] = 0, e[4] = 0, e[5] = 0, e[6] = 0, e[7] = 0), e[3] = 1, e
    }

    function yi(e) {
        var t = new v(8);
        return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t
    }

    function gi(e, t, n, r, i, o, a, s) {
        var c = new v(8);
        return c[0] = e, c[1] = t, c[2] = n, c[3] = r, c[4] = i, c[5] = o, c[6] = a, c[7] = s, c
    }

    function xi(e, t, n, r, i, o, a) {
        var s = new v(8);
        s[0] = e, s[1] = t, s[2] = n, s[3] = r;
        var c = .5 * i,
            u = .5 * o,
            l = .5 * a;
        return s[4] = c * r + u * n - l * t, s[5] = u * r + l * e - c * n, s[6] = l * r + c * t - u * e, s[7] = -c * e - u * t - l * n, s
    }

    function bi(e, t, n) {
        var r = .5 * n[0],
            i = .5 * n[1],
            o = .5 * n[2],
            a = t[0],
            s = t[1],
            c = t[2],
            u = t[3];
        return e[0] = a, e[1] = s, e[2] = c, e[3] = u, e[4] = r * u + i * c - o * s, e[5] = i * u + o * a - r * c, e[6] = o * u + r * s - i * a, e[7] = -r * a - i * s - o * c, e
    }

    function wi(e, t) {
        return e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 1, e[4] = .5 * t[0], e[5] = .5 * t[1], e[6] = .5 * t[2], e[7] = 0, e
    }

    function Mi(e, t) {
        return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = 0, e[5] = 0, e[6] = 0, e[7] = 0, e
    }

    function _i(e, t) {
        var n = Pr();
        Mt(n, t);
        var r = new v(3);
        return bt(r, t), bi(e, n, r), e
    }

    function Si(e, t) {
        return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e
    }

    function Pi(e) {
        return e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 1, e[4] = 0, e[5] = 0, e[6] = 0, e[7] = 0, e
    }

    function Ti(e, t, n, r, i, o, a, s, c) {
        return e[0] = t, e[1] = n, e[2] = r, e[3] = i, e[4] = o, e[5] = a, e[6] = s, e[7] = c, e
    }
    var Ei = $r;

    function zi(e, t) {
        return e[0] = t[4], e[1] = t[5], e[2] = t[6], e[3] = t[7], e
    }
    var Li = $r;

    function Ai(e, t) {
        return e[4] = t[0], e[5] = t[1], e[6] = t[2], e[7] = t[3], e
    }

    function Ci(e, t) {
        var n = t[4],
            r = t[5],
            i = t[6],
            o = t[7],
            a = -t[0],
            s = -t[1],
            c = -t[2],
            u = t[3];
        return e[0] = 2 * (n * u + o * a + r * c - i * s), e[1] = 2 * (r * u + o * s + i * a - n * c), e[2] = 2 * (i * u + o * c + n * s - r * a), e
    }

    function Ri(e, t, n) {
        var r = t[0],
            i = t[1],
            o = t[2],
            a = t[3],
            s = .5 * n[0],
            c = .5 * n[1],
            u = .5 * n[2],
            l = t[4],
            f = t[5],
            d = t[6],
            h = t[7];
        return e[0] = r, e[1] = i, e[2] = o, e[3] = a, e[4] = a * s + i * u - o * c + l, e[5] = a * c + o * s - r * u + f, e[6] = a * u + r * c - i * s + d, e[7] = -r * s - i * c - o * u + h, e
    }

    function Oi(e, t, n) {
        var r = -t[0],
            i = -t[1],
            o = -t[2],
            a = t[3],
            s = t[4],
            c = t[5],
            u = t[6],
            l = t[7],
            f = s * a + l * r + c * o - u * i,
            d = c * a + l * i + u * r - s * o,
            h = u * a + l * o + s * i - c * r,
            v = l * a - s * r - c * i - u * o;
        return Cr(e, t, n), r = e[0], i = e[1], o = e[2], a = e[3], e[4] = f * a + v * r + d * o - h * i, e[5] = d * a + v * i + h * r - f * o, e[6] = h * a + v * o + f * i - d * r, e[7] = v * a - f * r - d * i - h * o, e
    }

    function ji(e, t, n) {
        var r = -t[0],
            i = -t[1],
            o = -t[2],
            a = t[3],
            s = t[4],
            c = t[5],
            u = t[6],
            l = t[7],
            f = s * a + l * r + c * o - u * i,
            d = c * a + l * i + u * r - s * o,
            h = u * a + l * o + s * i - c * r,
            v = l * a - s * r - c * i - u * o;
        return Rr(e, t, n), r = e[0], i = e[1], o = e[2], a = e[3], e[4] = f * a + v * r + d * o - h * i, e[5] = d * a + v * i + h * r - f * o, e[6] = h * a + v * o + f * i - d * r, e[7] = v * a - f * r - d * i - h * o, e
    }

    function Ii(e, t, n) {
        var r = -t[0],
            i = -t[1],
            o = -t[2],
            a = t[3],
            s = t[4],
            c = t[5],
            u = t[6],
            l = t[7],
            f = s * a + l * r + c * o - u * i,
            d = c * a + l * i + u * r - s * o,
            h = u * a + l * o + s * i - c * r,
            v = l * a - s * r - c * i - u * o;
        return Or(e, t, n), r = e[0], i = e[1], o = e[2], a = e[3], e[4] = f * a + v * r + d * o - h * i, e[5] = d * a + v * i + h * r - f * o, e[6] = h * a + v * o + f * i - d * r, e[7] = v * a - f * r - d * i - h * o, e
    }

    function Di(e, t, n) {
        var r = n[0],
            i = n[1],
            o = n[2],
            a = n[3],
            s = t[0],
            c = t[1],
            u = t[2],
            l = t[3];
        return e[0] = s * a + l * r + c * o - u * i, e[1] = c * a + l * i + u * r - s * o, e[2] = u * a + l * o + s * i - c * r, e[3] = l * a - s * r - c * i - u * o, s = t[4], c = t[5], u = t[6], l = t[7], e[4] = s * a + l * r + c * o - u * i, e[5] = c * a + l * i + u * r - s * o, e[6] = u * a + l * o + s * i - c * r, e[7] = l * a - s * r - c * i - u * o, e
    }

    function ki(e, t, n) {
        var r = t[0],
            i = t[1],
            o = t[2],
            a = t[3],
            s = n[0],
            c = n[1],
            u = n[2],
            l = n[3];
        return e[0] = r * l + a * s + i * u - o * c, e[1] = i * l + a * c + o * s - r * u, e[2] = o * l + a * u + r * c - i * s, e[3] = a * l - r * s - i * c - o * u, s = n[4], c = n[5], u = n[6], l = n[7], e[4] = r * l + a * s + i * u - o * c, e[5] = i * l + a * c + o * s - r * u, e[6] = o * l + a * u + r * c - i * s, e[7] = a * l - r * s - i * c - o * u, e
    }

    function Fi(e, t, n, r) {
        if (Math.abs(r) < h) return Si(e, t);
        var i = Math.hypot(n[0], n[1], n[2]);
        r *= .5;
        var o = Math.sin(r),
            a = o * n[0] / i,
            s = o * n[1] / i,
            c = o * n[2] / i,
            u = Math.cos(r),
            l = t[0],
            f = t[1],
            d = t[2],
            v = t[3];
        e[0] = l * u + v * a + f * c - d * s, e[1] = f * u + v * s + d * a - l * c, e[2] = d * u + v * c + l * s - f * a, e[3] = v * u - l * a - f * s - d * c;
        var p = t[4],
            m = t[5],
            y = t[6],
            g = t[7];
        return e[4] = p * u + g * a + m * c - y * s, e[5] = m * u + g * s + y * a - p * c, e[6] = y * u + g * c + p * s - m * a, e[7] = g * u - p * a - m * s - y * c, e
    }

    function Gi(e, t, n) {
        return e[0] = t[0] + n[0], e[1] = t[1] + n[1], e[2] = t[2] + n[2], e[3] = t[3] + n[3], e[4] = t[4] + n[4], e[5] = t[5] + n[5], e[6] = t[6] + n[6], e[7] = t[7] + n[7], e
    }

    function Ni(e, t, n) {
        var r = t[0],
            i = t[1],
            o = t[2],
            a = t[3],
            s = n[4],
            c = n[5],
            u = n[6],
            l = n[7],
            f = t[4],
            d = t[5],
            h = t[6],
            v = t[7],
            p = n[0],
            m = n[1],
            y = n[2],
            g = n[3];
        return e[0] = r * g + a * p + i * y - o * m, e[1] = i * g + a * m + o * p - r * y, e[2] = o * g + a * y + r * m - i * p, e[3] = a * g - r * p - i * m - o * y, e[4] = r * l + a * s + i * u - o * c + f * g + v * p + d * y - h * m, e[5] = i * l + a * c + o * s - r * u + d * g + v * m + h * p - f * y, e[6] = o * l + a * u + r * c - i * s + h * g + v * y + f * m - d * p, e[7] = a * l - r * s - i * c - o * u + v * g - f * p - d * m - h * y, e
    }
    var Bi = Ni;

    function Ui(e, t, n) {
        return e[0] = t[0] * n, e[1] = t[1] * n, e[2] = t[2] * n, e[3] = t[3] * n, e[4] = t[4] * n, e[5] = t[5] * n, e[6] = t[6] * n, e[7] = t[7] * n, e
    }
    var Hi = ii;

    function Vi(e, t, n, r) {
        var i = 1 - r;
        return Hi(t, n) < 0 && (r = -r), e[0] = t[0] * i + n[0] * r, e[1] = t[1] * i + n[1] * r, e[2] = t[2] * i + n[2] * r, e[3] = t[3] * i + n[3] * r, e[4] = t[4] * i + n[4] * r, e[5] = t[5] * i + n[5] * r, e[6] = t[6] * i + n[6] * r, e[7] = t[7] * i + n[7] * r, e
    }

    function Wi(e, t) {
        var n = Ki(t);
        return e[0] = -t[0] / n, e[1] = -t[1] / n, e[2] = -t[2] / n, e[3] = t[3] / n, e[4] = -t[4] / n, e[5] = -t[5] / n, e[6] = -t[6] / n, e[7] = t[7] / n, e
    }

    function Yi(e, t) {
        return e[0] = -t[0], e[1] = -t[1], e[2] = -t[2], e[3] = t[3], e[4] = -t[4], e[5] = -t[5], e[6] = -t[6], e[7] = t[7], e
    }
    var Xi = ai,
        qi = Xi,
        Ki = ci,
        Zi = Ki;

    function Ji(e, t) {
        var n = Ki(t);
        if (n > 0) {
            n = Math.sqrt(n);
            var r = t[0] / n,
                i = t[1] / n,
                o = t[2] / n,
                a = t[3] / n,
                s = t[4],
                c = t[5],
                u = t[6],
                l = t[7],
                f = r * s + i * c + o * u + a * l;
            e[0] = r, e[1] = i, e[2] = o, e[3] = a, e[4] = (s - r * f) / n, e[5] = (c - i * f) / n, e[6] = (u - o * f) / n, e[7] = (l - a * f) / n
        }
        return e
    }

    function Qi(e) {
        return "quat2(" + e[0] + ", " + e[1] + ", " + e[2] + ", " + e[3] + ", " + e[4] + ", " + e[5] + ", " + e[6] + ", " + e[7] + ")"
    }

    function $i(e, t) {
        return e[0] === t[0] && e[1] === t[1] && e[2] === t[2] && e[3] === t[3] && e[4] === t[4] && e[5] === t[5] && e[6] === t[6] && e[7] === t[7]
    }

    function eo(e, t) {
        var n = e[0],
            r = e[1],
            i = e[2],
            o = e[3],
            a = e[4],
            s = e[5],
            c = e[6],
            u = e[7],
            l = t[0],
            f = t[1],
            d = t[2],
            v = t[3],
            p = t[4],
            m = t[5],
            y = t[6],
            g = t[7];
        return Math.abs(n - l) <= h * Math.max(1, Math.abs(n), Math.abs(l)) && Math.abs(r - f) <= h * Math.max(1, Math.abs(r), Math.abs(f)) && Math.abs(i - d) <= h * Math.max(1, Math.abs(i), Math.abs(d)) && Math.abs(o - v) <= h * Math.max(1, Math.abs(o), Math.abs(v)) && Math.abs(a - p) <= h * Math.max(1, Math.abs(a), Math.abs(p)) && Math.abs(s - m) <= h * Math.max(1, Math.abs(s), Math.abs(m)) && Math.abs(c - y) <= h * Math.max(1, Math.abs(c), Math.abs(y)) && Math.abs(u - g) <= h * Math.max(1, Math.abs(u), Math.abs(g))
    }

    function to() {
        var e = new v(2);
        return v != Float32Array && (e[0] = 0, e[1] = 0), e
    }

    function no(e) {
        var t = new v(2);
        return t[0] = e[0], t[1] = e[1], t
    }

    function ro(e, t) {
        var n = new v(2);
        return n[0] = e, n[1] = t, n
    }

    function io(e, t) {
        return e[0] = t[0], e[1] = t[1], e
    }

    function oo(e, t, n) {
        return e[0] = t, e[1] = n, e
    }

    function ao(e, t, n) {
        return e[0] = t[0] + n[0], e[1] = t[1] + n[1], e
    }

    function so(e, t, n) {
        return e[0] = t[0] - n[0], e[1] = t[1] - n[1], e
    }

    function co(e, t, n) {
        return e[0] = t[0] * n[0], e[1] = t[1] * n[1], e
    }

    function uo(e, t, n) {
        return e[0] = t[0] / n[0], e[1] = t[1] / n[1], e
    }

    function lo(e, t) {
        return e[0] = Math.ceil(t[0]), e[1] = Math.ceil(t[1]), e
    }

    function fo(e, t) {
        return e[0] = Math.floor(t[0]), e[1] = Math.floor(t[1]), e
    }

    function ho(e, t, n) {
        return e[0] = Math.min(t[0], n[0]), e[1] = Math.min(t[1], n[1]), e
    }

    function vo(e, t, n) {
        return e[0] = Math.max(t[0], n[0]), e[1] = Math.max(t[1], n[1]), e
    }

    function po(e, t) {
        return e[0] = Math.round(t[0]), e[1] = Math.round(t[1]), e
    }

    function mo(e, t, n) {
        return e[0] = t[0] * n, e[1] = t[1] * n, e
    }

    function yo(e, t, n, r) {
        return e[0] = t[0] + n[0] * r, e[1] = t[1] + n[1] * r, e
    }

    function go(e, t) {
        var n = t[0] - e[0],
            r = t[1] - e[1];
        return Math.hypot(n, r)
    }

    function xo(e, t) {
        var n = t[0] - e[0],
            r = t[1] - e[1];
        return n * n + r * r
    }

    function bo(e) {
        var t = e[0],
            n = e[1];
        return Math.hypot(t, n)
    }

    function wo(e) {
        var t = e[0],
            n = e[1];
        return t * t + n * n
    }

    function Mo(e, t) {
        return e[0] = -t[0], e[1] = -t[1], e
    }

    function _o(e, t) {
        return e[0] = 1 / t[0], e[1] = 1 / t[1], e
    }

    function So(e, t) {
        var n = t[0],
            r = t[1],
            i = n * n + r * r;
        return i > 0 && (i = 1 / Math.sqrt(i)), e[0] = t[0] * i, e[1] = t[1] * i, e
    }

    function Po(e, t) {
        return e[0] * t[0] + e[1] * t[1]
    }

    function To(e, t, n) {
        var r = t[0] * n[1] - t[1] * n[0];
        return e[0] = e[1] = 0, e[2] = r, e
    }

    function Eo(e, t, n, r) {
        var i = t[0],
            o = t[1];
        return e[0] = i + r * (n[0] - i), e[1] = o + r * (n[1] - o), e
    }

    function zo(e, t) {
        t = t || 1;
        var n = 2 * p() * Math.PI;
        return e[0] = Math.cos(n) * t, e[1] = Math.sin(n) * t, e
    }

    function Lo(e, t, n) {
        var r = t[0],
            i = t[1];
        return e[0] = n[0] * r + n[2] * i, e[1] = n[1] * r + n[3] * i, e
    }

    function Ao(e, t, n) {
        var r = t[0],
            i = t[1];
        return e[0] = n[0] * r + n[2] * i + n[4], e[1] = n[1] * r + n[3] * i + n[5], e
    }

    function Co(e, t, n) {
        var r = t[0],
            i = t[1];
        return e[0] = n[0] * r + n[3] * i + n[6], e[1] = n[1] * r + n[4] * i + n[7], e
    }

    function Ro(e, t, n) {
        var r = t[0],
            i = t[1];
        return e[0] = n[0] * r + n[4] * i + n[12], e[1] = n[1] * r + n[5] * i + n[13], e
    }

    function Oo(e, t, n, r) {
        var i = t[0] - n[0],
            o = t[1] - n[1],
            a = Math.sin(r),
            s = Math.cos(r);
        return e[0] = i * s - o * a + n[0], e[1] = i * a + o * s + n[1], e
    }

    function jo(e, t) {
        var n = e[0],
            r = e[1],
            i = t[0],
            o = t[1],
            a = n * n + r * r;
        a > 0 && (a = 1 / Math.sqrt(a));
        var s = i * i + o * o;
        s > 0 && (s = 1 / Math.sqrt(s));
        var c = (n * i + r * o) * a * s;
        return c > 1 ? 0 : c < -1 ? Math.PI : Math.acos(c)
    }

    function Io(e) {
        return e[0] = 0, e[1] = 0, e
    }

    function Do(e) {
        return "vec2(" + e[0] + ", " + e[1] + ")"
    }

    function ko(e, t) {
        return e[0] === t[0] && e[1] === t[1]
    }

    function Fo(e, t) {
        var n = e[0],
            r = e[1],
            i = t[0],
            o = t[1];
        return Math.abs(n - i) <= h * Math.max(1, Math.abs(n), Math.abs(i)) && Math.abs(r - o) <= h * Math.max(1, Math.abs(r), Math.abs(o))
    }
    var Go = bo,
        No = so,
        Bo = co,
        Uo = uo,
        Ho = go,
        Vo = xo,
        Wo = wo,
        Yo = function() {
            var e = to();
            return function(t, n, r, i, o, a) {
                var s, c;
                for (n || (n = 2), r || (r = 0), c = i ? Math.min(i * n + r, t.length) : t.length, s = r; s < c; s += n) e[0] = t[s], e[1] = t[s + 1], o(e, e, a), t[s] = e[0], t[s + 1] = e[1];
                return t
            }
        }();
    n.d(t, "glMatrix", (function() {
        return r
    })), n.d(t, "mat2", (function() {
        return i
    })), n.d(t, "mat2d", (function() {
        return o
    })), n.d(t, "mat3", (function() {
        return a
    })), n.d(t, "mat4", (function() {
        return s
    })), n.d(t, "quat", (function() {
        return l
    })), n.d(t, "quat2", (function() {
        return f
    })), n.d(t, "vec2", (function() {
        return d
    })), n.d(t, "vec3", (function() {
        return c
    })), n.d(t, "vec4", (function() {
        return u
    }))
}, function(e, t, n) {
    var r = n(8),
        i = n(5).document,
        o = r(i) && r(i.createElement);
    e.exports = function(e) {
        return o ? i.createElement(e) : {}
    }
}, function(e, t, n) {
    t.f = n(9)
}, function(e, t, n) {
    var r = n(58)("keys"),
        i = n(37);
    e.exports = function(e) {
        return r[e] || (r[e] = i(e))
    }
}, function(e, t) {
    e.exports = "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")
}, function(e, t, n) {
    var r = n(5).document;
    e.exports = r && r.documentElement
}, function(e, t, n) {
    var r = n(8),
        i = n(7),
        o = function(e, t) {
            if (i(e), !r(t) && null !== t) throw TypeError(t + ": can't set as prototype!")
        };
    e.exports = {
        set: Object.setPrototypeOf || ("__proto__" in {} ? function(e, t, r) {
            try {
                (r = n(24)(Function.call, n(27).f(Object.prototype, "__proto__").set, 2))(e, []), t = !(e instanceof Array)
            } catch (e) {
                t = !0
            }
            return function(e, n) {
                return o(e, n), t ? e.__proto__ = n : r(e, n), e
            }
        }({}, !1) : void 0),
        check: o
    }
}, function(e, t) {
    e.exports = "\t\n\v\f\r   ᠎             　\u2028\u2029\ufeff"
}, function(e, t, n) {
    var r = n(8),
        i = n(81).set;
    e.exports = function(e, t, n) {
        var o, a = t.constructor;
        return a !== n && "function" == typeof a && (o = a.prototype) !== n.prototype && r(o) && i && i(e, o), e
    }
}, function(e, t, n) {
    "use strict";
    var r = n(26),
        i = n(31);
    e.exports = function(e) {
        var t = String(i(this)),
            n = "",
            o = r(e);
        if (o < 0 || o == 1 / 0) throw RangeError("Count can't be negative");
        for (; o > 0;
            (o >>>= 1) && (t += t)) 1 & o && (n += t);
        return n
    }
}, function(e, t) {
    e.exports = Math.sign || function(e) {
        return 0 == (e = +e) || e != e ? e : e < 0 ? -1 : 1
    }
}, function(e, t) {
    var n = Math.expm1;
    e.exports = !n || n(10) > 22025.465794806718 || n(10) < 22025.465794806718 || -2e-17 != n(-2e-17) ? function(e) {
        return 0 == (e = +e) ? e : e > -1e-6 && e < 1e-6 ? e + e * e / 2 : Math.exp(e) - 1
    } : n
}, function(e, t, n) {
    var r = n(26),
        i = n(31);
    e.exports = function(e) {
        return function(t, n) {
            var o, a, s = String(i(t)),
                c = r(n),
                u = s.length;
            return c < 0 || c >= u ? e ? "" : void 0 : (o = s.charCodeAt(c)) < 55296 || o > 56319 || c + 1 === u || (a = s.charCodeAt(c + 1)) < 56320 || a > 57343 ? e ? s.charAt(c) : o : e ? s.slice(c, c + 2) : a - 56320 + (o - 55296 << 10) + 65536
        }
    }
}, function(e, t, n) {
    "use strict";
    var r = n(38),
        i = n(2),
        o = n(18),
        a = n(21),
        s = n(50),
        c = n(126),
        u = n(48),
        l = n(43),
        f = n(9)("iterator"),
        d = !([].keys && "next" in [].keys()),
        h = function() {
            return this
        };
    e.exports = function(e, t, n, v, p, m, y) {
        c(n, t, v);
        var g, x, b, w = function(e) {
                if (!d && e in P) return P[e];
                switch (e) {
                    case "keys":
                    case "values":
                        return function() {
                            return new n(this, e)
                        }
                }
                return function() {
                    return new n(this, e)
                }
            },
            M = t + " Iterator",
            _ = "values" == p,
            S = !1,
            P = e.prototype,
            T = P[f] || P["@@iterator"] || p && P[p],
            E = T || w(p),
            z = p ? _ ? w("entries") : E : void 0,
            L = "Array" == t && P.entries || T;
        if (L && (b = l(L.call(new e))) !== Object.prototype && b.next && (u(b, M, !0), r || "function" == typeof b[f] || a(b, f, h)), _ && T && "values" !== T.name && (S = !0, E = function() {
                return T.call(this)
            }), r && !y || !d && !S && P[f] || a(P, f, E), s[t] = E, s[M] = h, p)
            if (g = {
                    values: _ ? E : w("values"),
                    keys: m ? E : w("keys"),
                    entries: z
                }, y)
                for (x in g) x in P || o(P, x, g[x]);
            else i(i.P + i.F * (d || S), t, g);
        return g
    }
}, function(e, t, n) {
    var r = n(90),
        i = n(31);
    e.exports = function(e, t, n) {
        if (r(t)) throw TypeError("String#" + n + " doesn't accept regex!");
        return String(i(e))
    }
}, function(e, t, n) {
    var r = n(8),
        i = n(30),
        o = n(9)("match");
    e.exports = function(e) {
        var t;
        return r(e) && (void 0 !== (t = e[o]) ? !!t : "RegExp" == i(e))
    }
}, function(e, t, n) {
    var r = n(9)("match");
    e.exports = function(e) {
        var t = /./;
        try {
            "/./" [e](t)
        } catch (n) {
            try {
                return t[r] = !1, !"/./" [e](t)
            } catch (e) {}
        }
        return !0
    }
}, function(e, t, n) {
    var r = n(50),
        i = n(9)("iterator"),
        o = Array.prototype;
    e.exports = function(e) {
        return void 0 !== e && (r.Array === e || o[i] === e)
    }
}, function(e, t, n) {
    "use strict";
    var r = n(14),
        i = n(36);
    e.exports = function(e, t, n) {
        t in e ? r.f(e, t, i(0, n)) : e[t] = n
    }
}, function(e, t, n) {
    var r = n(56),
        i = n(9)("iterator"),
        o = n(50);
    e.exports = n(11).getIteratorMethod = function(e) {
        if (null != e) return e[i] || e["@@iterator"] || o[r(e)]
    }
}, function(e, t, n) {
    "use strict";
    var r = n(17),
        i = n(40),
        o = n(10);
    e.exports = function(e) {
        for (var t = r(this), n = o(t.length), a = arguments.length, s = i(a > 1 ? arguments[1] : void 0, n), c = a > 2 ? arguments[2] : void 0, u = void 0 === c ? n : i(c, n); u > s;) t[s++] = e;
        return t
    }
}, function(e, t, n) {
    "use strict";
    var r = n(44),
        i = n(131),
        o = n(50),
        a = n(22);
    e.exports = n(88)(Array, "Array", (function(e, t) {
        this._t = a(e), this._i = 0, this._k = t
    }), (function() {
        var e = this._t,
            t = this._k,
            n = this._i++;
        return !e || n >= e.length ? (this._t = void 0, i(1)) : i(0, "keys" == t ? n : "values" == t ? e[n] : [n, e[n]])
    }), "values"), o.Arguments = o.Array, r("keys"), r("values"), r("entries")
}, function(e, t, n) {
    "use strict";
    var r, i, o = n(63),
        a = RegExp.prototype.exec,
        s = String.prototype.replace,
        c = a,
        u = (r = /a/, i = /b*/g, a.call(r, "a"), a.call(i, "a"), 0 !== r.lastIndex || 0 !== i.lastIndex),
        l = void 0 !== /()??/.exec("")[1];
    (u || l) && (c = function(e) {
        var t, n, r, i, c = this;
        return l && (n = new RegExp("^" + c.source + "$(?!\\s)", o.call(c))), u && (t = c.lastIndex), r = a.call(c, e), u && r && (c.lastIndex = c.global ? r.index + r[0].length : t), l && r && r.length > 1 && s.call(r[0], n, (function() {
            for (i = 1; i < arguments.length - 2; i++) void 0 === arguments[i] && (r[i] = void 0)
        })), r
    }), e.exports = c
}, function(e, t, n) {
    "use strict";
    var r = n(87)(!0);
    e.exports = function(e, t, n) {
        return t + (n ? r(e, t).length : 1)
    }
}, function(e, t, n) {
    var r, i, o, a = n(24),
        s = n(120),
        c = n(80),
        u = n(76),
        l = n(5),
        f = l.process,
        d = l.setImmediate,
        h = l.clearImmediate,
        v = l.MessageChannel,
        p = l.Dispatch,
        m = 0,
        y = {},
        g = function() {
            var e = +this;
            if (y.hasOwnProperty(e)) {
                var t = y[e];
                delete y[e], t()
            }
        },
        x = function(e) {
            g.call(e.data)
        };
    d && h || (d = function(e) {
        for (var t = [], n = 1; arguments.length > n;) t.push(arguments[n++]);
        return y[++m] = function() {
            s("function" == typeof e ? e : Function(e), t)
        }, r(m), m
    }, h = function(e) {
        delete y[e]
    }, "process" == n(30)(f) ? r = function(e) {
        f.nextTick(a(g, e, 1))
    } : p && p.now ? r = function(e) {
        p.now(a(g, e, 1))
    } : v ? (o = (i = new v).port2, i.port1.onmessage = x, r = a(o.postMessage, o, 1)) : l.addEventListener && "function" == typeof postMessage && !l.importScripts ? (r = function(e) {
        l.postMessage(e + "", "*")
    }, l.addEventListener("message", x, !1)) : r = "onreadystatechange" in u("script") ? function(e) {
        c.appendChild(u("script")).onreadystatechange = function() {
            c.removeChild(this), g.call(e)
        }
    } : function(e) {
        setTimeout(a(g, e, 1), 0)
    }), e.exports = {
        set: d,
        clear: h
    }
}, function(e, t, n) {
    "use strict";
    var r = n(5),
        i = n(13),
        o = n(38),
        a = n(69),
        s = n(21),
        c = n(53),
        u = n(6),
        l = n(52),
        f = n(26),
        d = n(10),
        h = n(139),
        v = n(42).f,
        p = n(14).f,
        m = n(95),
        y = n(48),
        g = "prototype",
        x = "Wrong index!",
        b = r.ArrayBuffer,
        w = r.DataView,
        M = r.Math,
        _ = r.RangeError,
        S = r.Infinity,
        P = b,
        T = M.abs,
        E = M.pow,
        z = M.floor,
        L = M.log,
        A = M.LN2,
        C = i ? "_b" : "buffer",
        R = i ? "_l" : "byteLength",
        O = i ? "_o" : "byteOffset";

    function j(e, t, n) {
        var r, i, o, a = new Array(n),
            s = 8 * n - t - 1,
            c = (1 << s) - 1,
            u = c >> 1,
            l = 23 === t ? E(2, -24) - E(2, -77) : 0,
            f = 0,
            d = e < 0 || 0 === e && 1 / e < 0 ? 1 : 0;
        for ((e = T(e)) != e || e === S ? (i = e != e ? 1 : 0, r = c) : (r = z(L(e) / A), e * (o = E(2, -r)) < 1 && (r--, o *= 2), (e += r + u >= 1 ? l / o : l * E(2, 1 - u)) * o >= 2 && (r++, o /= 2), r + u >= c ? (i = 0, r = c) : r + u >= 1 ? (i = (e * o - 1) * E(2, t), r += u) : (i = e * E(2, u - 1) * E(2, t), r = 0)); t >= 8; a[f++] = 255 & i, i /= 256, t -= 8);
        for (r = r << t | i, s += t; s > 0; a[f++] = 255 & r, r /= 256, s -= 8);
        return a[--f] |= 128 * d, a
    }

    function I(e, t, n) {
        var r, i = 8 * n - t - 1,
            o = (1 << i) - 1,
            a = o >> 1,
            s = i - 7,
            c = n - 1,
            u = e[c--],
            l = 127 & u;
        for (u >>= 7; s > 0; l = 256 * l + e[c], c--, s -= 8);
        for (r = l & (1 << -s) - 1, l >>= -s, s += t; s > 0; r = 256 * r + e[c], c--, s -= 8);
        if (0 === l) l = 1 - a;
        else {
            if (l === o) return r ? NaN : u ? -S : S;
            r += E(2, t), l -= a
        }
        return (u ? -1 : 1) * r * E(2, l - t)
    }

    function D(e) {
        return e[3] << 24 | e[2] << 16 | e[1] << 8 | e[0]
    }

    function k(e) {
        return [255 & e]
    }

    function F(e) {
        return [255 & e, e >> 8 & 255]
    }

    function G(e) {
        return [255 & e, e >> 8 & 255, e >> 16 & 255, e >> 24 & 255]
    }

    function N(e) {
        return j(e, 52, 8)
    }

    function B(e) {
        return j(e, 23, 4)
    }

    function U(e, t, n) {
        p(e[g], t, {
            get: function() {
                return this[n]
            }
        })
    }

    function H(e, t, n, r) {
        var i = h(+n);
        if (i + t > e[R]) throw _(x);
        var o = e[C]._b,
            a = i + e[O],
            s = o.slice(a, a + t);
        return r ? s : s.reverse()
    }

    function V(e, t, n, r, i, o) {
        var a = h(+n);
        if (a + t > e[R]) throw _(x);
        for (var s = e[C]._b, c = a + e[O], u = r(+i), l = 0; l < t; l++) s[c + l] = u[o ? l : t - l - 1]
    }
    if (a.ABV) {
        if (!u((function() {
                b(1)
            })) || !u((function() {
                new b(-1)
            })) || u((function() {
                return new b, new b(1.5), new b(NaN), "ArrayBuffer" != b.name
            }))) {
            for (var W, Y = (b = function(e) {
                    return l(this, b), new P(h(e))
                })[g] = P[g], X = v(P), q = 0; X.length > q;)(W = X[q++]) in b || s(b, W, P[W]);
            o || (Y.constructor = b)
        }
        var K = new w(new b(2)),
            Z = w[g].setInt8;
        K.setInt8(0, 2147483648), K.setInt8(1, 2147483649), !K.getInt8(0) && K.getInt8(1) || c(w[g], {
            setInt8: function(e, t) {
                Z.call(this, e, t << 24 >> 24)
            },
            setUint8: function(e, t) {
                Z.call(this, e, t << 24 >> 24)
            }
        }, !0)
    } else b = function(e) {
        l(this, b, "ArrayBuffer");
        var t = h(e);
        this._b = m.call(new Array(t), 0), this[R] = t
    }, w = function(e, t, n) {
        l(this, w, "DataView"), l(e, b, "DataView");
        var r = e[R],
            i = f(t);
        if (i < 0 || i > r) throw _("Wrong offset!");
        if (i + (n = void 0 === n ? r - i : d(n)) > r) throw _("Wrong length!");
        this[C] = e, this[O] = i, this[R] = n
    }, i && (U(b, "byteLength", "_l"), U(w, "buffer", "_b"), U(w, "byteLength", "_l"), U(w, "byteOffset", "_o")), c(w[g], {
        getInt8: function(e) {
            return H(this, 1, e)[0] << 24 >> 24
        },
        getUint8: function(e) {
            return H(this, 1, e)[0]
        },
        getInt16: function(e) {
            var t = H(this, 2, e, arguments[1]);
            return (t[1] << 8 | t[0]) << 16 >> 16
        },
        getUint16: function(e) {
            var t = H(this, 2, e, arguments[1]);
            return t[1] << 8 | t[0]
        },
        getInt32: function(e) {
            return D(H(this, 4, e, arguments[1]))
        },
        getUint32: function(e) {
            return D(H(this, 4, e, arguments[1])) >>> 0
        },
        getFloat32: function(e) {
            return I(H(this, 4, e, arguments[1]), 23, 4)
        },
        getFloat64: function(e) {
            return I(H(this, 8, e, arguments[1]), 52, 8)
        },
        setInt8: function(e, t) {
            V(this, 1, e, k, t)
        },
        setUint8: function(e, t) {
            V(this, 1, e, k, t)
        },
        setInt16: function(e, t) {
            V(this, 2, e, F, t, arguments[2])
        },
        setUint16: function(e, t) {
            V(this, 2, e, F, t, arguments[2])
        },
        setInt32: function(e, t) {
            V(this, 4, e, G, t, arguments[2])
        },
        setUint32: function(e, t) {
            V(this, 4, e, G, t, arguments[2])
        },
        setFloat32: function(e, t) {
            V(this, 4, e, B, t, arguments[2])
        },
        setFloat64: function(e, t) {
            V(this, 8, e, N, t, arguments[2])
        }
    });
    y(b, "ArrayBuffer"), y(w, "DataView"), s(w[g], a.VIEW, !0), t.ArrayBuffer = b, t.DataView = w
}, function(e, t) {
    var n = e.exports = "undefined" != typeof window && window.Math == Math ? window : "undefined" != typeof self && self.Math == Math ? self : Function("return this")();
    "number" == typeof __g && (__g = n)
}, function(e, t) {
    e.exports = function(e) {
        return "object" == typeof e ? null !== e : "function" == typeof e
    }
}, function(e, t, n) {
    e.exports = !n(144)((function() {
        return 7 != Object.defineProperty({}, "a", {
            get: function() {
                return 7
            }
        }).a
    }))
}, function(e, t) {
    e.exports = function() {
        var e = navigator.userAgent;
        return e.indexOf("iPhone") >= 0 || e.indexOf("iPod") >= 0 || e.indexOf("iPad") >= 0
    }
}, function(e, t) {
    e.exports = function() {
        return navigator.userAgent.indexOf("Android") >= 0
    }
}, function(e, t, n) {
    "use strict";
    n.r(t);
    var r = n(0),
        i = new r.TextureLoader;
    t.default = function(e, t) {
        var n = Object.keys(e).length,
            o = {},
            a = 0,
            s = function() {
                var s = c;
                e.hasOwnProperty(s) && i.load(e[s], (function(e) {
                    e.repeat = r.RepeatWrapping, o[s] = e, ++a >= n && t(o)
                }))
            };
        for (var c in e) s()
    }
}, function(e, t, n) {
    "use strict";

    function r(e) {
        return (r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
            return typeof e
        } : function(e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
        })(e)
    }

    function i(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }

    function o(e, t) {
        return !t || "object" !== r(t) && "function" != typeof t ? function(e) {
            if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return e
        }(e) : t
    }

    function a(e) {
        return (a = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
            return e.__proto__ || Object.getPrototypeOf(e)
        })(e)
    }

    function s(e, t) {
        return (s = Object.setPrototypeOf || function(e, t) {
            return e.__proto__ = t, e
        })(e, t)
    }
    n.r(t), n.d(t, "default", (function() {
        return l
    }));
    var c = n(0),
        u = n(70).default,
        l = function(e) {
            function t(e, n, r, i) {
                var s;
                return function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, t), (s = o(this, a(t).call(this, e, n, r, i))).k = .02, s.d = .2, s.velocity = [0, 0, 0], s.acceleration = [0, 0, 0], s.anchor = [0, 0, 0], s.lookK = .02, s.lookD = .2, s.lookVelocity = [0, 0, 0], s.lookAcceleration = [0, 0, 0], s.lookAnchor = [0, 0, 0], s
            }
            var n, r, c;
            return function(e, t) {
                if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
                e.prototype = Object.create(t && t.prototype, {
                    constructor: {
                        value: e,
                        writable: !0,
                        configurable: !0
                    }
                }), t && s(e, t)
            }(t, e), n = t, (r = [{
                key: "updatePosition",
                value: function() {
                    u.applyHook(this.velocity, this.acceleration, this.anchor, 0, this.k), u.applyDrag(this.acceleration, this.d), u.updateVelocity(this.velocity, this.acceleration, 1)
                }
            }, {
                key: "updateLook",
                value: function() {
                    u.applyHook(this.lookVelocity, this.lookAcceleration, this.lookAnchor, 0, this.lookK), u.applyDrag(this.lookAcceleration, this.lookD), u.updateVelocity(this.lookVelocity, this.lookAcceleration, 1)
                }
            }, {
                key: "render",
                value: function() {
                    this.updatePosition(), this.updateLook(), this.position.set(this.velocity[0], this.velocity[1], this.velocity[2]), this.lookAt(this.lookVelocity[0], this.lookVelocity[1], this.lookVelocity[2])
                }
            }]) && i(n.prototype, r), c && i(n, c), t
        }(c.PerspectiveCamera)
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  gl_Position = vec4(position, 1.0);\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  gl_Position = vec4(position, 1.0);\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  gl_Position = vec4(position, 1.0);\n}\n"
}, function(e, t, n) {
    var r, i = n(0);
    n(16);
    e.exports = ((r = function() {
        this.velocity = new i.Vector2, this.acceleration = new i.Vector2, this.anchor = new i.Vector2, this.mass = 1
    }).prototype.updateVelocity = function() {
        this.acceleration.divideScalar(this.mass), this.velocity.add(this.acceleration)
    }, r.prototype.applyForce = function(e) {
        this.acceleration.add(e)
    }, r.prototype.applyFriction = function(e, t) {
        var n = this.acceleration.clone();
        t || (t = 1), n.multiplyScalar(-1), n.normalize(), n.multiplyScalar(e), this.applyForce(n)
    }, r.prototype.applyDrag = function(e) {
        var t = this.acceleration.clone();
        t.multiplyScalar(-1), t.normalize(), t.multiplyScalar(this.acceleration.length() * e), this.applyForce(t)
    }, r.prototype.applyHook = function(e, t) {
        var n = this.velocity.clone().sub(this.anchor),
            r = n.length() - e;
        n.normalize(), n.multiplyScalar(-1 * t * r), this.applyForce(n)
    }, r)
}, function(e, t, n) {
    e.exports = !n(13) && !n(6)((function() {
        return 7 != Object.defineProperty(n(76)("div"), "a", {
            get: function() {
                return 7
            }
        }).a
    }))
}, function(e, t, n) {
    var r = n(5),
        i = n(11),
        o = n(38),
        a = n(77),
        s = n(14).f;
    e.exports = function(e) {
        var t = i.Symbol || (i.Symbol = o ? {} : r.Symbol || {});
        "_" == e.charAt(0) || e in t || s(t, e, {
            value: a.f(e)
        })
    }
}, function(e, t, n) {
    var r = n(20),
        i = n(22),
        o = n(59)(!1),
        a = n(78)("IE_PROTO");
    e.exports = function(e, t) {
        var n, s = i(e),
            c = 0,
            u = [];
        for (n in s) n != a && r(s, n) && u.push(n);
        for (; t.length > c;) r(s, n = t[c++]) && (~o(u, n) || u.push(n));
        return u
    }
}, function(e, t, n) {
    var r = n(14),
        i = n(7),
        o = n(39);
    e.exports = n(13) ? Object.defineProperties : function(e, t) {
        i(e);
        for (var n, a = o(t), s = a.length, c = 0; s > c;) r.f(e, n = a[c++], t[n]);
        return e
    }
}, function(e, t, n) {
    var r = n(22),
        i = n(42).f,
        o = {}.toString,
        a = "object" == typeof window && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
    e.exports.f = function(e) {
        return a && "[object Window]" == o.call(e) ? function(e) {
            try {
                return i(e)
            } catch (e) {
                return a.slice()
            }
        }(e) : i(r(e))
    }
}, function(e, t, n) {
    "use strict";
    var r = n(13),
        i = n(39),
        o = n(60),
        a = n(55),
        s = n(17),
        c = n(54),
        u = Object.assign;
    e.exports = !u || n(6)((function() {
        var e = {},
            t = {},
            n = Symbol(),
            r = "abcdefghijklmnopqrst";
        return e[n] = 7, r.split("").forEach((function(e) {
            t[e] = e
        })), 7 != u({}, e)[n] || Object.keys(u({}, t)).join("") != r
    })) ? function(e, t) {
        for (var n = s(e), u = arguments.length, l = 1, f = o.f, d = a.f; u > l;)
            for (var h, v = c(arguments[l++]), p = f ? i(v).concat(f(v)) : i(v), m = p.length, y = 0; m > y;) h = p[y++], r && !d.call(v, h) || (n[h] = v[h]);
        return n
    } : u
}, function(e, t) {
    e.exports = Object.is || function(e, t) {
        return e === t ? 0 !== e || 1 / e == 1 / t : e != e && t != t
    }
}, function(e, t, n) {
    "use strict";
    var r = n(25),
        i = n(8),
        o = n(120),
        a = [].slice,
        s = {},
        c = function(e, t, n) {
            if (!(t in s)) {
                for (var r = [], i = 0; i < t; i++) r[i] = "a[" + i + "]";
                s[t] = Function("F,a", "return new F(" + r.join(",") + ")")
            }
            return s[t](e, n)
        };
    e.exports = Function.bind || function(e) {
        var t = r(this),
            n = a.call(arguments, 1),
            s = function() {
                var r = n.concat(a.call(arguments));
                return this instanceof s ? c(t, r.length, r) : o(t, r, e)
            };
        return i(t.prototype) && (s.prototype = t.prototype), s
    }
}, function(e, t) {
    e.exports = function(e, t, n) {
        var r = void 0 === n;
        switch (t.length) {
            case 0:
                return r ? e() : e.call(n);
            case 1:
                return r ? e(t[0]) : e.call(n, t[0]);
            case 2:
                return r ? e(t[0], t[1]) : e.call(n, t[0], t[1]);
            case 3:
                return r ? e(t[0], t[1], t[2]) : e.call(n, t[0], t[1], t[2]);
            case 4:
                return r ? e(t[0], t[1], t[2], t[3]) : e.call(n, t[0], t[1], t[2], t[3])
        }
        return e.apply(n, t)
    }
}, function(e, t, n) {
    var r = n(5).parseInt,
        i = n(49).trim,
        o = n(82),
        a = /^[-+]?0[xX]/;
    e.exports = 8 !== r(o + "08") || 22 !== r(o + "0x16") ? function(e, t) {
        var n = i(String(e), 3);
        return r(n, t >>> 0 || (a.test(n) ? 16 : 10))
    } : r
}, function(e, t, n) {
    var r = n(5).parseFloat,
        i = n(49).trim;
    e.exports = 1 / r(n(82) + "-0") != -1 / 0 ? function(e) {
        var t = i(String(e), 3),
            n = r(t);
        return 0 === n && "-" == t.charAt(0) ? -0 : n
    } : r
}, function(e, t, n) {
    var r = n(30);
    e.exports = function(e, t) {
        if ("number" != typeof e && "Number" != r(e)) throw TypeError(t);
        return +e
    }
}, function(e, t, n) {
    var r = n(8),
        i = Math.floor;
    e.exports = function(e) {
        return !r(e) && isFinite(e) && i(e) === e
    }
}, function(e, t) {
    e.exports = Math.log1p || function(e) {
        return (e = +e) > -1e-8 && e < 1e-8 ? e - e * e / 2 : Math.log(1 + e)
    }
}, function(e, t, n) {
    "use strict";
    var r = n(41),
        i = n(36),
        o = n(48),
        a = {};
    n(21)(a, n(9)("iterator"), (function() {
        return this
    })), e.exports = function(e, t, n) {
        e.prototype = r(a, {
            next: i(1, n)
        }), o(e, t + " Iterator")
    }
}, function(e, t, n) {
    var r = n(7);
    e.exports = function(e, t, n, i) {
        try {
            return i ? t(r(n)[0], n[1]) : t(n)
        } catch (t) {
            var o = e.return;
            throw void 0 !== o && r(o.call(e)), t
        }
    }
}, function(e, t, n) {
    var r = n(250);
    e.exports = function(e, t) {
        return new(r(e))(t)
    }
}, function(e, t, n) {
    var r = n(25),
        i = n(17),
        o = n(54),
        a = n(10);
    e.exports = function(e, t, n, s, c) {
        r(t);
        var u = i(e),
            l = o(u),
            f = a(u.length),
            d = c ? f - 1 : 0,
            h = c ? -1 : 1;
        if (n < 2)
            for (;;) {
                if (d in l) {
                    s = l[d], d += h;
                    break
                }
                if (d += h, c ? d < 0 : f <= d) throw TypeError("Reduce of empty array with no initial value")
            }
        for (; c ? d >= 0 : f > d; d += h) d in l && (s = t(s, l[d], d, u));
        return s
    }
}, function(e, t, n) {
    "use strict";
    var r = n(17),
        i = n(40),
        o = n(10);
    e.exports = [].copyWithin || function(e, t) {
        var n = r(this),
            a = o(n.length),
            s = i(e, a),
            c = i(t, a),
            u = arguments.length > 2 ? arguments[2] : void 0,
            l = Math.min((void 0 === u ? a : i(u, a)) - c, a - s),
            f = 1;
        for (c < s && s < c + l && (f = -1, c += l - 1, s += l - 1); l-- > 0;) c in n ? n[s] = n[c] : delete n[s], s += f, c += f;
        return n
    }
}, function(e, t) {
    e.exports = function(e, t) {
        return {
            value: t,
            done: !!e
        }
    }
}, function(e, t, n) {
    "use strict";
    var r = n(97);
    n(2)({
        target: "RegExp",
        proto: !0,
        forced: r !== /./.exec
    }, {
        exec: r
    })
}, function(e, t, n) {
    n(13) && "g" != /./g.flags && n(14).f(RegExp.prototype, "flags", {
        configurable: !0,
        get: n(63)
    })
}, function(e, t, n) {
    "use strict";
    var r, i, o, a, s = n(38),
        c = n(5),
        u = n(24),
        l = n(56),
        f = n(2),
        d = n(8),
        h = n(25),
        v = n(52),
        p = n(66),
        m = n(57),
        y = n(99).set,
        g = n(270)(),
        x = n(135),
        b = n(271),
        w = n(67),
        M = n(136),
        _ = c.TypeError,
        S = c.process,
        P = S && S.versions,
        T = P && P.v8 || "",
        E = c.Promise,
        z = "process" == l(S),
        L = function() {},
        A = i = x.f,
        C = !! function() {
            try {
                var e = E.resolve(1),
                    t = (e.constructor = {})[n(9)("species")] = function(e) {
                        e(L, L)
                    };
                return (z || "function" == typeof PromiseRejectionEvent) && e.then(L) instanceof t && 0 !== T.indexOf("6.6") && -1 === w.indexOf("Chrome/66")
            } catch (e) {}
        }(),
        R = function(e) {
            var t;
            return !(!d(e) || "function" != typeof(t = e.then)) && t
        },
        O = function(e, t) {
            if (!e._n) {
                e._n = !0;
                var n = e._c;
                g((function() {
                    for (var r = e._v, i = 1 == e._s, o = 0, a = function(t) {
                            var n, o, a, s = i ? t.ok : t.fail,
                                c = t.resolve,
                                u = t.reject,
                                l = t.domain;
                            try {
                                s ? (i || (2 == e._h && D(e), e._h = 1), !0 === s ? n = r : (l && l.enter(), n = s(r), l && (l.exit(), a = !0)), n === t.promise ? u(_("Promise-chain cycle")) : (o = R(n)) ? o.call(n, c, u) : c(n)) : u(r)
                            } catch (e) {
                                l && !a && l.exit(), u(e)
                            }
                        }; n.length > o;) a(n[o++]);
                    e._c = [], e._n = !1, t && !e._h && j(e)
                }))
            }
        },
        j = function(e) {
            y.call(c, (function() {
                var t, n, r, i = e._v,
                    o = I(e);
                if (o && (t = b((function() {
                        z ? S.emit("unhandledRejection", i, e) : (n = c.onunhandledrejection) ? n({
                            promise: e,
                            reason: i
                        }) : (r = c.console) && r.error && r.error("Unhandled promise rejection", i)
                    })), e._h = z || I(e) ? 2 : 1), e._a = void 0, o && t.e) throw t.v
            }))
        },
        I = function(e) {
            return 1 !== e._h && 0 === (e._a || e._c).length
        },
        D = function(e) {
            y.call(c, (function() {
                var t;
                z ? S.emit("rejectionHandled", e) : (t = c.onrejectionhandled) && t({
                    promise: e,
                    reason: e._v
                })
            }))
        },
        k = function(e) {
            var t = this;
            t._d || (t._d = !0, (t = t._w || t)._v = e, t._s = 2, t._a || (t._a = t._c.slice()), O(t, !0))
        },
        F = function(e) {
            var t, n = this;
            if (!n._d) {
                n._d = !0, n = n._w || n;
                try {
                    if (n === e) throw _("Promise can't be resolved itself");
                    (t = R(e)) ? g((function() {
                        var r = {
                            _w: n,
                            _d: !1
                        };
                        try {
                            t.call(e, u(F, r, 1), u(k, r, 1))
                        } catch (e) {
                            k.call(r, e)
                        }
                    })): (n._v = e, n._s = 1, O(n, !1))
                } catch (e) {
                    k.call({
                        _w: n,
                        _d: !1
                    }, e)
                }
            }
        };
    C || (E = function(e) {
        v(this, E, "Promise", "_h"), h(e), r.call(this);
        try {
            e(u(F, this, 1), u(k, this, 1))
        } catch (e) {
            k.call(this, e)
        }
    }, (r = function(e) {
        this._c = [], this._a = void 0, this._s = 0, this._d = !1, this._v = void 0, this._h = 0, this._n = !1
    }).prototype = n(53)(E.prototype, {
        then: function(e, t) {
            var n = A(m(this, E));
            return n.ok = "function" != typeof e || e, n.fail = "function" == typeof t && t, n.domain = z ? S.domain : void 0, this._c.push(n), this._a && this._a.push(n), this._s && O(this, !1), n.promise
        },
        catch: function(e) {
            return this.then(void 0, e)
        }
    }), o = function() {
        var e = new r;
        this.promise = e, this.resolve = u(F, e, 1), this.reject = u(k, e, 1)
    }, x.f = A = function(e) {
        return e === E || e === a ? new o(e) : i(e)
    }), f(f.G + f.W + f.F * !C, {
        Promise: E
    }), n(48)(E, "Promise"), n(51)("Promise"), a = n(11).Promise, f(f.S + f.F * !C, "Promise", {
        reject: function(e) {
            var t = A(this);
            return (0, t.reject)(e), t.promise
        }
    }), f(f.S + f.F * (s || !C), "Promise", {
        resolve: function(e) {
            return M(s && this === a ? E : this, e)
        }
    }), f(f.S + f.F * !(C && n(62)((function(e) {
        E.all(e).catch(L)
    }))), "Promise", {
        all: function(e) {
            var t = this,
                n = A(t),
                r = n.resolve,
                i = n.reject,
                o = b((function() {
                    var n = [],
                        o = 0,
                        a = 1;
                    p(e, !1, (function(e) {
                        var s = o++,
                            c = !1;
                        n.push(void 0), a++, t.resolve(e).then((function(e) {
                            c || (c = !0, n[s] = e, --a || r(n))
                        }), i)
                    })), --a || r(n)
                }));
            return o.e && i(o.v), n.promise
        },
        race: function(e) {
            var t = this,
                n = A(t),
                r = n.reject,
                i = b((function() {
                    p(e, !1, (function(e) {
                        t.resolve(e).then(n.resolve, r)
                    }))
                }));
            return i.e && r(i.v), n.promise
        }
    })
}, function(e, t, n) {
    "use strict";
    var r = n(25);

    function i(e) {
        var t, n;
        this.promise = new e((function(e, r) {
            if (void 0 !== t || void 0 !== n) throw TypeError("Bad Promise constructor");
            t = e, n = r
        })), this.resolve = r(t), this.reject = r(n)
    }
    e.exports.f = function(e) {
        return new i(e)
    }
}, function(e, t, n) {
    var r = n(7),
        i = n(8),
        o = n(135);
    e.exports = function(e, t) {
        if (r(e), i(t) && t.constructor === e) return t;
        var n = o.f(e);
        return (0, n.resolve)(t), n.promise
    }
}, function(e, t, n) {
    "use strict";
    var r = n(14).f,
        i = n(41),
        o = n(53),
        a = n(24),
        s = n(52),
        c = n(66),
        u = n(88),
        l = n(131),
        f = n(51),
        d = n(13),
        h = n(35).fastKey,
        v = n(45),
        p = d ? "_s" : "size",
        m = function(e, t) {
            var n, r = h(t);
            if ("F" !== r) return e._i[r];
            for (n = e._f; n; n = n.n)
                if (n.k == t) return n
        };
    e.exports = {
        getConstructor: function(e, t, n, u) {
            var l = e((function(e, r) {
                s(e, l, t, "_i"), e._t = t, e._i = i(null), e._f = void 0, e._l = void 0, e[p] = 0, null != r && c(r, n, e[u], e)
            }));
            return o(l.prototype, {
                clear: function() {
                    for (var e = v(this, t), n = e._i, r = e._f; r; r = r.n) r.r = !0, r.p && (r.p = r.p.n = void 0), delete n[r.i];
                    e._f = e._l = void 0, e[p] = 0
                },
                delete: function(e) {
                    var n = v(this, t),
                        r = m(n, e);
                    if (r) {
                        var i = r.n,
                            o = r.p;
                        delete n._i[r.i], r.r = !0, o && (o.n = i), i && (i.p = o), n._f == r && (n._f = i), n._l == r && (n._l = o), n[p]--
                    }
                    return !!r
                },
                forEach: function(e) {
                    v(this, t);
                    for (var n, r = a(e, arguments.length > 1 ? arguments[1] : void 0, 3); n = n ? n.n : this._f;)
                        for (r(n.v, n.k, this); n && n.r;) n = n.p
                },
                has: function(e) {
                    return !!m(v(this, t), e)
                }
            }), d && r(l.prototype, "size", {
                get: function() {
                    return v(this, t)[p]
                }
            }), l
        },
        def: function(e, t, n) {
            var r, i, o = m(e, t);
            return o ? o.v = n : (e._l = o = {
                i: i = h(t, !0),
                k: t,
                v: n,
                p: r = e._l,
                n: void 0,
                r: !1
            }, e._f || (e._f = o), r && (r.n = o), e[p]++, "F" !== i && (e._i[i] = o)), e
        },
        getEntry: m,
        setStrong: function(e, t, n) {
            u(e, t, (function(e, n) {
                this._t = v(e, t), this._k = n, this._l = void 0
            }), (function() {
                for (var e = this._k, t = this._l; t && t.r;) t = t.p;
                return this._t && (this._l = t = t ? t.n : this._t._f) ? l(0, "keys" == e ? t.k : "values" == e ? t.v : [t.k, t.v]) : (this._t = void 0, l(1))
            }), n ? "entries" : "values", !n, !0), f(t)
        }
    }
}, function(e, t, n) {
    "use strict";
    var r = n(53),
        i = n(35).getWeak,
        o = n(7),
        a = n(8),
        s = n(52),
        c = n(66),
        u = n(29),
        l = n(20),
        f = n(45),
        d = u(5),
        h = u(6),
        v = 0,
        p = function(e) {
            return e._l || (e._l = new m)
        },
        m = function() {
            this.a = []
        },
        y = function(e, t) {
            return d(e.a, (function(e) {
                return e[0] === t
            }))
        };
    m.prototype = {
        get: function(e) {
            var t = y(this, e);
            if (t) return t[1]
        },
        has: function(e) {
            return !!y(this, e)
        },
        set: function(e, t) {
            var n = y(this, e);
            n ? n[1] = t : this.a.push([e, t])
        },
        delete: function(e) {
            var t = h(this.a, (function(t) {
                return t[0] === e
            }));
            return ~t && this.a.splice(t, 1), !!~t
        }
    }, e.exports = {
        getConstructor: function(e, t, n, o) {
            var u = e((function(e, r) {
                s(e, u, t, "_i"), e._t = t, e._i = v++, e._l = void 0, null != r && c(r, n, e[o], e)
            }));
            return r(u.prototype, {
                delete: function(e) {
                    if (!a(e)) return !1;
                    var n = i(e);
                    return !0 === n ? p(f(this, t)).delete(e) : n && l(n, this._i) && delete n[this._i]
                },
                has: function(e) {
                    if (!a(e)) return !1;
                    var n = i(e);
                    return !0 === n ? p(f(this, t)).has(e) : n && l(n, this._i)
                }
            }), u
        },
        def: function(e, t, n) {
            var r = i(o(t), !0);
            return !0 === r ? p(e).set(t, n) : r[e._i] = n, e
        },
        ufstore: p
    }
}, function(e, t, n) {
    var r = n(26),
        i = n(10);
    e.exports = function(e) {
        if (void 0 === e) return 0;
        var t = r(e),
            n = i(t);
        if (t !== n) throw RangeError("Wrong length!");
        return n
    }
}, function(e, t, n) {
    var r = n(42),
        i = n(60),
        o = n(7),
        a = n(5).Reflect;
    e.exports = a && a.ownKeys || function(e) {
        var t = r.f(o(e)),
            n = i.f;
        return n ? t.concat(n(e)) : t
    }
}, function(e, t, n) {
    var r = n(10),
        i = n(84),
        o = n(31);
    e.exports = function(e, t, n, a) {
        var s = String(o(e)),
            c = s.length,
            u = void 0 === n ? " " : String(n),
            l = r(t);
        if (l <= c || "" == u) return s;
        var f = l - c,
            d = i.call(u, Math.ceil(f / u.length));
        return d.length > f && (d = d.slice(0, f)), a ? d + s : s + d
    }
}, function(e, t, n) {
    var r = n(13),
        i = n(39),
        o = n(22),
        a = n(55).f;
    e.exports = function(e) {
        return function(t) {
            for (var n, s = o(t), c = i(s), u = c.length, l = 0, f = []; u > l;) n = c[l++], r && !a.call(s, n) || f.push(e ? [n, s[n]] : s[n]);
            return f
        }
    }
}, function(e, t) {
    var n = e.exports = {
        version: "2.6.9"
    };
    "number" == typeof __e && (__e = n)
}, function(e, t) {
    e.exports = function(e) {
        try {
            return !!e()
        } catch (e) {
            return !0
        }
    }
}, function(e, t, n) {
    var r;
    ! function() {
        "use strict";
        var i = .5 * (Math.sqrt(3) - 1),
            o = (3 - Math.sqrt(3)) / 6,
            a = 1 / 6,
            s = (Math.sqrt(5) - 1) / 4,
            c = (5 - Math.sqrt(5)) / 20;

        function u(e) {
            var t;
            t = "function" == typeof e ? e : e ? function() {
                var e = 0,
                    t = 0,
                    n = 0,
                    r = 1,
                    i = (o = 4022871197, function(e) {
                        e = e.toString();
                        for (var t = 0; t < e.length; t++) {
                            var n = .02519603282416938 * (o += e.charCodeAt(t));
                            n -= o = n >>> 0, o = (n *= o) >>> 0, o += 4294967296 * (n -= o)
                        }
                        return 2.3283064365386963e-10 * (o >>> 0)
                    });
                var o;
                e = i(" "), t = i(" "), n = i(" ");
                for (var a = 0; a < arguments.length; a++)(e -= i(arguments[a])) < 0 && (e += 1), (t -= i(arguments[a])) < 0 && (t += 1), (n -= i(arguments[a])) < 0 && (n += 1);
                return i = null,
                    function() {
                        var i = 2091639 * e + 2.3283064365386963e-10 * r;
                        return e = t, t = n, n = i - (r = 0 | i)
                    }
            }(e) : Math.random, this.p = l(t), this.perm = new Uint8Array(512), this.permMod12 = new Uint8Array(512);
            for (var n = 0; n < 512; n++) this.perm[n] = this.p[255 & n], this.permMod12[n] = this.perm[n] % 12
        }

        function l(e) {
            var t, n = new Uint8Array(256);
            for (t = 0; t < 256; t++) n[t] = t;
            for (t = 0; t < 255; t++) {
                var r = t + ~~(e() * (256 - t)),
                    i = n[t];
                n[t] = n[r], n[r] = i
            }
            return n
        }
        u.prototype = {
            grad3: new Float32Array([1, 1, 0, -1, 1, 0, 1, -1, 0, -1, -1, 0, 1, 0, 1, -1, 0, 1, 1, 0, -1, -1, 0, -1, 0, 1, 1, 0, -1, 1, 0, 1, -1, 0, -1, -1]),
            grad4: new Float32Array([0, 1, 1, 1, 0, 1, 1, -1, 0, 1, -1, 1, 0, 1, -1, -1, 0, -1, 1, 1, 0, -1, 1, -1, 0, -1, -1, 1, 0, -1, -1, -1, 1, 0, 1, 1, 1, 0, 1, -1, 1, 0, -1, 1, 1, 0, -1, -1, -1, 0, 1, 1, -1, 0, 1, -1, -1, 0, -1, 1, -1, 0, -1, -1, 1, 1, 0, 1, 1, 1, 0, -1, 1, -1, 0, 1, 1, -1, 0, -1, -1, 1, 0, 1, -1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, -1, 1, 1, 1, 0, 1, 1, -1, 0, 1, -1, 1, 0, 1, -1, -1, 0, -1, 1, 1, 0, -1, 1, -1, 0, -1, -1, 1, 0, -1, -1, -1, 0]),
            noise2D: function(e, t) {
                var n, r, a = this.permMod12,
                    s = this.perm,
                    c = this.grad3,
                    u = 0,
                    l = 0,
                    f = 0,
                    d = (e + t) * i,
                    h = Math.floor(e + d),
                    v = Math.floor(t + d),
                    p = (h + v) * o,
                    m = e - (h - p),
                    y = t - (v - p);
                m > y ? (n = 1, r = 0) : (n = 0, r = 1);
                var g = m - n + o,
                    x = y - r + o,
                    b = m - 1 + 2 * o,
                    w = y - 1 + 2 * o,
                    M = 255 & h,
                    _ = 255 & v,
                    S = .5 - m * m - y * y;
                if (S >= 0) {
                    var P = 3 * a[M + s[_]];
                    u = (S *= S) * S * (c[P] * m + c[P + 1] * y)
                }
                var T = .5 - g * g - x * x;
                if (T >= 0) {
                    var E = 3 * a[M + n + s[_ + r]];
                    l = (T *= T) * T * (c[E] * g + c[E + 1] * x)
                }
                var z = .5 - b * b - w * w;
                if (z >= 0) {
                    var L = 3 * a[M + 1 + s[_ + 1]];
                    f = (z *= z) * z * (c[L] * b + c[L + 1] * w)
                }
                return 70 * (u + l + f)
            },
            noise3D: function(e, t, n) {
                var r, i, o, s, c, u, l, f, d, h, v = this.permMod12,
                    p = this.perm,
                    m = this.grad3,
                    y = (e + t + n) * (1 / 3),
                    g = Math.floor(e + y),
                    x = Math.floor(t + y),
                    b = Math.floor(n + y),
                    w = (g + x + b) * a,
                    M = e - (g - w),
                    _ = t - (x - w),
                    S = n - (b - w);
                M >= _ ? _ >= S ? (c = 1, u = 0, l = 0, f = 1, d = 1, h = 0) : M >= S ? (c = 1, u = 0, l = 0, f = 1, d = 0, h = 1) : (c = 0, u = 0, l = 1, f = 1, d = 0, h = 1) : _ < S ? (c = 0, u = 0, l = 1, f = 0, d = 1, h = 1) : M < S ? (c = 0, u = 1, l = 0, f = 0, d = 1, h = 1) : (c = 0, u = 1, l = 0, f = 1, d = 1, h = 0);
                var P = M - c + a,
                    T = _ - u + a,
                    E = S - l + a,
                    z = M - f + 2 * a,
                    L = _ - d + 2 * a,
                    A = S - h + 2 * a,
                    C = M - 1 + .5,
                    R = _ - 1 + .5,
                    O = S - 1 + .5,
                    j = 255 & g,
                    I = 255 & x,
                    D = 255 & b,
                    k = .6 - M * M - _ * _ - S * S;
                if (k < 0) r = 0;
                else {
                    var F = 3 * v[j + p[I + p[D]]];
                    r = (k *= k) * k * (m[F] * M + m[F + 1] * _ + m[F + 2] * S)
                }
                var G = .6 - P * P - T * T - E * E;
                if (G < 0) i = 0;
                else {
                    var N = 3 * v[j + c + p[I + u + p[D + l]]];
                    i = (G *= G) * G * (m[N] * P + m[N + 1] * T + m[N + 2] * E)
                }
                var B = .6 - z * z - L * L - A * A;
                if (B < 0) o = 0;
                else {
                    var U = 3 * v[j + f + p[I + d + p[D + h]]];
                    o = (B *= B) * B * (m[U] * z + m[U + 1] * L + m[U + 2] * A)
                }
                var H = .6 - C * C - R * R - O * O;
                if (H < 0) s = 0;
                else {
                    var V = 3 * v[j + 1 + p[I + 1 + p[D + 1]]];
                    s = (H *= H) * H * (m[V] * C + m[V + 1] * R + m[V + 2] * O)
                }
                return 32 * (r + i + o + s)
            },
            noise4D: function(e, t, n, r) {
                var i, o, a, u, l, f, d, h, v, p, m, y, g, x, b, w, M, _ = this.perm,
                    S = this.grad4,
                    P = (e + t + n + r) * s,
                    T = Math.floor(e + P),
                    E = Math.floor(t + P),
                    z = Math.floor(n + P),
                    L = Math.floor(r + P),
                    A = (T + E + z + L) * c,
                    C = e - (T - A),
                    R = t - (E - A),
                    O = n - (z - A),
                    j = r - (L - A),
                    I = 0,
                    D = 0,
                    k = 0,
                    F = 0;
                C > R ? I++ : D++, C > O ? I++ : k++, C > j ? I++ : F++, R > O ? D++ : k++, R > j ? D++ : F++, O > j ? k++ : F++;
                var G = C - (f = I >= 3 ? 1 : 0) + c,
                    N = R - (d = D >= 3 ? 1 : 0) + c,
                    B = O - (h = k >= 3 ? 1 : 0) + c,
                    U = j - (v = F >= 3 ? 1 : 0) + c,
                    H = C - (p = I >= 2 ? 1 : 0) + 2 * c,
                    V = R - (m = D >= 2 ? 1 : 0) + 2 * c,
                    W = O - (y = k >= 2 ? 1 : 0) + 2 * c,
                    Y = j - (g = F >= 2 ? 1 : 0) + 2 * c,
                    X = C - (x = I >= 1 ? 1 : 0) + 3 * c,
                    q = R - (b = D >= 1 ? 1 : 0) + 3 * c,
                    K = O - (w = k >= 1 ? 1 : 0) + 3 * c,
                    Z = j - (M = F >= 1 ? 1 : 0) + 3 * c,
                    J = C - 1 + 4 * c,
                    Q = R - 1 + 4 * c,
                    $ = O - 1 + 4 * c,
                    ee = j - 1 + 4 * c,
                    te = 255 & T,
                    ne = 255 & E,
                    re = 255 & z,
                    ie = 255 & L,
                    oe = .6 - C * C - R * R - O * O - j * j;
                if (oe < 0) i = 0;
                else {
                    var ae = _[te + _[ne + _[re + _[ie]]]] % 32 * 4;
                    i = (oe *= oe) * oe * (S[ae] * C + S[ae + 1] * R + S[ae + 2] * O + S[ae + 3] * j)
                }
                var se = .6 - G * G - N * N - B * B - U * U;
                if (se < 0) o = 0;
                else {
                    var ce = _[te + f + _[ne + d + _[re + h + _[ie + v]]]] % 32 * 4;
                    o = (se *= se) * se * (S[ce] * G + S[ce + 1] * N + S[ce + 2] * B + S[ce + 3] * U)
                }
                var ue = .6 - H * H - V * V - W * W - Y * Y;
                if (ue < 0) a = 0;
                else {
                    var le = _[te + p + _[ne + m + _[re + y + _[ie + g]]]] % 32 * 4;
                    a = (ue *= ue) * ue * (S[le] * H + S[le + 1] * V + S[le + 2] * W + S[le + 3] * Y)
                }
                var fe = .6 - X * X - q * q - K * K - Z * Z;
                if (fe < 0) u = 0;
                else {
                    var de = _[te + x + _[ne + b + _[re + w + _[ie + M]]]] % 32 * 4;
                    u = (fe *= fe) * fe * (S[de] * X + S[de + 1] * q + S[de + 2] * K + S[de + 3] * Z)
                }
                var he = .6 - J * J - Q * Q - $ * $ - ee * ee;
                if (he < 0) l = 0;
                else {
                    var ve = _[te + 1 + _[ne + 1 + _[re + 1 + _[ie + 1]]]] % 32 * 4;
                    l = (he *= he) * he * (S[ve] * J + S[ve + 1] * Q + S[ve + 2] * $ + S[ve + 3] * ee)
                }
                return 27 * (i + o + a + u + l)
            }
        }, u._buildPermutationTable = l, void 0 === (r = function() {
            return u
        }.call(t, n, t, e)) || (e.exports = r), t.SimplexNoise = u, e.exports = u
    }()
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec3 position2;\nattribute vec2 uv;\nattribute float opacity;\nattribute float opacity2;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform float time;\nuniform float timeTransform;\nuniform float durationTransform;\nuniform float prevIndex;\nuniform float nextIndex;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\nvarying float vOpacity;\n\nfloat exponentialOut(float t) {\n  return t == 1.0 ? t : 1.0 - pow(2.0, -10.0 * t);\n}\n\nmat4 calcRotateMat4X(float radian) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, cos(radian), -sin(radian), 0.0,\n    0.0, sin(radian), cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4Y(float radian) {\n  return mat4(\n    cos(radian), 0.0, sin(radian), 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    -sin(radian), 0.0, cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4Z(float radian) {\n  return mat4(\n    cos(radian), -sin(radian), 0.0, 0.0,\n    sin(radian), cos(radian), 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4(vec3 radian) {\n  return calcRotateMat4X(radian.x) * calcRotateMat4Y(radian.y) * calcRotateMat4Z(radian.z);\n}\n\nvoid main(void) {\n  // transform\n  vec3 prevPosition =\n    position * (1.0 - step(1.0, prevIndex))\n    + position2 * step(1.0, prevIndex) * (1.0 - step(2.0, prevIndex));\n  vec3 nextPosition =\n    position * (1.0 - step(1.0, nextIndex))\n    + position2 * step(1.0, nextIndex) * (1.0 - step(2.0, nextIndex));\n  float prevOpacity =\n    opacity * (1.0 - step(1.0, prevIndex))\n    + opacity2 * step(1.0, prevIndex) * (1.0 - step(2.0, prevIndex));\n  float nextOpacity =\n    opacity * (1.0 - step(1.0, nextIndex))\n    + opacity2 * step(1.0, nextIndex) * (1.0 - step(2.0, nextIndex));\n  float ease = exponentialOut(min(timeTransform / 1.0, durationTransform) / durationTransform);\n  vec3 mixPosition = mix(prevPosition, nextPosition, ease);\n  float mixOpacity = mix(prevOpacity, nextOpacity, ease);\n\n  // calculate shake moving.\n  float now = time * 10.0 + length(mixPosition);\n  mat4 rotateMat = calcRotateMat4(vec3(now));\n  vec3 shake = (rotateMat * vec4(vec3(0.0, sin(now) * 5.0, 0.0), 1.0)).xyz;\n\n  // coordinate transformation\n  vec4 mvPosition = modelViewMatrix * vec4(mixPosition + shake, 1.0);\n\n  vPosition = mixPosition;\n  vUv = uv;\n  vOpacity = mixOpacity;\n\n  gl_Position = projectionMatrix * mvPosition;\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform float time;\nuniform float timeShow;\nuniform float durationShow;\n\nvec3 convertHsvToRgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nmat4 calcRotateMat4X(float radian) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, cos(radian), -sin(radian), 0.0,\n    0.0, sin(radian), cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4Y(float radian) {\n  return mat4(\n    cos(radian), 0.0, sin(radian), 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    -sin(radian), 0.0, cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4Z(float radian) {\n  return mat4(\n    cos(radian), -sin(radian), 0.0, 0.0,\n    sin(radian), cos(radian), 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4(vec3 radian) {\n  return calcRotateMat4X(radian.x) * calcRotateMat4Y(radian.y) * calcRotateMat4Z(radian.z);\n}\n\nvarying vec3 vPosition;\nvarying vec3 vColor;\nvarying float vOpacity;\n\nvoid main() {\n  // convert uv to range from -1.0 to 1.0\n  vec2 resolution = uv * 2.0 - 1.0;\n\n  // update rotation\n  float rotateX = resolution.x * 100.0 + time / 2.0;\n  float rotateY = resolution.y * 200.0 + time / 2.0;\n  float rotateZ = length(resolution.xy) * 150.0 + time / 2.0;\n  mat4 rotateMat = calcRotateMat4(vec3(rotateX, rotateY, rotateZ));\n  vec3 rotatePosition = (rotateMat * vec4(vec3(sin(time * 0.1 + resolution.x * 10.0) * 150.0), 1.0)).xyz;\n\n  // update position\n  vec3 wavePosition = vec3(0.0, 0.0, sin(time * 0.1 + (resolution.x + resolution.y) * 5.6) * 300.0);\n  vec3 updatePosition = position + rotatePosition + wavePosition;\n\n  // calculate colors\n  vec3 hsv = vec3(time * 0.1 + 0.5, 0.35, 0.6);\n  vec3 rgb = convertHsvToRgb(hsv);\n\n  // coordinate transformation\n  vec4 mvPosition = modelViewMatrix * vec4(updatePosition, 1.0);\n\n  vPosition = updatePosition;\n  vColor = rgb;\n\n  gl_Position = projectionMatrix * mvPosition;\n}\n"
}, function(e, t, n) {
    "use strict";

    function r(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }
    n.r(t), n.d(t, "default", (function() {
        return o
    }));
    var i = n(0),
        o = function() {
            function e(t, n, r, o) {
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, e), this.uniforms = {
                    resolution: {
                        type: "v2",
                        value: new i.Vector2
                    },
                    direction: {
                        type: "v2",
                        value: new i.Vector2(n, r)
                    },
                    radius: {
                        type: "f",
                        value: o
                    },
                    texture: {
                        type: "t",
                        value: t
                    }
                }, this.obj, this.createObj()
            }
            var t, o, a;
            return t = e, (o = [{
                key: "createObj",
                value: function() {
                    var e = new i.PlaneBufferGeometry(2, 2),
                        t = new i.RawShaderMaterial({
                            uniforms: this.uniforms,
                            vertexShader: n(108).default,
                            fragmentShader: n(513).default
                        });
                    this.obj = new i.Mesh(e, t), this.obj.visible = !1
                }
            }, {
                key: "resize",
                value: function(e) {
                    this.uniforms.resolution.value.set(e.x, e.y)
                }
            }, {
                key: "render",
                value: function(e, t, n) {
                    var r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null;
                    this.obj.visible = !0, e.setRenderTarget(r), e.render(t, n), this.obj.visible = !1
                }
            }]) && r(t.prototype, o), a && r(t, a), e
        }()
}, function(e, t, n) {
    "use strict";

    function r(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }
    n.r(t), n.d(t, "default", (function() {
        return o
    }));
    var i = n(0),
        o = function() {
            function e(t, n, r, o) {
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, e), this.uniforms = {
                    resolution: {
                        type: "v2",
                        value: new i.Vector2
                    },
                    direction: {
                        type: "v2",
                        value: new i.Vector2(n, r)
                    },
                    radius: {
                        type: "f",
                        value: o
                    },
                    texture: {
                        type: "t",
                        value: t
                    }
                }, this.obj = this.createObj(), this.obj.visible = !1
            }
            var t, o, a;
            return t = e, (o = [{
                key: "createObj",
                value: function() {
                    return new i.Mesh(new i.PlaneBufferGeometry(2, 2), new i.RawShaderMaterial({
                        uniforms: this.uniforms,
                        vertexShader: n(109).default,
                        fragmentShader: n(532).default
                    }))
                }
            }, {
                key: "resize",
                value: function(e) {
                    this.uniforms.resolution.value.set(e.x, e.y)
                }
            }, {
                key: "render",
                value: function(e, t, n) {
                    var r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null;
                    this.obj.visible = !0, e.setRenderTarget(r), e.render(t, n), this.obj.visible = !1
                }
            }]) && r(t.prototype, o), a && r(t, a), e
        }()
}, function(e, t, n) {
    "use strict";

    function r(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }
    n.r(t), n.d(t, "default", (function() {
        return o
    }));
    var i = n(0),
        o = function() {
            function e(t, n, r, o) {
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, e), this.side = 0, this.aScene = new i.Scene, this.vScene = new i.Scene, this.camera = new i.PerspectiveCamera(45, 1, 1, 1e3), this.option = {
                    type: i.FloatType,
                    minFilter: i.LinearFilter,
                    magFilter: i.NearestFilter
                }, this.acceleration = [new i.WebGLRenderTarget(0, 0, this.option), new i.WebGLRenderTarget(0, 0, this.option)], this.velocity = [new i.WebGLRenderTarget(0, 0, this.option), new i.WebGLRenderTarget(0, 0, this.option)], this.aUniforms = {
                    resolution: {
                        type: "v2",
                        value: new i.Vector2(document.body.clientWidth, window.innerHeight)
                    },
                    velocity: {
                        type: "t",
                        value: null
                    },
                    acceleration: {
                        type: "t",
                        value: null
                    },
                    time: {
                        type: "f",
                        value: 0
                    }
                }, this.vUniforms = {
                    resolution: {
                        type: "v2",
                        value: new i.Vector2(document.body.clientWidth, window.innerHeight)
                    },
                    side: {
                        type: "f",
                        value: 0
                    },
                    velocityInit: {
                        type: "t",
                        value: null
                    },
                    velocity: {
                        type: "t",
                        value: null
                    },
                    acceleration: {
                        type: "t",
                        value: null
                    },
                    time: {
                        type: "f",
                        value: 0
                    }
                }, this.accelerationMesh = this.createMesh(this.aUniforms, t, n), this.velocityMesh = this.createMesh(this.vUniforms, r, o), this.uvs = [], this.targetIndex = 0
            }
            var t, o, a;
            return t = e, (o = [{
                key: "init",
                value: function(e, t, r, o) {
                    this.side = Math.ceil(Math.sqrt(t.length / 3)), this.vUniforms.side.value = this.side;
                    for (var a = [], s = 0; s < 3 * Math.pow(this.side, 2); s += 3) null != t[s] ? (a[s + 0] = t[s + 0], a[s + 1] = t[s + 1], a[s + 2] = t[s + 2], this.uvs[s / 3 * 2 + 0] = s / 3 % this.side / (this.side - 1), this.uvs[s / 3 * 2 + 1] = Math.floor(s / 3 / this.side) / (this.side - 1)) : (a[s + 0] = 0, a[s + 1] = 0, a[s + 2] = 0);
                    if (r) {
                        var c = Object.keys(r);
                        if (c.length)
                            for (s = 0; s < c.length; s++) {
                                for (var u = r[c[s]], l = u.array.length; l < a.length / 3 * u.itemSize; l++) u.array.push(0);
                                this.accelerationMesh.geometry.addAttribute(c[s], new i.BufferAttribute(new Float32Array(u.array), u.itemSize))
                            }
                    }
                    if (o) {
                        var f = Object.keys(o);
                        if (f.length)
                            for (s = 0; s < f.length; s++) {
                                var d = o[f[s]];
                                for (l = d.array.length; l < a.length / 3 * d.itemSize; l++) d.array.push(0);
                                this.velocityMesh.geometry.addAttribute(f[s], new i.BufferAttribute(new Float32Array(d.array), d.itemSize))
                            }
                    }
                    this.vUniforms.velocityInit.value = new i.DataTexture(new Float32Array(a), this.side, this.side, i.RGBFormat, i.FloatType), this.vUniforms.velocityInit.value.needsUpdate = !0;
                    var h = new i.Mesh(new i.PlaneBufferGeometry(2, 2), new i.ShaderMaterial({
                        uniforms: {
                            velocity: {
                                type: "t",
                                value: this.vUniforms.velocityInit.value
                            }
                        },
                        vertexShader: n(585).default,
                        fragmentShader: n(586).default
                    }));
                    for (s = 0; s < 2; s++) this.acceleration[s].setSize(this.side, this.side), this.velocity[s].setSize(this.side, this.side);
                    this.vScene.add(this.camera), this.vScene.add(h), e.setRenderTarget(this.velocity[0]), e.render(this.vScene, this.camera), e.setRenderTarget(this.velocity[1]), e.render(this.vScene, this.camera), this.vScene.remove(h), this.vScene.add(this.velocityMesh), this.aScene.add(this.accelerationMesh)
                }
            }, {
                key: "createMesh",
                value: function(e, t, n) {
                    return new i.Mesh(new i.PlaneBufferGeometry(2, 2), new i.ShaderMaterial({
                        uniforms: e,
                        vertexShader: t,
                        fragmentShader: n
                    }))
                }
            }, {
                key: "render",
                value: function(e, t) {
                    var n = Math.abs(this.targetIndex - 1),
                        r = this.targetIndex;
                    this.aUniforms.acceleration.value = this.acceleration[n].texture, this.aUniforms.velocity.value = this.velocity[r].texture, e.setRenderTarget(this.acceleration[r]), e.render(this.aScene, this.camera), this.vUniforms.acceleration.value = this.acceleration[r].texture, this.vUniforms.velocity.value = this.velocity[r].texture, e.setRenderTarget(this.velocity[n]), e.render(this.vScene, this.camera), this.targetIndex = n, this.aUniforms.time.value += t, this.vUniforms.time.value += t
                }
            }, {
                key: "getBufferAttributeUv",
                value: function() {
                    return new i.BufferAttribute(new Float32Array(this.uvs), 2)
                }
            }, {
                key: "getCurrentVelocity",
                value: function() {
                    return this.velocity[Math.abs(this.targetIndex - 1)].texture
                }
            }, {
                key: "getCurrentAcceleration",
                value: function() {
                    return this.acceleration[Math.abs(this.targetIndex - 1)].texture
                }
            }, {
                key: "mergeAUniforms",
                value: function(e) {
                    this.aUniforms = Object.assign(this.aUniforms, e)
                }
            }, {
                key: "mergeVUniforms",
                value: function(e) {
                    this.vUniforms = Object.assign(this.vUniforms, e)
                }
            }, {
                key: "resize",
                value: function(e) {
                    this.aUniforms.resolution.value.set(document.body.clientWidth, window.clientHeight), this.vUniforms.resolution.value.set(document.body.clientWidth, window.clientHeight)
                }
            }]) && r(t.prototype, o), a && r(t, a), e
        }()
}, function(e, t, n) {
    var r, i = n(0),
        o = n(16),
        a = n(46);
    e.exports = (((r = function(e, t, n) {
        i.HemisphereLight.call(this, e, t, n), this.force = new a
    }).prototype = Object.create(i.HemisphereLight.prototype)).constructor = r, r.prototype.updatePosition = function() {
        this.position.copy(this.force.velocity)
    }, r.prototype.setPositionSpherical = function(e, t, n) {
        this.position.copy(o.getPolarCoord(e, t, n))
    }, r)
}, function(e, t, n) {
    var r, i = n(0),
        o = n(16),
        a = n(46);
    e.exports = (((r = function(e, t, n, r) {
        i.PointLight.call(this, e, t, n, r), this.force = new a
    }).prototype = Object.create(i.PointLight.prototype)).constructor = r, r.prototype.updatePosition = function() {
        this.position.copy(this.force.velocity)
    }, r.prototype.setPolarCoord = function(e, t, n) {
        this.position.copy(o.getPolarCoord(e, t, n))
    }, r)
}, function(e, t, n) {
    var r, i;
    void 0 === (i = "function" == typeof(r = {
        easeInQuad: function(e) {
            return Math.pow(e, 2)
        },
        easeOutQuad: function(e) {
            return -(Math.pow(e - 1, 2) - 1)
        },
        easeInOutQuad: function(e) {
            return (e /= .5) < 1 ? .5 * Math.pow(e, 2) : -.5 * ((e -= 2) * e - 2)
        },
        easeInCubic: function(e) {
            return Math.pow(e, 3)
        },
        easeOutCubic: function(e) {
            return Math.pow(e - 1, 3) + 1
        },
        easeInOutCubic: function(e) {
            return (e /= .5) < 1 ? .5 * Math.pow(e, 3) : .5 * (Math.pow(e - 2, 3) + 2)
        },
        easeInQuart: function(e) {
            return Math.pow(e, 4)
        },
        easeOutQuart: function(e) {
            return -(Math.pow(e - 1, 4) - 1)
        },
        easeInOutQuart: function(e) {
            return (e /= .5) < 1 ? .5 * Math.pow(e, 4) : -.5 * ((e -= 2) * Math.pow(e, 3) - 2)
        },
        easeInQuint: function(e) {
            return Math.pow(e, 5)
        },
        easeOutQuint: function(e) {
            return Math.pow(e - 1, 5) + 1
        },
        easeInOutQuint: function(e) {
            return (e /= .5) < 1 ? .5 * Math.pow(e, 5) : .5 * (Math.pow(e - 2, 5) + 2)
        },
        easeInSine: function(e) {
            return 1 - Math.cos(e * (Math.PI / 2))
        },
        easeOutSine: function(e) {
            return Math.sin(e * (Math.PI / 2))
        },
        easeInOutSine: function(e) {
            return -.5 * (Math.cos(Math.PI * e) - 1)
        },
        easeInExpo: function(e) {
            return 0 === e ? 0 : Math.pow(2, 10 * (e - 1))
        },
        easeOutExpo: function(e) {
            return 1 === e ? 1 : 1 - Math.pow(2, -10 * e)
        },
        easeInOutExpo: function(e) {
            return 0 === e ? 0 : 1 === e ? 1 : (e /= .5) < 1 ? .5 * Math.pow(2, 10 * (e - 1)) : .5 * (2 - Math.pow(2, -10 * --e))
        },
        easeInCirc: function(e) {
            return -(Math.sqrt(1 - e * e) - 1)
        },
        easeOutCirc: function(e) {
            return Math.sqrt(1 - Math.pow(e - 1, 2))
        },
        easeInOutCirc: function(e) {
            return (e /= .5) < 1 ? -.5 * (Math.sqrt(1 - e * e) - 1) : .5 * (Math.sqrt(1 - (e -= 2) * e) + 1)
        },
        easeOutBounce: function(e) {
            return e < 1 / 2.75 ? 7.5625 * e * e : e < 2 / 2.75 ? 7.5625 * (e -= 1.5 / 2.75) * e + .75 : e < 2.5 / 2.75 ? 7.5625 * (e -= 2.25 / 2.75) * e + .9375 : 7.5625 * (e -= 2.625 / 2.75) * e + .984375
        },
        easeInBack: function(e) {
            var t = 1.70158;
            return e * e * ((t + 1) * e - t)
        },
        easeOutBack: function(e) {
            var t = 1.70158;
            return (e -= 1) * e * ((t + 1) * e + t) + 1
        },
        easeInOutBack: function(e) {
            var t = 1.70158;
            return (e /= .5) < 1 ? e * e * ((1 + (t *= 1.525)) * e - t) * .5 : .5 * ((e -= 2) * e * ((1 + (t *= 1.525)) * e + t) + 2)
        },
        elastic: function(e) {
            return -1 * Math.pow(4, -8 * e) * Math.sin((6 * e - 1) * (2 * Math.PI) / 2) + 1
        },
        swingFromTo: function(e) {
            var t = 1.70158;
            return (e /= .5) < 1 ? e * e * ((1 + (t *= 1.525)) * e - t) * .5 : .5 * ((e -= 2) * e * ((1 + (t *= 1.525)) * e + t) + 2)
        },
        swingFrom: function(e) {
            var t = 1.70158;
            return e * e * ((t + 1) * e - t)
        },
        swingTo: function(e) {
            var t = 1.70158;
            return (e -= 1) * e * ((t + 1) * e + t) + 1
        },
        bounce: function(e) {
            return e < 1 / 2.75 ? 7.5625 * e * e : e < 2 / 2.75 ? 7.5625 * (e -= 1.5 / 2.75) * e + .75 : e < 2.5 / 2.75 ? 7.5625 * (e -= 2.25 / 2.75) * e + .9375 : 7.5625 * (e -= 2.625 / 2.75) * e + .984375
        },
        bouncePast: function(e) {
            return e < 1 / 2.75 ? 7.5625 * e * e : e < 2 / 2.75 ? 2 - (7.5625 * (e -= 1.5 / 2.75) * e + .75) : e < 2.5 / 2.75 ? 2 - (7.5625 * (e -= 2.25 / 2.75) * e + .9375) : 2 - (7.5625 * (e -= 2.625 / 2.75) * e + .984375)
        },
        easeFromTo: function(e) {
            return (e /= .5) < 1 ? .5 * Math.pow(e, 4) : -.5 * ((e -= 2) * Math.pow(e, 3) - 2)
        },
        easeFrom: function(e) {
            return Math.pow(e, 4)
        },
        easeTo: function(e) {
            return Math.pow(e, .25)
        }
    }) ? r.call(t, n, t, e) : r) || (e.exports = i)
}, function(e, t, n) {
    var r;
    ! function(i, o) {
        "use strict";
        var a = "model",
            s = "name",
            c = "type",
            u = "vendor",
            l = "version",
            f = "mobile",
            d = "tablet",
            h = {
                extend: function(e, t) {
                    var n = {};
                    for (var r in e) t[r] && t[r].length % 2 == 0 ? n[r] = t[r].concat(e[r]) : n[r] = e[r];
                    return n
                },
                has: function(e, t) {
                    return "string" == typeof e && -1 !== t.toLowerCase().indexOf(e.toLowerCase())
                },
                lowerize: function(e) {
                    return e.toLowerCase()
                },
                major: function(e) {
                    return "string" == typeof e ? e.replace(/[^\d\.]/g, "").split(".")[0] : void 0
                },
                trim: function(e) {
                    return e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "")
                }
            },
            v = {
                rgx: function(e, t) {
                    for (var n, r, i, o, a, s, c = 0; c < t.length && !a;) {
                        var u = t[c],
                            l = t[c + 1];
                        for (n = r = 0; n < u.length && !a;)
                            if (a = u[n++].exec(e))
                                for (i = 0; i < l.length; i++) s = a[++r], "object" == typeof(o = l[i]) && o.length > 0 ? 2 == o.length ? "function" == typeof o[1] ? this[o[0]] = o[1].call(this, s) : this[o[0]] = o[1] : 3 == o.length ? "function" != typeof o[1] || o[1].exec && o[1].test ? this[o[0]] = s ? s.replace(o[1], o[2]) : void 0 : this[o[0]] = s ? o[1].call(this, s, o[2]) : void 0 : 4 == o.length && (this[o[0]] = s ? o[3].call(this, s.replace(o[1], o[2])) : void 0) : this[o] = s || void 0;
                        c += 2
                    }
                },
                str: function(e, t) {
                    for (var n in t)
                        if ("object" == typeof t[n] && t[n].length > 0) {
                            for (var r = 0; r < t[n].length; r++)
                                if (h.has(t[n][r], e)) return "?" === n ? void 0 : n
                        } else if (h.has(t[n], e)) return "?" === n ? void 0 : n;
                    return e
                }
            },
            p = {
                browser: {
                    oldsafari: {
                        version: {
                            "1.0": "/8",
                            1.2: "/1",
                            1.3: "/3",
                            "2.0": "/412",
                            "2.0.2": "/416",
                            "2.0.3": "/417",
                            "2.0.4": "/419",
                            "?": "/"
                        }
                    }
                },
                device: {
                    amazon: {
                        model: {
                            "Fire Phone": ["SD", "KF"]
                        }
                    },
                    sprint: {
                        model: {
                            "Evo Shift 4G": "7373KT"
                        },
                        vendor: {
                            HTC: "APA",
                            Sprint: "Sprint"
                        }
                    }
                },
                os: {
                    windows: {
                        version: {
                            ME: "4.90",
                            "NT 3.11": "NT3.51",
                            "NT 4.0": "NT4.0",
                            2e3: "NT 5.0",
                            XP: ["NT 5.1", "NT 5.2"],
                            Vista: "NT 6.0",
                            7: "NT 6.1",
                            8: "NT 6.2",
                            8.1: "NT 6.3",
                            10: ["NT 6.4", "NT 10.0"],
                            RT: "ARM"
                        }
                    }
                }
            },
            m = {
                browser: [
                    [/(opera\smini)\/([\w\.-]+)/i, /(opera\s[mobiletab]+).+version\/([\w\.-]+)/i, /(opera).+version\/([\w\.]+)/i, /(opera)[\/\s]+([\w\.]+)/i],
                    [s, l],
                    [/(opios)[\/\s]+([\w\.]+)/i],
                    [
                        [s, "Opera Mini"], l
                    ],
                    [/\s(opr)\/([\w\.]+)/i],
                    [
                        [s, "Opera"], l
                    ],
                    [/(kindle)\/([\w\.]+)/i, /(lunascape|maxthon|netfront|jasmine|blazer)[\/\s]?([\w\.]+)*/i, /(avant\s|iemobile|slim|baidu)(?:browser)?[\/\s]?([\w\.]*)/i, /(?:ms|\()(ie)\s([\w\.]+)/i, /(rekonq)\/([\w\.]+)*/i, /(chromium|flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi|iridium|phantomjs|bowser)\/([\w\.-]+)/i],
                    [s, l],
                    [/(trident).+rv[:\s]([\w\.]+).+like\sgecko/i],
                    [
                        [s, "IE"], l
                    ],
                    [/(edge)\/((\d+)?[\w\.]+)/i],
                    [s, l],
                    [/(yabrowser)\/([\w\.]+)/i],
                    [
                        [s, "Yandex"], l
                    ],
                    [/(puffin)\/([\w\.]+)/i],
                    [
                        [s, "Puffin"], l
                    ],
                    [/((?:[\s\/])uc?\s?browser|(?:juc.+)ucweb)[\/\s]?([\w\.]+)/i],
                    [
                        [s, "UCBrowser"], l
                    ],
                    [/(comodo_dragon)\/([\w\.]+)/i],
                    [
                        [s, /_/g, " "], l
                    ],
                    [/(micromessenger)\/([\w\.]+)/i],
                    [
                        [s, "WeChat"], l
                    ],
                    [/(QQ)\/([\d\.]+)/i],
                    [s, l],
                    [/m?(qqbrowser)[\/\s]?([\w\.]+)/i],
                    [s, l],
                    [/xiaomi\/miuibrowser\/([\w\.]+)/i],
                    [l, [s, "MIUI Browser"]],
                    [/;fbav\/([\w\.]+);/i],
                    [l, [s, "Facebook"]],
                    [/headlesschrome(?:\/([\w\.]+)|\s)/i],
                    [l, [s, "Chrome Headless"]],
                    [/\swv\).+(chrome)\/([\w\.]+)/i],
                    [
                        [s, /(.+)/, "$1 WebView"], l
                    ],
                    [/((?:oculus|samsung)browser)\/([\w\.]+)/i],
                    [
                        [s, /(.+(?:g|us))(.+)/, "$1 $2"], l
                    ],
                    [/android.+version\/([\w\.]+)\s+(?:mobile\s?safari|safari)*/i],
                    [l, [s, "Android Browser"]],
                    [/(chrome|omniweb|arora|[tizenoka]{5}\s?browser)\/v?([\w\.]+)/i],
                    [s, l],
                    [/(dolfin)\/([\w\.]+)/i],
                    [
                        [s, "Dolphin"], l
                    ],
                    [/((?:android.+)crmo|crios)\/([\w\.]+)/i],
                    [
                        [s, "Chrome"], l
                    ],
                    [/(coast)\/([\w\.]+)/i],
                    [
                        [s, "Opera Coast"], l
                    ],
                    [/fxios\/([\w\.-]+)/i],
                    [l, [s, "Firefox"]],
                    [/version\/([\w\.]+).+?mobile\/\w+\s(safari)/i],
                    [l, [s, "Mobile Safari"]],
                    [/version\/([\w\.]+).+?(mobile\s?safari|safari)/i],
                    [l, s],
                    [/webkit.+?(gsa)\/([\w\.]+).+?(mobile\s?safari|safari)(\/[\w\.]+)/i],
                    [
                        [s, "GSA"], l
                    ],
                    [/webkit.+?(mobile\s?safari|safari)(\/[\w\.]+)/i],
                    [s, [l, v.str, p.browser.oldsafari.version]],
                    [/(konqueror)\/([\w\.]+)/i, /(webkit|khtml)\/([\w\.]+)/i],
                    [s, l],
                    [/(navigator|netscape)\/([\w\.-]+)/i],
                    [
                        [s, "Netscape"], l
                    ],
                    [/(swiftfox)/i, /(icedragon|iceweasel|camino|chimera|fennec|maemo\sbrowser|minimo|conkeror)[\/\s]?([\w\.\+]+)/i, /(firefox|seamonkey|k-meleon|icecat|iceape|firebird|phoenix)\/([\w\.-]+)/i, /(mozilla)\/([\w\.]+).+rv\:.+gecko\/\d+/i, /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir)[\/\s]?([\w\.]+)/i, /(links)\s\(([\w\.]+)/i, /(gobrowser)\/?([\w\.]+)*/i, /(ice\s?browser)\/v?([\w\._]+)/i, /(mosaic)[\/\s]([\w\.]+)/i],
                    [s, l]
                ],
                cpu: [
                    [/(?:(amd|x(?:(?:86|64)[_-])?|wow|win)64)[;\)]/i],
                    [
                        ["architecture", "amd64"]
                    ],
                    [/(ia32(?=;))/i],
                    [
                        ["architecture", h.lowerize]
                    ],
                    [/((?:i[346]|x)86)[;\)]/i],
                    [
                        ["architecture", "ia32"]
                    ],
                    [/windows\s(ce|mobile);\sppc;/i],
                    [
                        ["architecture", "arm"]
                    ],
                    [/((?:ppc|powerpc)(?:64)?)(?:\smac|;|\))/i],
                    [
                        ["architecture", /ower/, "", h.lowerize]
                    ],
                    [/(sun4\w)[;\)]/i],
                    [
                        ["architecture", "sparc"]
                    ],
                    [/((?:avr32|ia64(?=;))|68k(?=\))|arm(?:64|(?=v\d+;))|(?=atmel\s)avr|(?:irix|mips|sparc)(?:64)?(?=;)|pa-risc)/i],
                    [
                        ["architecture", h.lowerize]
                    ]
                ],
                device: [
                    [/\((ipad|playbook);[\w\s\);-]+(rim|apple)/i],
                    [a, u, [c, d]],
                    [/applecoremedia\/[\w\.]+ \((ipad)/],
                    [a, [u, "Apple"],
                        [c, d]
                    ],
                    [/(apple\s{0,1}tv)/i],
                    [
                        [a, "Apple TV"],
                        [u, "Apple"]
                    ],
                    [/(archos)\s(gamepad2?)/i, /(hp).+(touchpad)/i, /(hp).+(tablet)/i, /(kindle)\/([\w\.]+)/i, /\s(nook)[\w\s]+build\/(\w+)/i, /(dell)\s(strea[kpr\s\d]*[\dko])/i],
                    [u, a, [c, d]],
                    [/(kf[A-z]+)\sbuild\/[\w\.]+.*silk\//i],
                    [a, [u, "Amazon"],
                        [c, d]
                    ],
                    [/(sd|kf)[0349hijorstuw]+\sbuild\/[\w\.]+.*silk\//i],
                    [
                        [a, v.str, p.device.amazon.model],
                        [u, "Amazon"],
                        [c, f]
                    ],
                    [/\((ip[honed|\s\w*]+);.+(apple)/i],
                    [a, u, [c, f]],
                    [/\((ip[honed|\s\w*]+);/i],
                    [a, [u, "Apple"],
                        [c, f]
                    ],
                    [/(blackberry)[\s-]?(\w+)/i, /(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron)[\s_-]?([\w-]+)*/i, /(hp)\s([\w\s]+\w)/i, /(asus)-?(\w+)/i],
                    [u, a, [c, f]],
                    [/\(bb10;\s(\w+)/i],
                    [a, [u, "BlackBerry"],
                        [c, f]
                    ],
                    [/android.+(transfo[prime\s]{4,10}\s\w+|eeepc|slider\s\w+|nexus 7|padfone)/i],
                    [a, [u, "Asus"],
                        [c, d]
                    ],
                    [/(sony)\s(tablet\s[ps])\sbuild\//i, /(sony)?(?:sgp.+)\sbuild\//i],
                    [
                        [u, "Sony"],
                        [a, "Xperia Tablet"],
                        [c, d]
                    ],
                    [/android.+\s([c-g]\d{4}|so[-l]\w+)\sbuild\//i],
                    [a, [u, "Sony"],
                        [c, f]
                    ],
                    [/\s(ouya)\s/i, /(nintendo)\s([wids3u]+)/i],
                    [u, a, [c, "console"]],
                    [/android.+;\s(shield)\sbuild/i],
                    [a, [u, "Nvidia"],
                        [c, "console"]
                    ],
                    [/(playstation\s[34portablevi]+)/i],
                    [a, [u, "Sony"],
                        [c, "console"]
                    ],
                    [/(sprint\s(\w+))/i],
                    [
                        [u, v.str, p.device.sprint.vendor],
                        [a, v.str, p.device.sprint.model],
                        [c, f]
                    ],
                    [/(lenovo)\s?(S(?:5000|6000)+(?:[-][\w+]))/i],
                    [u, a, [c, d]],
                    [/(htc)[;_\s-]+([\w\s]+(?=\))|\w+)*/i, /(zte)-(\w+)*/i, /(alcatel|geeksphone|lenovo|nexian|panasonic|(?=;\s)sony)[_\s-]?([\w-]+)*/i],
                    [u, [a, /_/g, " "],
                        [c, f]
                    ],
                    [/(nexus\s9)/i],
                    [a, [u, "HTC"],
                        [c, d]
                    ],
                    [/d\/huawei([\w\s-]+)[;\)]/i, /(nexus\s6p)/i],
                    [a, [u, "Huawei"],
                        [c, f]
                    ],
                    [/(microsoft);\s(lumia[\s\w]+)/i],
                    [u, a, [c, f]],
                    [/[\s\(;](xbox(?:\sone)?)[\s\);]/i],
                    [a, [u, "Microsoft"],
                        [c, "console"]
                    ],
                    [/(kin\.[onetw]{3})/i],
                    [
                        [a, /\./g, " "],
                        [u, "Microsoft"],
                        [c, f]
                    ],
                    [/\s(milestone|droid(?:[2-4x]|\s(?:bionic|x2|pro|razr))?(:?\s4g)?)[\w\s]+build\//i, /mot[\s-]?(\w+)*/i, /(XT\d{3,4}) build\//i, /(nexus\s6)/i],
                    [a, [u, "Motorola"],
                        [c, f]
                    ],
                    [/android.+\s(mz60\d|xoom[\s2]{0,2})\sbuild\//i],
                    [a, [u, "Motorola"],
                        [c, d]
                    ],
                    [/hbbtv\/\d+\.\d+\.\d+\s+\([\w\s]*;\s*(\w[^;]*);([^;]*)/i],
                    [
                        [u, h.trim],
                        [a, h.trim],
                        [c, "smarttv"]
                    ],
                    [/hbbtv.+maple;(\d+)/i],
                    [
                        [a, /^/, "SmartTV"],
                        [u, "Samsung"],
                        [c, "smarttv"]
                    ],
                    [/\(dtv[\);].+(aquos)/i],
                    [a, [u, "Sharp"],
                        [c, "smarttv"]
                    ],
                    [/android.+((sch-i[89]0\d|shw-m380s|gt-p\d{4}|gt-n\d+|sgh-t8[56]9|nexus 10))/i, /((SM-T\w+))/i],
                    [
                        [u, "Samsung"], a, [c, d]
                    ],
                    [/smart-tv.+(samsung)/i],
                    [u, [c, "smarttv"], a],
                    [/((s[cgp]h-\w+|gt-\w+|galaxy\snexus|sm-\w[\w\d]+))/i, /(sam[sung]*)[\s-]*(\w+-?[\w-]*)*/i, /sec-((sgh\w+))/i],
                    [
                        [u, "Samsung"], a, [c, f]
                    ],
                    [/sie-(\w+)*/i],
                    [a, [u, "Siemens"],
                        [c, f]
                    ],
                    [/(maemo|nokia).*(n900|lumia\s\d+)/i, /(nokia)[\s_-]?([\w-]+)*/i],
                    [
                        [u, "Nokia"], a, [c, f]
                    ],
                    [/android\s3\.[\s\w;-]{10}(a\d{3})/i],
                    [a, [u, "Acer"],
                        [c, d]
                    ],
                    [/android.+([vl]k\-?\d{3})\s+build/i],
                    [a, [u, "LG"],
                        [c, d]
                    ],
                    [/android\s3\.[\s\w;-]{10}(lg?)-([06cv9]{3,4})/i],
                    [
                        [u, "LG"], a, [c, d]
                    ],
                    [/(lg) netcast\.tv/i],
                    [u, a, [c, "smarttv"]],
                    [/(nexus\s[45])/i, /lg[e;\s\/-]+(\w+)*/i, /android.+lg(\-?[\d\w]+)\s+build/i],
                    [a, [u, "LG"],
                        [c, f]
                    ],
                    [/android.+(ideatab[a-z0-9\-\s]+)/i],
                    [a, [u, "Lenovo"],
                        [c, d]
                    ],
                    [/linux;.+((jolla));/i],
                    [u, a, [c, f]],
                    [/((pebble))app\/[\d\.]+\s/i],
                    [u, a, [c, "wearable"]],
                    [/android.+;\s(oppo)\s?([\w\s]+)\sbuild/i],
                    [u, a, [c, f]],
                    [/crkey/i],
                    [
                        [a, "Chromecast"],
                        [u, "Google"]
                    ],
                    [/android.+;\s(glass)\s\d/i],
                    [a, [u, "Google"],
                        [c, "wearable"]
                    ],
                    [/android.+;\s(pixel c)\s/i],
                    [a, [u, "Google"],
                        [c, d]
                    ],
                    [/android.+;\s(pixel xl|pixel)\s/i],
                    [a, [u, "Google"],
                        [c, f]
                    ],
                    [/android.+(\w+)\s+build\/hm\1/i, /android.+(hm[\s\-_]*note?[\s_]*(?:\d\w)?)\s+build/i, /android.+(mi[\s\-_]*(?:one|one[\s_]plus|note lte)?[\s_]*(?:\d\w)?)\s+build/i, /android.+(redmi[\s\-_]*(?:note)?(?:[\s_]*[\w\s]+)?)\s+build/i],
                    [
                        [a, /_/g, " "],
                        [u, "Xiaomi"],
                        [c, f]
                    ],
                    [/android.+(mi[\s\-_]*(?:pad)?(?:[\s_]*[\w\s]+)?)\s+build/i],
                    [
                        [a, /_/g, " "],
                        [u, "Xiaomi"],
                        [c, d]
                    ],
                    [/android.+;\s(m[1-5]\snote)\sbuild/i],
                    [a, [u, "Meizu"],
                        [c, d]
                    ],
                    [/android.+a000(1)\s+build/i],
                    [a, [u, "OnePlus"],
                        [c, f]
                    ],
                    [/android.+[;\/]\s*(RCT[\d\w]+)\s+build/i],
                    [a, [u, "RCA"],
                        [c, d]
                    ],
                    [/android.+[;\/]\s*(Venue[\d\s]*)\s+build/i],
                    [a, [u, "Dell"],
                        [c, d]
                    ],
                    [/android.+[;\/]\s*(Q[T|M][\d\w]+)\s+build/i],
                    [a, [u, "Verizon"],
                        [c, d]
                    ],
                    [/android.+[;\/]\s+(Barnes[&\s]+Noble\s+|BN[RT])(V?.*)\s+build/i],
                    [
                        [u, "Barnes & Noble"], a, [c, d]
                    ],
                    [/android.+[;\/]\s+(TM\d{3}.*\b)\s+build/i],
                    [a, [u, "NuVision"],
                        [c, d]
                    ],
                    [/android.+[;\/]\s*(zte)?.+(k\d{2})\s+build/i],
                    [
                        [u, "ZTE"], a, [c, d]
                    ],
                    [/android.+[;\/]\s*(gen\d{3})\s+build.*49h/i],
                    [a, [u, "Swiss"],
                        [c, f]
                    ],
                    [/android.+[;\/]\s*(zur\d{3})\s+build/i],
                    [a, [u, "Swiss"],
                        [c, d]
                    ],
                    [/android.+[;\/]\s*((Zeki)?TB.*\b)\s+build/i],
                    [a, [u, "Zeki"],
                        [c, d]
                    ],
                    [/(android).+[;\/]\s+([YR]\d{2}x?.*)\s+build/i, /android.+[;\/]\s+(Dragon[\-\s]+Touch\s+|DT)(.+)\s+build/i],
                    [
                        [u, "Dragon Touch"], a, [c, d]
                    ],
                    [/android.+[;\/]\s*(NS-?.+)\s+build/i],
                    [a, [u, "Insignia"],
                        [c, d]
                    ],
                    [/android.+[;\/]\s*((NX|Next)-?.+)\s+build/i],
                    [a, [u, "NextBook"],
                        [c, d]
                    ],
                    [/android.+[;\/]\s*(Xtreme\_?)?(V(1[045]|2[015]|30|40|60|7[05]|90))\s+build/i],
                    [
                        [u, "Voice"], a, [c, f]
                    ],
                    [/android.+[;\/]\s*(LVTEL\-?)?(V1[12])\s+build/i],
                    [
                        [u, "LvTel"], a, [c, f]
                    ],
                    [/android.+[;\/]\s*(V(100MD|700NA|7011|917G).*\b)\s+build/i],
                    [a, [u, "Envizen"],
                        [c, d]
                    ],
                    [/android.+[;\/]\s*(Le[\s\-]+Pan)[\s\-]+(.*\b)\s+build/i],
                    [u, a, [c, d]],
                    [/android.+[;\/]\s*(Trio[\s\-]*.*)\s+build/i],
                    [a, [u, "MachSpeed"],
                        [c, d]
                    ],
                    [/android.+[;\/]\s*(Trinity)[\-\s]*(T\d{3})\s+build/i],
                    [u, a, [c, d]],
                    [/android.+[;\/]\s*TU_(1491)\s+build/i],
                    [a, [u, "Rotor"],
                        [c, d]
                    ],
                    [/android.+(KS(.+))\s+build/i],
                    [a, [u, "Amazon"],
                        [c, d]
                    ],
                    [/android.+(Gigaset)[\s\-]+(Q.+)\s+build/i],
                    [u, a, [c, d]],
                    [/\s(tablet|tab)[;\/]/i, /\s(mobile)(?:[;\/]|\ssafari)/i],
                    [
                        [c, h.lowerize], u, a
                    ],
                    [/(android.+)[;\/].+build/i],
                    [a, [u, "Generic"]]
                ],
                engine: [
                    [/windows.+\sedge\/([\w\.]+)/i],
                    [l, [s, "EdgeHTML"]],
                    [/(presto)\/([\w\.]+)/i, /(webkit|trident|netfront|netsurf|amaya|lynx|w3m)\/([\w\.]+)/i, /(khtml|tasman|links)[\/\s]\(?([\w\.]+)/i, /(icab)[\/\s]([23]\.[\d\.]+)/i],
                    [s, l],
                    [/rv\:([\w\.]+).*(gecko)/i],
                    [l, s]
                ],
                os: [
                    [/microsoft\s(windows)\s(vista|xp)/i],
                    [s, l],
                    [/(windows)\snt\s6\.2;\s(arm)/i, /(windows\sphone(?:\sos)*)[\s\/]?([\d\.\s]+\w)*/i, /(windows\smobile|windows)[\s\/]?([ntce\d\.\s]+\w)/i],
                    [s, [l, v.str, p.os.windows.version]],
                    [/(win(?=3|9|n)|win\s9x\s)([nt\d\.]+)/i],
                    [
                        [s, "Windows"],
                        [l, v.str, p.os.windows.version]
                    ],
                    [/\((bb)(10);/i],
                    [
                        [s, "BlackBerry"], l
                    ],
                    [/(blackberry)\w*\/?([\w\.]+)*/i, /(tizen)[\/\s]([\w\.]+)/i, /(android|webos|palm\sos|qnx|bada|rim\stablet\sos|meego|contiki)[\/\s-]?([\w\.]+)*/i, /linux;.+(sailfish);/i],
                    [s, l],
                    [/(symbian\s?os|symbos|s60(?=;))[\/\s-]?([\w\.]+)*/i],
                    [
                        [s, "Symbian"], l
                    ],
                    [/\((series40);/i],
                    [s],
                    [/mozilla.+\(mobile;.+gecko.+firefox/i],
                    [
                        [s, "Firefox OS"], l
                    ],
                    [/(nintendo|playstation)\s([wids34portablevu]+)/i, /(mint)[\/\s\(]?(\w+)*/i, /(mageia|vectorlinux)[;\s]/i, /(joli|[kxln]?ubuntu|debian|[open]*suse|gentoo|(?=\s)arch|slackware|fedora|mandriva|centos|pclinuxos|redhat|zenwalk|linpus)[\/\s-]?(?!chrom)([\w\.-]+)*/i, /(hurd|linux)\s?([\w\.]+)*/i, /(gnu)\s?([\w\.]+)*/i],
                    [s, l],
                    [/(cros)\s[\w]+\s([\w\.]+\w)/i],
                    [
                        [s, "Chromium OS"], l
                    ],
                    [/(sunos)\s?([\w\.]+\d)*/i],
                    [
                        [s, "Solaris"], l
                    ],
                    [/\s([frentopc-]{0,4}bsd|dragonfly)\s?([\w\.]+)*/i],
                    [s, l],
                    [/(haiku)\s(\w+)/i],
                    [s, l],
                    [/cfnetwork\/.+darwin/i, /ip[honead]+(?:.*os\s([\w]+)\slike\smac|;\sopera)/i],
                    [
                        [l, /_/g, "."],
                        [s, "iOS"]
                    ],
                    [/(mac\sos\sx)\s?([\w\s\.]+\w)*/i, /(macintosh|mac(?=_powerpc)\s)/i],
                    [
                        [s, "Mac OS"],
                        [l, /_/g, "."]
                    ],
                    [/((?:open)?solaris)[\/\s-]?([\w\.]+)*/i, /(aix)\s((\d)(?=\.|\)|\s)[\w\.]*)*/i, /(plan\s9|minix|beos|os\/2|amigaos|morphos|risc\sos|openvms)/i, /(unix)\s?([\w\.]+)*/i],
                    [s, l]
                ]
            },
            y = function(e, t) {
                if ("object" == typeof e && (t = e, e = void 0), !(this instanceof y)) return new y(e, t).getResult();
                var n = e || (i && i.navigator && i.navigator.userAgent ? i.navigator.userAgent : ""),
                    r = t ? h.extend(m, t) : m;
                return this.getBrowser = function() {
                    var e = {
                        name: void 0,
                        version: void 0
                    };
                    return v.rgx.call(e, n, r.browser), e.major = h.major(e.version), e
                }, this.getCPU = function() {
                    var e = {
                        architecture: void 0
                    };
                    return v.rgx.call(e, n, r.cpu), e
                }, this.getDevice = function() {
                    var e = {
                        vendor: void 0,
                        model: void 0,
                        type: void 0
                    };
                    return v.rgx.call(e, n, r.device), e
                }, this.getEngine = function() {
                    var e = {
                        name: void 0,
                        version: void 0
                    };
                    return v.rgx.call(e, n, r.engine), e
                }, this.getOS = function() {
                    var e = {
                        name: void 0,
                        version: void 0
                    };
                    return v.rgx.call(e, n, r.os), e
                }, this.getResult = function() {
                    return {
                        ua: this.getUA(),
                        browser: this.getBrowser(),
                        engine: this.getEngine(),
                        os: this.getOS(),
                        device: this.getDevice(),
                        cpu: this.getCPU()
                    }
                }, this.getUA = function() {
                    return n
                }, this.setUA = function(e) {
                    return n = e, this
                }, this
            };
        y.VERSION = "0.7.17", y.BROWSER = {
            NAME: s,
            MAJOR: "major",
            VERSION: l
        }, y.CPU = {
            ARCHITECTURE: "architecture"
        }, y.DEVICE = {
            MODEL: a,
            VENDOR: u,
            TYPE: c,
            CONSOLE: "console",
            MOBILE: f,
            SMARTTV: "smarttv",
            TABLET: d,
            WEARABLE: "wearable",
            EMBEDDED: "embedded"
        }, y.ENGINE = {
            NAME: s,
            VERSION: l
        }, y.OS = {
            NAME: s,
            VERSION: l
        }, void 0 !== t ? (void 0 !== e && e.exports && (t = e.exports = y), t.UAParser = y) : n(380) ? void 0 === (r = function() {
            return y
        }.call(t, n, t, e)) || (e.exports = r) : i && (i.UAParser = y);
        var g = i && (i.jQuery || i.Zepto);
        if (void 0 !== g) {
            var x = new y;
            g.ua = x.getResult(), g.ua.get = function() {
                return x.getUA()
            }, g.ua.set = function(e) {
                x.setUA(e);
                var t = x.getResult();
                for (var n in t) g.ua[n] = t[n]
            }
        }
    }("object" == typeof window ? window : this)
}, function(e, t, n) {
    n(156);
    var r = n(342).default,
        i = n(343).default,
        o = document.querySelector(".l-page").dataset.id;
    new r;
    if ("index" == o) n(344).default();
    else {
        var a = document.getElementById("canvas-webgl");
        switch (a.addEventListener("contextmenu", (function(e) {
            e.preventDefault()
        })), a.addEventListener("selectstart", (function(e) {
            e.preventDefault()
        })), o) {
            case "skull":
                n(629).default();
                break;
            case "aura":
                n(631).default();
                break;
            case "shadow":
                n(634).default();
                break;
            case "splash":
                n(638).default();
                break;
            case "burn":
                n(632).default();
                break;
            case "crystal":
                n(628).default();
                break;
            case "node":
                n(636).default();
                break;
            case "sun":
                n(630).default();
                break;
            case "easy_glitch":
                n(633).default();
                break;
            case "dissolve":
                n(640).default();
                break;
            case "dna":
                n(639).default();
                break;
            case "newyear2019":
                n(637).default();
                break;
            case "buddha":
                n(635).default();
                break;
            case "planet":
                n(405).default();
                break;
            case "land":
                n(419).default();
                break;
            case "webcam":
                n(427).default();
                break;
            case "fog":
                n(444).default();
                break;
            case "node_text":
                n(448).default();
                break;
            case "repel":
                n(457).default();
                break;
            case "flame":
                n(461).default();
                break;
            case "cyberspace":
                n(475).default();
                break;
            case "beam":
                n(497).default();
                break;
            case "blink":
                n(501).default();
                break;
            case "transform":
                n(505).default();
                break;
            case "egg":
                n(520).default();
                break;
            case "butterfly":
                n(524).default();
                break;
            case "puddle":
                n(539).default();
                break;
            case "reel":
                n(543).default();
                break;
            case "glitch":
                n(559).default();
                break;
            case "instancing":
                n(566).default();
                break;
            case "particle":
                n(577).default();
                break;
            case "attract":
                n(593).default();
                break;
            case "hole":
                n(600).default();
                break;
            case "metal_cube":
                n(613).default();
                break;
            case "distort":
                n(618).default();
                break;
            case "image_data":
                n(623).default();
                break;
            case "gallery":
                n(624).default();
                break;
            case "comet":
                n(625).default();
                break;
            case "hyper_space":
                n(626).default();
                break;
            case "fire_ball":
                n(627).default()
        }
    }
    i()
}, function(e, t, n) {
    "use strict";
    n(157);
    var r, i = (r = n(329)) && r.__esModule ? r : {
        default: r
    };
    i.default._babelPolyfill && "undefined" != typeof console && console.warn && console.warn("@babel/polyfill is loaded more than once on this page. This is probably not desirable/intended and may have consequences if different versions of the polyfills are applied sequentially. If you do need to load the polyfill more than once, use @babel/polyfill/noConflict instead to bypass the warning."), i.default._babelPolyfill = !0
}, function(e, t, n) {
    "use strict";
    n(158), n(301), n(303), n(306), n(308), n(310), n(312), n(314), n(316), n(318), n(320), n(322), n(324), n(328)
}, function(e, t, n) {
    n(159), n(162), n(163), n(164), n(165), n(166), n(167), n(168), n(169), n(170), n(171), n(172), n(173), n(174), n(175), n(176), n(177), n(178), n(179), n(180), n(181), n(182), n(183), n(184), n(185), n(186), n(187), n(188), n(189), n(190), n(191), n(192), n(193), n(194), n(195), n(196), n(197), n(198), n(199), n(200), n(201), n(202), n(203), n(205), n(206), n(207), n(208), n(209), n(210), n(211), n(212), n(213), n(214), n(215), n(216), n(217), n(218), n(219), n(220), n(221), n(222), n(223), n(224), n(225), n(226), n(227), n(228), n(229), n(230), n(231), n(232), n(233), n(234), n(235), n(236), n(237), n(238), n(240), n(241), n(243), n(244), n(245), n(246), n(247), n(248), n(249), n(251), n(252), n(253), n(254), n(255), n(256), n(257), n(258), n(259), n(260), n(261), n(262), n(263), n(96), n(264), n(132), n(265), n(133), n(266), n(267), n(268), n(269), n(134), n(272), n(273), n(274), n(275), n(276), n(277), n(278), n(279), n(280), n(281), n(282), n(283), n(284), n(285), n(286), n(287), n(288), n(289), n(290), n(291), n(292), n(293), n(294), n(295), n(296), n(297), n(298), n(299), n(300), e.exports = n(11)
}, function(e, t, n) {
    "use strict";
    var r = n(5),
        i = n(20),
        o = n(13),
        a = n(2),
        s = n(18),
        c = n(35).KEY,
        u = n(6),
        l = n(58),
        f = n(48),
        d = n(37),
        h = n(9),
        v = n(77),
        p = n(113),
        m = n(161),
        y = n(61),
        g = n(7),
        x = n(8),
        b = n(17),
        w = n(22),
        M = n(34),
        _ = n(36),
        S = n(41),
        P = n(116),
        T = n(27),
        E = n(60),
        z = n(14),
        L = n(39),
        A = T.f,
        C = z.f,
        R = P.f,
        O = r.Symbol,
        j = r.JSON,
        I = j && j.stringify,
        D = h("_hidden"),
        k = h("toPrimitive"),
        F = {}.propertyIsEnumerable,
        G = l("symbol-registry"),
        N = l("symbols"),
        B = l("op-symbols"),
        U = Object.prototype,
        H = "function" == typeof O && !!E.f,
        V = r.QObject,
        W = !V || !V.prototype || !V.prototype.findChild,
        Y = o && u((function() {
            return 7 != S(C({}, "a", {
                get: function() {
                    return C(this, "a", {
                        value: 7
                    }).a
                }
            })).a
        })) ? function(e, t, n) {
            var r = A(U, t);
            r && delete U[t], C(e, t, n), r && e !== U && C(U, t, r)
        } : C,
        X = function(e) {
            var t = N[e] = S(O.prototype);
            return t._k = e, t
        },
        q = H && "symbol" == typeof O.iterator ? function(e) {
            return "symbol" == typeof e
        } : function(e) {
            return e instanceof O
        },
        K = function(e, t, n) {
            return e === U && K(B, t, n), g(e), t = M(t, !0), g(n), i(N, t) ? (n.enumerable ? (i(e, D) && e[D][t] && (e[D][t] = !1), n = S(n, {
                enumerable: _(0, !1)
            })) : (i(e, D) || C(e, D, _(1, {})), e[D][t] = !0), Y(e, t, n)) : C(e, t, n)
        },
        Z = function(e, t) {
            g(e);
            for (var n, r = m(t = w(t)), i = 0, o = r.length; o > i;) K(e, n = r[i++], t[n]);
            return e
        },
        J = function(e) {
            var t = F.call(this, e = M(e, !0));
            return !(this === U && i(N, e) && !i(B, e)) && (!(t || !i(this, e) || !i(N, e) || i(this, D) && this[D][e]) || t)
        },
        Q = function(e, t) {
            if (e = w(e), t = M(t, !0), e !== U || !i(N, t) || i(B, t)) {
                var n = A(e, t);
                return !n || !i(N, t) || i(e, D) && e[D][t] || (n.enumerable = !0), n
            }
        },
        $ = function(e) {
            for (var t, n = R(w(e)), r = [], o = 0; n.length > o;) i(N, t = n[o++]) || t == D || t == c || r.push(t);
            return r
        },
        ee = function(e) {
            for (var t, n = e === U, r = R(n ? B : w(e)), o = [], a = 0; r.length > a;) !i(N, t = r[a++]) || n && !i(U, t) || o.push(N[t]);
            return o
        };
    H || (s((O = function() {
        if (this instanceof O) throw TypeError("Symbol is not a constructor!");
        var e = d(arguments.length > 0 ? arguments[0] : void 0),
            t = function(n) {
                this === U && t.call(B, n), i(this, D) && i(this[D], e) && (this[D][e] = !1), Y(this, e, _(1, n))
            };
        return o && W && Y(U, e, {
            configurable: !0,
            set: t
        }), X(e)
    }).prototype, "toString", (function() {
        return this._k
    })), T.f = Q, z.f = K, n(42).f = P.f = $, n(55).f = J, E.f = ee, o && !n(38) && s(U, "propertyIsEnumerable", J, !0), v.f = function(e) {
        return X(h(e))
    }), a(a.G + a.W + a.F * !H, {
        Symbol: O
    });
    for (var te = "hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","), ne = 0; te.length > ne;) h(te[ne++]);
    for (var re = L(h.store), ie = 0; re.length > ie;) p(re[ie++]);
    a(a.S + a.F * !H, "Symbol", {
        for: function(e) {
            return i(G, e += "") ? G[e] : G[e] = O(e)
        },
        keyFor: function(e) {
            if (!q(e)) throw TypeError(e + " is not a symbol!");
            for (var t in G)
                if (G[t] === e) return t
        },
        useSetter: function() {
            W = !0
        },
        useSimple: function() {
            W = !1
        }
    }), a(a.S + a.F * !H, "Object", {
        create: function(e, t) {
            return void 0 === t ? S(e) : Z(S(e), t)
        },
        defineProperty: K,
        defineProperties: Z,
        getOwnPropertyDescriptor: Q,
        getOwnPropertyNames: $,
        getOwnPropertySymbols: ee
    });
    var oe = u((function() {
        E.f(1)
    }));
    a(a.S + a.F * oe, "Object", {
        getOwnPropertySymbols: function(e) {
            return E.f(b(e))
        }
    }), j && a(a.S + a.F * (!H || u((function() {
        var e = O();
        return "[null]" != I([e]) || "{}" != I({
            a: e
        }) || "{}" != I(Object(e))
    }))), "JSON", {
        stringify: function(e) {
            for (var t, n, r = [e], i = 1; arguments.length > i;) r.push(arguments[i++]);
            if (n = t = r[1], (x(t) || void 0 !== e) && !q(e)) return y(t) || (t = function(e, t) {
                if ("function" == typeof n && (t = n.call(this, e, t)), !q(t)) return t
            }), r[1] = t, I.apply(j, r)
        }
    }), O.prototype[k] || n(21)(O.prototype, k, O.prototype.valueOf), f(O, "Symbol"), f(Math, "Math", !0), f(r.JSON, "JSON", !0)
}, function(e, t, n) {
    e.exports = n(58)("native-function-to-string", Function.toString)
}, function(e, t, n) {
    var r = n(39),
        i = n(60),
        o = n(55);
    e.exports = function(e) {
        var t = r(e),
            n = i.f;
        if (n)
            for (var a, s = n(e), c = o.f, u = 0; s.length > u;) c.call(e, a = s[u++]) && t.push(a);
        return t
    }
}, function(e, t, n) {
    var r = n(2);
    r(r.S, "Object", {
        create: n(41)
    })
}, function(e, t, n) {
    var r = n(2);
    r(r.S + r.F * !n(13), "Object", {
        defineProperty: n(14).f
    })
}, function(e, t, n) {
    var r = n(2);
    r(r.S + r.F * !n(13), "Object", {
        defineProperties: n(115)
    })
}, function(e, t, n) {
    var r = n(22),
        i = n(27).f;
    n(28)("getOwnPropertyDescriptor", (function() {
        return function(e, t) {
            return i(r(e), t)
        }
    }))
}, function(e, t, n) {
    var r = n(17),
        i = n(43);
    n(28)("getPrototypeOf", (function() {
        return function(e) {
            return i(r(e))
        }
    }))
}, function(e, t, n) {
    var r = n(17),
        i = n(39);
    n(28)("keys", (function() {
        return function(e) {
            return i(r(e))
        }
    }))
}, function(e, t, n) {
    n(28)("getOwnPropertyNames", (function() {
        return n(116).f
    }))
}, function(e, t, n) {
    var r = n(8),
        i = n(35).onFreeze;
    n(28)("freeze", (function(e) {
        return function(t) {
            return e && r(t) ? e(i(t)) : t
        }
    }))
}, function(e, t, n) {
    var r = n(8),
        i = n(35).onFreeze;
    n(28)("seal", (function(e) {
        return function(t) {
            return e && r(t) ? e(i(t)) : t
        }
    }))
}, function(e, t, n) {
    var r = n(8),
        i = n(35).onFreeze;
    n(28)("preventExtensions", (function(e) {
        return function(t) {
            return e && r(t) ? e(i(t)) : t
        }
    }))
}, function(e, t, n) {
    var r = n(8);
    n(28)("isFrozen", (function(e) {
        return function(t) {
            return !r(t) || !!e && e(t)
        }
    }))
}, function(e, t, n) {
    var r = n(8);
    n(28)("isSealed", (function(e) {
        return function(t) {
            return !r(t) || !!e && e(t)
        }
    }))
}, function(e, t, n) {
    var r = n(8);
    n(28)("isExtensible", (function(e) {
        return function(t) {
            return !!r(t) && (!e || e(t))
        }
    }))
}, function(e, t, n) {
    var r = n(2);
    r(r.S + r.F, "Object", {
        assign: n(117)
    })
}, function(e, t, n) {
    var r = n(2);
    r(r.S, "Object", {
        is: n(118)
    })
}, function(e, t, n) {
    var r = n(2);
    r(r.S, "Object", {
        setPrototypeOf: n(81).set
    })
}, function(e, t, n) {
    "use strict";
    var r = n(56),
        i = {};
    i[n(9)("toStringTag")] = "z", i + "" != "[object z]" && n(18)(Object.prototype, "toString", (function() {
        return "[object " + r(this) + "]"
    }), !0)
}, function(e, t, n) {
    var r = n(2);
    r(r.P, "Function", {
        bind: n(119)
    })
}, function(e, t, n) {
    var r = n(14).f,
        i = Function.prototype,
        o = /^\s*function ([^ (]*)/;
    "name" in i || n(13) && r(i, "name", {
        configurable: !0,
        get: function() {
            try {
                return ("" + this).match(o)[1]
            } catch (e) {
                return ""
            }
        }
    })
}, function(e, t, n) {
    "use strict";
    var r = n(8),
        i = n(43),
        o = n(9)("hasInstance"),
        a = Function.prototype;
    o in a || n(14).f(a, o, {
        value: function(e) {
            if ("function" != typeof this || !r(e)) return !1;
            if (!r(this.prototype)) return e instanceof this;
            for (; e = i(e);)
                if (this.prototype === e) return !0;
            return !1
        }
    })
}, function(e, t, n) {
    var r = n(2),
        i = n(121);
    r(r.G + r.F * (parseInt != i), {
        parseInt: i
    })
}, function(e, t, n) {
    var r = n(2),
        i = n(122);
    r(r.G + r.F * (parseFloat != i), {
        parseFloat: i
    })
}, function(e, t, n) {
    "use strict";
    var r = n(5),
        i = n(20),
        o = n(30),
        a = n(83),
        s = n(34),
        c = n(6),
        u = n(42).f,
        l = n(27).f,
        f = n(14).f,
        d = n(49).trim,
        h = r.Number,
        v = h,
        p = h.prototype,
        m = "Number" == o(n(41)(p)),
        y = "trim" in String.prototype,
        g = function(e) {
            var t = s(e, !1);
            if ("string" == typeof t && t.length > 2) {
                var n, r, i, o = (t = y ? t.trim() : d(t, 3)).charCodeAt(0);
                if (43 === o || 45 === o) {
                    if (88 === (n = t.charCodeAt(2)) || 120 === n) return NaN
                } else if (48 === o) {
                    switch (t.charCodeAt(1)) {
                        case 66:
                        case 98:
                            r = 2, i = 49;
                            break;
                        case 79:
                        case 111:
                            r = 8, i = 55;
                            break;
                        default:
                            return +t
                    }
                    for (var a, c = t.slice(2), u = 0, l = c.length; u < l; u++)
                        if ((a = c.charCodeAt(u)) < 48 || a > i) return NaN;
                    return parseInt(c, r)
                }
            }
            return +t
        };
    if (!h(" 0o1") || !h("0b1") || h("+0x1")) {
        h = function(e) {
            var t = arguments.length < 1 ? 0 : e,
                n = this;
            return n instanceof h && (m ? c((function() {
                p.valueOf.call(n)
            })) : "Number" != o(n)) ? a(new v(g(t)), n, h) : g(t)
        };
        for (var x, b = n(13) ? u(v) : "MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger".split(","), w = 0; b.length > w; w++) i(v, x = b[w]) && !i(h, x) && f(h, x, l(v, x));
        h.prototype = p, p.constructor = h, n(18)(r, "Number", h)
    }
}, function(e, t, n) {
    "use strict";
    var r = n(2),
        i = n(26),
        o = n(123),
        a = n(84),
        s = 1..toFixed,
        c = Math.floor,
        u = [0, 0, 0, 0, 0, 0],
        l = "Number.toFixed: incorrect invocation!",
        f = function(e, t) {
            for (var n = -1, r = t; ++n < 6;) r += e * u[n], u[n] = r % 1e7, r = c(r / 1e7)
        },
        d = function(e) {
            for (var t = 6, n = 0; --t >= 0;) n += u[t], u[t] = c(n / e), n = n % e * 1e7
        },
        h = function() {
            for (var e = 6, t = ""; --e >= 0;)
                if ("" !== t || 0 === e || 0 !== u[e]) {
                    var n = String(u[e]);
                    t = "" === t ? n : t + a.call("0", 7 - n.length) + n
                }
            return t
        },
        v = function(e, t, n) {
            return 0 === t ? n : t % 2 == 1 ? v(e, t - 1, n * e) : v(e * e, t / 2, n)
        };
    r(r.P + r.F * (!!s && ("0.000" !== 8e-5.toFixed(3) || "1" !== .9.toFixed(0) || "1.25" !== 1.255.toFixed(2) || "1000000000000000128" !== (0xde0b6b3a7640080).toFixed(0)) || !n(6)((function() {
        s.call({})
    }))), "Number", {
        toFixed: function(e) {
            var t, n, r, s, c = o(this, l),
                u = i(e),
                p = "",
                m = "0";
            if (u < 0 || u > 20) throw RangeError(l);
            if (c != c) return "NaN";
            if (c <= -1e21 || c >= 1e21) return String(c);
            if (c < 0 && (p = "-", c = -c), c > 1e-21)
                if (n = (t = function(e) {
                        for (var t = 0, n = e; n >= 4096;) t += 12, n /= 4096;
                        for (; n >= 2;) t += 1, n /= 2;
                        return t
                    }(c * v(2, 69, 1)) - 69) < 0 ? c * v(2, -t, 1) : c / v(2, t, 1), n *= 4503599627370496, (t = 52 - t) > 0) {
                    for (f(0, n), r = u; r >= 7;) f(1e7, 0), r -= 7;
                    for (f(v(10, r, 1), 0), r = t - 1; r >= 23;) d(1 << 23), r -= 23;
                    d(1 << r), f(1, 1), d(2), m = h()
                } else f(0, n), f(1 << -t, 0), m = h() + a.call("0", u);
            return m = u > 0 ? p + ((s = m.length) <= u ? "0." + a.call("0", u - s) + m : m.slice(0, s - u) + "." + m.slice(s - u)) : p + m
        }
    })
}, function(e, t, n) {
    "use strict";
    var r = n(2),
        i = n(6),
        o = n(123),
        a = 1..toPrecision;
    r(r.P + r.F * (i((function() {
        return "1" !== a.call(1, void 0)
    })) || !i((function() {
        a.call({})
    }))), "Number", {
        toPrecision: function(e) {
            var t = o(this, "Number#toPrecision: incorrect invocation!");
            return void 0 === e ? a.call(t) : a.call(t, e)
        }
    })
}, function(e, t, n) {
    var r = n(2);
    r(r.S, "Number", {
        EPSILON: Math.pow(2, -52)
    })
}, function(e, t, n) {
    var r = n(2),
        i = n(5).isFinite;
    r(r.S, "Number", {
        isFinite: function(e) {
            return "number" == typeof e && i(e)
        }
    })
}, function(e, t, n) {
    var r = n(2);
    r(r.S, "Number", {
        isInteger: n(124)
    })
}, function(e, t, n) {
    var r = n(2);
    r(r.S, "Number", {
        isNaN: function(e) {
            return e != e
        }
    })
}, function(e, t, n) {
    var r = n(2),
        i = n(124),
        o = Math.abs;
    r(r.S, "Number", {
        isSafeInteger: function(e) {
            return i(e) && o(e) <= 9007199254740991
        }
    })
}, function(e, t, n) {
    var r = n(2);
    r(r.S, "Number", {
        MAX_SAFE_INTEGER: 9007199254740991
    })
}, function(e, t, n) {
    var r = n(2);
    r(r.S, "Number", {
        MIN_SAFE_INTEGER: -9007199254740991
    })
}, function(e, t, n) {
    var r = n(2),
        i = n(122);
    r(r.S + r.F * (Number.parseFloat != i), "Number", {
        parseFloat: i
    })
}, function(e, t, n) {
    var r = n(2),
        i = n(121);
    r(r.S + r.F * (Number.parseInt != i), "Number", {
        parseInt: i
    })
}, function(e, t, n) {
    var r = n(2),
        i = n(125),
        o = Math.sqrt,
        a = Math.acosh;
    r(r.S + r.F * !(a && 710 == Math.floor(a(Number.MAX_VALUE)) && a(1 / 0) == 1 / 0), "Math", {
        acosh: function(e) {
            return (e = +e) < 1 ? NaN : e > 94906265.62425156 ? Math.log(e) + Math.LN2 : i(e - 1 + o(e - 1) * o(e + 1))
        }
    })
}, function(e, t, n) {
    var r = n(2),
        i = Math.asinh;
    r(r.S + r.F * !(i && 1 / i(0) > 0), "Math", {
        asinh: function e(t) {
            return isFinite(t = +t) && 0 != t ? t < 0 ? -e(-t) : Math.log(t + Math.sqrt(t * t + 1)) : t
        }
    })
}, function(e, t, n) {
    var r = n(2),
        i = Math.atanh;
    r(r.S + r.F * !(i && 1 / i(-0) < 0), "Math", {
        atanh: function(e) {
            return 0 == (e = +e) ? e : Math.log((1 + e) / (1 - e)) / 2
        }
    })
}, function(e, t, n) {
    var r = n(2),
        i = n(85);
    r(r.S, "Math", {
        cbrt: function(e) {
            return i(e = +e) * Math.pow(Math.abs(e), 1 / 3)
        }
    })
}, function(e, t, n) {
    var r = n(2);
    r(r.S, "Math", {
        clz32: function(e) {
            return (e >>>= 0) ? 31 - Math.floor(Math.log(e + .5) * Math.LOG2E) : 32
        }
    })
}, function(e, t, n) {
    var r = n(2),
        i = Math.exp;
    r(r.S, "Math", {
        cosh: function(e) {
            return (i(e = +e) + i(-e)) / 2
        }
    })
}, function(e, t, n) {
    var r = n(2),
        i = n(86);
    r(r.S + r.F * (i != Math.expm1), "Math", {
        expm1: i
    })
}, function(e, t, n) {
    var r = n(2);
    r(r.S, "Math", {
        fround: n(204)
    })
}, function(e, t, n) {
    var r = n(85),
        i = Math.pow,
        o = i(2, -52),
        a = i(2, -23),
        s = i(2, 127) * (2 - a),
        c = i(2, -126);
    e.exports = Math.fround || function(e) {
        var t, n, i = Math.abs(e),
            u = r(e);
        return i < c ? u * (i / c / a + 1 / o - 1 / o) * c * a : (n = (t = (1 + a / o) * i) - (t - i)) > s || n != n ? u * (1 / 0) : u * n
    }
}, function(e, t, n) {
    var r = n(2),
        i = Math.abs;
    r(r.S, "Math", {
        hypot: function(e, t) {
            for (var n, r, o = 0, a = 0, s = arguments.length, c = 0; a < s;) c < (n = i(arguments[a++])) ? (o = o * (r = c / n) * r + 1, c = n) : o += n > 0 ? (r = n / c) * r : n;
            return c === 1 / 0 ? 1 / 0 : c * Math.sqrt(o)
        }
    })
}, function(e, t, n) {
    var r = n(2),
        i = Math.imul;
    r(r.S + r.F * n(6)((function() {
        return -5 != i(4294967295, 5) || 2 != i.length
    })), "Math", {
        imul: function(e, t) {
            var n = +e,
                r = +t,
                i = 65535 & n,
                o = 65535 & r;
            return 0 | i * o + ((65535 & n >>> 16) * o + i * (65535 & r >>> 16) << 16 >>> 0)
        }
    })
}, function(e, t, n) {
    var r = n(2);
    r(r.S, "Math", {
        log10: function(e) {
            return Math.log(e) * Math.LOG10E
        }
    })
}, function(e, t, n) {
    var r = n(2);
    r(r.S, "Math", {
        log1p: n(125)
    })
}, function(e, t, n) {
    var r = n(2);
    r(r.S, "Math", {
        log2: function(e) {
            return Math.log(e) / Math.LN2
        }
    })
}, function(e, t, n) {
    var r = n(2);
    r(r.S, "Math", {
        sign: n(85)
    })
}, function(e, t, n) {
    var r = n(2),
        i = n(86),
        o = Math.exp;
    r(r.S + r.F * n(6)((function() {
        return -2e-17 != !Math.sinh(-2e-17)
    })), "Math", {
        sinh: function(e) {
            return Math.abs(e = +e) < 1 ? (i(e) - i(-e)) / 2 : (o(e - 1) - o(-e - 1)) * (Math.E / 2)
        }
    })
}, function(e, t, n) {
    var r = n(2),
        i = n(86),
        o = Math.exp;
    r(r.S, "Math", {
        tanh: function(e) {
            var t = i(e = +e),
                n = i(-e);
            return t == 1 / 0 ? 1 : n == 1 / 0 ? -1 : (t - n) / (o(e) + o(-e))
        }
    })
}, function(e, t, n) {
    var r = n(2);
    r(r.S, "Math", {
        trunc: function(e) {
            return (e > 0 ? Math.floor : Math.ceil)(e)
        }
    })
}, function(e, t, n) {
    var r = n(2),
        i = n(40),
        o = String.fromCharCode,
        a = String.fromCodePoint;
    r(r.S + r.F * (!!a && 1 != a.length), "String", {
        fromCodePoint: function(e) {
            for (var t, n = [], r = arguments.length, a = 0; r > a;) {
                if (t = +arguments[a++], i(t, 1114111) !== t) throw RangeError(t + " is not a valid code point");
                n.push(t < 65536 ? o(t) : o(55296 + ((t -= 65536) >> 10), t % 1024 + 56320))
            }
            return n.join("")
        }
    })
}, function(e, t, n) {
    var r = n(2),
        i = n(22),
        o = n(10);
    r(r.S, "String", {
        raw: function(e) {
            for (var t = i(e.raw), n = o(t.length), r = arguments.length, a = [], s = 0; n > s;) a.push(String(t[s++])), s < r && a.push(String(arguments[s]));
            return a.join("")
        }
    })
}, function(e, t, n) {
    "use strict";
    n(49)("trim", (function(e) {
        return function() {
            return e(this, 3)
        }
    }))
}, function(e, t, n) {
    "use strict";
    var r = n(87)(!0);
    n(88)(String, "String", (function(e) {
        this._t = String(e), this._i = 0
    }), (function() {
        var e, t = this._t,
            n = this._i;
        return n >= t.length ? {
            value: void 0,
            done: !0
        } : (e = r(t, n), this._i += e.length, {
            value: e,
            done: !1
        })
    }))
}, function(e, t, n) {
    "use strict";
    var r = n(2),
        i = n(87)(!1);
    r(r.P, "String", {
        codePointAt: function(e) {
            return i(this, e)
        }
    })
}, function(e, t, n) {
    "use strict";
    var r = n(2),
        i = n(10),
        o = n(89),
        a = "".endsWith;
    r(r.P + r.F * n(91)("endsWith"), "String", {
        endsWith: function(e) {
            var t = o(this, e, "endsWith"),
                n = arguments.length > 1 ? arguments[1] : void 0,
                r = i(t.length),
                s = void 0 === n ? r : Math.min(i(n), r),
                c = String(e);
            return a ? a.call(t, c, s) : t.slice(s - c.length, s) === c
        }
    })
}, function(e, t, n) {
    "use strict";
    var r = n(2),
        i = n(89);
    r(r.P + r.F * n(91)("includes"), "String", {
        includes: function(e) {
            return !!~i(this, e, "includes").indexOf(e, arguments.length > 1 ? arguments[1] : void 0)
        }
    })
}, function(e, t, n) {
    var r = n(2);
    r(r.P, "String", {
        repeat: n(84)
    })
}, function(e, t, n) {
    "use strict";
    var r = n(2),
        i = n(10),
        o = n(89),
        a = "".startsWith;
    r(r.P + r.F * n(91)("startsWith"), "String", {
        startsWith: function(e) {
            var t = o(this, e, "startsWith"),
                n = i(Math.min(arguments.length > 1 ? arguments[1] : void 0, t.length)),
                r = String(e);
            return a ? a.call(t, r, n) : t.slice(n, n + r.length) === r
        }
    })
}, function(e, t, n) {
    "use strict";
    n(19)("anchor", (function(e) {
        return function(t) {
            return e(this, "a", "name", t)
        }
    }))
}, function(e, t, n) {
    "use strict";
    n(19)("big", (function(e) {
        return function() {
            return e(this, "big", "", "")
        }
    }))
}, function(e, t, n) {
    "use strict";
    n(19)("blink", (function(e) {
        return function() {
            return e(this, "blink", "", "")
        }
    }))
}, function(e, t, n) {
    "use strict";
    n(19)("bold", (function(e) {
        return function() {
            return e(this, "b", "", "")
        }
    }))
}, function(e, t, n) {
    "use strict";
    n(19)("fixed", (function(e) {
        return function() {
            return e(this, "tt", "", "")
        }
    }))
}, function(e, t, n) {
    "use strict";
    n(19)("fontcolor", (function(e) {
        return function(t) {
            return e(this, "font", "color", t)
        }
    }))
}, function(e, t, n) {
    "use strict";
    n(19)("fontsize", (function(e) {
        return function(t) {
            return e(this, "font", "size", t)
        }
    }))
}, function(e, t, n) {
    "use strict";
    n(19)("italics", (function(e) {
        return function() {
            return e(this, "i", "", "")
        }
    }))
}, function(e, t, n) {
    "use strict";
    n(19)("link", (function(e) {
        return function(t) {
            return e(this, "a", "href", t)
        }
    }))
}, function(e, t, n) {
    "use strict";
    n(19)("small", (function(e) {
        return function() {
            return e(this, "small", "", "")
        }
    }))
}, function(e, t, n) {
    "use strict";
    n(19)("strike", (function(e) {
        return function() {
            return e(this, "strike", "", "")
        }
    }))
}, function(e, t, n) {
    "use strict";
    n(19)("sub", (function(e) {
        return function() {
            return e(this, "sub", "", "")
        }
    }))
}, function(e, t, n) {
    "use strict";
    n(19)("sup", (function(e) {
        return function() {
            return e(this, "sup", "", "")
        }
    }))
}, function(e, t, n) {
    var r = n(2);
    r(r.S, "Date", {
        now: function() {
            return (new Date).getTime()
        }
    })
}, function(e, t, n) {
    "use strict";
    var r = n(2),
        i = n(17),
        o = n(34);
    r(r.P + r.F * n(6)((function() {
        return null !== new Date(NaN).toJSON() || 1 !== Date.prototype.toJSON.call({
            toISOString: function() {
                return 1
            }
        })
    })), "Date", {
        toJSON: function(e) {
            var t = i(this),
                n = o(t);
            return "number" != typeof n || isFinite(n) ? t.toISOString() : null
        }
    })
}, function(e, t, n) {
    var r = n(2),
        i = n(239);
    r(r.P + r.F * (Date.prototype.toISOString !== i), "Date", {
        toISOString: i
    })
}, function(e, t, n) {
    "use strict";
    var r = n(6),
        i = Date.prototype.getTime,
        o = Date.prototype.toISOString,
        a = function(e) {
            return e > 9 ? e : "0" + e
        };
    e.exports = r((function() {
        return "0385-07-25T07:06:39.999Z" != o.call(new Date(-5e13 - 1))
    })) || !r((function() {
        o.call(new Date(NaN))
    })) ? function() {
        if (!isFinite(i.call(this))) throw RangeError("Invalid time value");
        var e = this,
            t = e.getUTCFullYear(),
            n = e.getUTCMilliseconds(),
            r = t < 0 ? "-" : t > 9999 ? "+" : "";
        return r + ("00000" + Math.abs(t)).slice(r ? -6 : -4) + "-" + a(e.getUTCMonth() + 1) + "-" + a(e.getUTCDate()) + "T" + a(e.getUTCHours()) + ":" + a(e.getUTCMinutes()) + ":" + a(e.getUTCSeconds()) + "." + (n > 99 ? n : "0" + a(n)) + "Z"
    } : o
}, function(e, t, n) {
    var r = Date.prototype,
        i = r.toString,
        o = r.getTime;
    new Date(NaN) + "" != "Invalid Date" && n(18)(r, "toString", (function() {
        var e = o.call(this);
        return e == e ? i.call(this) : "Invalid Date"
    }))
}, function(e, t, n) {
    var r = n(9)("toPrimitive"),
        i = Date.prototype;
    r in i || n(21)(i, r, n(242))
}, function(e, t, n) {
    "use strict";
    var r = n(7),
        i = n(34);
    e.exports = function(e) {
        if ("string" !== e && "number" !== e && "default" !== e) throw TypeError("Incorrect hint");
        return i(r(this), "number" != e)
    }
}, function(e, t, n) {
    var r = n(2);
    r(r.S, "Array", {
        isArray: n(61)
    })
}, function(e, t, n) {
    "use strict";
    var r = n(24),
        i = n(2),
        o = n(17),
        a = n(127),
        s = n(92),
        c = n(10),
        u = n(93),
        l = n(94);
    i(i.S + i.F * !n(62)((function(e) {
        Array.from(e)
    })), "Array", {
        from: function(e) {
            var t, n, i, f, d = o(e),
                h = "function" == typeof this ? this : Array,
                v = arguments.length,
                p = v > 1 ? arguments[1] : void 0,
                m = void 0 !== p,
                y = 0,
                g = l(d);
            if (m && (p = r(p, v > 2 ? arguments[2] : void 0, 2)), null == g || h == Array && s(g))
                for (n = new h(t = c(d.length)); t > y; y++) u(n, y, m ? p(d[y], y) : d[y]);
            else
                for (f = g.call(d), n = new h; !(i = f.next()).done; y++) u(n, y, m ? a(f, p, [i.value, y], !0) : i.value);
            return n.length = y, n
        }
    })
}, function(e, t, n) {
    "use strict";
    var r = n(2),
        i = n(93);
    r(r.S + r.F * n(6)((function() {
        function e() {}
        return !(Array.of.call(e) instanceof e)
    })), "Array", {
        of: function() {
            for (var e = 0, t = arguments.length, n = new("function" == typeof this ? this : Array)(t); t > e;) i(n, e, arguments[e++]);
            return n.length = t, n
        }
    })
}, function(e, t, n) {
    "use strict";
    var r = n(2),
        i = n(22),
        o = [].join;
    r(r.P + r.F * (n(54) != Object || !n(23)(o)), "Array", {
        join: function(e) {
            return o.call(i(this), void 0 === e ? "," : e)
        }
    })
}, function(e, t, n) {
    "use strict";
    var r = n(2),
        i = n(80),
        o = n(30),
        a = n(40),
        s = n(10),
        c = [].slice;
    r(r.P + r.F * n(6)((function() {
        i && c.call(i)
    })), "Array", {
        slice: function(e, t) {
            var n = s(this.length),
                r = o(this);
            if (t = void 0 === t ? n : t, "Array" == r) return c.call(this, e, t);
            for (var i = a(e, n), u = a(t, n), l = s(u - i), f = new Array(l), d = 0; d < l; d++) f[d] = "String" == r ? this.charAt(i + d) : this[i + d];
            return f
        }
    })
}, function(e, t, n) {
    "use strict";
    var r = n(2),
        i = n(25),
        o = n(17),
        a = n(6),
        s = [].sort,
        c = [1, 2, 3];
    r(r.P + r.F * (a((function() {
        c.sort(void 0)
    })) || !a((function() {
        c.sort(null)
    })) || !n(23)(s)), "Array", {
        sort: function(e) {
            return void 0 === e ? s.call(o(this)) : s.call(o(this), i(e))
        }
    })
}, function(e, t, n) {
    "use strict";
    var r = n(2),
        i = n(29)(0),
        o = n(23)([].forEach, !0);
    r(r.P + r.F * !o, "Array", {
        forEach: function(e) {
            return i(this, e, arguments[1])
        }
    })
}, function(e, t, n) {
    var r = n(8),
        i = n(61),
        o = n(9)("species");
    e.exports = function(e) {
        var t;
        return i(e) && ("function" != typeof(t = e.constructor) || t !== Array && !i(t.prototype) || (t = void 0), r(t) && null === (t = t[o]) && (t = void 0)), void 0 === t ? Array : t
    }
}, function(e, t, n) {
    "use strict";
    var r = n(2),
        i = n(29)(1);
    r(r.P + r.F * !n(23)([].map, !0), "Array", {
        map: function(e) {
            return i(this, e, arguments[1])
        }
    })
}, function(e, t, n) {
    "use strict";
    var r = n(2),
        i = n(29)(2);
    r(r.P + r.F * !n(23)([].filter, !0), "Array", {
        filter: function(e) {
            return i(this, e, arguments[1])
        }
    })
}, function(e, t, n) {
    "use strict";
    var r = n(2),
        i = n(29)(3);
    r(r.P + r.F * !n(23)([].some, !0), "Array", {
        some: function(e) {
            return i(this, e, arguments[1])
        }
    })
}, function(e, t, n) {
    "use strict";
    var r = n(2),
        i = n(29)(4);
    r(r.P + r.F * !n(23)([].every, !0), "Array", {
        every: function(e) {
            return i(this, e, arguments[1])
        }
    })
}, function(e, t, n) {
    "use strict";
    var r = n(2),
        i = n(129);
    r(r.P + r.F * !n(23)([].reduce, !0), "Array", {
        reduce: function(e) {
            return i(this, e, arguments.length, arguments[1], !1)
        }
    })
}, function(e, t, n) {
    "use strict";
    var r = n(2),
        i = n(129);
    r(r.P + r.F * !n(23)([].reduceRight, !0), "Array", {
        reduceRight: function(e) {
            return i(this, e, arguments.length, arguments[1], !0)
        }
    })
}, function(e, t, n) {
    "use strict";
    var r = n(2),
        i = n(59)(!1),
        o = [].indexOf,
        a = !!o && 1 / [1].indexOf(1, -0) < 0;
    r(r.P + r.F * (a || !n(23)(o)), "Array", {
        indexOf: function(e) {
            return a ? o.apply(this, arguments) || 0 : i(this, e, arguments[1])
        }
    })
}, function(e, t, n) {
    "use strict";
    var r = n(2),
        i = n(22),
        o = n(26),
        a = n(10),
        s = [].lastIndexOf,
        c = !!s && 1 / [1].lastIndexOf(1, -0) < 0;
    r(r.P + r.F * (c || !n(23)(s)), "Array", {
        lastIndexOf: function(e) {
            if (c) return s.apply(this, arguments) || 0;
            var t = i(this),
                n = a(t.length),
                r = n - 1;
            for (arguments.length > 1 && (r = Math.min(r, o(arguments[1]))), r < 0 && (r = n + r); r >= 0; r--)
                if (r in t && t[r] === e) return r || 0;
            return -1
        }
    })
}, function(e, t, n) {
    var r = n(2);
    r(r.P, "Array", {
        copyWithin: n(130)
    }), n(44)("copyWithin")
}, function(e, t, n) {
    var r = n(2);
    r(r.P, "Array", {
        fill: n(95)
    }), n(44)("fill")
}, function(e, t, n) {
    "use strict";
    var r = n(2),
        i = n(29)(5),
        o = !0;
    "find" in [] && Array(1).find((function() {
        o = !1
    })), r(r.P + r.F * o, "Array", {
        find: function(e) {
            return i(this, e, arguments.length > 1 ? arguments[1] : void 0)
        }
    }), n(44)("find")
}, function(e, t, n) {
    "use strict";
    var r = n(2),
        i = n(29)(6),
        o = "findIndex",
        a = !0;
    o in [] && Array(1)[o]((function() {
        a = !1
    })), r(r.P + r.F * a, "Array", {
        findIndex: function(e) {
            return i(this, e, arguments.length > 1 ? arguments[1] : void 0)
        }
    }), n(44)(o)
}, function(e, t, n) {
    n(51)("Array")
}, function(e, t, n) {
    var r = n(5),
        i = n(83),
        o = n(14).f,
        a = n(42).f,
        s = n(90),
        c = n(63),
        u = r.RegExp,
        l = u,
        f = u.prototype,
        d = /a/g,
        h = /a/g,
        v = new u(d) !== d;
    if (n(13) && (!v || n(6)((function() {
            return h[n(9)("match")] = !1, u(d) != d || u(h) == h || "/a/i" != u(d, "i")
        })))) {
        u = function(e, t) {
            var n = this instanceof u,
                r = s(e),
                o = void 0 === t;
            return !n && r && e.constructor === u && o ? e : i(v ? new l(r && !o ? e.source : e, t) : l((r = e instanceof u) ? e.source : e, r && o ? c.call(e) : t), n ? this : f, u)
        };
        for (var p = function(e) {
                e in u || o(u, e, {
                    configurable: !0,
                    get: function() {
                        return l[e]
                    },
                    set: function(t) {
                        l[e] = t
                    }
                })
            }, m = a(l), y = 0; m.length > y;) p(m[y++]);
        f.constructor = u, u.prototype = f, n(18)(r, "RegExp", u)
    }
    n(51)("RegExp")
}, function(e, t, n) {
    "use strict";
    n(133);
    var r = n(7),
        i = n(63),
        o = n(13),
        a = /./.toString,
        s = function(e) {
            n(18)(RegExp.prototype, "toString", e, !0)
        };
    n(6)((function() {
        return "/a/b" != a.call({
            source: "a",
            flags: "b"
        })
    })) ? s((function() {
        var e = r(this);
        return "/".concat(e.source, "/", "flags" in e ? e.flags : !o && e instanceof RegExp ? i.call(e) : void 0)
    })) : "toString" != a.name && s((function() {
        return a.call(this)
    }))
}, function(e, t, n) {
    "use strict";
    var r = n(7),
        i = n(10),
        o = n(98),
        a = n(64);
    n(65)("match", 1, (function(e, t, n, s) {
        return [function(n) {
            var r = e(this),
                i = null == n ? void 0 : n[t];
            return void 0 !== i ? i.call(n, r) : new RegExp(n)[t](String(r))
        }, function(e) {
            var t = s(n, e, this);
            if (t.done) return t.value;
            var c = r(e),
                u = String(this);
            if (!c.global) return a(c, u);
            var l = c.unicode;
            c.lastIndex = 0;
            for (var f, d = [], h = 0; null !== (f = a(c, u));) {
                var v = String(f[0]);
                d[h] = v, "" === v && (c.lastIndex = o(u, i(c.lastIndex), l)), h++
            }
            return 0 === h ? null : d
        }]
    }))
}, function(e, t, n) {
    "use strict";
    var r = n(7),
        i = n(17),
        o = n(10),
        a = n(26),
        s = n(98),
        c = n(64),
        u = Math.max,
        l = Math.min,
        f = Math.floor,
        d = /\$([$&`']|\d\d?|<[^>]*>)/g,
        h = /\$([$&`']|\d\d?)/g;
    n(65)("replace", 2, (function(e, t, n, v) {
        return [function(r, i) {
            var o = e(this),
                a = null == r ? void 0 : r[t];
            return void 0 !== a ? a.call(r, o, i) : n.call(String(o), r, i)
        }, function(e, t) {
            var i = v(n, e, this, t);
            if (i.done) return i.value;
            var f = r(e),
                d = String(this),
                h = "function" == typeof t;
            h || (t = String(t));
            var m = f.global;
            if (m) {
                var y = f.unicode;
                f.lastIndex = 0
            }
            for (var g = [];;) {
                var x = c(f, d);
                if (null === x) break;
                if (g.push(x), !m) break;
                "" === String(x[0]) && (f.lastIndex = s(d, o(f.lastIndex), y))
            }
            for (var b, w = "", M = 0, _ = 0; _ < g.length; _++) {
                x = g[_];
                for (var S = String(x[0]), P = u(l(a(x.index), d.length), 0), T = [], E = 1; E < x.length; E++) T.push(void 0 === (b = x[E]) ? b : String(b));
                var z = x.groups;
                if (h) {
                    var L = [S].concat(T, P, d);
                    void 0 !== z && L.push(z);
                    var A = String(t.apply(void 0, L))
                } else A = p(S, d, P, T, z, t);
                P >= M && (w += d.slice(M, P) + A, M = P + S.length)
            }
            return w + d.slice(M)
        }];

        function p(e, t, r, o, a, s) {
            var c = r + e.length,
                u = o.length,
                l = h;
            return void 0 !== a && (a = i(a), l = d), n.call(s, l, (function(n, i) {
                var s;
                switch (i.charAt(0)) {
                    case "$":
                        return "$";
                    case "&":
                        return e;
                    case "`":
                        return t.slice(0, r);
                    case "'":
                        return t.slice(c);
                    case "<":
                        s = a[i.slice(1, -1)];
                        break;
                    default:
                        var l = +i;
                        if (0 === l) return n;
                        if (l > u) {
                            var d = f(l / 10);
                            return 0 === d ? n : d <= u ? void 0 === o[d - 1] ? i.charAt(1) : o[d - 1] + i.charAt(1) : n
                        }
                        s = o[l - 1]
                }
                return void 0 === s ? "" : s
            }))
        }
    }))
}, function(e, t, n) {
    "use strict";
    var r = n(7),
        i = n(118),
        o = n(64);
    n(65)("search", 1, (function(e, t, n, a) {
        return [function(n) {
            var r = e(this),
                i = null == n ? void 0 : n[t];
            return void 0 !== i ? i.call(n, r) : new RegExp(n)[t](String(r))
        }, function(e) {
            var t = a(n, e, this);
            if (t.done) return t.value;
            var s = r(e),
                c = String(this),
                u = s.lastIndex;
            i(u, 0) || (s.lastIndex = 0);
            var l = o(s, c);
            return i(s.lastIndex, u) || (s.lastIndex = u), null === l ? -1 : l.index
        }]
    }))
}, function(e, t, n) {
    "use strict";
    var r = n(90),
        i = n(7),
        o = n(57),
        a = n(98),
        s = n(10),
        c = n(64),
        u = n(97),
        l = n(6),
        f = Math.min,
        d = [].push,
        h = !l((function() {
            RegExp(4294967295, "y")
        }));
    n(65)("split", 2, (function(e, t, n, l) {
        var v;
        return v = "c" == "abbc".split(/(b)*/)[1] || 4 != "test".split(/(?:)/, -1).length || 2 != "ab".split(/(?:ab)*/).length || 4 != ".".split(/(.?)(.?)/).length || ".".split(/()()/).length > 1 || "".split(/.?/).length ? function(e, t) {
            var i = String(this);
            if (void 0 === e && 0 === t) return [];
            if (!r(e)) return n.call(i, e, t);
            for (var o, a, s, c = [], l = (e.ignoreCase ? "i" : "") + (e.multiline ? "m" : "") + (e.unicode ? "u" : "") + (e.sticky ? "y" : ""), f = 0, h = void 0 === t ? 4294967295 : t >>> 0, v = new RegExp(e.source, l + "g");
                (o = u.call(v, i)) && !((a = v.lastIndex) > f && (c.push(i.slice(f, o.index)), o.length > 1 && o.index < i.length && d.apply(c, o.slice(1)), s = o[0].length, f = a, c.length >= h));) v.lastIndex === o.index && v.lastIndex++;
            return f === i.length ? !s && v.test("") || c.push("") : c.push(i.slice(f)), c.length > h ? c.slice(0, h) : c
        } : "0".split(void 0, 0).length ? function(e, t) {
            return void 0 === e && 0 === t ? [] : n.call(this, e, t)
        } : n, [function(n, r) {
            var i = e(this),
                o = null == n ? void 0 : n[t];
            return void 0 !== o ? o.call(n, i, r) : v.call(String(i), n, r)
        }, function(e, t) {
            var r = l(v, e, this, t, v !== n);
            if (r.done) return r.value;
            var u = i(e),
                d = String(this),
                p = o(u, RegExp),
                m = u.unicode,
                y = (u.ignoreCase ? "i" : "") + (u.multiline ? "m" : "") + (u.unicode ? "u" : "") + (h ? "y" : "g"),
                g = new p(h ? u : "^(?:" + u.source + ")", y),
                x = void 0 === t ? 4294967295 : t >>> 0;
            if (0 === x) return [];
            if (0 === d.length) return null === c(g, d) ? [d] : [];
            for (var b = 0, w = 0, M = []; w < d.length;) {
                g.lastIndex = h ? w : 0;
                var _, S = c(g, h ? d : d.slice(w));
                if (null === S || (_ = f(s(g.lastIndex + (h ? 0 : w)), d.length)) === b) w = a(d, w, m);
                else {
                    if (M.push(d.slice(b, w)), M.length === x) return M;
                    for (var P = 1; P <= S.length - 1; P++)
                        if (M.push(S[P]), M.length === x) return M;
                    w = b = _
                }
            }
            return M.push(d.slice(b)), M
        }]
    }))
}, function(e, t, n) {
    var r = n(5),
        i = n(99).set,
        o = r.MutationObserver || r.WebKitMutationObserver,
        a = r.process,
        s = r.Promise,
        c = "process" == n(30)(a);
    e.exports = function() {
        var e, t, n, u = function() {
            var r, i;
            for (c && (r = a.domain) && r.exit(); e;) {
                i = e.fn, e = e.next;
                try {
                    i()
                } catch (r) {
                    throw e ? n() : t = void 0, r
                }
            }
            t = void 0, r && r.enter()
        };
        if (c) n = function() {
            a.nextTick(u)
        };
        else if (!o || r.navigator && r.navigator.standalone)
            if (s && s.resolve) {
                var l = s.resolve(void 0);
                n = function() {
                    l.then(u)
                }
            } else n = function() {
                i.call(r, u)
            };
        else {
            var f = !0,
                d = document.createTextNode("");
            new o(u).observe(d, {
                characterData: !0
            }), n = function() {
                d.data = f = !f
            }
        }
        return function(r) {
            var i = {
                fn: r,
                next: void 0
            };
            t && (t.next = i), e || (e = i, n()), t = i
        }
    }
}, function(e, t) {
    e.exports = function(e) {
        try {
            return {
                e: !1,
                v: e()
            }
        } catch (e) {
            return {
                e: !0,
                v: e
            }
        }
    }
}, function(e, t, n) {
    "use strict";
    var r = n(137),
        i = n(45);
    e.exports = n(68)("Map", (function(e) {
        return function() {
            return e(this, arguments.length > 0 ? arguments[0] : void 0)
        }
    }), {
        get: function(e) {
            var t = r.getEntry(i(this, "Map"), e);
            return t && t.v
        },
        set: function(e, t) {
            return r.def(i(this, "Map"), 0 === e ? 0 : e, t)
        }
    }, r, !0)
}, function(e, t, n) {
    "use strict";
    var r = n(137),
        i = n(45);
    e.exports = n(68)("Set", (function(e) {
        return function() {
            return e(this, arguments.length > 0 ? arguments[0] : void 0)
        }
    }), {
        add: function(e) {
            return r.def(i(this, "Set"), e = 0 === e ? 0 : e, e)
        }
    }, r)
}, function(e, t, n) {
    "use strict";
    var r, i = n(5),
        o = n(29)(0),
        a = n(18),
        s = n(35),
        c = n(117),
        u = n(138),
        l = n(8),
        f = n(45),
        d = n(45),
        h = !i.ActiveXObject && "ActiveXObject" in i,
        v = s.getWeak,
        p = Object.isExtensible,
        m = u.ufstore,
        y = function(e) {
            return function() {
                return e(this, arguments.length > 0 ? arguments[0] : void 0)
            }
        },
        g = {
            get: function(e) {
                if (l(e)) {
                    var t = v(e);
                    return !0 === t ? m(f(this, "WeakMap")).get(e) : t ? t[this._i] : void 0
                }
            },
            set: function(e, t) {
                return u.def(f(this, "WeakMap"), e, t)
            }
        },
        x = e.exports = n(68)("WeakMap", y, g, u, !0, !0);
    d && h && (c((r = u.getConstructor(y, "WeakMap")).prototype, g), s.NEED = !0, o(["delete", "has", "get", "set"], (function(e) {
        var t = x.prototype,
            n = t[e];
        a(t, e, (function(t, i) {
            if (l(t) && !p(t)) {
                this._f || (this._f = new r);
                var o = this._f[e](t, i);
                return "set" == e ? this : o
            }
            return n.call(this, t, i)
        }))
    })))
}, function(e, t, n) {
    "use strict";
    var r = n(138),
        i = n(45);
    n(68)("WeakSet", (function(e) {
        return function() {
            return e(this, arguments.length > 0 ? arguments[0] : void 0)
        }
    }), {
        add: function(e) {
            return r.def(i(this, "WeakSet"), e, !0)
        }
    }, r, !1, !0)
}, function(e, t, n) {
    "use strict";
    var r = n(2),
        i = n(69),
        o = n(100),
        a = n(7),
        s = n(40),
        c = n(10),
        u = n(8),
        l = n(5).ArrayBuffer,
        f = n(57),
        d = o.ArrayBuffer,
        h = o.DataView,
        v = i.ABV && l.isView,
        p = d.prototype.slice,
        m = i.VIEW;
    r(r.G + r.W + r.F * (l !== d), {
        ArrayBuffer: d
    }), r(r.S + r.F * !i.CONSTR, "ArrayBuffer", {
        isView: function(e) {
            return v && v(e) || u(e) && m in e
        }
    }), r(r.P + r.U + r.F * n(6)((function() {
        return !new d(2).slice(1, void 0).byteLength
    })), "ArrayBuffer", {
        slice: function(e, t) {
            if (void 0 !== p && void 0 === t) return p.call(a(this), e);
            for (var n = a(this).byteLength, r = s(e, n), i = s(void 0 === t ? n : t, n), o = new(f(this, d))(c(i - r)), u = new h(this), l = new h(o), v = 0; r < i;) l.setUint8(v++, u.getUint8(r++));
            return o
        }
    }), n(51)("ArrayBuffer")
}, function(e, t, n) {
    var r = n(2);
    r(r.G + r.W + r.F * !n(69).ABV, {
        DataView: n(100).DataView
    })
}, function(e, t, n) {
    n(32)("Int8", 1, (function(e) {
        return function(t, n, r) {
            return e(this, t, n, r)
        }
    }))
}, function(e, t, n) {
    n(32)("Uint8", 1, (function(e) {
        return function(t, n, r) {
            return e(this, t, n, r)
        }
    }))
}, function(e, t, n) {
    n(32)("Uint8", 1, (function(e) {
        return function(t, n, r) {
            return e(this, t, n, r)
        }
    }), !0)
}, function(e, t, n) {
    n(32)("Int16", 2, (function(e) {
        return function(t, n, r) {
            return e(this, t, n, r)
        }
    }))
}, function(e, t, n) {
    n(32)("Uint16", 2, (function(e) {
        return function(t, n, r) {
            return e(this, t, n, r)
        }
    }))
}, function(e, t, n) {
    n(32)("Int32", 4, (function(e) {
        return function(t, n, r) {
            return e(this, t, n, r)
        }
    }))
}, function(e, t, n) {
    n(32)("Uint32", 4, (function(e) {
        return function(t, n, r) {
            return e(this, t, n, r)
        }
    }))
}, function(e, t, n) {
    n(32)("Float32", 4, (function(e) {
        return function(t, n, r) {
            return e(this, t, n, r)
        }
    }))
}, function(e, t, n) {
    n(32)("Float64", 8, (function(e) {
        return function(t, n, r) {
            return e(this, t, n, r)
        }
    }))
}, function(e, t, n) {
    var r = n(2),
        i = n(25),
        o = n(7),
        a = (n(5).Reflect || {}).apply,
        s = Function.apply;
    r(r.S + r.F * !n(6)((function() {
        a((function() {}))
    })), "Reflect", {
        apply: function(e, t, n) {
            var r = i(e),
                c = o(n);
            return a ? a(r, t, c) : s.call(r, t, c)
        }
    })
}, function(e, t, n) {
    var r = n(2),
        i = n(41),
        o = n(25),
        a = n(7),
        s = n(8),
        c = n(6),
        u = n(119),
        l = (n(5).Reflect || {}).construct,
        f = c((function() {
            function e() {}
            return !(l((function() {}), [], e) instanceof e)
        })),
        d = !c((function() {
            l((function() {}))
        }));
    r(r.S + r.F * (f || d), "Reflect", {
        construct: function(e, t) {
            o(e), a(t);
            var n = arguments.length < 3 ? e : o(arguments[2]);
            if (d && !f) return l(e, t, n);
            if (e == n) {
                switch (t.length) {
                    case 0:
                        return new e;
                    case 1:
                        return new e(t[0]);
                    case 2:
                        return new e(t[0], t[1]);
                    case 3:
                        return new e(t[0], t[1], t[2]);
                    case 4:
                        return new e(t[0], t[1], t[2], t[3])
                }
                var r = [null];
                return r.push.apply(r, t), new(u.apply(e, r))
            }
            var c = n.prototype,
                h = i(s(c) ? c : Object.prototype),
                v = Function.apply.call(e, h, t);
            return s(v) ? v : h
        }
    })
}, function(e, t, n) {
    var r = n(14),
        i = n(2),
        o = n(7),
        a = n(34);
    i(i.S + i.F * n(6)((function() {
        Reflect.defineProperty(r.f({}, 1, {
            value: 1
        }), 1, {
            value: 2
        })
    })), "Reflect", {
        defineProperty: function(e, t, n) {
            o(e), t = a(t, !0), o(n);
            try {
                return r.f(e, t, n), !0
            } catch (e) {
                return !1
            }
        }
    })
}, function(e, t, n) {
    var r = n(2),
        i = n(27).f,
        o = n(7);
    r(r.S, "Reflect", {
        deleteProperty: function(e, t) {
            var n = i(o(e), t);
            return !(n && !n.configurable) && delete e[t]
        }
    })
}, function(e, t, n) {
    "use strict";
    var r = n(2),
        i = n(7),
        o = function(e) {
            this._t = i(e), this._i = 0;
            var t, n = this._k = [];
            for (t in e) n.push(t)
        };
    n(126)(o, "Object", (function() {
        var e, t = this._k;
        do {
            if (this._i >= t.length) return {
                value: void 0,
                done: !0
            }
        } while (!((e = t[this._i++]) in this._t));
        return {
            value: e,
            done: !1
        }
    })), r(r.S, "Reflect", {
        enumerate: function(e) {
            return new o(e)
        }
    })
}, function(e, t, n) {
    var r = n(27),
        i = n(43),
        o = n(20),
        a = n(2),
        s = n(8),
        c = n(7);
    a(a.S, "Reflect", {
        get: function e(t, n) {
            var a, u, l = arguments.length < 3 ? t : arguments[2];
            return c(t) === l ? t[n] : (a = r.f(t, n)) ? o(a, "value") ? a.value : void 0 !== a.get ? a.get.call(l) : void 0 : s(u = i(t)) ? e(u, n, l) : void 0
        }
    })
}, function(e, t, n) {
    var r = n(27),
        i = n(2),
        o = n(7);
    i(i.S, "Reflect", {
        getOwnPropertyDescriptor: function(e, t) {
            return r.f(o(e), t)
        }
    })
}, function(e, t, n) {
    var r = n(2),
        i = n(43),
        o = n(7);
    r(r.S, "Reflect", {
        getPrototypeOf: function(e) {
            return i(o(e))
        }
    })
}, function(e, t, n) {
    var r = n(2);
    r(r.S, "Reflect", {
        has: function(e, t) {
            return t in e
        }
    })
}, function(e, t, n) {
    var r = n(2),
        i = n(7),
        o = Object.isExtensible;
    r(r.S, "Reflect", {
        isExtensible: function(e) {
            return i(e), !o || o(e)
        }
    })
}, function(e, t, n) {
    var r = n(2);
    r(r.S, "Reflect", {
        ownKeys: n(140)
    })
}, function(e, t, n) {
    var r = n(2),
        i = n(7),
        o = Object.preventExtensions;
    r(r.S, "Reflect", {
        preventExtensions: function(e) {
            i(e);
            try {
                return o && o(e), !0
            } catch (e) {
                return !1
            }
        }
    })
}, function(e, t, n) {
    var r = n(14),
        i = n(27),
        o = n(43),
        a = n(20),
        s = n(2),
        c = n(36),
        u = n(7),
        l = n(8);
    s(s.S, "Reflect", {
        set: function e(t, n, s) {
            var f, d, h = arguments.length < 4 ? t : arguments[3],
                v = i.f(u(t), n);
            if (!v) {
                if (l(d = o(t))) return e(d, n, s, h);
                v = c(0)
            }
            if (a(v, "value")) {
                if (!1 === v.writable || !l(h)) return !1;
                if (f = i.f(h, n)) {
                    if (f.get || f.set || !1 === f.writable) return !1;
                    f.value = s, r.f(h, n, f)
                } else r.f(h, n, c(0, s));
                return !0
            }
            return void 0 !== v.set && (v.set.call(h, s), !0)
        }
    })
}, function(e, t, n) {
    var r = n(2),
        i = n(81);
    i && r(r.S, "Reflect", {
        setPrototypeOf: function(e, t) {
            i.check(e, t);
            try {
                return i.set(e, t), !0
            } catch (e) {
                return !1
            }
        }
    })
}, function(e, t, n) {
    n(302), e.exports = n(11).Array.includes
}, function(e, t, n) {
    "use strict";
    var r = n(2),
        i = n(59)(!0);
    r(r.P, "Array", {
        includes: function(e) {
            return i(this, e, arguments.length > 1 ? arguments[1] : void 0)
        }
    }), n(44)("includes")
}, function(e, t, n) {
    n(304), e.exports = n(11).Array.flatMap
}, function(e, t, n) {
    "use strict";
    var r = n(2),
        i = n(305),
        o = n(17),
        a = n(10),
        s = n(25),
        c = n(128);
    r(r.P, "Array", {
        flatMap: function(e) {
            var t, n, r = o(this);
            return s(e), t = a(r.length), n = c(r, 0), i(n, r, r, t, 0, 1, e, arguments[1]), n
        }
    }), n(44)("flatMap")
}, function(e, t, n) {
    "use strict";
    var r = n(61),
        i = n(8),
        o = n(10),
        a = n(24),
        s = n(9)("isConcatSpreadable");
    e.exports = function e(t, n, c, u, l, f, d, h) {
        for (var v, p, m = l, y = 0, g = !!d && a(d, h, 3); y < u;) {
            if (y in c) {
                if (v = g ? g(c[y], y, n) : c[y], p = !1, i(v) && (p = void 0 !== (p = v[s]) ? !!p : r(v)), p && f > 0) m = e(t, n, v, o(v.length), m, f - 1) - 1;
                else {
                    if (m >= 9007199254740991) throw TypeError();
                    t[m] = v
                }
                m++
            }
            y++
        }
        return m
    }
}, function(e, t, n) {
    n(307), e.exports = n(11).String.padStart
}, function(e, t, n) {
    "use strict";
    var r = n(2),
        i = n(141),
        o = n(67),
        a = /Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(o);
    r(r.P + r.F * a, "String", {
        padStart: function(e) {
            return i(this, e, arguments.length > 1 ? arguments[1] : void 0, !0)
        }
    })
}, function(e, t, n) {
    n(309), e.exports = n(11).String.padEnd
}, function(e, t, n) {
    "use strict";
    var r = n(2),
        i = n(141),
        o = n(67),
        a = /Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(o);
    r(r.P + r.F * a, "String", {
        padEnd: function(e) {
            return i(this, e, arguments.length > 1 ? arguments[1] : void 0, !1)
        }
    })
}, function(e, t, n) {
    n(311), e.exports = n(11).String.trimLeft
}, function(e, t, n) {
    "use strict";
    n(49)("trimLeft", (function(e) {
        return function() {
            return e(this, 1)
        }
    }), "trimStart")
}, function(e, t, n) {
    n(313), e.exports = n(11).String.trimRight
}, function(e, t, n) {
    "use strict";
    n(49)("trimRight", (function(e) {
        return function() {
            return e(this, 2)
        }
    }), "trimEnd")
}, function(e, t, n) {
    n(315), e.exports = n(77).f("asyncIterator")
}, function(e, t, n) {
    n(113)("asyncIterator")
}, function(e, t, n) {
    n(317), e.exports = n(11).Object.getOwnPropertyDescriptors
}, function(e, t, n) {
    var r = n(2),
        i = n(140),
        o = n(22),
        a = n(27),
        s = n(93);
    r(r.S, "Object", {
        getOwnPropertyDescriptors: function(e) {
            for (var t, n, r = o(e), c = a.f, u = i(r), l = {}, f = 0; u.length > f;) void 0 !== (n = c(r, t = u[f++])) && s(l, t, n);
            return l
        }
    })
}, function(e, t, n) {
    n(319), e.exports = n(11).Object.values
}, function(e, t, n) {
    var r = n(2),
        i = n(142)(!1);
    r(r.S, "Object", {
        values: function(e) {
            return i(e)
        }
    })
}, function(e, t, n) {
    n(321), e.exports = n(11).Object.entries
}, function(e, t, n) {
    var r = n(2),
        i = n(142)(!0);
    r(r.S, "Object", {
        entries: function(e) {
            return i(e)
        }
    })
}, function(e, t, n) {
    "use strict";
    n(134), n(323), e.exports = n(11).Promise.finally
}, function(e, t, n) {
    "use strict";
    var r = n(2),
        i = n(11),
        o = n(5),
        a = n(57),
        s = n(136);
    r(r.P + r.R, "Promise", {
        finally: function(e) {
            var t = a(this, i.Promise || o.Promise),
                n = "function" == typeof e;
            return this.then(n ? function(n) {
                return s(t, e()).then((function() {
                    return n
                }))
            } : e, n ? function(n) {
                return s(t, e()).then((function() {
                    throw n
                }))
            } : e)
        }
    })
}, function(e, t, n) {
    n(325), n(326), n(327), e.exports = n(11)
}, function(e, t, n) {
    var r = n(5),
        i = n(2),
        o = n(67),
        a = [].slice,
        s = /MSIE .\./.test(o),
        c = function(e) {
            return function(t, n) {
                var r = arguments.length > 2,
                    i = !!r && a.call(arguments, 2);
                return e(r ? function() {
                    ("function" == typeof t ? t : Function(t)).apply(this, i)
                } : t, n)
            }
        };
    i(i.G + i.B + i.F * s, {
        setTimeout: c(r.setTimeout),
        setInterval: c(r.setInterval)
    })
}, function(e, t, n) {
    var r = n(2),
        i = n(99);
    r(r.G + r.B, {
        setImmediate: i.set,
        clearImmediate: i.clear
    })
}, function(e, t, n) {
    for (var r = n(96), i = n(39), o = n(18), a = n(5), s = n(21), c = n(50), u = n(9), l = u("iterator"), f = u("toStringTag"), d = c.Array, h = {
            CSSRuleList: !0,
            CSSStyleDeclaration: !1,
            CSSValueList: !1,
            ClientRectList: !1,
            DOMRectList: !1,
            DOMStringList: !1,
            DOMTokenList: !0,
            DataTransferItemList: !1,
            FileList: !1,
            HTMLAllCollection: !1,
            HTMLCollection: !1,
            HTMLFormElement: !1,
            HTMLSelectElement: !1,
            MediaList: !0,
            MimeTypeArray: !1,
            NamedNodeMap: !1,
            NodeList: !0,
            PaintRequestList: !1,
            Plugin: !1,
            PluginArray: !1,
            SVGLengthList: !1,
            SVGNumberList: !1,
            SVGPathSegList: !1,
            SVGPointList: !1,
            SVGStringList: !1,
            SVGTransformList: !1,
            SourceBufferList: !1,
            StyleSheetList: !0,
            TextTrackCueList: !1,
            TextTrackList: !1,
            TouchList: !1
        }, v = i(h), p = 0; p < v.length; p++) {
        var m, y = v[p],
            g = h[y],
            x = a[y],
            b = x && x.prototype;
        if (b && (b[l] || s(b, l, d), b[f] || s(b, f, y), c[y] = d, g))
            for (m in r) b[m] || o(b, m, r[m], !0)
    }
}, function(e, t, n) {
    var r = function(e) {
        "use strict";
        var t, n = Object.prototype,
            r = n.hasOwnProperty,
            i = "function" == typeof Symbol ? Symbol : {},
            o = i.iterator || "@@iterator",
            a = i.asyncIterator || "@@asyncIterator",
            s = i.toStringTag || "@@toStringTag";

        function c(e, t, n, r) {
            var i = t && t.prototype instanceof p ? t : p,
                o = Object.create(i.prototype),
                a = new E(r || []);
            return o._invoke = function(e, t, n) {
                var r = l;
                return function(i, o) {
                    if (r === d) throw new Error("Generator is already running");
                    if (r === h) {
                        if ("throw" === i) throw o;
                        return L()
                    }
                    for (n.method = i, n.arg = o;;) {
                        var a = n.delegate;
                        if (a) {
                            var s = S(a, n);
                            if (s) {
                                if (s === v) continue;
                                return s
                            }
                        }
                        if ("next" === n.method) n.sent = n._sent = n.arg;
                        else if ("throw" === n.method) {
                            if (r === l) throw r = h, n.arg;
                            n.dispatchException(n.arg)
                        } else "return" === n.method && n.abrupt("return", n.arg);
                        r = d;
                        var c = u(e, t, n);
                        if ("normal" === c.type) {
                            if (r = n.done ? h : f, c.arg === v) continue;
                            return {
                                value: c.arg,
                                done: n.done
                            }
                        }
                        "throw" === c.type && (r = h, n.method = "throw", n.arg = c.arg)
                    }
                }
            }(e, n, a), o
        }

        function u(e, t, n) {
            try {
                return {
                    type: "normal",
                    arg: e.call(t, n)
                }
            } catch (e) {
                return {
                    type: "throw",
                    arg: e
                }
            }
        }
        e.wrap = c;
        var l = "suspendedStart",
            f = "suspendedYield",
            d = "executing",
            h = "completed",
            v = {};

        function p() {}

        function m() {}

        function y() {}
        var g = {};
        g[o] = function() {
            return this
        };
        var x = Object.getPrototypeOf,
            b = x && x(x(z([])));
        b && b !== n && r.call(b, o) && (g = b);
        var w = y.prototype = p.prototype = Object.create(g);

        function M(e) {
            ["next", "throw", "return"].forEach((function(t) {
                e[t] = function(e) {
                    return this._invoke(t, e)
                }
            }))
        }

        function _(e) {
            var t;
            this._invoke = function(n, i) {
                function o() {
                    return new Promise((function(t, o) {
                        ! function t(n, i, o, a) {
                            var s = u(e[n], e, i);
                            if ("throw" !== s.type) {
                                var c = s.arg,
                                    l = c.value;
                                return l && "object" == typeof l && r.call(l, "__await") ? Promise.resolve(l.__await).then((function(e) {
                                    t("next", e, o, a)
                                }), (function(e) {
                                    t("throw", e, o, a)
                                })) : Promise.resolve(l).then((function(e) {
                                    c.value = e, o(c)
                                }), (function(e) {
                                    return t("throw", e, o, a)
                                }))
                            }
                            a(s.arg)
                        }(n, i, t, o)
                    }))
                }
                return t = t ? t.then(o, o) : o()
            }
        }

        function S(e, n) {
            var r = e.iterator[n.method];
            if (r === t) {
                if (n.delegate = null, "throw" === n.method) {
                    if (e.iterator.return && (n.method = "return", n.arg = t, S(e, n), "throw" === n.method)) return v;
                    n.method = "throw", n.arg = new TypeError("The iterator does not provide a 'throw' method")
                }
                return v
            }
            var i = u(r, e.iterator, n.arg);
            if ("throw" === i.type) return n.method = "throw", n.arg = i.arg, n.delegate = null, v;
            var o = i.arg;
            return o ? o.done ? (n[e.resultName] = o.value, n.next = e.nextLoc, "return" !== n.method && (n.method = "next", n.arg = t), n.delegate = null, v) : o : (n.method = "throw", n.arg = new TypeError("iterator result is not an object"), n.delegate = null, v)
        }

        function P(e) {
            var t = {
                tryLoc: e[0]
            };
            1 in e && (t.catchLoc = e[1]), 2 in e && (t.finallyLoc = e[2], t.afterLoc = e[3]), this.tryEntries.push(t)
        }

        function T(e) {
            var t = e.completion || {};
            t.type = "normal", delete t.arg, e.completion = t
        }

        function E(e) {
            this.tryEntries = [{
                tryLoc: "root"
            }], e.forEach(P, this), this.reset(!0)
        }

        function z(e) {
            if (e) {
                var n = e[o];
                if (n) return n.call(e);
                if ("function" == typeof e.next) return e;
                if (!isNaN(e.length)) {
                    var i = -1,
                        a = function n() {
                            for (; ++i < e.length;)
                                if (r.call(e, i)) return n.value = e[i], n.done = !1, n;
                            return n.value = t, n.done = !0, n
                        };
                    return a.next = a
                }
            }
            return {
                next: L
            }
        }

        function L() {
            return {
                value: t,
                done: !0
            }
        }
        return m.prototype = w.constructor = y, y.constructor = m, y[s] = m.displayName = "GeneratorFunction", e.isGeneratorFunction = function(e) {
            var t = "function" == typeof e && e.constructor;
            return !!t && (t === m || "GeneratorFunction" === (t.displayName || t.name))
        }, e.mark = function(e) {
            return Object.setPrototypeOf ? Object.setPrototypeOf(e, y) : (e.__proto__ = y, s in e || (e[s] = "GeneratorFunction")), e.prototype = Object.create(w), e
        }, e.awrap = function(e) {
            return {
                __await: e
            }
        }, M(_.prototype), _.prototype[a] = function() {
            return this
        }, e.AsyncIterator = _, e.async = function(t, n, r, i) {
            var o = new _(c(t, n, r, i));
            return e.isGeneratorFunction(n) ? o : o.next().then((function(e) {
                return e.done ? e.value : o.next()
            }))
        }, M(w), w[s] = "Generator", w[o] = function() {
            return this
        }, w.toString = function() {
            return "[object Generator]"
        }, e.keys = function(e) {
            var t = [];
            for (var n in e) t.push(n);
            return t.reverse(),
                function n() {
                    for (; t.length;) {
                        var r = t.pop();
                        if (r in e) return n.value = r, n.done = !1, n
                    }
                    return n.done = !0, n
                }
        }, e.values = z, E.prototype = {
            constructor: E,
            reset: function(e) {
                if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(T), !e)
                    for (var n in this) "t" === n.charAt(0) && r.call(this, n) && !isNaN(+n.slice(1)) && (this[n] = t)
            },
            stop: function() {
                this.done = !0;
                var e = this.tryEntries[0].completion;
                if ("throw" === e.type) throw e.arg;
                return this.rval
            },
            dispatchException: function(e) {
                if (this.done) throw e;
                var n = this;

                function i(r, i) {
                    return s.type = "throw", s.arg = e, n.next = r, i && (n.method = "next", n.arg = t), !!i
                }
                for (var o = this.tryEntries.length - 1; o >= 0; --o) {
                    var a = this.tryEntries[o],
                        s = a.completion;
                    if ("root" === a.tryLoc) return i("end");
                    if (a.tryLoc <= this.prev) {
                        var c = r.call(a, "catchLoc"),
                            u = r.call(a, "finallyLoc");
                        if (c && u) {
                            if (this.prev < a.catchLoc) return i(a.catchLoc, !0);
                            if (this.prev < a.finallyLoc) return i(a.finallyLoc)
                        } else if (c) {
                            if (this.prev < a.catchLoc) return i(a.catchLoc, !0)
                        } else {
                            if (!u) throw new Error("try statement without catch or finally");
                            if (this.prev < a.finallyLoc) return i(a.finallyLoc)
                        }
                    }
                }
            },
            abrupt: function(e, t) {
                for (var n = this.tryEntries.length - 1; n >= 0; --n) {
                    var i = this.tryEntries[n];
                    if (i.tryLoc <= this.prev && r.call(i, "finallyLoc") && this.prev < i.finallyLoc) {
                        var o = i;
                        break
                    }
                }
                o && ("break" === e || "continue" === e) && o.tryLoc <= t && t <= o.finallyLoc && (o = null);
                var a = o ? o.completion : {};
                return a.type = e, a.arg = t, o ? (this.method = "next", this.next = o.finallyLoc, v) : this.complete(a)
            },
            complete: function(e, t) {
                if ("throw" === e.type) throw e.arg;
                return "break" === e.type || "continue" === e.type ? this.next = e.arg : "return" === e.type ? (this.rval = this.arg = e.arg, this.method = "return", this.next = "end") : "normal" === e.type && t && (this.next = t), v
            },
            finish: function(e) {
                for (var t = this.tryEntries.length - 1; t >= 0; --t) {
                    var n = this.tryEntries[t];
                    if (n.finallyLoc === e) return this.complete(n.completion, n.afterLoc), T(n), v
                }
            },
            catch: function(e) {
                for (var t = this.tryEntries.length - 1; t >= 0; --t) {
                    var n = this.tryEntries[t];
                    if (n.tryLoc === e) {
                        var r = n.completion;
                        if ("throw" === r.type) {
                            var i = r.arg;
                            T(n)
                        }
                        return i
                    }
                }
                throw new Error("illegal catch attempt")
            },
            delegateYield: function(e, n, r) {
                return this.delegate = {
                    iterator: z(e),
                    resultName: n,
                    nextLoc: r
                }, "next" === this.method && (this.arg = t), v
            }
        }, e
    }(e.exports);
    try {
        regeneratorRuntime = r
    } catch (e) {
        Function("r", "regeneratorRuntime = r")(r)
    }
}, function(e, t, n) {
    n(330), e.exports = n(143).global
}, function(e, t, n) {
    var r = n(331);
    r(r.G, {
        global: n(101)
    })
}, function(e, t, n) {
    var r = n(101),
        i = n(143),
        o = n(332),
        a = n(334),
        s = n(341),
        c = function(e, t, n) {
            var u, l, f, d = e & c.F,
                h = e & c.G,
                v = e & c.S,
                p = e & c.P,
                m = e & c.B,
                y = e & c.W,
                g = h ? i : i[t] || (i[t] = {}),
                x = g.prototype,
                b = h ? r : v ? r[t] : (r[t] || {}).prototype;
            for (u in h && (n = t), n)(l = !d && b && void 0 !== b[u]) && s(g, u) || (f = l ? b[u] : n[u], g[u] = h && "function" != typeof b[u] ? n[u] : m && l ? o(f, r) : y && b[u] == f ? function(e) {
                var t = function(t, n, r) {
                    if (this instanceof e) {
                        switch (arguments.length) {
                            case 0:
                                return new e;
                            case 1:
                                return new e(t);
                            case 2:
                                return new e(t, n)
                        }
                        return new e(t, n, r)
                    }
                    return e.apply(this, arguments)
                };
                return t.prototype = e.prototype, t
            }(f) : p && "function" == typeof f ? o(Function.call, f) : f, p && ((g.virtual || (g.virtual = {}))[u] = f, e & c.R && x && !x[u] && a(x, u, f)))
        };
    c.F = 1, c.G = 2, c.S = 4, c.P = 8, c.B = 16, c.W = 32, c.U = 64, c.R = 128, e.exports = c
}, function(e, t, n) {
    var r = n(333);
    e.exports = function(e, t, n) {
        if (r(e), void 0 === t) return e;
        switch (n) {
            case 1:
                return function(n) {
                    return e.call(t, n)
                };
            case 2:
                return function(n, r) {
                    return e.call(t, n, r)
                };
            case 3:
                return function(n, r, i) {
                    return e.call(t, n, r, i)
                }
        }
        return function() {
            return e.apply(t, arguments)
        }
    }
}, function(e, t) {
    e.exports = function(e) {
        if ("function" != typeof e) throw TypeError(e + " is not a function!");
        return e
    }
}, function(e, t, n) {
    var r = n(335),
        i = n(340);
    e.exports = n(103) ? function(e, t, n) {
        return r.f(e, t, i(1, n))
    } : function(e, t, n) {
        return e[t] = n, e
    }
}, function(e, t, n) {
    var r = n(336),
        i = n(337),
        o = n(339),
        a = Object.defineProperty;
    t.f = n(103) ? Object.defineProperty : function(e, t, n) {
        if (r(e), t = o(t, !0), r(n), i) try {
            return a(e, t, n)
        } catch (e) {}
        if ("get" in n || "set" in n) throw TypeError("Accessors not supported!");
        return "value" in n && (e[t] = n.value), e
    }
}, function(e, t, n) {
    var r = n(102);
    e.exports = function(e) {
        if (!r(e)) throw TypeError(e + " is not an object!");
        return e
    }
}, function(e, t, n) {
    e.exports = !n(103) && !n(144)((function() {
        return 7 != Object.defineProperty(n(338)("div"), "a", {
            get: function() {
                return 7
            }
        }).a
    }))
}, function(e, t, n) {
    var r = n(102),
        i = n(101).document,
        o = r(i) && r(i.createElement);
    e.exports = function(e) {
        return o ? i.createElement(e) : {}
    }
}, function(e, t, n) {
    var r = n(102);
    e.exports = function(e, t) {
        if (!r(e)) return e;
        var n, i;
        if (t && "function" == typeof(n = e.toString) && !r(i = n.call(e))) return i;
        if ("function" == typeof(n = e.valueOf) && !r(i = n.call(e))) return i;
        if (!t && "function" == typeof(n = e.toString) && !r(i = n.call(e))) return i;
        throw TypeError("Can't convert object to primitive value")
    }
}, function(e, t) {
    e.exports = function(e, t) {
        return {
            enumerable: !(1 & e),
            configurable: !(2 & e),
            writable: !(4 & e),
            value: t
        }
    }
}, function(e, t) {
    var n = {}.hasOwnProperty;
    e.exports = function(e, t) {
        return n.call(e, t)
    }
}, function(e, t, n) {
    "use strict";

    function r(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }
    n.r(t), n.d(t, "default", (function() {
        return i
    }));
    var i = function() {
        function e() {
            ! function(e, t) {
                if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
            }(this, e), this.message = "created by yoichi kobayashi", this.url = "http://www.tplh.net", this.show()
        }
        var t, n, i;
        return t = e, (n = [{
            key: "show",
            value: function() {
                if (navigator.userAgent.toLowerCase().indexOf("chrome") > -1) {
                    var e = ["%c ".concat(this.message, " %c ").concat(this.url), "color: #fff; background: #47c; padding:3px 0;", "padding:3px 1px;"];
                    console.log.apply(console, e)
                } else window.console && console.log("".concat(this.message, " ").concat(this.url))
            }
        }]) && r(t.prototype, n), i && r(t, i), e
    }()
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = function() {
        for (var e = decodeURIComponent(location.search.substring(1)).split("&"), t = 0; t < e.length; t++)
            if (!(e[t].indexOf("sketch_id") < 0)) {
                var n = e[t].replace("sketch_id=", "");
                switch (n = parseInt(n, 10)) {
                    case 9:
                        location.href = "/sketch-threejs/sketch/attract.html";
                        break;
                    case 8:
                        location.href = "/sketch-threejs/sketch/hole.html";
                        break;
                    case 7:
                        location.href = "/sketch-threejs/sketch/metal_cube.html";
                        break;
                    case 6:
                        location.href = "/sketch-threejs/sketch/distort.html";
                        break;
                    case 5:
                        location.href = "/sketch-threejs/sketch/image_data.html";
                        break;
                    case 4:
                        location.href = "/sketch-threejs/sketch/gallery.html";
                        break;
                    case 3:
                        location.href = "/sketch-threejs/sketch/comet.html";
                        break;
                    case 2:
                        location.href = "/sketch-threejs/sketch/hyper_space.html";
                        break;
                    case 1:
                        location.href = "/sketch-threejs/sketch/fire_ball.html"
                }
            }
    }
}, function(e, t, n) {
    "use strict";
    n.r(t);
    var r = n(0),
        i = n(3),
        o = n(345).default,
        a = n(352).default,
        s = n(355).default,
        c = n(358).default,
        u = n(361).default,
        l = n(364).default,
        f = n(367).default,
        d = n(370).default;
    t.default = function() {
        var e = new o,
            t = document.getElementById("canvas-webgl"),
            n = new r.WebGLRenderer({
                antialias: !1,
                canvas: t
            }),
            h = new r.WebGLRenderTarget(document.body.clientWidth, window.innerHeight),
            v = new r.Scene,
            p = new r.Scene,
            m = new r.OrthographicCamera(-1, 1, 1, -1, 0, 1),
            y = new r.PerspectiveCamera(45, document.body.clientWidth / window.innerHeight, 1, 1e4),
            g = new r.Clock,
            x = new a,
            b = (new s, new c),
            w = new u,
            M = new l,
            _ = [new f(400, -500, 200), new f(-350, -600, -50), new f(-150, -700, -150), new f(-500, -900, 0), new f(100, -1100, 250), new f(-100, -1200, -300), new f(150, -1500, -100)],
            S = new d(h.texture),
            P = document.getElementsByClassName("js-transition-intro"),
            T = function() {
                t.width = document.body.clientWidth, t.height = window.innerHeight, y.aspect = document.body.clientWidth / window.innerHeight, y.updateProjectionMatrix(), h.setSize(document.body.clientWidth, window.innerHeight), n.setSize(document.body.clientWidth, window.innerHeight), S.resize()
            },
            E = function e() {
                ! function() {
                    var e = g.getDelta();
                    x.render(e), b.render(e), w.render(e), M.render(e);
                    for (var t = 0; t < _.length; t++) _[t].render(e);
                    n.setRenderTarget(h), n.render(p, y), S.render(e), n.setRenderTarget(null), n.render(v, m)
                }(), requestAnimationFrame(e)
            };
        n.setSize(document.body.clientWidth, window.innerHeight), n.setClearColor(1118481, 1), y.position.z = 800, v.add(S.obj), x.loadTexture((function() {
            p.add(x.obj), p.add(b.obj), p.add(w.obj), p.add(M.obj);
            for (var e = 0; e < _.length; e++) p.add(_[e].obj);
            ! function() {
                for (var e = 0; e < P.length; e++) P[e].classList.add("is-shown")
            }()
        })), g.start(), window.addEventListener("resize", i((function() {
            T()
        })), 1e3), e.renderNext = function() {
            e.isValidSmooth() ? y.position.y = .6 * e.hookes.contents.velocity[1] : y.position.y = -1 * e.scrollTop
        }, T(), E(), e.start()
    }
}, function(e, t, n) {
    "use strict";

    function r(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }
    n.r(t), n.d(t, "default", (function() {
        return f
    }));
    var i = n(3),
        o = n(104),
        a = n(105),
        s = n(346).default,
        c = n(347).default,
        u = document.querySelector(".js-contents"),
        l = document.querySelector(".js-dummy-scroll"),
        f = function() {
            function e() {
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, e), this.scrollItems = new c(this), this.scrollTop = 0, this.scrollFrame = 0, this.scrollTopPause = 0, this.resolution = {
                    x: 0,
                    y: 0
                }, this.bodyResolution = {
                    x: 0,
                    y: 0
                }, this.X_SWITCH_SMOOTH = 1024, this.hookes = {}, this.scrollPrev = null, this.scrollNext = null, this.resizeReset = null, this.resizePrev = null, this.resizeNext = null, this.renderPrev = null, this.renderNext = null, this.isWorking = !1, this.isWorkingSmooth = !1, this.isAlreadyAddEvent = !1
            }
            var t, n, f;
            return t = e, (n = [{
                key: "start",
                value: function(e) {
                    var t = this;
                    setTimeout((function() {
                        t.scrollTop = window.pageYOffset, t.initHookes(), t.scrollItems.init();
                        var n = location.hash,
                            r = n ? document.querySelector(n) : null;
                        if (r) {
                            var i = r.getBoundingClientRect();
                            t.scrollTop, i.top
                        }
                        t.resize((function() {
                            t.scroll(), t.isWorkingSmooth = !0, t.renderLoop(), t.on(), e && e()
                        }))
                    }), 100)
                }
            }, {
                key: "pause",
                value: function() {
                    this.isWorking = !1, u.style.position = "fixed", this.hookes.contents.velocity[1] = this.hookes.contents.anchor[1] = -1 * this.scrollTop, this.scrollTopPause = this.scrollTop, window.scrollTo(0, this.scrollTop)
                }
            }, {
                key: "play",
                value: function() {
                    u.style.position = "", this.scrollTop = this.scrollTopPause, this.resolution.x <= this.X_SWITCH_SMOOTH && (this.hookes.contents.velocity[1] = this.hookes.contents.anchor[1] = 0), window.scrollTo(0, this.scrollTop), this.isWorking = !0
                }
            }, {
                key: "initDummyScroll",
                value: function() {
                    this.resolution.x <= this.X_SWITCH_SMOOTH ? (u.style.transform = "", u.classList.remove("is-fixed"), l.style.height = "0") : (u.classList.add("is-fixed"), l.style.height = "".concat(u.clientHeight, "px")), this.render()
                }
            }, {
                key: "initHookes",
                value: function() {
                    this.hookes = {
                        contents: new s({
                            k: .575,
                            d: .8
                        }),
                        smooth: new s({
                            k: .18,
                            d: .75
                        }),
                        parallax: new s({
                            k: .28,
                            d: .7
                        })
                    }
                }
            }, {
                key: "scrollBasis",
                value: function() {
                    this.resolution.x > this.X_SWITCH_SMOOTH && (this.hookes.contents.anchor[1] = -1 * this.scrollTop, this.hookes.smooth.velocity[1] += this.scrollFrame, this.hookes.parallax.anchor[1] = this.scrollTop + .5 * this.resolution.y), this.scrollItems.scroll()
                }
            }, {
                key: "scroll",
                value: function(e) {
                    if (!1 !== this.isWorking) {
                        var t = window.pageYOffset;
                        this.scrollFrame = t - this.scrollTop, this.scrollTop = t, this.scrollPrev && this.scrollPrev(), this.scrollBasis(), this.scrollNext && this.scrollNext()
                    }
                }
            }, {
                key: "tilt",
                value: function(e) {
                    !1 !== this.isWorking && this.resolution.x > this.X_SWITCH_SMOOTH && (this.hookes.parallax.anchor[0] = -100 * (e.clientX / this.resolution.x * 2 - 1))
                }
            }, {
                key: "resizeBasis",
                value: function() {
                    this.scrollItems.resize()
                }
            }, {
                key: "resize",
                value: function(e) {
                    if (this.isWorking = !1, this.resizeReset && this.resizeReset(), this.scrollTop = window.pageYOffset, this.resolution.x = window.innerWidth, this.resolution.y = window.innerHeight, this.bodyResolution.x = document.body.clientWidth, this.bodyResolution.y = document.body.clientHeight, this.resolution.x > this.X_SWITCH_SMOOTH) this.hookes.contents.velocity[1] = this.hookes.contents.anchor[1] = -this.scrollTop, this.hookes.parallax.velocity[1] = this.hookes.parallax.anchor[1] = this.scrollTop + .5 * this.resolution.y;
                    else
                        for (var t in this.hookes) switch (t) {
                            case "contents":
                            case "parallax":
                                this.hookes[t].anchor[1] = this.hookes[t].velocity[1] = 0;
                                break;
                            default:
                                this.hookes[t].velocity[1] = 0
                        }
                    this.resizePrev && this.resizePrev(), this.initDummyScroll(), this.render(), window.scrollTo(0, this.scrollTop), this.resizeBasis(), this.resizeNext && this.resizeNext(), this.isWorking = !0, e && e()
                }
            }, {
                key: "render",
                value: function() {
                    this.renderPrev && this.renderPrev();
                    var e = Math.floor(1e3 * this.hookes.contents.velocity[1]) / 1e3;
                    for (var t in u.style.transform = "translate3D(0, ".concat(e, "px, 0)"), this.hookes) this.hookes[t].render();
                    this.scrollItems.render(this.isValidSmooth()), this.renderNext && this.renderNext()
                }
            }, {
                key: "renderLoop",
                value: function() {
                    var e = this;
                    this.render(), this.isWorkingSmooth && requestAnimationFrame((function() {
                        e.renderLoop()
                    }))
                }
            }, {
                key: "on",
                value: function() {
                    var e = this;
                    if (!this.isAlreadyAddEvent) {
                        var t = o() || a() ? "orientationchange" : "resize";
                        window.addEventListener("scroll", (function(t) {
                            e.scroll(t)
                        }), !1), window.addEventListener("mousemove", (function(t) {
                            e.tilt(t)
                        }), !1), window.addEventListener(t, i((function(t) {
                            e.resize()
                        }), 400), !1), this.isAlreadyAddEvent = !0
                    }
                }
            }, {
                key: "off",
                value: function() {
                    this.scrollPrev = null, this.scrollNext = null, this.resizeReset = null, this.resizePrev = null, this.resizeNext = null, this.renderPrev = null, this.renderNext = null
                }
            }, {
                key: "isValidSmooth",
                value: function() {
                    return this.isWorkingSmooth && this.resolution.x > this.X_SWITCH_SMOOTH
                }
            }]) && r(t.prototype, n), f && r(t, f), e
        }()
}, function(e, t, n) {
    "use strict";

    function r(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }
    n.r(t), n.d(t, "default", (function() {
        return o
    }));
    var i = n(70).default,
        o = function() {
            function e(t) {
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, e), this.velocity = [0, 0, 0], this.acceleration = [0, 0, 0], this.anchor = [0, 0, 0], this.k = t && void 0 !== t.k ? t.k : .3, this.d = t && void 0 !== t.d ? t.d : .7, this.m = t && void 0 !== t.m ? t.m : 1
            }
            var t, n, o;
            return t = e, (n = [{
                key: "render",
                value: function() {
                    i.applyHook(this.velocity, this.acceleration, this.anchor, 0, this.k), i.applyDrag(this.acceleration, this.d), i.updateVelocity(this.velocity, this.acceleration, this.m)
                }
            }]) && r(t.prototype, n), o && r(t, o), e
        }()
}, function(e, t, n) {
    "use strict";

    function r(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }
    n.r(t), n.d(t, "default", (function() {
        return s
    }));
    var i = n(348).default,
        o = n(349).default,
        a = n(350).default,
        s = function() {
            function e(t) {
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, e), this.scrollManager = t, this.scrollItems = [], this.smoothItems = [], this.parallaxItems = []
            }
            var t, n, s;
            return t = e, (n = [{
                key: "init",
                value: function() {
                    var e = document.querySelectorAll(".js-scroll-item"),
                        t = document.querySelectorAll(".js-smooth-item"),
                        n = document.querySelectorAll(".js-parallax-item");
                    this.scrollItems = [], this.smoothItems = [], this.parallaxItems = [];
                    for (var r = 0; r < e.length; r++) this.scrollItems[r] = new i(e[r], this.scrollManager);
                    for (r = 0; r < t.length; r++) this.smoothItems[r] = new o(t[r], this.scrollManager, this.scrollManager.hookes.smooth, t[r].dataset);
                    for (r = 0; r < n.length; r++) this.parallaxItems[r] = new a(n[r], this.scrollManager, this.scrollManager.hookes.parallax, n[r].dataset)
                }
            }, {
                key: "scroll",
                value: function() {
                    for (var e = 0; e < this.scrollItems.length; e++) this.scrollItems[e].show(this.scrollManager.scrollTop + this.scrollManager.resolution.y, this.scrollManager.scrollTop)
                }
            }, {
                key: "resize",
                value: function() {
                    for (var e = 0; e < this.scrollItems.length; e++) this.scrollItems[e].init(this.scrollManager.scrollTop);
                    for (e = 0; e < this.smoothItems.length; e++) this.smoothItems[e].init(this.scrollManager.scrollTop);
                    for (e = 0; e < this.parallaxItems.length; e++) this.parallaxItems[e].init(this.scrollManager.scrollTop)
                }
            }, {
                key: "render",
                value: function(e) {
                    for (var t = 0; t < this.smoothItems.length; t++) this.smoothItems[t].render(e);
                    for (t = 0; t < this.parallaxItems.length; t++) this.parallaxItems[t].render(e)
                }
            }]) && r(t.prototype, n), s && r(t, s), e
        }()
}, function(e, t, n) {
    "use strict";

    function r(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }
    n.r(t), n.d(t, "default", (function() {
        return i
    }));
    var i = function() {
        function e(t) {
            ! function(e, t) {
                if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
            }(this, e), this.elm = t, this.elmChildren = t.querySelectorAll(".js-scroll-item-child"), this.top = 0, this.bottom = 0
        }
        var t, n, i;
        return t = e, (n = [{
            key: "init",
            value: function(e) {
                var t = this.elm.getBoundingClientRect();
                this.top = e + t.top, this.bottom = this.top + t.height
            }
        }, {
            key: "show",
            value: function(e, t) {
                if (e > this.top && t < this.bottom) {
                    this.elm.classList.add("is-shown");
                    for (var n = 0; n < this.elmChildren.length; n++) this.elmChildren[n].classList.add("is-shown")
                }
            }
        }]) && r(t.prototype, n), i && r(t, i), e
    }()
}, function(e, t, n) {
    "use strict";

    function r(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }
    n.r(t), n.d(t, "default", (function() {
        return i
    }));
    var i = function() {
        function e(t, n, r, i) {
            ! function(e, t) {
                if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
            }(this, e), this.scrollManager = n, this.hookes = r, this.elm = t, this.height = 0, this.top = 0, this.max = i && i.max ? i.max : null, this.min = i && i.min ? i.min : null, this.ratio = i && i.ratio ? i.ratio : .1, this.unit = i && i.unit ? i.unit : "px"
        }
        var t, n, i;
        return t = e, (n = [{
            key: "init",
            value: function(e) {
                var t = this.elm.getBoundingClientRect();
                this.height = t.height, this.top = e + t.top, this.elm.style.backfaceVisibility = "hidden"
            }
        }, {
            key: "render",
            value: function(e) {
                var t = 0;
                e && (t = this.hookes.velocity[1] * this.ratio, Math.abs(this.hookes.acceleration[1]) < .01 && (this.hookes.velocity[1] = this.hookes.anchor[1]), this.min && (t = Math.max(t, this.min)), this.max && (t = Math.min(t, this.max))), this.elm.style.transform = "translate3D(0, ".concat(t).concat(this.unit, ", 0)")
            }
        }]) && r(t.prototype, n), i && r(t, i), e
    }()
}, function(e, t, n) {
    "use strict";

    function r(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }
    n.r(t), n.d(t, "default", (function() {
        return a
    }));
    var i = n(1),
        o = n(351),
        a = function() {
            function e(t, n, r, i) {
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, e), this.scrollManager = n, this.hookes = r, this.elm = t, this.height = 0, this.top = 0, this.rangeX = i && i.rangeX ? i.rangeX : 1e4, this.ratioX = i && i.ratioX ? i.ratioX : 0, this.unitX = i && i.unitX ? i.unitX : "px", this.rangeY = i && i.rangeY ? i.rangeY : 10, this.ratioY = i && i.ratioY ? i.ratioY : .012, this.unitY = i && i.unitY ? i.unitY : "%"
            }
            var t, n, a;
            return t = e, (n = [{
                key: "init",
                value: function(e) {
                    this.elm.style.transform = "";
                    var t = this.elm.getBoundingClientRect();
                    this.height = t.height, this.top = e + t.top, this.elm.style.backfaceVisibility = "hidden", this.render()
                }
            }, {
                key: "render",
                value: function(e) {
                    var t = e ? i.clamp(this.hookes.velocity[0] * this.ratioX, -1 * this.rangeX, this.rangeX) : 0,
                        n = e ? i.clamp((this.hookes.velocity[1] - (this.top + .5 * this.height)) * this.ratioY, -1 * this.rangeY, this.rangeY) : 0;
                    this.elm.style.transform = o() ? "translate(".concat(t).concat(this.unitX, ", ").concat(n).concat(this.unitY, ")") : "translate3D(".concat(t).concat(this.unitX, ", ").concat(n).concat(this.unitY, ", 0)")
                }
            }]) && r(t.prototype, n), a && r(t, a), e
        }()
}, function(e, t) {
    e.exports = function() {
        var e = navigator.userAgent;
        return e.indexOf("MSIE") > -1 || e.indexOf("rv:11.0") > -1
    }
}, function(e, t, n) {
    "use strict";

    function r(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }
    n.r(t), n.d(t, "default", (function() {
        return o
    }));
    var i = n(0),
        o = function() {
            function e() {
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, e), this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    },
                    resolution: {
                        type: "v2",
                        value: new i.Vector2
                    },
                    texture: {
                        type: "t",
                        value: null
                    }
                }, this.obj, this.isLoaded = !1
            }
            var t, o, a;
            return t = e, (o = [{
                key: "loadTexture",
                value: function(e) {
                    var t = this;
                    (new i.TextureLoader).load("/sketch-threejs/img/index/tex_title.png", (function(n) {
                        n.magFilter = i.NearestFilter, n.minFilter = i.NearestFilter, t.uniforms.texture.value = n, t.obj = t.createObj(), t.isLoaded = !0, e()
                    }))
                }
            }, {
                key: "createObj",
                value: function() {
                    return new i.Mesh(new i.PlaneBufferGeometry(256, 64, 40, 10), new i.RawShaderMaterial({
                        uniforms: this.uniforms,
                        vertexShader: n(353).default,
                        fragmentShader: n(354).default,
                        transparent: !0
                    }))
                }
            }, {
                key: "render",
                value: function(e) {
                    this.isLoaded && (this.uniforms.time.value += e)
                }
            }]) && r(t.prototype, o), a && r(t, a), e
        }()
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform float time;\n\nvarying vec2 vUv;\n\nconst float interval = 3.0;\n\nfloat cubicOut(float t) {\n  float f = t - 1.0;\n  return f * f * f + 1.0;\n}\n\nvoid main() {\n  float now = cubicOut(min(time / interval, 1.0));\n  vec3 updatePosition = vec3(\n    position.x * (1.2 - now * 0.2),\n    position.y * (1.2 - now * 0.2),\n    position.z\n  );\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(updatePosition, 1.0);\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\nuniform sampler2D texture;\n\nvarying vec2 vUv;\n\nconst float interval = 3.0;\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\nfloat cubicOut(float t) {\n  float f = t - 1.0;\n  return f * f * f + 1.0;\n}\n\nvoid main() {\n  float now = cubicOut(min(time / interval, 1.0));\n  float noise = (snoise(vec3(vUv.x * 4.0, vUv.y * 4.0, 1.0)) + 1.0) / 2.0;\n  float opacity = smoothstep(0.4, 0.6, ((noise - 1.0) + now * interval) - vUv.x);\n  gl_FragColor = texture2D(texture, vUv) * vec4(vec3(1.0), opacity);\n}\n"
}, function(e, t, n) {
    "use strict";

    function r(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }
    n.r(t), n.d(t, "default", (function() {
        return o
    }));
    var i = n(0),
        o = function() {
            function e() {
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, e), this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    },
                    resolution: {
                        type: "v2",
                        value: new i.Vector2
                    }
                }, this.obj = this.createObj()
            }
            var t, o, a;
            return t = e, (o = [{
                key: "createObj",
                value: function() {
                    var e = new i.BufferGeometry,
                        t = new Float32Array([0, Math.sqrt(3) / 2, 0, -1, Math.sqrt(3) / 2 * -1, 0, 1, Math.sqrt(3) / 2 * -1, 0]),
                        r = new Uint16Array([0, 1, 2, 0]);
                    return e.addAttribute("position", new i.BufferAttribute(t, 3)), e.setIndex(new i.BufferAttribute(r, 1)), new i.Line(e, new i.RawShaderMaterial({
                        uniforms: this.uniforms,
                        vertexShader: n(356).default,
                        fragmentShader: n(357).default
                    }))
                }
            }]) && r(t.prototype, o), a && r(t, a), e
        }()
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nattribute vec3 position;\nattribute float index;\n\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\n\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nvoid main() {\n  gl_FragColor = vec4(1.0);\n}\n"
}, function(e, t, n) {
    "use strict";

    function r(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }
    n.r(t), n.d(t, "default", (function() {
        return a
    }));
    var i = n(0),
        o = (n(1), function(e, t, n) {
            var r = [],
                i = [t[0] - e[0], t[1] - e[1], t[2] - e[2]],
                o = [n[0] - e[0], n[1] - e[1], n[2] - e[2]];
            r[0] = i[1] * o[2] - i[2] * o[1], r[1] = i[2] * o[0] - i[0] * o[2], r[2] = i[0] * o[1] - i[1] * o[0];
            for (var a = Math.sqrt(r[0] * r[0] + r[1] * r[1] + r[2] * r[2], 2), s = 0; s < r.length; s++) r[s] = r[s] / a;
            return r
        }),
        a = function() {
            function e() {
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, e), this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    }
                }, this.obj = this.createObj()
            }
            var t, a, s;
            return t = e, (a = [{
                key: "createObj",
                value: function() {
                    for (var e = new i.OctahedronBufferGeometry(90, 4), t = e.attributes.position.array, r = [], a = [], s = [], c = 0; c < t.length; c += 9) {
                        var u = o([t[c + 0], t[c + 1], t[c + 2]], [t[c + 3], t[c + 4], t[c + 5]], [t[c + 6], t[c + 7], t[c + 8]]);
                        r.push(u[0], u[1], u[2], u[0], u[1], u[2], u[0], u[1], u[2]);
                        var l = [(t[c + 0] + t[c + 3] + t[c + 6]) / 3, (t[c + 1] + t[c + 4] + t[c + 7]) / 3, (t[c + 2] + t[c + 5] + t[c + 8]) / 3],
                            f = .5 * Math.random();
                        a.push(l[0], l[1], l[2], l[0], l[1], l[2], l[0], l[1], l[2]), s.push(f, f, f)
                    }
                    var d = new Float32Array(r),
                        h = new Float32Array(a),
                        v = new Float32Array(s);
                    return e.addAttribute("faceNormal", new i.BufferAttribute(d, 3)), e.addAttribute("center", new i.BufferAttribute(h, 3)), e.addAttribute("delay", new i.BufferAttribute(v, 1)), new i.Mesh(e, new i.RawShaderMaterial({
                        uniforms: this.uniforms,
                        vertexShader: n(359).default,
                        fragmentShader: n(360).default,
                        flatShading: !0,
                        transparent: !0,
                        side: i.DoubleSide
                    }))
                }
            }, {
                key: "render",
                value: function(e) {
                    this.uniforms.time.value += e
                }
            }]) && r(t.prototype, a), s && r(t, s), e
        }()
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = '#define GLSLIFY 1\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec3 faceNormal;\nattribute vec3 center;\nattribute float delay;\n\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform float time;\n\nvarying vec3 vPosition;\nvarying float vNoise;\nvarying float vNow;\n\nconst float duration = 2.0;\nconst float delayAll = 1.0;\n\nfloat exponentialOut(float t) {\n  return t == 1.0 ? t : 1.0 - pow(2.0, -10.0 * t);\n}\n\nmat4 calcTranslateMat4(vec3 v) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    v.x, v.y, v.z, 1.0\n  );\n}\n\nmat4 calcRotateMat4X(float radian) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, cos(radian), -sin(radian), 0.0,\n    0.0, sin(radian), cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4Y(float radian) {\n  return mat4(\n    cos(radian), 0.0, sin(radian), 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    -sin(radian), 0.0, cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4Z(float radian) {\n  return mat4(\n    cos(radian), -sin(radian), 0.0, 0.0,\n    sin(radian), cos(radian), 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4(vec3 radian) {\n  return calcRotateMat4X(radian.x) * calcRotateMat4Y(radian.y) * calcRotateMat4Z(radian.z);\n}\n\n//\n// GLSL textureless classic 3D noise "cnoise",\n// with an RSL-style periodic variant "pnoise".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-10-11\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec3 fade(vec3 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise(vec3 P)\n{\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod289(Pi0);\n  Pi1 = mod289(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n  return 2.2 * n_xyz;\n}\n\nvoid main() {\n  float now = exponentialOut(max((time - delayAll - delay - (faceNormal.x + 1.0) / 2.0 - (faceNormal.y + 1.0) / 2.0) / duration, 0.0));\n  mat4 translateMat = calcTranslateMat4(vec3(faceNormal) * 1200.0 * (1.0 - now) + vec3(0.0, sin(time) * 10.0 + 210.0, 0.0));\n  mat4 rotateMat = calcRotateMat4(vec3(0.0, radians((1.0 - now) * faceNormal.y * 4320.0), 0.0));\n  float rotateRadian = radians((time + faceNormal.x + faceNormal.y) * 1440.0);\n  mat4 rotateMatSelf = calcRotateMat4(vec3(rotateRadian, rotateRadian, 0.0));\n  float noise = smoothstep(-0.4, 0.4,\n    cnoise(vec3(position.x * 0.035 - time, position.y * 0.035 - time, position.z * 0.035 + time))\n  ) * 2.0 - 1.0;\n  vec3 updatePositionSelf = (rotateMatSelf * vec4(position - center, 1.0)).xyz * (1.0 - now) + position\n    + normalize(position) * noise ;\n  vec4 updatePosition = rotateMat * translateMat * vec4(updatePositionSelf, 1.0);\n  vPosition = updatePosition.xyz;\n  vNoise = noise;\n  vNow = now;\n  gl_Position = projectionMatrix * modelViewMatrix * updatePosition;\n}\n'
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "precision highp float;\n#define GLSLIFY 1\n\nuniform mat3 normalMatrix;\nuniform float time;\n\nvarying vec3 vPosition;\nvarying float vNoise;\nvarying float vNow;\n\nconst vec3 lightDirection = vec3(1.0, -1.0, -1.0);\nconst float duration = 2.0;\nconst float delayAll = 1.0;\n\nvec3 convertHsvToRgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  float now = clamp((time - delayAll - 1.5) / duration, 0.0, 1.0);\n  vec3 normal = normalize(cross(dFdx(vPosition), dFdy(vPosition)));\n  vec3 light = normalize(normalMatrix * lightDirection);\n  float diff = (dot(normal, light) + 1.0) / 2.0 * 0.2;\n  float opacity = smoothstep(0.1, 0.2, vNow);\n  vec3 v = normalize(vPosition);\n  vec3 rgb = (1.0 - now) * vec3(1.0) + convertHsvToRgb(vec3(0.5 + (v.x + v.y + v.x) / 40.0 + time * 0.1, 0.8, 0.4 + sin(time) * 0.05 + vNoise * 0.02));\n  gl_FragColor = vec4(rgb + diff, opacity);\n}\n"
}, function(e, t, n) {
    "use strict";

    function r(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }
    n.r(t), n.d(t, "default", (function() {
        return o
    }));
    var i = n(0),
        o = (n(1), function() {
            function e() {
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, e), this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    }
                }, this.obj = this.createObj()
            }
            var t, o, a;
            return t = e, (o = [{
                key: "createObj",
                value: function() {
                    var e = new i.OctahedronBufferGeometry(150, 4);
                    return new i.Mesh(e, new i.RawShaderMaterial({
                        uniforms: this.uniforms,
                        vertexShader: n(362).default,
                        fragmentShader: n(363).default,
                        transparent: !0,
                        side: i.DoubleSide,
                        depthWrite: !1
                    }))
                }
            }, {
                key: "render",
                value: function(e) {
                    this.uniforms.time.value += e
                }
            }]) && r(t.prototype, o), a && r(t, a), e
        }())
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = '#define GLSLIFY 1\nattribute vec3 position;\n\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform float time;\n\nvarying vec3 vPosition;\nvarying float vOpacity;\n\nconst float duration = 4.0;\nconst float delay = 3.0;\n\nfloat exponentialOut(float t) {\n  return t == 1.0 ? t : 1.0 - pow(2.0, -10.0 * t);\n}\n\n//\n// GLSL textureless classic 3D noise "cnoise",\n// with an RSL-style periodic variant "pnoise".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-10-11\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec3 fade(vec3 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise(vec3 P)\n{\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod289(Pi0);\n  Pi1 = mod289(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n  return 2.2 * n_xyz;\n}\n\nmat4 calcTranslateMat4(vec3 v) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    v.x, v.y, v.z, 1.0\n  );\n}\n\nmat4 calcScaleMat4(vec3 scale) {\n  return mat4(\n    scale.x, 0.0, 0.0, 0.0,\n    0.0, scale.y, 0.0, 0.0,\n    0.0, 0.0, scale.z, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4X(float radian) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, cos(radian), -sin(radian), 0.0,\n    0.0, sin(radian), cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4Y(float radian) {\n  return mat4(\n    cos(radian), 0.0, sin(radian), 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    -sin(radian), 0.0, cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4Z(float radian) {\n  return mat4(\n    cos(radian), -sin(radian), 0.0, 0.0,\n    sin(radian), cos(radian), 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4(vec3 radian) {\n  return calcRotateMat4X(radian.x) * calcRotateMat4Y(radian.y) * calcRotateMat4Z(radian.z);\n}\n\nvoid main() {\n  float now = clamp((time - delay) / duration, 0.0, 1.0);\n  mat4 translateMat = calcTranslateMat4(vec3(0.0, sin(time) * 10.0 + 210.0, 0.0));\n  mat4 scaleMat = calcScaleMat4(vec3(exponentialOut(now) * 0.6 + 0.4 + sin(time * 2.0) * 0.04));\n  mat4 rotateMat = calcRotateMat4(vec3(radians(45.0), radians(time * 2.0), radians(-time * 2.0)));\n  float noise = smoothstep(-0.4, 0.4, cnoise(position * 0.035 - time)) * 2.0 - 1.0;\n  vec4 updatePosition = translateMat * rotateMat * scaleMat * vec4(position + normalize(position) * noise * 2.0, 1.0);\n  vPosition = normalize(position);\n  vOpacity = normalize(updatePosition).z;\n  gl_Position = projectionMatrix * modelViewMatrix * updatePosition;\n}\n'
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = 'precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\n\nvarying vec3 vPosition;\nvarying float vOpacity;\n\nconst float duration = 4.0;\nconst float delay = 3.0;\n\nvec3 convertHsvToRgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n//\n// GLSL textureless classic 3D noise "cnoise",\n// with an RSL-style periodic variant "pnoise".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-10-11\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec3 fade(vec3 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise(vec3 P)\n{\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod289(Pi0);\n  Pi1 = mod289(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n  return 2.2 * n_xyz;\n}\n\nfloat random(vec2 c){\n  return fract(sin(dot(c.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid main() {\n  float now = clamp((time - delay) / duration, 0.0, 1.0);\n  float noise1 = cnoise(vec3((vPosition * vec3(0.4, 2.0, -0.6) * 2.0 + time))) * 7.0 - (1.0 + (1.0 - now) * 7.0);\n  float noise2 = cnoise(vec3((vPosition * 42.0 + time)));\n  float noise3 = cnoise(vec3((vPosition * 7.0 + time))) * 2.0;\n  float bright = smoothstep(-0.2, 1.0, (noise1 + noise2 + noise3) * now);\n  vec3 v = normalize(vPosition);\n  vec3 rgb = (1.0 - now) * vec3(1.0) + convertHsvToRgb(vec3(0.5 + (v.x + v.y + v.x) / 40.0 + time * 0.1, 0.4, 1.0));\n  float whiteNoise = random(vPosition.xy);\n  if (bright < 0.4) discard;\n  gl_FragColor = vec4(rgb * vec3(1.0 - bright + 0.6) + whiteNoise * 0.2, 0.4 + vOpacity * 0.5 + sin(time * 2.0) * 0.1);\n}\n'
}, function(e, t, n) {
    "use strict";

    function r(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }
    n.r(t), n.d(t, "default", (function() {
        return a
    }));
    var i = n(0),
        o = n(1),
        a = function() {
            function e() {
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, e), this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    }
                }, this.obj = this.createObj(), this.obj.position.set(0, -200, 0), this.obj.rotation.set(o.radians(-90), 0, 0)
            }
            var t, a, s;
            return t = e, (a = [{
                key: "createObj",
                value: function() {
                    return new i.Mesh(new i.PlaneBufferGeometry(1024, 1024, 32, 32), new i.RawShaderMaterial({
                        uniforms: this.uniforms,
                        vertexShader: n(365).default,
                        fragmentShader: n(366).default,
                        transparent: !0,
                        wireframe: !0
                    }))
                }
            }, {
                key: "render",
                value: function(e) {
                    this.uniforms.time.value += e
                }
            }]) && r(t.prototype, a), s && r(t, s), e
        }()
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nattribute vec3 position;\n\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform float time;\n\nvarying vec3 vPosition;\n\nvoid main() {\n  float sin1 = sin((position.x + position.y) * 0.2 + time * 0.5);\n  float sin2 = sin((position.x - position.y) * 0.4 + time * 2.0);\n  float sin3 = sin((position.x + position.y) * -0.6 + time);\n  vec3 updatePosition = vec3(position.x, position.y, position.z + sin1 * 50.0 + sin2 * 10.0 + sin3 * 8.0);\n  vPosition = position;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(updatePosition, 1.0);\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\n\nvarying vec3 vPosition;\n\nconst float duration = 8.0;\nconst float delay = 4.0;\n\nvec3 convertHsvToRgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  float now = clamp((time - delay) / duration, 0.0, 1.0);\n  float opacity = (1.0 - length(vPosition.xy / vec2(512.0))) * 0.6 * now;\n  vec3 v = normalize(vPosition);\n  vec3 rgb = convertHsvToRgb(vec3(0.5 + (v.x + v.y + v.x) / 40.0 + time * 0.1, 0.4, 1.0));\n  gl_FragColor = vec4(rgb, opacity);\n}\n"
}, function(e, t, n) {
    "use strict";

    function r(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }
    n.r(t), n.d(t, "default", (function() {
        return o
    }));
    var i = n(0),
        o = (n(1), function() {
            function e(t, n, r) {
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, e), this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    },
                    rotate: {
                        type: "f",
                        value: 10 * Math.random()
                    }
                }, this.obj = this.createObj(), this.obj.position.set(t, n, r)
            }
            var t, o, a;
            return t = e, (o = [{
                key: "createObj",
                value: function() {
                    return new i.Mesh(new i.BoxBufferGeometry(100, 100, 100), new i.RawShaderMaterial({
                        uniforms: this.uniforms,
                        vertexShader: n(368).default,
                        fragmentShader: n(369).default,
                        transparent: !0,
                        wireframe: !0
                    }))
                }
            }, {
                key: "render",
                value: function(e) {
                    this.uniforms.time.value += e
                }
            }]) && r(t.prototype, o), a && r(t, a), e
        }())
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nattribute vec3 position;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform float time;\nuniform float rotate;\n\nmat4 calcRotateMat4X(float radian) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, cos(radian), -sin(radian), 0.0,\n    0.0, sin(radian), cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4Y(float radian) {\n  return mat4(\n    cos(radian), 0.0, sin(radian), 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    -sin(radian), 0.0, cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4Z(float radian) {\n  return mat4(\n    cos(radian), -sin(radian), 0.0, 0.0,\n    sin(radian), cos(radian), 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4(vec3 radian) {\n  return calcRotateMat4X(radian.x) * calcRotateMat4Y(radian.y) * calcRotateMat4Z(radian.z);\n}\n\nvoid main(void) {\n  mat4 rotateMat = calcRotateMat4(vec3(time * 0.1 + rotate));\n  vec4 updatePosition = rotateMat * vec4(position, 1.0);\n  gl_Position = projectionMatrix * modelViewMatrix * updatePosition;\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\n\nvec3 convertHsvToRgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  vec3 hsv = vec3(0.5 + time * 0.1, 0.4, 1.0);\n  vec3 rgb = convertHsvToRgb(hsv);\n  gl_FragColor = vec4(rgb, 0.25);\n}\n"
}, function(e, t, n) {
    "use strict";

    function r(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }
    n.r(t), n.d(t, "default", (function() {
        return o
    }));
    var i = n(0),
        o = function() {
            function e(t) {
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, e), this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    },
                    resolution: {
                        type: "v2",
                        value: new i.Vector2(document.body.clientWidth, window.innerHeight)
                    },
                    texture: {
                        type: "t",
                        value: t
                    }
                }, this.obj = this.createObj(t), this.time = 1
            }
            var t, o, a;
            return t = e, (o = [{
                key: "createObj",
                value: function() {
                    return new i.Mesh(new i.PlaneBufferGeometry(2, 2), new i.RawShaderMaterial({
                        uniforms: this.uniforms,
                        vertexShader: n(371).default,
                        fragmentShader: n(372).default
                    }))
                }
            }, {
                key: "render",
                value: function(e) {
                    this.uniforms.time.value += e * this.time
                }
            }, {
                key: "resize",
                value: function() {
                    this.uniforms.resolution.value.set(document.body.clientWidth, window.innerHeight)
                }
            }]) && r(t.prototype, o), a && r(t, a), e
        }()
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  gl_Position = vec4(position, 1.0);\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = 'precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\nuniform vec2 resolution;\nuniform sampler2D texture;\n\nvarying vec2 vUv;\n\nconst float duration = 8.0;\nconst float delay = 4.0;\n\n//\n// GLSL textureless classic 3D noise "cnoise",\n// with an RSL-style periodic variant "pnoise".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-10-11\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec3 fade(vec3 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise(vec3 P)\n{\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod289(Pi0);\n  Pi1 = mod289(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n  return 2.2 * n_xyz;\n}\n\nfloat random(vec2 c){\n  return fract(sin(dot(c.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 convertHsvToRgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  float now = clamp((time - delay) / duration, 0.0, 1.0);\n\n  // ホワイトノイズ\n  float whiteNoise = random(vUv.xy * time) * 0.1 - 0.1;\n\n  // モニターエフェクト\n  float monitor1 = abs(sin(vUv.y * resolution.y * 2.4 + time * 10.0)) * 0.04;\n  float monitor2 = abs(sin(vUv.y * resolution.y * 1.0 + time * 3.0)) * 0.04;\n  float monitor = monitor1 - monitor2;\n\n  // ヴィネット\n  float vignetteMask = smoothstep(0.8, 1.4, length(vUv * 2.0 - 1.0));\n  vec3 vignetteColor = convertHsvToRgb(vec3(0.5 + (vUv.x + vUv.y) / 40.0 + time * 0.1, 0.4, 1.0));\n  vec3 vignette = vignetteMask * vignetteColor * 0.1;\n\n  // RGBズレ\n  float r = texture2D(texture, vUv - vec2(2.0, 0.0) / resolution).r;\n  float g = texture2D(texture, vUv).g;\n  float b = texture2D(texture, vUv + vec2(2.0, 0.0) / resolution).b;\n\n  gl_FragColor = vec4((vec3(r, g, b) + whiteNoise) + monitor + vignette, 1.0);\n}\n'
}, function(e, t, n) {
    var r = n(0);
    r.OBJLoader = function() {
        var e = /^[og]\s*(.+)?/,
            t = /^mtllib /,
            n = /^usemtl /;

        function i() {
            var e = {
                objects: [],
                object: {},
                vertices: [],
                normals: [],
                colors: [],
                uvs: [],
                materialLibraries: [],
                startObject: function(e, t) {
                    if (this.object && !1 === this.object.fromDeclaration) return this.object.name = e, void(this.object.fromDeclaration = !1 !== t);
                    var n = this.object && "function" == typeof this.object.currentMaterial ? this.object.currentMaterial() : void 0;
                    if (this.object && "function" == typeof this.object._finalize && this.object._finalize(!0), this.object = {
                            name: e || "",
                            fromDeclaration: !1 !== t,
                            geometry: {
                                vertices: [],
                                normals: [],
                                colors: [],
                                uvs: []
                            },
                            materials: [],
                            smooth: !0,
                            startMaterial: function(e, t) {
                                var n = this._finalize(!1);
                                n && (n.inherited || n.groupCount <= 0) && this.materials.splice(n.index, 1);
                                var r = {
                                    index: this.materials.length,
                                    name: e || "",
                                    mtllib: Array.isArray(t) && t.length > 0 ? t[t.length - 1] : "",
                                    smooth: void 0 !== n ? n.smooth : this.smooth,
                                    groupStart: void 0 !== n ? n.groupEnd : 0,
                                    groupEnd: -1,
                                    groupCount: -1,
                                    inherited: !1,
                                    clone: function(e) {
                                        var t = {
                                            index: "number" == typeof e ? e : this.index,
                                            name: this.name,
                                            mtllib: this.mtllib,
                                            smooth: this.smooth,
                                            groupStart: 0,
                                            groupEnd: -1,
                                            groupCount: -1,
                                            inherited: !1
                                        };
                                        return t.clone = this.clone.bind(t), t
                                    }
                                };
                                return this.materials.push(r), r
                            },
                            currentMaterial: function() {
                                if (this.materials.length > 0) return this.materials[this.materials.length - 1]
                            },
                            _finalize: function(e) {
                                var t = this.currentMaterial();
                                if (t && -1 === t.groupEnd && (t.groupEnd = this.geometry.vertices.length / 3, t.groupCount = t.groupEnd - t.groupStart, t.inherited = !1), e && this.materials.length > 1)
                                    for (var n = this.materials.length - 1; n >= 0; n--) this.materials[n].groupCount <= 0 && this.materials.splice(n, 1);
                                return e && 0 === this.materials.length && this.materials.push({
                                    name: "",
                                    smooth: this.smooth
                                }), t
                            }
                        }, n && n.name && "function" == typeof n.clone) {
                        var r = n.clone(0);
                        r.inherited = !0, this.object.materials.push(r)
                    }
                    this.objects.push(this.object)
                },
                finalize: function() {
                    this.object && "function" == typeof this.object._finalize && this.object._finalize(!0)
                },
                parseVertexIndex: function(e, t) {
                    var n = parseInt(e, 10);
                    return 3 * (n >= 0 ? n - 1 : n + t / 3)
                },
                parseNormalIndex: function(e, t) {
                    var n = parseInt(e, 10);
                    return 3 * (n >= 0 ? n - 1 : n + t / 3)
                },
                parseUVIndex: function(e, t) {
                    var n = parseInt(e, 10);
                    return 2 * (n >= 0 ? n - 1 : n + t / 2)
                },
                addVertex: function(e, t, n) {
                    var r = this.vertices,
                        i = this.object.geometry.vertices;
                    i.push(r[e + 0], r[e + 1], r[e + 2]), i.push(r[t + 0], r[t + 1], r[t + 2]), i.push(r[n + 0], r[n + 1], r[n + 2])
                },
                addVertexLine: function(e) {
                    var t = this.vertices;
                    this.object.geometry.vertices.push(t[e + 0], t[e + 1], t[e + 2])
                },
                addNormal: function(e, t, n) {
                    var r = this.normals,
                        i = this.object.geometry.normals;
                    i.push(r[e + 0], r[e + 1], r[e + 2]), i.push(r[t + 0], r[t + 1], r[t + 2]), i.push(r[n + 0], r[n + 1], r[n + 2])
                },
                addColor: function(e, t, n) {
                    var r = this.colors,
                        i = this.object.geometry.colors;
                    i.push(r[e + 0], r[e + 1], r[e + 2]), i.push(r[t + 0], r[t + 1], r[t + 2]), i.push(r[n + 0], r[n + 1], r[n + 2])
                },
                addUV: function(e, t, n) {
                    var r = this.uvs,
                        i = this.object.geometry.uvs;
                    i.push(r[e + 0], r[e + 1]), i.push(r[t + 0], r[t + 1]), i.push(r[n + 0], r[n + 1])
                },
                addUVLine: function(e) {
                    var t = this.uvs;
                    this.object.geometry.uvs.push(t[e + 0], t[e + 1])
                },
                addFace: function(e, t, n, r, i, o, a, s, c) {
                    var u = this.vertices.length,
                        l = this.parseVertexIndex(e, u),
                        f = this.parseVertexIndex(t, u),
                        d = this.parseVertexIndex(n, u);
                    if (this.addVertex(l, f, d), void 0 !== r) {
                        var h = this.uvs.length;
                        l = this.parseUVIndex(r, h), f = this.parseUVIndex(i, h), d = this.parseUVIndex(o, h), this.addUV(l, f, d)
                    }
                    if (void 0 !== a) {
                        var v = this.normals.length;
                        l = this.parseNormalIndex(a, v), f = a === s ? l : this.parseNormalIndex(s, v), d = a === c ? l : this.parseNormalIndex(c, v), this.addNormal(l, f, d)
                    }
                    this.colors.length > 0 && this.addColor(l, f, d)
                },
                addLineGeometry: function(e, t) {
                    this.object.geometry.type = "Line";
                    for (var n = this.vertices.length, r = this.uvs.length, i = 0, o = e.length; i < o; i++) this.addVertexLine(this.parseVertexIndex(e[i], n));
                    var a = 0;
                    for (o = t.length; a < o; a++) this.addUVLine(this.parseUVIndex(t[a], r))
                }
            };
            return e.startObject("", !1), e
        }

        function o(e) {
            this.manager = void 0 !== e ? e : r.DefaultLoadingManager, this.materials = null
        }
        return o.prototype = {
            constructor: o,
            load: function(e, t, n, i) {
                var o = this,
                    a = new r.FileLoader(o.manager);
                a.setPath(this.path), a.load(e, (function(e) {
                    t(o.parse(e))
                }), n, i)
            },
            setPath: function(e) {
                this.path = e
            },
            setMaterials: function(e) {
                return this.materials = e, this
            },
            parse: function(o) {
                console.time("OBJLoader");
                var a = new i; - 1 !== o.indexOf("\r\n") && (o = o.replace(/\r\n/g, "\n")), -1 !== o.indexOf("\\\n") && (o = o.replace(/\\\n/g, ""));
                for (var s = o.split("\n"), c = "", u = "", l = [], f = "function" == typeof "".trimLeft, d = 0, h = s.length; d < h; d++)
                    if (c = s[d], 0 !== (c = f ? c.trimLeft() : c.trim()).length && "#" !== (u = c.charAt(0)))
                        if ("v" === u) {
                            var v = c.split(/\s+/);
                            switch (v[0]) {
                                case "v":
                                    a.vertices.push(parseFloat(v[1]), parseFloat(v[2]), parseFloat(v[3])), 8 === v.length && a.colors.push(parseFloat(v[4]), parseFloat(v[5]), parseFloat(v[6]));
                                    break;
                                case "vn":
                                    a.normals.push(parseFloat(v[1]), parseFloat(v[2]), parseFloat(v[3]));
                                    break;
                                case "vt":
                                    a.uvs.push(parseFloat(v[1]), parseFloat(v[2]))
                            }
                        } else if ("f" === u) {
                    for (var p = c.substr(1).trim().split(/\s+/), m = [], y = 0, g = p.length; y < g; y++) {
                        var x = p[y];
                        if (x.length > 0) {
                            var b = x.split("/");
                            m.push(b)
                        }
                    }
                    var w = m[0];
                    for (y = 1, g = m.length - 1; y < g; y++) {
                        var M = m[y],
                            _ = m[y + 1];
                        a.addFace(w[0], M[0], _[0], w[1], M[1], _[1], w[2], M[2], _[2])
                    }
                } else if ("l" === u) {
                    var S = c.substring(1).trim().split(" "),
                        P = [],
                        T = [];
                    if (-1 === c.indexOf("/")) P = S;
                    else
                        for (var E = 0, z = S.length; E < z; E++) {
                            var L = S[E].split("/");
                            "" !== L[0] && P.push(L[0]), "" !== L[1] && T.push(L[1])
                        }
                    a.addLineGeometry(P, T)
                } else if (null !== (l = e.exec(c))) {
                    var A = (" " + l[0].substr(1).trim()).substr(1);
                    a.startObject(A)
                } else if (n.test(c)) a.object.startMaterial(c.substring(7).trim(), a.materialLibraries);
                else if (t.test(c)) a.materialLibraries.push(c.substring(7).trim());
                else {
                    if ("s" !== u) {
                        if ("\0" === c) continue;
                        throw new Error('THREE.OBJLoader: Unexpected line: "' + c + '"')
                    }
                    if ((l = c.split(" ")).length > 1) {
                        var C = l[1].trim().toLowerCase();
                        a.object.smooth = "0" !== C && "off" !== C
                    } else a.object.smooth = !0;
                    (H = a.object.currentMaterial()) && (H.smooth = a.object.smooth)
                }
                a.finalize();
                var R = new r.Group;
                R.materialLibraries = [].concat(a.materialLibraries);
                for (d = 0, h = a.objects.length; d < h; d++) {
                    var O = a.objects[d],
                        j = O.geometry,
                        I = O.materials,
                        D = "Line" === j.type;
                    if (0 !== j.vertices.length) {
                        var k = new r.BufferGeometry;
                        k.addAttribute("position", new r.Float32BufferAttribute(j.vertices, 3)), j.normals.length > 0 ? k.addAttribute("normal", new r.Float32BufferAttribute(j.normals, 3)) : k.computeVertexNormals(), j.colors.length > 0 && k.addAttribute("color", new r.Float32BufferAttribute(j.colors, 3)), j.uvs.length > 0 && k.addAttribute("uv", new r.Float32BufferAttribute(j.uvs, 2));
                        for (var F, G = [], N = 0, B = I.length; N < B; N++) {
                            var U = I[N],
                                H = void 0;
                            if (null !== this.materials && (H = this.materials.create(U.name), D && H && !(H instanceof r.LineBasicMaterial))) {
                                var V = new r.LineBasicMaterial;
                                V.copy(H), H = V
                            }
                            H || ((H = D ? new r.LineBasicMaterial : new r.MeshPhongMaterial).name = U.name), H.flatShading = !U.smooth, G.push(H)
                        }
                        if (G.length > 1) {
                            for (N = 0, B = I.length; N < B; N++) {
                                U = I[N];
                                k.addGroup(U.groupStart, U.groupCount, N)
                            }
                            F = D ? new r.LineSegments(k, G) : new r.Mesh(k, G)
                        } else F = D ? new r.LineSegments(k, G[0]) : new r.Mesh(k, G[0]);
                        F.name = O.name, R.add(F)
                    }
                }
                return console.timeEnd("OBJLoader"), R
            }
        }, o
    }()
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nuniform vec2 resolution;\nuniform vec2 imageResolution;\n\nvarying vec2 vUv;\n\nvoid main(void) {\n  vec2 ratio = vec2(\n    min((resolution.x / resolution.y) / (imageResolution.x / imageResolution.y), 1.0),\n    min((resolution.y / resolution.x) / (imageResolution.y / imageResolution.x), 1.0)\n  );\n\n  vec2 updateUv = vec2(\n    uv.x * ratio.x + (1.0 - ratio.x) * 0.5,\n    uv.y * ratio.y + (1.0 - ratio.y) * 0.5\n  );\n\n  vUv = updateUv;\n  gl_Position = vec4(position, 1.0);\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = 'precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\nuniform float interval;\nuniform float duration;\nuniform sampler2D textures[5];\n\nvarying vec2 vUv;\n\nfloat cubicInOut(float t) {\n  return t < 0.5\n    ? 4.0 * t * t * t\n    : 0.5 * pow(2.0 * t - 2.0, 3.0) + 1.0;\n}\n\n//\n// GLSL textureless classic 3D noise "cnoise",\n// with an RSL-style periodic variant "pnoise".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-10-11\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec3 fade(vec3 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise(vec3 P)\n{\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod289(Pi0);\n  Pi1 = mod289(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n  return 2.2 * n_xyz;\n}\n\nvec4 getTexColor(float index, vec2 uv) {\n  vec4 color;\n  color += texture2D(textures[0], uv) * (1.0 - step(0.9, index));\n  color += texture2D(textures[1], uv) * step(1.0, index) * (1.0 - step(1.9, index));\n  color += texture2D(textures[2], uv) * step(2.0, index) * (1.0 - step(2.9, index));\n  color += texture2D(textures[3], uv) * step(3.0, index) * (1.0 - step(3.9, index));\n  color += texture2D(textures[4], uv) * step(4.0, index) * (1.0 - step(4.9, index));\n  return color;\n}\n\nvoid main(void) {\n  vec2 p = vUv * 2.0 - 1.0;\n\n  float alpha = cubicInOut(clamp(mod(time, interval) / duration - (interval / duration - 1.0), 0.0, 1.0));\n  float noise1 = cnoise(vec3(vUv * vec2(12.0), time * 0.1));\n  float noise2 = cnoise(vec3(vUv * vec2(12.0), time * 0.1 + 100.0));\n  float noise3 = cnoise(vec3(vUv * vec2(48.0), time * 0.3));\n  float noiseA = noise1 * 0.85 + noise3 * 0.15;\n  float noiseB = noise2 * 0.85 + noise3 * 0.15;\n\n  float mask = clamp(alpha * 2.0 - (noiseA * 0.5 + 0.5), 0.0, 1.0);\n  float mask1 = smoothstep(0.5, 1.0, mask);\n  float mask2 = smoothstep(0.0, 0.5, mask);\n\n  vec2 uvPrev = (vUv + p * 0.15 * alpha) + vec2(0.2) * vec2(noiseA, noiseB) * length(p) * alpha;\n  vec2 uvNext = (vUv - p * 0.15 * (1.0 - alpha)) + vec2(0.2) * vec2(noiseA, noiseB) * length(p) * (1.0 - alpha);\n\n  float indexPrev = floor(mod(time, interval * 5.0) / interval);\n  float indexNext = floor(mod(time + interval, interval * 5.0) / interval);\n\n  vec4 texColorPrev = getTexColor(indexPrev, uvPrev) * (1.0 - mask1);\n  vec4 texColorNext = getTexColor(indexNext, uvNext) * mask2;\n\n  gl_FragColor = texColorPrev + texColorNext;\n}\n'
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nattribute vec3 position;\nattribute float radian;\nattribute float radius;\nattribute float delay;\n\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\nuniform float time;\n\nvarying vec3 vColor;\n\nvoid main() {\n  // coordinate transformation\n  vec3 updatePosition = position\n    + vec3(\n      sin(time * 4.0 + delay),\n      sin(radian + time * 0.4) * (radius + sin(time * 4.0 + delay)),\n      cos(radian + time * 0.4) * (radius + sin(time * 4.0 + delay))\n      );\n  vec4 mvPosition = viewMatrix * modelMatrix * vec4(updatePosition, 1.0);\n  float distanceFromCamera = length(mvPosition.xyz);\n  float pointSize = 1000.0 / distanceFromCamera * 1.6;\n\n  vColor = vec3(0.8 - delay * 0.1, 0.6, 0.6);\n\n  gl_Position = projectionMatrix * mvPosition;\n  gl_PointSize = pointSize;\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "precision highp float;\n#define GLSLIFY 1\n\nvarying vec3 vColor;\n\nvoid main() {\n  // Convert PointCoord to the other vec2 has a range from -1.0 to 1.0.\n  vec2 p = gl_PointCoord * 2.0 - 1.0;\n\n  // Draw circle\n  float radius = length(p);\n  float opacity1 = (1.0 - smoothstep(0.5, 0.7, radius));\n  float opacity2 = smoothstep(0.8, 1.0, radius) * (1.0 - smoothstep(1.0, 1.2, radius));\n\n  gl_FragColor = vec4(vColor, (opacity1 + opacity2) * 0.5);\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n\n  gl_Position = vec4(position, 1.0);\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\nuniform sampler2D texture;\nuniform vec2 resolution;\n\nvarying vec2 vUv;\n\nfloat random2(vec2 c){\n  return fract(sin(dot(c.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\nfloat randomNoise(vec2 p) {\n  return (random2(p - vec2(sin(time))) * 2.0 - 1.0) * 0.04;\n}\n\nvoid main() {\n  // Convert uv to the other vec2 has a range from -1.0 to 1.0.\n  vec2 p = vUv * 2.0 - 1.0;\n  vec2 ratio = 1.0 / resolution;\n\n  // Random Noise\n  float rNoise = randomNoise(vUv);\n\n  // RGB Shift\n  float texColorR = texture2D(texture, vUv - vec2((2.0 * abs(p.x) + 1.0) * ratio.x, 0.0)).r;\n  float texColorG = texture2D(texture, vUv + vec2((2.0 * abs(p.x) + 1.0) * ratio.x, 0.0)).g;\n  float texColorB = texture2D(texture, vUv).b;\n\n  // Sum total of colors.\n  vec3 color = vec3(texColorR, texColorG, texColorB) + rNoise;\n\n  gl_FragColor = vec4(vec3(texColorR, texColorG, texColorB) + rNoise, 1.0);\n}\n"
}, function(e, t) {
    (function(t) {
        e.exports = t
    }).call(this, {})
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\n\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\nuniform mat3 normalMatrix;\nuniform float time;\n\nvarying vec3 vPosition;\nvarying vec3 vMPosition;\nvarying vec2 vUv;\n\nfloat exponentialOut(float t) {\n  return t == 1.0 ? t : 1.0 - pow(2.0, -10.0 * t);\n}\n\nmat4 calcScaleMat4(vec3 scale) {\n  return mat4(\n    scale.x, 0.0, 0.0, 0.0,\n    0.0, scale.y, 0.0, 0.0,\n    0.0, 0.0, scale.z, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nvoid main(void) {\n  float show = exponentialOut(min(time - 1.0, 4.0) / 4.0);\n\n  // coordinate transformation\n  mat4 scaleMat = calcScaleMat4(vec3(0.5 + show * 0.5));\n  vec4 mPosition = modelMatrix * scaleMat * vec4(position, 1.0);\n  vec4 mvPosition = viewMatrix *mPosition;\n\n  vPosition = position;\n  vMPosition = mPosition.xyz;\n  vUv = uv;\n\n  gl_Position = projectionMatrix * mvPosition;\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = 'precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\nuniform float drawBrightOnly;\nuniform float dissolveEdge;\n\nvarying vec3 vPosition;\nvarying vec3 vMPosition;\nvarying vec2 vUv;\n\n//\n// GLSL textureless classic 3D noise "cnoise",\n// with an RSL-style periodic variant "pnoise".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-10-11\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec3 fade(vec3 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise(vec3 P)\n{\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod289(Pi0);\n  Pi1 = mod289(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n  return 2.2 * n_xyz;\n}\n\nvec3 convertHsvToRgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat exponentialOut(float t) {\n  return t == 1.0 ? t : 1.0 - pow(2.0, -10.0 * t);\n}\n\nvoid main() {\n  // Flat Shading\n  vec3 normal = normalize(cross(dFdx(vMPosition), dFdy(vMPosition)));\n\n  vec3 light1 = normalize(vec3(0.0, 0.333, 1.0));\n  float d1 = (dot(normal, light1) + 1.0) / 2.0;\n  float glow1A = smoothstep(0.875, 1.0, d1);\n  float glow1B = smoothstep(0.75, 1.0, d1) * 0.8;\n\n  vec3 light2 = normalize(vec3(-0.0, -0.333, 1.0));\n  float d2 = (dot(normal, light2) + 1.0) / 2.0;\n  float glow2A = smoothstep(0.875, 1.0, d2);\n  float glow2B = smoothstep(0.75, 1.0, d2) * 0.8;\n\n  // dissolve\n  float show1 = exponentialOut(min(time - 1.0, 6.0) / 6.0);\n  float show2 = exponentialOut(clamp(time - 3.0, 0.0, 3.0) / 3.0);\n  float dissolveA = cnoise(\n    vec3(\n      vPosition.x * 0.06,\n      (vPosition.y - vPosition.x * 0.5 + vPosition.z * 0.5) * 0.18,\n      vPosition.z * 0.06\n    ) + time * 0.02\n  ) * 0.5 + 0.5;\n  float dissolveB = cnoise(\n    vec3(\n      vPosition.x * 0.4,\n      (vPosition.y - vPosition.x * 0.5 + vPosition.z * 0.5) * .9,\n      vPosition.z * 0.4\n    )\n  ) * 0.5 + 0.5;\n  float dissolve1 = smoothstep(\n    0.01 + show2 * 0.35 + dissolveEdge,\n    0.015 + show2 * 0.35 + dissolveEdge,\n    dissolveA * 0.8 + dissolveB * 0.2\n  );\n  float dissolve2 = smoothstep(\n    0.0 + show2 * 0.35 + dissolveEdge,\n    0.005 + show2 * 0.35 + dissolveEdge,\n    dissolveA * 0.8 + dissolveB * 0.2\n  );\n  float dissolve3 = smoothstep(\n    show1 - 0.05,\n    show1 - 0.04,\n    dissolveA * 0.8 + dissolveB * 0.2\n  );\n  float dissolve4 = smoothstep(\n    show1 - 0.01,\n    show1,\n    dissolveA * 0.8 + dissolveB * 0.2\n  );\n\n  // define colors.\n  float h = dissolveA * 0.2 - 0.02;\n  vec3 hsv1 = vec3(\n    h,\n    (glow1A + glow2A) * 0.8 + 0.2,\n    (glow1A + glow2A) * 0.25 + 0.05\n  );\n  vec3 rgb1 = convertHsvToRgb(hsv1);\n\n  // define colors.\n  vec3 hsv2 = vec3(\n    h + (glow1B + glow2B) * 0.1 - 0.05,\n    0.7,\n    (glow1B + glow2B) * 0.7 + 0.22\n  );\n  vec3 rgb2 = convertHsvToRgb(hsv2);\n\n  gl_FragColor = vec4(rgb1 * dissolve1 * (1.0 - dissolve3) * (1.0 - drawBrightOnly) + rgb2 * (1.0 - dissolve2) + rgb2 * dissolve3, 1.0 - dissolve4);\n}\n'
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\nuniform float time;\nuniform float time2;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\nvarying float vTime1;\nvarying float vTime2;\nvarying float vTime3;\nvarying float vTime4;\n\nfloat circularOut(float t) {\n  return sqrt((2.0 - t) * t);\n}\n\nvoid main(void) {\n  // Defined several timers.\n  float timeA = circularOut(clamp(time - 1.0, 0.0, 2.0) / 2.0);\n  float timeB = circularOut(clamp(time - 3.0, 0.0, 2.0) / 2.0);\n\n  // coordinate transformation\n  vec4 mPosition = modelMatrix * vec4(position + vec3(0.0, 0.0, (1.0 - timeA) * 20.0), 1.0);\n\n  vPosition = position;\n  vUv = uv;\n  vTime1 = timeA;\n  vTime2 = timeB;\n  vTime3 = circularOut(smoothstep(0.0, 0.8, time2));\n  vTime4 = circularOut(smoothstep(5.0, 7.0, time2));\n\n  gl_Position = projectionMatrix * viewMatrix * mPosition;\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = 'precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\nuniform sampler2D tex;\nuniform float drawBrightOnly;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\nvarying float vTime1;\nvarying float vTime2;\nvarying float vTime3;\nvarying float vTime4;\n\n//\n// GLSL textureless classic 3D noise "cnoise",\n// with an RSL-style periodic variant "pnoise".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-10-11\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec3 fade(vec3 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise(vec3 P)\n{\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod289(Pi0);\n  Pi1 = mod289(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n  return 2.2 * n_xyz;\n}\n\nvoid main() {\n  vec2 p = vUv * 2.0 - 1.0;\n  vec4 texColor = texture2D(tex, vUv);\n\n  float noise = cnoise(vPosition * vec3(1.6)) * 0.5 + 0.5;\n  float opacity1 = smoothstep(0.0, 0.01, (1.2 - length(p)) + noise * 0.8 + vTime1 * 2.0 - 2.0);\n  float opacity2 = smoothstep(0.0, 0.01, (1.2 - length(p)) + noise * 0.8 + vTime2 * 2.0 - 2.0);\n  float opacity3 = smoothstep(0.0, 0.01, (1.2 - length(p)) + noise * 0.8 + vTime3 * 2.0 - 2.0);\n  float opacity4 = smoothstep(0.0, 0.01, (1.2 - length(p)) + noise * 0.8 + vTime4 * 2.0 - 2.0);\n\n  vec4 color1 = vec4(vec3(1.0, 1.0, 0.9), 0.9) * (opacity1 - opacity2);\n  vec4 color2 = vec4(vec3(1.0, 1.0, 0.9), 0.05) * (opacity2 - opacity3);\n  vec4 color3 = vec4(vec3(0.7, 0.1, 0.1), 0.9) * (opacity3 - opacity4);\n  vec4 color4 = vec4(vec3(1.0, 1.0, 0.9), 0.05) * opacity4;\n\n  if (texColor.a < 0.5) discard;\n  gl_FragColor =\n    (\n      (color1 + color2 + color3 + color4) * (1.0 - drawBrightOnly)\n      + vec4(vec3(0.0), opacity3 - opacity4) * drawBrightOnly\n    )\n    * vec4(vec3(1.0), texColor.a);\n}\n'
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\nattribute vec3 iPosition;\nattribute vec3 iColor;\nattribute vec3 iRotate;\nattribute float iDelay;\n\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\nuniform float time;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\nvarying vec4 vColor;\n\nmat4 calcRotateMat4X(float radian) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, cos(radian), -sin(radian), 0.0,\n    0.0, sin(radian), cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4Y(float radian) {\n  return mat4(\n    cos(radian), 0.0, sin(radian), 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    -sin(radian), 0.0, cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4Z(float radian) {\n  return mat4(\n    cos(radian), -sin(radian), 0.0, 0.0,\n    sin(radian), cos(radian), 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4(vec3 radian) {\n  return calcRotateMat4X(radian.x) * calcRotateMat4Y(radian.y) * calcRotateMat4Z(radian.z);\n}\n\nfloat exponentialOut(float t) {\n  return t == 1.0 ? t : 1.0 - pow(2.0, -10.0 * t);\n}\n\nconst float DURATION = 5.5;\n\nvoid main(void) {\n  float alpha = clamp(time, 0.0, DURATION) / DURATION;\n\n  // coordinate transformation\n  mat4 rotateMat1 = calcRotateMat4(iRotate);\n  mat4 rotateMat2 = calcRotateMat4(vec3(0.0, (time + iDelay) * 14.0, 0.0));\n  vec3 rotate = (rotateMat1 * rotateMat2 * vec4(position, 1.0)).xyz;\n  vec3 move = vec3(0.0, 0.0, exponentialOut(alpha) * 40.0 + time * 4.0);\n  vec4 mPosition = modelMatrix * vec4(iPosition + rotate + move, 1.0);\n\n  float opacity = smoothstep(0.0, 0.05, alpha) * (1.0 - smoothstep(0.9, 1.0, alpha));\n\n  vPosition = position;\n  vUv = uv;\n  vColor = vec4(iColor, opacity);\n\n  gl_Position = projectionMatrix * viewMatrix * mPosition;\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "precision highp float;\n#define GLSLIFY 1\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\nvarying vec4 vColor;\n\nvoid main() {\n  gl_FragColor = vColor;\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform float time;\n\nvarying vec3 vColor;\n\nvec3 convertHsvToRgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat exponentialOut(float t) {\n  return t == 1.0 ? t : 1.0 - pow(2.0, -10.0 * t);\n}\n\nvoid main(void) {\n  vec2 p = uv * 2.0 - 1.0;\n  float show = min(time, 0.2) / 0.2;\n\n  // calculate gradation\n  vec3 hsv = vec3(\n    p.y * 0.1 + 0.07,\n    1.0 - show * 0.2,\n    0.1 + show * 0.8\n  );\n  vec3 rgb = convertHsvToRgb(hsv);\n\n  // coordinate transformation\n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n\n  vColor = rgb;\n\n  gl_Position = projectionMatrix * mvPosition;\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "precision highp float;\n#define GLSLIFY 1\n\nvarying vec3 vColor;\n\nvoid main() {\n  gl_FragColor = vec4(vColor, 1.0);\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n\n  gl_Position = vec4(position, 1.0);\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\nuniform sampler2D texture1;\nuniform sampler2D texture2;\nuniform vec2 resolution;\n\nvarying vec2 vUv;\n\nconst float godrayIteration = 60.0;\nconst float godrayStrength = 24.0;\n\nfloat random2(vec2 c){\n  return fract(sin(dot(c.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\nfloat randomNoise(vec2 p) {\n  return (random2(p - vec2(sin(time))) * 2.0 - 1.0) * 0.02;\n}\n\nvoid main() {\n  // Convert uv to the other vec2 has a range from -1.0 to 1.0.\n  vec2 p = vUv * 2.0 - 1.0;\n  vec2 ratio = 1.0 / resolution;\n\n  // Random Noise\n  float rNoise = randomNoise(vUv);\n\n  // get texture color.\n  vec4 texColor = texture2D(texture1, vUv);\n\n  // godray\n  vec2 godrayCenter = vec2(0.5);\n  vec3 godrayDestColor = vec3(0.0);\n  float godrayTotalWeight = 0.0;\n\n  for (float i = 0.0; i < 60.0; i++) {\n    float alpha = i / godrayIteration; // step in loop [0, 1].\n    float weight = alpha - alpha * alpha; // conic curve [0, 0.25, 0].\n    vec2 shiftUv = vUv - (vUv - godrayCenter) * alpha * godrayStrength / godrayIteration; // define a range of to shift UV.\n    godrayDestColor += texture2D(texture2, shiftUv).rgb * weight; // draw gradation.\n    godrayTotalWeight += weight;\n  }\n  vec3 godray = godrayDestColor / godrayTotalWeight;\n\n  // Sum total of colors.\n  vec3 color = texColor.rgb + rNoise + godray * 0.5;\n\n  gl_FragColor = vec4(color, 1.0);\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = '#define GLSLIFY 1\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\n\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\nuniform mat3 normalMatrix;\nuniform float time;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\n\n//\n// GLSL textureless classic 3D noise "cnoise",\n// with an RSL-style periodic variant "pnoise".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-10-11\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec3 fade(vec3 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise(vec3 P)\n{\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod289(Pi0);\n  Pi1 = mod289(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n  return 2.2 * n_xyz;\n}\n\nvoid main(void) {\n  //\n  float noise = cnoise(position * 0.8 + time * 0.4) * (sin(position.y - time * 0.8) * 1.4 + sin(position.y - time * 2.0) * 0.6) / 2.0;\n  vec3 noisePosition = normalize(position * vec3(1.0, 0.0, 1.0)) * pow(noise, 2.0) * 0.8;\n\n  // coordinate transformation\n  vec4 mvPosition = viewMatrix * modelMatrix * vec4(position + noisePosition, 1.0);\n\n  vPosition = (modelMatrix * vec4(position + noisePosition, 0.0)).xyz;\n  vUv = uv;\n\n  gl_Position = projectionMatrix * mvPosition;\n}\n'
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "precision highp float;\n#define GLSLIFY 1\n\nuniform sampler2D tex;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\n\nvec3 convertHsvToRgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Flat Shading\n  vec3 light = normalize(vec3(0.5, 0.5, 1.0));\n  vec3 normal = normalize(cross(dFdx(vPosition), dFdy(vPosition)));\n  float d = (dot(normal, light) + 1.0) / 2.0;\n  float glow = smoothstep(0.85, 1.0, d);\n  float shadow = d;\n\n  // define colors.\n  vec3 hsv = vec3(0.13, 1.0 - glow * 0.8, (shadow + glow * 6.0) / 8.0);\n  vec3 rgb = convertHsvToRgb(hsv);\n\n  vec4 texColor = texture2D(tex, vUv);\n  gl_FragColor = vec4(rgb, 1.0) * texColor;\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\nattribute vec3 iPosition;\nattribute vec2 iUv;\nattribute float iId;\nattribute float iTime;\nattribute float iIsAnimated;\nattribute float iScale;\nattribute float iMove;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform float time;\nuniform float unitUv;\nuniform float duration;\n\nvarying vec3 vPositionNoise;\nvarying vec2 vUv;\nvarying vec2 vUvBase;\nvarying float vOpacity;\nvarying float vStep;\n\nmat4 calcScaleMat4(vec3 scale) {\n  return mat4(\n    scale.x, 0.0, 0.0, 0.0,\n    0.0, scale.y, 0.0, 0.0,\n    0.0, 0.0, scale.z, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4X(float radian) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, cos(radian), -sin(radian), 0.0,\n    0.0, sin(radian), cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4Y(float radian) {\n  return mat4(\n    cos(radian), 0.0, sin(radian), 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    -sin(radian), 0.0, cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4Z(float radian) {\n  return mat4(\n    cos(radian), -sin(radian), 0.0, 0.0,\n    sin(radian), cos(radian), 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4(vec3 radian) {\n  return calcRotateMat4X(radian.x) * calcRotateMat4Y(radian.y) * calcRotateMat4Z(radian.z);\n}\n\nvoid main(void) {\n  vec3 move = vec3(0.0, iTime / duration * iMove, 0.0);\n  mat4 scaleMat = calcScaleMat4(vec3(iScale));\n  mat4 rotateMat = calcRotateMat4(vec3(\n    radians(sin(time * 0.3 + iId * 30.0) * 30.0),\n    radians(cos(time * 0.3 + iId * 30.0) * 45.0),\n    radians(cos(time * 0.3 + iId * 30.0) * 30.0)\n  ));\n  vec3 updatePosition = (rotateMat * scaleMat * vec4(position, 1.0)).xyz;\n\n  // coordinate transformation\n  vec4 mvPosition = modelViewMatrix * vec4(iPosition + move + updatePosition, 1.0);\n\n  vPositionNoise = position + iId;\n  vUv = uv * unitUv + iUv;\n  vUvBase = uv;\n  vOpacity = iIsAnimated;\n  vStep = iTime / duration;\n\n  gl_Position = projectionMatrix * mvPosition;\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = 'precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\nuniform sampler2D texHannyaShingyo;\n\nvarying vec3 vPositionNoise;\nvarying vec2 vUv;\nvarying vec2 vUvBase;\nvarying float vOpacity;\nvarying float vStep;\n\n//\n// GLSL textureless classic 3D noise "cnoise",\n// with an RSL-style periodic variant "pnoise".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-10-11\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec3 fade(vec3 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise(vec3 P)\n{\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod289(Pi0);\n  Pi1 = mod289(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n  return 2.2 * n_xyz;\n}\n\nvec3 convertHsvToRgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // coordinate tex color.\n  vec4 texColor = texture2D(texHannyaShingyo, vUv);\n\n  // coordinate cross fade alpha value with delay.\n  float dRange = 0.1;\n  float crossFadeDelay = vUvBase.y * dRange;\n  float crossFade = smoothstep(crossFadeDelay, crossFadeDelay + 0.3, vStep)\n    * (1.0 - smoothstep(crossFadeDelay + 0.7 - dRange, crossFadeDelay + 1.0 - dRange, vStep));\n\n  // dissolve effect.\n  float noise1 = cnoise(vec3(vPositionNoise * 0.7));\n  float noise2 = cnoise(vec3(vPositionNoise * 1.8));\n  float noiseAll = (noise1 * 2.0 + noise2 * 0.4) / 2.4;\n  float noise = (noiseAll * 0.5 + 0.5) + (crossFade * 2.0 - 1.0);\n  float disolveMask = smoothstep(0.28, 0.3, noise);\n  vec4 disolve = vec4(convertHsvToRgb(vec3(0.13, 0.9, 0.75)), 1.0) * disolveMask;\n  float disolveEdgeMask = smoothstep(0.0, 0.02, noise) * (1.0 - smoothstep(0.28, 0.3, noise));\n  vec4 disolveEdge = vec4(convertHsvToRgb(vec3(0.13, 0.4, 1.0)), 1.0) * disolveEdgeMask;\n\n  // glow\n  float glow = cnoise(vPositionNoise * 0.25 + time) * 0.5;\n\n  gl_FragColor = (disolve + disolveEdge + vec4(vec3(glow), 0.0)) * vOpacity * texColor.a;\n}\n'
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\n\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\nuniform mat3 normalMatrix;\nuniform float time;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\nvarying float vOpacity;\n\nvoid main(void) {\n  vec2 p = uv * 2.0 - 1.0;\n\n  // wave motion.\n  float force = pow(smoothstep(0.0, 0.5, length(p)) * (1.0 - smoothstep(0.5, 1.0, length(p))), 2.0) * 1.8;\n  vec3 wave = vec3(0.0, 0.0, (sin(-time * 4.0 + length(p.xy) * 24.0) * 0.5 + 0.5) * force);\n\n  // coordinate transformation\n  vec3 updatePosition = position + wave;\n  vec4 mvPosition = viewMatrix * modelMatrix * vec4(updatePosition, 1.0);\n\n  vPosition = updatePosition;\n  vUv = uv;\n  vOpacity = 1.0 - smoothstep(0.9, 1.0, length(p));\n\n  gl_Position = projectionMatrix * mvPosition;\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "precision highp float;\n#define GLSLIFY 1\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\nvarying float vOpacity;\n\nvec3 convertHsvToRgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Flat Shading\n  vec3 light = normalize(vec3(0.5, 0.5, 1.0));\n  vec3 normal = normalize(cross(dFdx(vPosition), dFdy(vPosition)));\n  float diff = (dot(normal, light) + 1.0) / 2.0;\n  float glow = smoothstep(0.9, 1.0, diff);\n\n  vec3 hsv = vec3(0.13, 1.0 - glow * 0.8, 0.05 + glow * 0.95);\n  vec3 rgb = convertHsvToRgb(hsv);\n\n  gl_FragColor = vec4(rgb, vOpacity);\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nattribute vec3 position;\nattribute float delay1;\nattribute float delay2;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform float time;\n\nvarying vec3 vColor;\nvarying float vOpacity;\n\nvec3 convertHsvToRgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nconst float duration = 120.0;\n\nvoid main() {\n  // Loop animation\n  float interval = mod(time + delay1, duration) / duration;\n  vec3 move = vec3(\n    cos(time * 0.5 + delay1) * 2.0,\n    interval * 100.0,\n    sin(time * 0.5 + delay2) * 2.0\n    );\n\n  // calculate gradation with position.y\n  vec3 hsv = vec3(0.14, 0.65, 0.85);\n  vec3 rgb = convertHsvToRgb(hsv);\n\n  // calculate opacity.\n  float fadeIn = smoothstep(0.0, 10.0, move.y);\n  float blink = sin(time * 0.1 + delay2);\n\n  // coordinate transformation\n  vec4 mvPosition = modelViewMatrix * vec4(position + move, 1.0);\n  float distanceFromCamera = 1000.0 / length(mvPosition.xyz);\n\n  vColor = rgb;\n  vOpacity = fadeIn * blink;\n\n  gl_Position = projectionMatrix * mvPosition;\n  gl_PointSize = distanceFromCamera;\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "precision highp float;\n#define GLSLIFY 1\n\nvarying vec3 vColor;\nvarying float vOpacity;\n\nvoid main() {\n  // Convert PointCoord to a range from -1.0 to 1.0\n  vec2 p = gl_PointCoord * 2.0 - 1.0;\n\n  // Draw double circle\n  float radius = length(p);\n  float opacity = (1.0 - smoothstep(0.2, 1.0, radius)) * vOpacity;\n\n  gl_FragColor = vec4(vColor, opacity);\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = '#define GLSLIFY 1\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\n\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\nuniform float time;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\nvarying float vOpacity;\n\nfloat quadraticOut(float t) {\n  return -t * (t - 2.0);\n}\n\n//\n// GLSL textureless classic 3D noise "cnoise",\n// with an RSL-style periodic variant "pnoise".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-10-11\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec3 fade(vec3 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise(vec3 P)\n{\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod289(Pi0);\n  Pi1 = mod289(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n  return 2.2 * n_xyz;\n}\n\nvoid main(void) {\n  vec2 p = uv * 2.0 - 1.0;\n\n  float circle = quadraticOut(clamp(1.0 - length(p), 0.0, 1.0));\n  float noise = cnoise(position * 0.05 + vec3(0.0, 0.0, time) * 0.1);\n  vec3 noisePosition = normalize(position) * noise * 0.0;\n\n  float noiseA = cnoise(vec3(p.x + cos(time), length(p) * 20.0, p.y + sin(time)));\n\n  // coordinate transformation\n  vec3 updatePosition = noisePosition + position;\n  vec4 mPosition = modelMatrix * vec4(updatePosition, 1.0);\n  vec4 mvPosition = viewMatrix * mPosition;\n\n  vPosition = updatePosition;\n  vUv = uv;\n  vOpacity = circle * noiseA * 2.0;\n\n  gl_Position = projectionMatrix * mvPosition;\n}\n'
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "precision highp float;\n#define GLSLIFY 1\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\nvarying float vOpacity;\n\nvec3 convertHsvToRgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  vec3 hsv = vec3(0.13, 0.3, 1.0);\n  vec3 rgb = convertHsvToRgb(hsv);\n\n  gl_FragColor = vec4(rgb, vOpacity);\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform float time;\n\nvarying vec3 vColor;\n\nvec3 convertHsvToRgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main(void) {\n  vec2 p = uv * 2.0 - 1.0;\n  // calculate gradation\n  vec3 hsv = vec3(0.13, 0.8, p.y * 0.8 + 0.04);\n  vec3 rgb = convertHsvToRgb(hsv);\n\n  // coordinate transformation\n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n\n  vColor = rgb;\n\n  gl_Position = projectionMatrix * mvPosition;\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "precision highp float;\n#define GLSLIFY 1\n\nvarying vec3 vColor;\n\nvoid main() {\n  gl_FragColor = vec4(vColor, 1.0);\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n\n  gl_Position = vec4(position, 1.0);\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\nuniform sampler2D texture;\nuniform vec2 resolution;\n\nvarying vec2 vUv;\n\nconst float godrayIteration = 60.0;\nconst float godrayStrength = 20.0;\n\nfloat random2(vec2 c){\n  return fract(sin(dot(c.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\nfloat randomNoise(vec2 p) {\n  return (random2(p - vec2(sin(time))) * 2.0 - 1.0) * 0.04;\n}\n\nvoid main() {\n  // Convert uv to the other vec2 has a range from -1.0 to 1.0.\n  vec2 p = vUv * 2.0 - 1.0;\n  vec2 ratio = 1.0 / resolution;\n\n  // Random Noise\n  float rNoise = randomNoise(vUv);\n\n  // RGB Shift\n  float texColorR = texture2D(texture, vUv - vec2((2.0 * abs(p.x) + 1.0) * ratio.x, 0.0)).r;\n  float texColorG = texture2D(texture, vUv + vec2((2.0 * abs(p.x) + 1.0) * ratio.x, 0.0)).g;\n  float texColorB = texture2D(texture, vUv).b;\n\n  // godray\n  vec2 godrayCenter = vec2(0.5);\n  vec3 godrayDestColor = vec3(0.0);\n  float godrayTotalWeight = 0.0;\n\n  for (float i = 0.0; i < 60.0; i++) {\n    float alpha = i / godrayIteration; // step in loop [0, 1].\n    float weight = alpha - alpha * alpha; // conic curve [0, 0.25, 0].\n    vec2 shiftUv = vUv - (vUv - godrayCenter) * alpha * godrayStrength / godrayIteration; // define a range of to shift UV.\n    godrayDestColor += texture2D(texture, shiftUv).rgb * weight; // draw gradation.\n    godrayTotalWeight += weight;\n  }\n  vec3 godray = godrayDestColor / godrayTotalWeight;\n\n  // Sum total of colors.\n  vec3 color = vec3(texColorR, texColorG, texColorB) + rNoise + godray;\n\n  gl_FragColor = vec4(color, 1.0);\n}\n"
}, function(e, t, n) {
    "use strict";

    function r(e, t, n, r, i, o, a) {
        try {
            var s = e[o](a),
                c = s.value
        } catch (e) {
            return void n(e)
        }
        s.done ? t(c) : Promise.resolve(c).then(r, i)
    }
    n.r(t);
    var i = n(0),
        o = n(3),
        a = n(1),
        s = n(406).default,
        c = n(409).default,
        u = n(412).default,
        l = n(415).default,
        f = n(418).default;

    function d() {
        var e;
        return e = regeneratorRuntime.mark((function e() {
            var t, n, r, d, h, v, p, m, y, g, x, b, w, M, _, S, P;
            return regeneratorRuntime.wrap((function(e) {
                for (;;) switch (e.prev = e.next) {
                    case 0:
                        return t = new i.Vector2, n = document.getElementById("canvas-webgl"), r = new i.WebGLRenderer({
                            alpha: !0,
                            antialias: !0,
                            canvas: n
                        }), d = new i.Scene, h = new i.PerspectiveCamera, v = new i.Clock({
                            autoStart: !1
                        }), p = Math.random(), m = new s(p), y = new c(p), g = new u, x = new l(p), b = new i.Group, w = new f(t), M = function() {
                            var e = v.getDelta();
                            w.render(t), b.rotation.set(a.radians(w.v.y), a.radians(w.v.x), 0), m.render(e), y.render(e), g.render(e), x.render(e), r.render(d, h)
                        }, _ = function e() {
                            M(), requestAnimationFrame(e)
                        }, S = function() {
                            h.aspect = t.x / t.y, h.updateProjectionMatrix(), h.setFocalLength(15 * a.step(1, t.y / t.x) + 35)
                        }, P = function() {
                            t.set(document.body.clientWidth, window.innerHeight), n.width = t.x, n.height = t.y, S(), r.setSize(t.x, t.y)
                        }, T = void 0, E = void 0, z = void 0, T = function(e) {
                            w.touchStart(e)
                        }, E = function(e) {
                            w.touchMove(e)
                        }, z = function(e) {
                            w.touchEnd(e)
                        }, n.addEventListener("mousedown", T, {
                            passive: !1
                        }), window.addEventListener("mousemove", E, {
                            passive: !1
                        }), window.addEventListener("mouseup", z), n.addEventListener("touchstart", T, {
                            passive: !1
                        }), window.addEventListener("touchmove", E, {
                            passive: !1
                        }), window.addEventListener("touchend", z), window.addEventListener("resize", o(P, 1e3)), P(), r.setClearColor(15658734, 1), h.far = 1e3, h.setFocalLength(15 * a.step(1, t.y / t.x) + 35), h.position.set(0, 0, 300), h.lookAt(new i.Vector3(0, 0, 0)), m.createObj(), y.createObj(), g.createObj(), x.createObj(), b.add(m.obj), b.add(y.obj), b.add(g.obj), d.add(b), d.add(x.obj), v.start(), _(), e.abrupt("return");
                    case 37:
                    case "end":
                        return e.stop()
                }
                var T, E, z
            }), e)
        })), (d = function() {
            var t = this,
                n = arguments;
            return new Promise((function(i, o) {
                var a = e.apply(t, n);

                function s(e) {
                    r(a, i, o, s, c, "next", e)
                }

                function c(e) {
                    r(a, i, o, s, c, "throw", e)
                }
                s(void 0)
            }))
        }).apply(this, arguments)
    }
    t.default = function() {
        return d.apply(this, arguments)
    }
}, function(e, t, n) {
    "use strict";

    function r(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }
    n.r(t), n.d(t, "default", (function() {
        return s
    }));
    var i = n(0),
        o = n(1),
        a = n(145),
        s = function() {
            function e(t) {
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, e), this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    },
                    addH1: {
                        type: "f",
                        value: t
                    },
                    addH2: {
                        type: "f",
                        value: t - .5
                    }
                }, this.obj
            }
            var t, s, c;
            return t = e, (s = [{
                key: "createObj",
                value: function() {
                    for (var e = new a(Math.random), t = new i.OctahedronBufferGeometry(50, 5), r = 0; r < t.attributes.position.count; r++) {
                        var s = new i.Vector3(t.attributes.position.getX(r), t.attributes.position.getY(r), t.attributes.position.getZ(r)),
                            c = e.noise4D(s.x / 72, s.y / 64, s.z / 72, 1),
                            u = e.noise4D(s.x / 28, s.y / 24, s.z / 28, 1),
                            l = e.noise4D(s.x / 4, s.y / 4, s.z / 4, 1),
                            f = (2 * o.smoothstep(-.05, .05, c + u) - 1) * (2 + 2 * o.smoothstep(.1, .2, Math.pow(c + u, 2)) + 6 * o.smoothstep(.6, .7, Math.pow(c + u, 2)) + .2 * l);
                        s.add(s.clone().normalize().multiplyScalar(f)), t.attributes.position.setXYZ(r, s.x, s.y, s.z)
                    }
                    var d = new i.RawShaderMaterial({
                        uniforms: this.uniforms,
                        vertexShader: n(407).default,
                        fragmentShader: n(408).default,
                        flatShading: !0
                    });
                    this.obj = new i.Mesh(t, d)
                }
            }, {
                key: "render",
                value: function(e) {
                    this.uniforms.time.value += e
                }
            }]) && r(t.prototype, s), c && r(t, c), e
        }()
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\n\nvarying vec3 vMPosition;\nvarying float vHeight;\n\nvoid main(void) {\n  // coordinate transformation\n  vec4 mPosition = modelMatrix * vec4(position, 1.0);\n\n  vHeight = length(position);\n  vMPosition = mPosition.xyz;\n\n  gl_Position = projectionMatrix * viewMatrix * mPosition;\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "precision highp float;\n#define GLSLIFY 1\n\nuniform float addH1;\nuniform float addH2;\n\nvarying vec3 vMPosition;\nvarying float vHeight;\n\nvec3 convertHsvToRgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nconst float edge1 = 56.0;\nconst float edge2 = 52.0;\nconst float edge3 = 50.0;\nconst float range = 2.0;\n\nvoid main() {\n  // Flat Shading\n  vec3 light = normalize(vec3(-1.0, 1.0, 1.0));\n  vec3 normal = normalize(cross(dFdx(vMPosition), dFdy(vMPosition)));\n  float diff = (dot(normal, light) + 1.0) / 2.0;\n\n  float stepTop     = smoothstep(edge1, edge1 + range, vHeight);\n  float stepMiddle1 = smoothstep(edge2, edge2 + range, vHeight) * (1.0 - smoothstep(edge1, edge1 + range, vHeight));\n  float stepMiddle2 = smoothstep(edge3, edge3 + range, vHeight) * (1.0 - smoothstep(edge2, edge2 + range, vHeight));\n  float stepBottom  = 1.0 - smoothstep(edge3, edge3 + range, vHeight);\n\n  vec4 colorTop     = vec4(convertHsvToRgb(vec3(0.25 + addH1, 0.05, 1.0)), 1.0) * stepTop;\n  vec4 colorMiddle1 = vec4(convertHsvToRgb(vec3(0.25 + addH2, 0.05, 1.0)), 1.0) * stepMiddle1;\n  vec4 colorMiddle2 = vec4(convertHsvToRgb(vec3(0.25 + addH2, 0.1, 0.9)), 1.0) * stepMiddle2;\n  vec4 colorBottom  = vec4(convertHsvToRgb(vec3(0.25 + addH1, 0.1, 0.9)), 1.0) * stepBottom;\n\n  vec4 colorAll = (colorTop + colorMiddle1 + colorMiddle2 + colorBottom) * diff;\n\n  gl_FragColor = colorAll;\n}\n"
}, function(e, t, n) {
    "use strict";

    function r(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }
    n.r(t), n.d(t, "default", (function() {
        return o
    }));
    var i = n(0),
        o = (n(1), function() {
            function e(t) {
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, e), this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    },
                    addH: {
                        type: "f",
                        value: t
                    }
                }, this.obj
            }
            var t, o, a;
            return t = e, (o = [{
                key: "createObj",
                value: function() {
                    var e = new i.OctahedronBufferGeometry(50, 5),
                        t = new i.RawShaderMaterial({
                            uniforms: this.uniforms,
                            vertexShader: n(410).default,
                            fragmentShader: n(411).default,
                            flatShading: !0,
                            transparent: !0
                        });
                    this.obj = new i.Mesh(e, t)
                }
            }, {
                key: "render",
                value: function(e) {
                    this.uniforms.time.value += e
                }
            }]) && r(t.prototype, o), a && r(t, a), e
        }())
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\nuniform float time;\n\nvarying vec3 vPosition;\nvarying float vSinAll;\n\nmat4 calcTranslateMat4(vec3 v) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    v.x, v.y, v.z, 1.0\n  );\n}\n\nvoid main(void) {\n  float sin1 = sin(time + position.x / 16.0);\n  float sin2 = sin(time + position.y / 8.0);\n  float sin3 = sin(time - length(position.xy + 50.0) / 4.0);\n  float sinAll = (sin1 + sin2 * 0.5 + sin3 * 0.2) / 1.7;\n  mat4 waveMat = calcTranslateMat4(vec3(0.0, 0.0, sinAll * 1.5));\n\n  // coordinate transformation\n  vec4 mPosition = modelMatrix * waveMat * vec4(position, 1.0);\n\n  vPosition = mPosition.xyz;\n  vSinAll = sinAll;\n\n  gl_Position = projectionMatrix * viewMatrix * mPosition;\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "precision highp float;\n#define GLSLIFY 1\n\nuniform float addH;\n\nvarying vec3 vPosition;\nvarying float vSinAll;\n\nvec3 convertHsvToRgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Flat Shading\n  vec3 light = normalize(vec3(-1.0, 1.0, 1.0));\n  vec3 normal = normalize(cross(dFdx(vPosition), dFdy(vPosition)));\n  float diff = (dot(normal, light) + 1.0) / 2.0;\n\n  vec4 color = vec4(convertHsvToRgb(vec3(0.2 + vSinAll * 0.08 + addH, 0.4, 1.0)), 0.8);\n\n  gl_FragColor = color * vec4(vec3(diff), 1.0);\n}\n"
}, function(e, t, n) {
    "use strict";

    function r(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }
    n.r(t), n.d(t, "default", (function() {
        return a
    }));
    var i = n(0),
        o = n(1),
        a = function() {
            function e() {
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, e), this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    }
                }, this.obj
            }
            var t, a, s;
            return t = e, (a = [{
                key: "createObj",
                value: function() {
                    var e = new i.InstancedBufferGeometry,
                        t = new i.BoxBufferGeometry(2, 2, 20, 2, 2, 6);
                    e.copy(t);
                    for (var r = new i.InstancedBufferAttribute(new Float32Array(120), 3), a = new i.InstancedBufferAttribute(new Float32Array(120), 3), s = new i.InstancedBufferAttribute(new Float32Array(120), 3), c = new i.InstancedBufferAttribute(new Float32Array(40), 1), u = 0; u < 40; u++) {
                        var l = o.radians(30 * (2 * Math.random() - 1)),
                            f = o.radians(180 * (2 * Math.random() - 1)),
                            d = o.spherical(l, f, 12 * Math.random() + 65);
                        r.setXYZ(u, d[0], d[1], d[2]), a.setXYZ(u, 0, f, -l), s.setXYZ(u, 1, .2 * Math.random() + 1, .4 * Math.random() + .8), c.setXYZ(u, .05 * Math.random() + .01)
                    }
                    e.addAttribute("instancePosition", r), e.addAttribute("instanceRotate", a), e.addAttribute("instanceScale", s), e.addAttribute("speed", c);
                    var h = new i.RawShaderMaterial({
                        uniforms: this.uniforms,
                        vertexShader: n(413).default,
                        fragmentShader: n(414).default,
                        flatShading: !0
                    });
                    this.obj = new i.Mesh(e, h), this.obj.frustumCulled = !1
                }
            }, {
                key: "render",
                value: function(e) {
                    this.uniforms.time.value += e
                }
            }]) && r(t.prototype, a), s && r(t, s), e
        }()
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec3 instancePosition;\nattribute vec3 instanceRotate;\nattribute vec3 instanceScale;\nattribute float speed;\nattribute vec2 uv;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform float time;\n\nvarying vec3 vPosition;\n\nmat4 calcTranslateMat4(vec3 v) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    v.x, v.y, v.z, 1.0\n  );\n}\n\nmat4 calcRotateMat4X(float radian) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, cos(radian), -sin(radian), 0.0,\n    0.0, sin(radian), cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4Y(float radian) {\n  return mat4(\n    cos(radian), 0.0, sin(radian), 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    -sin(radian), 0.0, cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4Z(float radian) {\n  return mat4(\n    cos(radian), -sin(radian), 0.0, 0.0,\n    sin(radian), cos(radian), 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4(vec3 radian) {\n  return calcRotateMat4X(radian.x) * calcRotateMat4Y(radian.y) * calcRotateMat4Z(radian.z);\n}\n\nmat4 calcScaleMat4(vec3 scale) {\n  return mat4(\n    scale.x, 0.0, 0.0, 0.0,\n    0.0, scale.y, 0.0, 0.0,\n    0.0, 0.0, scale.z, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\nfloat exponentialOut(float t) {\n  return t == 1.0 ? t : 1.0 - pow(2.0, -10.0 * t);\n}\n\nvoid main(void) {\n  // added Noise to form like a cloud.\n  float noise = snoise(position + instancePosition);\n  vec3 noiseEasePos = normalize(vec3(position.x, position.y, 0.01)) * exponentialOut(1.0 - abs(position.z / 10.0)) * vec3(0.4, 1.0, 1.0);\n  vec3 noisePosition = (noise + 1.0) / 2.0 * noiseEasePos * 3.0 + noiseEasePos * 1.0;\n\n  // coordinate transformation\n  mat4 translateMat = calcTranslateMat4(instancePosition);\n  mat4 rotateMat = calcRotateMat4(instanceRotate);\n  mat4 scaleMat = calcScaleMat4(instanceScale);\n  mat4 worldRotateMat = calcRotateMat4(vec3(0.0, -time * speed, 0.0));\n  vec4 mvPosition = modelViewMatrix * worldRotateMat * translateMat * rotateMat * scaleMat * vec4(position + noisePosition, 1.0);\n\n  vPosition = mvPosition.xyz;\n\n  gl_Position = projectionMatrix * mvPosition;\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "precision highp float;\n#define GLSLIFY 1\n\nvarying vec3 vPosition;\n\nvec3 convertHsvToRgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Flat Shading\n  vec3 light = normalize(vec3(-1.0, 1.0, 1.0));\n  vec3 normal = normalize(cross(dFdx(vPosition), dFdy(vPosition)));\n  float diff = (dot(normal, light) + 1.0) / 2.0;\n\n  vec3 hsv = vec3(0.0, 0.0, 0.8 + diff * 0.2);\n  vec3 rgb = convertHsvToRgb(hsv);\n\n  gl_FragColor = vec4(rgb, 1.0);\n}\n"
}, function(e, t, n) {
    "use strict";

    function r(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }
    n.r(t), n.d(t, "default", (function() {
        return o
    }));
    var i = n(0),
        o = (n(1), function() {
            function e(t) {
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, e), this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    },
                    addH: {
                        type: "f",
                        value: t + .3
                    }
                }, this.obj
            }
            var t, o, a;
            return t = e, (o = [{
                key: "createObj",
                value: function() {
                    var e = new i.SphereBufferGeometry(200, 128, 128),
                        t = new i.RawShaderMaterial({
                            uniforms: this.uniforms,
                            vertexShader: n(416).default,
                            fragmentShader: n(417).default,
                            side: i.BackSide
                        });
                    this.obj = new i.Mesh(e, t)
                }
            }, {
                key: "render",
                value: function(e) {
                    this.uniforms.time.value += e
                }
            }]) && r(t.prototype, o), a && r(t, a), e
        }())
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform float addH;\n\nvarying vec3 vColor;\n\nvec3 convertHsvToRgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main(void) {\n  // calculate gradation with position.y\n  vec3 hsv1 = vec3(addH + 0.22, 0.12, 0.96);\n  vec3 hsv2 = vec3(addH - 0.22, 0.12, 0.96);\n  vec3 rgb = convertHsvToRgb(mix(hsv1, hsv2, (normalize(position).y + 1.0) / 2.0));\n\n  // coordinate transformation\n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n\n  vColor = rgb;\n\n  gl_Position = projectionMatrix * mvPosition;\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\nuniform sampler2D tex;\n\nvarying vec3 vColor;\n\nvoid main() {\n  gl_FragColor = vec4(vColor, 1.0);\n}\n"
}, function(e, t, n) {
    "use strict";

    function r(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }
    n.r(t), n.d(t, "default", (function() {
        return a
    }));
    var i = n(0),
        o = n(1),
        a = function() {
            function e(t) {
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, e), this.resolution = t, this.vTouchStart = new i.Vector2, this.vPrev = new i.Vector2, this.v = new i.Vector2, this.a = new i.Vector2, this.anchor = new i.Vector2, this.isTouched = !1
            }
            var t, n, a;
            return t = e, (n = [{
                key: "touchStart",
                value: function(e) {
                    e.touches || e.preventDefault(), this.vPrev.copy(this.v), this.a.set(0, 0), this.vTouchStart.set(e.touches ? e.touches[0].clientX : e.clientX, e.touches ? e.touches[0].clientY : e.clientY), this.isTouched = !0
                }
            }, {
                key: "touchMove",
                value: function(e) {
                    e.preventDefault();
                    var t = e.touches ? e.touches[0].clientX : e.clientX,
                        n = e.touches ? e.touches[0].clientY : e.clientY;
                    !1 !== this.isTouched && this.anchor.set((t - this.vTouchStart.x) / (this.resolution.x / 200) + this.vPrev.x, o.clamp((n - this.vTouchStart.y) / (this.resolution.y / 200) + this.vPrev.y, -90, 90))
                }
            }, {
                key: "touchEnd",
                value: function(e) {
                    this.isTouched = !1
                }
            }, {
                key: "render",
                value: function() {
                    this.a.set((this.anchor.x - this.v.x) / 10, (this.anchor.y - this.v.y) / 10), this.v.add(this.a)
                }
            }]) && r(t.prototype, n), a && r(t, a), e
        }()
}, function(e, t, n) {
    "use strict";
    n.r(t);
    var r = n(0),
        i = n(3),
        o = n(1),
        a = n(420).default,
        s = n(423).default,
        c = n(426).default;
    t.default = function() {
        var e = new r.Vector2,
            t = document.getElementById("canvas-webgl"),
            n = new r.WebGLRenderer({
                alpha: !0,
                antialias: !0,
                canvas: t
            }),
            u = new r.Scene,
            l = new r.PerspectiveCamera,
            f = new r.Clock({
                autoStart: !1
            });
        l.far = 1e3, l.setFocalLength(50);
        var d, h, v, p = Math.random(),
            m = new a(p),
            y = new s(p),
            g = new r.Group,
            x = new c,
            b = function() {
                e.set(document.body.clientWidth, window.innerHeight), t.width = e.x, t.height = e.y, l.aspect = e.x / e.y, l.updateProjectionMatrix(), n.setSize(e.x, e.y)
            };
        n.setClearColor(15658734, 1), l.position.set(0, 0, 300), l.lookAt(new r.Vector3(0, 0, 0)), m.createObj(), y.createObj(), g.add(m.obj), g.add(y.obj), u.add(g), d = function(e) {
                x.touchStart(e)
            }, h = function(e) {
                x.touchMove(e)
            }, v = function(e) {
                x.touchEnd(e)
            }, t.addEventListener("mousedown", d, {
                passive: !1
            }), window.addEventListener("mousemove", h, {
                passive: !1
            }), window.addEventListener("mouseup", v), t.addEventListener("touchstart", d, {
                passive: !1
            }), window.addEventListener("touchmove", h, {
                passive: !1
            }), window.addEventListener("touchend", v), window.addEventListener("resize", i(b, 1e3)), b(), f.start(),
            function t() {
                var r;
                r = f.getDelta(), x.render(e), g.rotation.set(o.radians(x.v.y / e.x * 1e3 + 45), o.radians(x.v.x / e.y * 1e3 - 30), 0), m.render(r), y.render(r), n.render(u, l), requestAnimationFrame(t)
            }()
    }
}, function(e, t, n) {
    "use strict";

    function r(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }
    n.r(t), n.d(t, "default", (function() {
        return s
    }));
    var i = n(0),
        o = n(1),
        a = n(145),
        s = function() {
            function e(t) {
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, e), this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    },
                    addH1: {
                        type: "f",
                        value: t - .5
                    },
                    addH2: {
                        type: "f",
                        value: t
                    }
                }, this.obj
            }
            var t, s, c;
            return t = e, (s = [{
                key: "createObj",
                value: function() {
                    for (var e = new a(Math.random), t = new i.BoxBufferGeometry(100, 5, 100, 60, 1, 60), r = 0; r < t.attributes.position.count; r++) {
                        var s = t.attributes.position.getX(r),
                            c = t.attributes.position.getY(r),
                            u = t.attributes.position.getZ(r),
                            l = 48 * (.75 * e.noise4D(s / 80, c / 80, u / 80, 1) + .25) + 18 * e.noise4D(s / 48, c / 32, u / 32, 1) + 1.2 * e.noise4D(s / 6, c / 6, u / 6, 1) + .6 * e.noise4D(s / 2, c / 2, u / 2, 1),
                            f = function(e, t, n) {
                                if (!(e >= t)) {
                                    var r = o.clamp((n - e) / (t - e), 0, 1);
                                    return r * r * (3 - 2 * r)
                                }
                            }(0, 5, l),
                            d = function(e, t) {
                                return t >= e ? 1 : 0
                            }(0, c);
                        t.attributes.position.setY(r, (c + l * f) * d)
                    }
                    var h = new i.RawShaderMaterial({
                        uniforms: this.uniforms,
                        vertexShader: n(421).default,
                        fragmentShader: n(422).default,
                        flatShading: !0
                    });
                    this.obj = new i.Mesh(t, h)
                }
            }, {
                key: "render",
                value: function(e) {
                    this.uniforms.time.value += e
                }
            }]) && r(t.prototype, s), c && r(t, c), e
        }()
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\n\nvarying vec3 vPosition;\nvarying vec3 vMPosition;\nvarying vec2 vUv;\n\nvoid main(void) {\n  // coordinate transformation\n  vec4 mPosition = modelMatrix * vec4(position, 1.0);\n\n  vPosition = position;\n  vMPosition = mPosition.xyz;\n  vUv = uv;\n\n  gl_Position = projectionMatrix * viewMatrix * mPosition;\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "precision highp float;\n#define GLSLIFY 1\n\nuniform float addH1;\nuniform float addH2;\n\nvarying vec3 vPosition;\nvarying vec3 vMPosition;\nvarying vec2 vUv;\n\nvec3 convertHsvToRgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nconst float edge1 = 48.0;\nconst float edge2 = 24.0;\nconst float edge3 = 8.0;\nconst float range = 14.0;\n\nvoid main() {\n  // Flat Shading\n  vec3 light = normalize(vec3(-1.0, 1.0, 1.0));\n  vec3 normal = normalize(cross(dFdx(vMPosition), dFdy(vMPosition)));\n  float diff = (dot(normal, light) + 1.0) / 2.0;\n\n  float stepTop     = smoothstep(edge1, edge1 + range, vPosition.y);\n  float stepMiddle1 = smoothstep(edge2, edge2 + range, vPosition.y) * (1.0 - smoothstep(edge1, edge1 + range, vPosition.y));\n  float stepMiddle2 = smoothstep(edge3, edge3 + range, vPosition.y) * (1.0 - smoothstep(edge2, edge2 + range, vPosition.y));\n  float stepBottom  = 1.0 - smoothstep(edge3, edge3 + range, vPosition.y);\n\n  vec4 colorTop     = vec4(convertHsvToRgb(vec3( 0.1 + addH1, 0.1, 0.8)), 1.0) * stepTop;\n  vec4 colorMiddle1 = vec4(convertHsvToRgb(vec3(0.25 + addH2, 0.4, 0.6)), 1.0) * stepMiddle1;\n  vec4 colorMiddle2 = vec4(convertHsvToRgb(vec3(0.25 + addH2, 0.25, 0.8)), 1.0) * stepMiddle2;\n  vec4 colorBottom  = vec4(convertHsvToRgb(vec3( 0.1 + addH1, 0.4, 0.3)), 1.0) * stepBottom;\n\n  vec4 colorAll = (colorTop + colorMiddle1 + colorMiddle2 + colorBottom) * diff;\n\n  gl_FragColor = colorAll;\n}\n"
}, function(e, t, n) {
    "use strict";

    function r(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }
    n.r(t), n.d(t, "default", (function() {
        return a
    }));
    var i = n(0),
        o = n(1),
        a = function() {
            function e(t) {
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, e), this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    },
                    addH: {
                        type: "f",
                        value: t - .5
                    }
                }, this.obj
            }
            var t, a, s;
            return t = e, (a = [{
                key: "createObj",
                value: function() {
                    var e = new i.PlaneBufferGeometry(100, 100, 60, 60),
                        t = new i.RawShaderMaterial({
                            uniforms: this.uniforms,
                            vertexShader: n(424).default,
                            fragmentShader: n(425).default,
                            flatShading: !0,
                            transparent: !0
                        });
                    this.obj = new i.Mesh(e, t), this.obj.translateY(8), this.obj.rotation.set(o.radians(-90), 0, 0)
                }
            }, {
                key: "render",
                value: function(e) {
                    this.uniforms.time.value += e
                }
            }]) && r(t.prototype, a), s && r(t, s), e
        }()
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\nuniform float time;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\nvarying float vSinAll;\n\nmat4 calcTranslateMat4(vec3 v) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    v.x, v.y, v.z, 1.0\n  );\n}\n\nvoid main(void) {\n  float sin1 = sin(time + position.x / 16.0);\n  float sin2 = sin(time + position.y / 8.0);\n  float sin3 = sin(time - length(position.xy + 50.0) / 4.0);\n  float sinAll = (sin1 + sin2 * 0.5 + sin3 * 0.2) / 1.7;\n  mat4 waveMat = calcTranslateMat4(vec3(0.0, 0.0, sinAll * 1.5));\n\n  // coordinate transformation\n  vec4 mPosition = modelMatrix * waveMat * vec4(position, 1.0);\n\n  vPosition = mPosition.xyz;\n  vUv = uv;\n  vSinAll = sinAll;\n\n  gl_Position = projectionMatrix * viewMatrix * mPosition;\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "precision highp float;\n#define GLSLIFY 1\n\nuniform float addH;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\nvarying float vSinAll;\n\nvec3 convertHsvToRgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Flat Shading\n  vec3 light = normalize(vec3(-1.0, 1.0, 1.0));\n  vec3 normal = normalize(cross(dFdx(vPosition), dFdy(vPosition)));\n  float diff = dot(normal, light);\n\n  vec4 color = vec4(convertHsvToRgb(vec3(0.2 + vSinAll * 0.15 + addH, 0.2, 1.0)), 0.4);\n\n  gl_FragColor = color * vec4(vec3(diff), 1.0);\n}\n"
}, function(e, t, n) {
    "use strict";

    function r(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }
    n.r(t), n.d(t, "default", (function() {
        return o
    }));
    var i = n(0),
        o = function() {
            function e() {
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, e), this.vTouchStart = new i.Vector2, this.vPrev = new i.Vector2, this.v = new i.Vector2, this.a = new i.Vector2, this.anchor = new i.Vector2, this.isTouched = !1
            }
            var t, n, o;
            return t = e, (n = [{
                key: "touchStart",
                value: function(e) {
                    e.touches || e.preventDefault(), this.vPrev.copy(this.v), this.a.set(0, 0), this.vTouchStart.set(e.touches ? e.touches[0].clientX : e.clientX, e.touches ? e.touches[0].clientY : e.clientY), this.isTouched = !0
                }
            }, {
                key: "touchMove",
                value: function(e) {
                    var t = e.touches ? e.touches[0].clientX : e.clientX,
                        n = e.touches ? e.touches[0].clientY : e.clientY;
                    !1 !== this.isTouched && (this.anchor.set((t - this.vTouchStart.x) / 10 + this.vPrev.x, (n - this.vTouchStart.y) / 10 + this.vPrev.y), e.touches && e.preventDefault())
                }
            }, {
                key: "touchEnd",
                value: function(e) {
                    this.isTouched = !1, this.isDraging = !1
                }
            }, {
                key: "render",
                value: function() {
                    this.a.set((this.anchor.x - this.v.x) / 10, (this.anchor.y - this.v.y) / 10), this.v.add(this.a)
                }
            }]) && r(t.prototype, n), o && r(t, o), e
        }()
}, function(e, t, n) {
    "use strict";

    function r(e, t, n, r, i, o, a) {
        try {
            var s = e[o](a),
                c = s.value
        } catch (e) {
            return void n(e)
        }
        s.done ? t(c) : Promise.resolve(c).then(r, i)
    }

    function i(e) {
        return function() {
            var t = this,
                n = arguments;
            return new Promise((function(i, o) {
                var a = e.apply(t, n);

                function s(e) {
                    r(a, i, o, s, c, "next", e)
                }

                function c(e) {
                    r(a, i, o, s, c, "throw", e)
                }
                s(void 0)
            }))
        }
    }
    n.r(t);
    var o = n(0),
        a = n(3),
        s = n(1),
        c = n(428).default,
        u = n(429).default,
        l = n(432).default,
        f = n(435).default,
        d = n(438).default,
        h = n(441).default;

    function v() {
        return (v = i(regeneratorRuntime.mark((function e() {
            var t, n, r, v, p, m, y, g, x, b, w, M, _, S, P, T, E, z;
            return regeneratorRuntime.wrap((function(e) {
                for (;;) switch (e.prev = e.next) {
                    case 0:
                        return t = new o.Vector2, n = document.getElementById("canvas-webgl"), r = new o.WebGLRenderer({
                            alpha: !0,
                            antialias: !0,
                            canvas: n
                        }), v = new o.Scene, p = new o.PerspectiveCamera, m = new o.Clock({
                            autoStart: !1
                        }), y = new c, g = new u, x = new l, b = new f, w = new d, M = new h(0), _ = new clm.tracker, S = function() {
                            var e = i(regeneratorRuntime.mark((function e() {
                                var t, n, i;
                                return regeneratorRuntime.wrap((function(e) {
                                    for (;;) switch (e.prev = e.next) {
                                        case 0:
                                            return t = m.getDelta(), n = _.getCurrentPosition(), i = _.getScore(), y.render(n, i), g.render(t, y.force.v), x.render(t, y.force.v), b.render(t, y.force.v), w.render(t, n, i, y), M.render(t, y.force.v), r.render(v, p), e.abrupt("return");
                                        case 11:
                                        case "end":
                                            return e.stop()
                                    }
                                }), e)
                            })));
                            return function() {
                                return e.apply(this, arguments)
                            }
                        }(), P = function() {
                            var e = i(regeneratorRuntime.mark((function e() {
                                return regeneratorRuntime.wrap((function(e) {
                                    for (;;) switch (e.prev = e.next) {
                                        case 0:
                                            return e.next = 2, S();
                                        case 2:
                                            return requestAnimationFrame(P), e.abrupt("return");
                                        case 4:
                                        case "end":
                                            return e.stop()
                                    }
                                }), e)
                            })));
                            return function() {
                                return e.apply(this, arguments)
                            }
                        }(), T = function() {
                            p.aspect = t.x / t.y, p.updateProjectionMatrix(), p.setFocalLength(15 * s.step(1, t.y / t.x) + 35)
                        }, E = function() {
                            var e = i(regeneratorRuntime.mark((function e() {
                                return regeneratorRuntime.wrap((function(e) {
                                    for (;;) switch (e.prev = e.next) {
                                        case 0:
                                            return t.set(document.body.clientWidth, window.innerHeight), n.width = t.x, n.height = t.y, T(), r.setSize(t.x, t.y), e.next = 7, y.init();
                                        case 7:
                                        case "end":
                                            return e.stop()
                                    }
                                }), e)
                            })));
                            return function() {
                                return e.apply(this, arguments)
                            }
                        }(), z = function() {
                            window.addEventListener("resize", a((function() {
                                E().then((function() {
                                    g.resize(y)
                                }))
                            }), 500))
                        }, r.setClearColor(15658734, 1), p.far = 1e3, p.position.set(0, 0, 100), p.lookAt(new o.Vector3), m.start(), z(), e.next = 26, E();
                    case 26:
                        g.createObj(y), x.createObj(), b.createObj(), w.createObj(), M.createObj(), g.obj.renderOrder = 10, x.obj.renderOrder = 2, b.obj.renderOrder = 1, w.obj.renderOrder = 20, v.add(g.obj), v.add(x.obj), v.add(b.obj), v.add(w.obj), v.add(M.obj), _.init(pModel), _.start(y.video), P();
                    case 43:
                    case "end":
                        return e.stop()
                }
            }), e)
        })))).apply(this, arguments)
    }
    t.default = function() {
        return v.apply(this, arguments)
    }
}, function(e, t, n) {
    "use strict";

    function r(e, t, n, r, i, o, a) {
        try {
            var s = e[o](a),
                c = s.value
        } catch (e) {
            return void n(e)
        }
        s.done ? t(c) : Promise.resolve(c).then(r, i)
    }

    function i(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }
    n.r(t), n.d(t, "default", (function() {
        return s
    }));
    var o = n(0),
        a = n(12),
        s = function() {
            function e() {
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, e), this.video = document.createElement("video"), this.facingMode = void 0, this.resolution = {
                    x: 0,
                    y: 0
                }, this.mouth = [new o.Vector2, new o.Vector2, new o.Vector2, new o.Vector2], this.force = {
                    a: 0,
                    v: 1
                }
            }
            var t, n, s, c, u;
            return t = e, (n = [{
                key: "init",
                value: (c = regeneratorRuntime.mark((function e() {
                    var t = this;
                    return regeneratorRuntime.wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                if (navigator.mediaDevices) {
                                    e.next = 2;
                                    break
                                }
                                return e.abrupt("return");
                            case 2:
                                return this.facingMode = "user", e.next = 5, navigator.mediaDevices.getUserMedia({
                                    audio: !1,
                                    video: {
                                        facingMode: this.facingMode
                                    }
                                }).then((function(e) {
                                    t.video.srcObject = e
                                })).catch((function(e) {
                                    window.alert("It wasn't allowed to use WebCam.")
                                }));
                            case 5:
                                return this.video.setAttribute("playsinline", !0), this.video.setAttribute("controls", !0), this.video.play(), e.next = 10, a(1e3);
                            case 10:
                                return this.resolution.x = this.video.width = this.video.videoWidth, this.resolution.y = this.video.height = this.video.videoHeight, e.abrupt("return");
                            case 13:
                            case "end":
                                return e.stop()
                        }
                    }), e, this)
                })), u = function() {
                    var e = this,
                        t = arguments;
                    return new Promise((function(n, i) {
                        var o = c.apply(e, t);

                        function a(e) {
                            r(o, n, i, a, s, "next", e)
                        }

                        function s(e) {
                            r(o, n, i, a, s, "throw", e)
                        }
                        a(void 0)
                    }))
                }, function() {
                    return u.apply(this, arguments)
                })
            }, {
                key: "render",
                value: function(e, t) {
                    var n = 0;
                    if (t >= .3 && !1 !== e) {
                        this.mouth[0].set(e[47][0], e[47][1]), this.mouth[1].set(e[60][0], e[60][1]), this.mouth[2].set(e[57][0], e[57][1]), this.mouth[3].set(e[53][0], e[53][1]);
                        var r = this.mouth[0].distanceTo(this.mouth[1]),
                            i = this.mouth[1].distanceTo(this.mouth[2]),
                            o = this.mouth[2].distanceTo(this.mouth[3]);
                        n = Math.max(i / (r + o) - 1, 0)
                    }
                    var a = .01 * (1 - this.force.v),
                        s = .16 * -this.force.a,
                        c = .1 * n;
                    this.force.a += a + s + c, this.force.v = this.force.v + this.force.a
                }
            }]) && i(t.prototype, n), s && i(t, s), e
        }()
}, function(e, t, n) {
    "use strict";

    function r(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }
    n.r(t), n.d(t, "default", (function() {
        return o
    }));
    var i = n(0),
        o = (n(1), function() {
            function e() {
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, e), this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    },
                    texVideo: {
                        type: "t",
                        value: null
                    },
                    facing: {
                        type: "f",
                        value: 0
                    },
                    resolution: {
                        type: "v2",
                        value: new i.Vector2
                    },
                    force: {
                        type: "f",
                        value: 0
                    }
                }, this.obj
            }
            var t, o, a;
            return t = e, (o = [{
                key: "createObj",
                value: function(e) {
                    var t = new i.PlaneBufferGeometry(50, 50, 2, 2),
                        r = new i.RawShaderMaterial({
                            uniforms: this.uniforms,
                            vertexShader: n(430).default,
                            fragmentShader: n(431).default,
                            transparent: !0
                        }),
                        o = new i.VideoTexture(e.video);
                    o.minFilter = i.LinearFilter, o.magFilter = i.LinearFilter, o.format = i.RGBFormat, this.uniforms.texVideo.value = o, this.uniforms.facing.value = "user" === e.facingMode ? 1 : 0, this.uniforms.resolution.value.set(e.resolution.x, e.resolution.y), this.obj = new i.Mesh(t, r)
                }
            }, {
                key: "resize",
                value: function(e) {
                    this.uniforms.resolution.value.set(e.resolution.x, e.resolution.y)
                }
            }, {
                key: "render",
                value: function(e, t) {
                    var n = .008 * t + 1;
                    this.uniforms.force.value = t, this.uniforms.time.value += e * (1.2 * t), this.obj.scale.set(n, n, n)
                }
            }]) && r(t.prototype, o), a && r(t, a), e
        }())
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\n\nvoid main(void) {\n  // coordinate transformation\n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n\n  vPosition = position;\n  vUv = uv;\n\n  gl_Position = projectionMatrix * mvPosition;\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = 'precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\nuniform sampler2D texVideo;\nuniform float facing;\nuniform vec2 resolution;\nuniform float force;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\n\n//\n// GLSL textureless classic 3D noise "cnoise",\n// with an RSL-style periodic variant "pnoise".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-10-11\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec3 fade(vec3 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise(vec3 P)\n{\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod289(Pi0);\n  Pi1 = mod289(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n  return 2.2 * n_xyz;\n}\n\nvec3 convertHsvToRgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  vec2 p = (vUv * 2.0 - 1.0);\n  float grad = 1.0 - smoothstep(0.5, 1.0, length(p));\n  float noise1 = cnoise(vec3(p * (1.4 + force * 0.5), time * 0.4)) * (0.15 + smoothstep(0.5, 0.75, length(p)) * (1.0 - smoothstep(0.75, 1.0, length(p))));\n  float noise2 = cnoise(vec3(p * (5.4 + force * 0.3), time * 0.4)) * (0.15 + smoothstep(0.3, 0.4, length(p)) * (1.0 - smoothstep(0.9, 1.0, length(p))));\n  float noiseSum = (noise1 + noise2) / 2.0;\n\n  vec2 adjustUv = vec2(\n    min(resolution.y / resolution.x, 1.0) * (1.0 + force * 0.03),\n    min(resolution.x / resolution.y, 1.0) * (1.0 + force * 0.03)\n    );\n  vec2 updateUv = vec2(\n    abs(vUv.x - facing) * adjustUv.x + (1.0 - adjustUv.x) * 0.5,\n                  vUv.y * adjustUv.y + (1.0 - adjustUv.y) * 0.5\n                  );\n  vec4 texColor1 = texture2D(texVideo, updateUv - vec2(noise1 * noise2 - abs(p.x) / 50.0));\n  vec4 texColor2 = texture2D(texVideo, updateUv - vec2(noise1 * noise2));\n  vec4 texColor3 = texture2D(texVideo, updateUv - vec2(noise1 * noise2 + abs(p.x) / 50.0));\n  vec3 texColorSum = vec3(texColor1.r, texColor2.g, texColor3.b);\n\n  vec3 addColor = convertHsvToRgb(vec3((grad + noiseSum + updateUv.x * 0.5) / 2.0 + time * 0.1, 0.8, 0.6));\n\n  float mask1 = smoothstep(0.19, 0.2, grad + noiseSum);\n  vec4 color1 = vec4(texColorSum * vec3(1.2) + addColor * 0.24, 1.0) * mask1;\n\n  float mask2 = smoothstep(0.15, 0.16, grad + noiseSum) * (1.0 - smoothstep(0.7, 0.71, grad + noiseSum));\n  vec4 color2 = vec4(texColorSum * 0.1 + addColor * 0.7, 1.0) * mask2;\n\n  gl_FragColor = color1 + color2;\n}\n'
}, function(e, t, n) {
    "use strict";

    function r(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }
    n.r(t), n.d(t, "default", (function() {
        return a
    }));
    var i = n(0),
        o = n(1),
        a = function() {
            function e() {
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, e), this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    },
                    force: {
                        type: "f",
                        value: 0
                    }
                }, this.obj
            }
            var t, a, s;
            return t = e, (a = [{
                key: "createObj",
                value: function() {
                    for (var e = new i.BufferGeometry, t = [], r = [], a = 0; a < 600; a += 3) {
                        var s = Math.random() * Math.random() * 60 + 20,
                            c = o.radians(360 * Math.random());
                        t[a + 0] = Math.cos(c) * s, t[a + 1] = Math.sin(c) * s, t[a + 2] = 0, r[a / 3] = 8 * Math.random()
                    }
                    var u = new i.BufferAttribute(new Float32Array(t), 3),
                        l = new i.BufferAttribute(new Float32Array(r), 1);
                    e.addAttribute("position", u), e.addAttribute("delay", l);
                    var f = new i.RawShaderMaterial({
                        uniforms: this.uniforms,
                        vertexShader: n(433).default,
                        fragmentShader: n(434).default,
                        transparent: !0,
                        depthWrite: !1
                    });
                    this.obj = new i.Points(e, f)
                }
            }, {
                key: "render",
                value: function(e, t) {
                    this.uniforms.force.value = t, this.uniforms.time.value += e * (1.2 * t)
                }
            }]) && r(t.prototype, a), s && r(t, s), e
        }()
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nattribute vec3 position;\nattribute float delay;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform float time;\nuniform float force;\n\nvarying vec3 vColor;\nvarying float vOpacity;\n\nvec3 convertHsvToRgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nconst float duration = 8.0;\n\nvoid main() {\n  // Loop animation\n  float interval = mod(time + delay, duration) / duration;\n  vec3 move = vec3(0.0, 0.0, (interval * 2.0 - 1.0) * 100.0);\n\n  // calculate gradation with position.y\n  vec3 hsv = vec3(0.3 + time * 0.1, 0.65 - force * 0.01, 0.85 + force * 0.01);\n  vec3 rgb = convertHsvToRgb(hsv);\n\n  // coordinate transformation\n  vec4 mvPosition = modelViewMatrix * vec4(position + move, 1.0);\n  float distanceFromCamera = 1000.0 / length(mvPosition.xyz);\n\n  vColor = rgb;\n  vOpacity = smoothstep(-100.0, 100.0, move.z);\n\n  gl_Position = projectionMatrix * mvPosition;\n  gl_PointSize = distanceFromCamera;\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "precision highp float;\n#define GLSLIFY 1\n\nvarying vec3 vColor;\nvarying float vOpacity;\n\nvoid main() {\n  // convert PointCoord to range from -1.0 to 1.0\n  vec2 p = gl_PointCoord * 2.0 - 1.0;\n\n  // draw double circle\n  float radius = length(p);\n  float opacity = (1.0 - smoothstep(0.9, 1.0, radius)) * vOpacity;\n\n  gl_FragColor = vec4(vColor, opacity);\n}\n"
}, function(e, t, n) {
    "use strict";

    function r(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }
    n.r(t), n.d(t, "default", (function() {
        return a
    }));
    var i = n(0),
        o = n(1),
        a = function() {
            function e() {
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, e), this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    },
                    force: {
                        type: "f",
                        value: 0
                    }
                }, this.obj
            }
            var t, a, s;
            return t = e, (a = [{
                key: "createObj",
                value: function() {
                    var e = new i.InstancedBufferGeometry,
                        t = new i.BoxBufferGeometry(1.2, 1.2, 18);
                    e.copy(t);
                    for (var r = new i.InstancedBufferAttribute(new Float32Array(360), 3), a = new i.InstancedBufferAttribute(new Float32Array(120), 1), s = 0; s < 120; s++) {
                        var c = Math.random() * Math.random() * 40 + 40,
                            u = o.radians(360 * Math.random());
                        r.setXYZ(s, Math.cos(u) * c, Math.sin(u) * c, 0), a.setX(s, 8 * Math.random())
                    }
                    e.addAttribute("iPosition", r), e.addAttribute("iDelay", a);
                    var l = new i.RawShaderMaterial({
                        uniforms: this.uniforms,
                        vertexShader: n(436).default,
                        fragmentShader: n(437).default,
                        flatShading: !0,
                        transparent: !0,
                        depthWrite: !1
                    });
                    this.obj = new i.Mesh(e, l), this.obj.frustumCulled = !1
                }
            }, {
                key: "render",
                value: function(e, t) {
                    this.uniforms.force.value = t, this.uniforms.time.value += e * (1.2 * t)
                }
            }]) && r(t.prototype, a), s && r(t, s), e
        }()
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\nattribute vec3 iPosition;\nattribute float iDelay;\n\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\nuniform float time;\nuniform float force;\n\nvarying vec3 vPosition;\nvarying vec3 vColor;\nvarying float vOpacity;\n\nmat4 calcTranslateMat4(vec3 v) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    v.x, v.y, v.z, 1.0\n  );\n}\n\nvec3 convertHsvToRgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nconst float duration = 8.0;\n\nvoid main(void) {\n  // Loop animation\n  float interval = mod(time + iDelay, duration) / duration;\n  vec3 move = vec3(0.0, 0.0, (interval * 2.0 - 1.0) * 100.0);\n\n  // calculate gradation with position.y\n  vec3 hsv = vec3(0.3 + time * 0.1, 0.3 - force * 0.01, 0.85 + force * 0.01);\n  vec3 rgb = convertHsvToRgb(hsv);\n\n  // coordinate transformation\n  mat4 translateMat = calcTranslateMat4(iPosition);\n  vec4 mPosition = modelMatrix * translateMat * vec4(position + move, 1.0);\n  vec4 mvPosition = viewMatrix * mPosition;\n\n  vPosition = mPosition.xyz;\n  vColor = rgb;\n  vOpacity = smoothstep(-100.0, 0.0, move.z);\n\n  gl_Position = projectionMatrix * mvPosition;\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "precision highp float;\n#define GLSLIFY 1\n\nvarying vec3 vPosition;\nvarying vec3 vColor;\nvarying float vOpacity;\n\nvoid main() {\n  // Flat Shading\n  vec3 light = normalize(vec3(0.0, 1.0, 0.5));\n  vec3 normal = normalize(cross(dFdx(vPosition), dFdy(vPosition)));\n  float diff = (dot(normal, light) + 1.0) / 2.0;\n\n  vec3 color = vColor + diff * 0.1;\n\n  gl_FragColor = vec4(color, vOpacity);\n}\n"
}, function(e, t, n) {
    "use strict";

    function r(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }
    n.r(t), n.d(t, "default", (function() {
        return o
    }));
    var i = n(0),
        o = (n(1), function() {
            function e() {
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, e), this.positions = void 0, this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    }
                }, this.obj
            }
            var t, o, a;
            return t = e, (o = [{
                key: "createObj",
                value: function() {
                    var e = new i.BufferGeometry;
                    this.positions = new i.BufferAttribute(new Float32Array(204), 3), e.addAttribute("position", this.positions);
                    var t = new i.RawShaderMaterial({
                        uniforms: this.uniforms,
                        vertexShader: n(439).default,
                        fragmentShader: n(440).default,
                        transparent: !0,
                        depthWrite: !1,
                        blending: i.AdditiveBlending
                    });
                    this.obj = new i.Points(e, t)
                }
            }, {
                key: "setPositions",
                value: function(e, t, n) {
                    var r = "user" === n.facingMode ? -1 : 1;
                    if (this.obj.visible = t >= .3, !1 !== e) {
                        for (var i = 0; i < this.positions.count; i++) this.positions.setXYZ(i, 25 * (e[i][0] / n.resolution.x * 2 - 1) * r, -25 * (e[i][1] / n.resolution.y * 2 - 1), 10);
                        this.positions.needsUpdate = !0
                    }
                }
            }, {
                key: "render",
                value: function(e, t, n, r) {
                    this.uniforms.time.value += e * (1.2 * r.force.v), this.setPositions(t, n, r)
                }
            }]) && r(t.prototype, o), a && r(t, a), e
        }())
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nattribute vec3 position;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform float time;\n\nvarying vec3 vColor;\n\nvec3 convertHsvToRgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nconst float duration = 3.0;\n\nvoid main() {\n  // calculate colors\n  vec3 hsv = vec3(0.45 + time * 0.1, 0.6, 1.0);\n  vec3 rgb = convertHsvToRgb(hsv);\n\n  // coordinate transformation\n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n\n  vColor = rgb;\n\n  gl_Position = projectionMatrix * mvPosition;\n  gl_PointSize = 7.0;\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "precision highp float;\n#define GLSLIFY 1\n\nvarying vec3 vColor;\n\nvoid main() {\n  // convert PointCoord to range from -1.0 to 1.0\n  vec2 p = gl_PointCoord * 2.0 - 1.0;\n\n  float r = 1.0 - smoothstep(0.5, 1.0, length(p));\n\n  gl_FragColor = vec4(vColor, r);\n}\n"
}, function(e, t, n) {
    "use strict";

    function r(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }
    n.r(t), n.d(t, "default", (function() {
        return a
    }));
    var i = n(0),
        o = n(1),
        a = function() {
            function e(t) {
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, e), this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    },
                    force: {
                        type: "f",
                        value: 0
                    }
                }, this.obj
            }
            var t, a, s;
            return t = e, (a = [{
                key: "createObj",
                value: function() {
                    var e = new i.SphereBufferGeometry(150, 128, 128, 0, 6.3, 0, 1.6),
                        t = new i.RawShaderMaterial({
                            uniforms: this.uniforms,
                            vertexShader: n(442).default,
                            fragmentShader: n(443).default,
                            side: i.BackSide
                        });
                    this.obj = new i.Mesh(e, t), this.obj.rotation.set(o.radians(-90), 0, 0)
                }
            }, {
                key: "render",
                value: function(e, t) {
                    this.uniforms.force.value = t, this.uniforms.time.value += e * (1.2 * t)
                }
            }]) && r(t.prototype, a), s && r(t, s), e
        }()
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform float time;\nuniform float force;\n\nvarying vec3 vColor;\n\nvec3 convertHsvToRgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main(void) {\n  // calculate gradation\n  vec3 hsv = vec3(0.1 + sin(radians(uv.y * 180.0 * 4.0)) * 0.12 - time * 0.1, 0.12 + force * 0.03, 0.96 - force * 0.03);\n  vec3 rgb = convertHsvToRgb(hsv);\n\n  // coordinate transformation\n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n\n  vColor = rgb;\n\n  gl_Position = projectionMatrix * mvPosition;\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "precision highp float;\n#define GLSLIFY 1\n\nvarying vec3 vColor;\n\nvoid main() {\n  gl_FragColor = vec4(vColor, 1.0);\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t);
    var r = n(0),
        i = n(3),
        o = n(106).default,
        a = n(445).default;
    t.default = function() {
        var e = new r.Vector2,
            t = document.getElementById("canvas-webgl"),
            n = new r.WebGLRenderer({
                alpha: !0,
                antialias: !0,
                canvas: t
            }),
            s = new r.Scene,
            c = new r.PerspectiveCamera,
            u = new r.Clock;
        c.far = 5e4, c.setFocalLength(24);
        var l = {
                fog: "../img/sketch/fog/fog.png"
            },
            f = new a,
            d = function e() {
                var t;
                t = u.getDelta(), f.render(t), n.render(s, c), requestAnimationFrame(e)
            },
            h = function() {
                e.set(document.body.clientWidth, window.innerHeight), t.width = e.x, t.height = e.y, c.aspect = e.x / e.y, c.updateProjectionMatrix(), n.setSize(e.x, e.y)
            };
        o(l, (function(e) {
            f.createObj(e.fog), s.add(f.obj), n.setClearColor(1118481, 1), c.position.set(0, 0, 1e3), c.lookAt(new r.Vector3), u.start(), window.addEventListener("resize", i(h, 1e3)), h(), d()
        }))
    }
}, function(e, t, n) {
    "use strict";

    function r(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }
    n.r(t), n.d(t, "default", (function() {
        return o
    }));
    var i = n(0),
        o = (n(1), function() {
            function e() {
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, e), this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    },
                    tex: {
                        type: "t",
                        value: null
                    }
                }, this.num = 200, this.obj
            }
            var t, o, a;
            return t = e, (o = [{
                key: "createObj",
                value: function(e) {
                    var t = new i.InstancedBufferGeometry,
                        r = new i.PlaneBufferGeometry(1100, 1100, 20, 20);
                    t.copy(r);
                    for (var o = new i.InstancedBufferAttribute(new Float32Array(3 * this.num), 3), a = new i.InstancedBufferAttribute(new Float32Array(this.num), 1), s = new i.InstancedBufferAttribute(new Float32Array(this.num), 1), c = 0, u = this.num; c < u; c++) o.setXYZ(c, 850 * (2 * Math.random() - 1), 0, 300 * (2 * Math.random() - 1)), a.setXYZ(c, Math.random()), s.setXYZ(c, 2 * Math.random() + 1);
                    t.addAttribute("instancePosition", o), t.addAttribute("delay", a), t.addAttribute("rotate", s);
                    var l = new i.RawShaderMaterial({
                        uniforms: this.uniforms,
                        vertexShader: n(446).default,
                        fragmentShader: n(447).default,
                        transparent: !0,
                        depthWrite: !1,
                        blending: i.AdditiveBlending
                    });
                    this.uniforms.tex.value = e, this.obj = new i.Mesh(t, l)
                }
            }, {
                key: "render",
                value: function(e) {
                    this.uniforms.time.value += e
                }
            }]) && r(t.prototype, o), a && r(t, a), e
        }())
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\nattribute vec3 instancePosition;\nattribute float delay;\nattribute float rotate;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform float time;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\nvarying vec3 vColor;\nvarying float vBlink;\n\nconst float duration = 200.0;\n\nmat4 calcRotateMat4Z(float radian) {\n  return mat4(\n    cos(radian), -sin(radian), 0.0, 0.0,\n    sin(radian), cos(radian), 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nvec3 convertHsvToRgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main(void) {\n  float now = mod(time + delay * duration, duration) / duration;\n\n  mat4 rotateMat = calcRotateMat4Z(radians(rotate * 360.0) + time * 0.1);\n  vec3 rotatePosition = (rotateMat * vec4(position, 1.0)).xyz;\n\n  vec3 moveRise = vec3(\n    (now * 2.0 - 1.0) * (2500.0 - (delay * 2.0 - 1.0) * 2000.0),\n    (now * 2.0 - 1.0) * 2000.0,\n    sin(radians(time * 50.0 + delay + length(position))) * 30.0\n    );\n  vec3 updatePosition = instancePosition + moveRise + rotatePosition;\n\n  vec3 hsv = vec3(time * 0.1 + delay * 0.2 + length(instancePosition) * 100.0, 0.5 , 0.8);\n  vec3 rgb = convertHsvToRgb(hsv);\n  float blink = (sin(radians(now * 360.0 * 20.0)) + 1.0) * 0.88;\n\n  // coordinate transformation\n  vec4 mvPosition = modelViewMatrix * vec4(updatePosition, 1.0);\n\n  vPosition = position;\n  vUv = uv;\n  vColor = rgb;\n  vBlink = blink;\n\n  gl_Position = projectionMatrix * mvPosition;\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "precision highp float;\n#define GLSLIFY 1\n\nuniform sampler2D tex;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\nvarying vec3 vColor;\nvarying float vBlink;\n\nvoid main() {\n  vec2 p = vUv * 2.0 - 1.0;\n\n  vec4 texColor = texture2D(tex, vUv);\n  vec3 color = (texColor.rgb - vBlink * length(p) * 0.8) * vColor;\n  float opacity = texColor.a * 0.36;\n\n  gl_FragColor = vec4(color, opacity);\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t);
    var r = n(0),
        i = n(3),
        o = n(449).default,
        a = n(454).default;
    t.default = function() {
        var e = new r.Vector2,
            t = document.getElementById("canvas-webgl"),
            n = new r.WebGLRenderer({
                alpha: !0,
                antialias: !0,
                canvas: t
            }),
            s = new r.Scene,
            c = new r.PerspectiveCamera,
            u = new r.Clock,
            l = new r.FontLoader;
        c.far = 5e4, c.setFocalLength(24);
        var f = new o,
            d = new a,
            h = function e() {
                var t;
                t = u.getDelta(), f.render(t), n.render(s, c), requestAnimationFrame(e)
            },
            v = function() {
                e.set(document.body.clientWidth, window.innerHeight), t.width = e.x, t.height = e.y, c.aspect = e.x / e.y, c.updateProjectionMatrix(), n.setSize(e.x, e.y)
            };
        l.load("https://threejs.org/examples/fonts/helvetiker_bold.typeface.json", (function(e) {
            f.createObj(e), d.createObj(), s.add(f.objWire), s.add(f.objPoints), s.add(d.obj), n.setClearColor(1118481, 1), c.position.set(0, 0, 1e3), c.lookAt(new r.Vector3), u.start(), window.addEventListener("resize", i(v, 1e3)), window.addEventListener("click", (function() {
                f.transform()
            })), v(), h()
        }))
    }
}, function(e, t, n) {
    "use strict";

    function r(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }
    n.r(t), n.d(t, "default", (function() {
        return a
    }));
    var i = n(0),
        o = n(1),
        a = function() {
            function e() {
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, e), this.durationTransform = .8, this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    },
                    timeTransform: {
                        type: "f",
                        value: this.durationTransform
                    },
                    durationTransform: {
                        type: "f",
                        value: this.durationTransform
                    },
                    prevIndex: {
                        type: "f",
                        value: 1
                    },
                    nextIndex: {
                        type: "f",
                        value: 0
                    }
                }, this.isTransform = !1, this.obj, this.objWire = null, this.objPoints = null
            }
            var t, a, s;
            return t = e, (a = [{
                key: "createObj",
                value: function(e) {
                    var t = {
                            font: e,
                            size: 300,
                            height: 0,
                            curveSegments: 1
                        },
                        r = [new i.TextBufferGeometry("HELLO", t), new i.TextBufferGeometry("WORLD", t)],
                        o = new i.BufferGeometry,
                        a = 0;
                    r.map((function(e, t) {
                        e.center(), e.attributes.position.count > a && (a = e.attributes.position.count)
                    })), r.map((function(e, t) {
                        var n = t > 0 ? t + 1 : "";
                        if (e.attributes.position.count < a) {
                            for (var r = e.attributes.position.array, s = [], c = [], u = 0; u < 3 * a; u += 3)
                                if (u < (3 * a - r.length) / 2) s[u] = 700 * (2 * Math.random() - 1), s[u + 1] = 250 * (2 * Math.random() - 1), s[u + 2] = 250 * (2 * Math.random() - 1), c[u / 3] = 0;
                                else if (u >= r.length + (3 * a - r.length) / 2) s[u] = 700 * (2 * Math.random() - 1), s[u + 1] = 250 * (2 * Math.random() - 1), s[u + 2] = 250 * (2 * Math.random() - 1), c[u / 3] = 0;
                            else {
                                var l = u - (3 * a - r.length) / 2;
                                s[u] = e.attributes.position.array[l], s[u + 1] = e.attributes.position.array[l + 1], s[u + 2] = e.attributes.position.array[l + 2], c[u / 3] = 1
                            }
                            o.addAttribute("position".concat(n), new i.Float32BufferAttribute(s, 3, 1)), o.addAttribute("opacity".concat(n), new i.Float32BufferAttribute(c, 1, 1))
                        } else {
                            var f = [];
                            for (u = 0; u < a; u++) f[u] = 1;
                            o.addAttribute("position".concat(n), e.attributes.position), o.addAttribute("opacity".concat(n), new i.Float32BufferAttribute(f, 1, 1)), o.addAttribute("normal", e.attributes.normal), o.addAttribute("uv", e.attributes.uv), o.setIndex(e.index)
                        }
                    }));
                    var s = new i.RawShaderMaterial({
                            uniforms: this.uniforms,
                            vertexShader: n(146).default,
                            fragmentShader: n(450).default,
                            depthWrite: !1,
                            transparent: !0,
                            flatShading: !0
                        }),
                        c = new i.RawShaderMaterial({
                            uniforms: this.uniforms,
                            vertexShader: n(146).default,
                            fragmentShader: n(451).default,
                            depthWrite: !1,
                            transparent: !0,
                            wireframe: !0
                        }),
                        u = new i.RawShaderMaterial({
                            uniforms: this.uniforms,
                            vertexShader: n(452).default,
                            fragmentShader: n(453).default,
                            depthWrite: !1,
                            transparent: !0
                        });
                    this.obj = new i.Mesh(o, s), this.objWire = new i.Mesh(o, c), this.objPoints = new i.Points(o, u)
                }
            }, {
                key: "transform",
                value: function() {
                    this.isTransform = !0, this.uniforms.timeTransform.value = 0, this.uniforms.prevIndex.value = this.uniforms.prevIndex.value < 1 ? this.uniforms.prevIndex.value + 1 : 0, this.uniforms.nextIndex.value = this.uniforms.nextIndex.value < 1 ? this.uniforms.nextIndex.value + 1 : 0
                }
            }, {
                key: "render",
                value: function(e) {
                    this.uniforms.time.value += e, this.isTransform && (this.uniforms.timeTransform.value = o.clamp(this.uniforms.timeTransform.value + e, 0, this.durationTransform)), this.uniforms.timeTransform.value === this.durationTransform && (this.isTransform = !1)
                }
            }]) && r(t.prototype, a), s && r(t, s), e
        }()
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "precision highp float;\n#define GLSLIFY 1\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\nvarying float vOpacity;\n\nvoid main() {\n  gl_FragColor = vec4(vec3(1.0), vOpacity);\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "precision highp float;\n#define GLSLIFY 1\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\nvarying float vOpacity;\n\nvoid main() {\n  gl_FragColor = vec4(vec3(1.0), vOpacity);\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec3 position2;\nattribute float opacity;\nattribute float opacity2;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform float time;\nuniform float timeTransform;\nuniform float durationTransform;\nuniform float prevIndex;\nuniform float nextIndex;\n\nvarying float vOpacity;\n\nfloat exponentialOut(float t) {\n  return t == 1.0 ? t : 1.0 - pow(2.0, -10.0 * t);\n}\n\nmat4 calcRotateMat4X(float radian) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, cos(radian), -sin(radian), 0.0,\n    0.0, sin(radian), cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4Y(float radian) {\n  return mat4(\n    cos(radian), 0.0, sin(radian), 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    -sin(radian), 0.0, cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4Z(float radian) {\n  return mat4(\n    cos(radian), -sin(radian), 0.0, 0.0,\n    sin(radian), cos(radian), 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4(vec3 radian) {\n  return calcRotateMat4X(radian.x) * calcRotateMat4Y(radian.y) * calcRotateMat4Z(radian.z);\n}\n\nvoid main() {\n  // transform\n  vec3 prevPosition =\n    position * (1.0 - step(1.0, prevIndex))\n    + position2 * step(1.0, prevIndex) * (1.0 - step(2.0, prevIndex));\n  vec3 nextPosition =\n    position * (1.0 - step(1.0, nextIndex))\n    + position2 * step(1.0, nextIndex) * (1.0 - step(2.0, nextIndex));\n  float prevOpacity =\n    opacity * (1.0 - step(1.0, prevIndex))\n    + opacity2 * step(1.0, prevIndex) * (1.0 - step(2.0, prevIndex));\n  float nextOpacity =\n    opacity * (1.0 - step(1.0, nextIndex))\n    + opacity2 * step(1.0, nextIndex) * (1.0 - step(2.0, nextIndex));\n  float ease = exponentialOut(min(timeTransform / 1.0, durationTransform) / durationTransform);\n  vec3 mixPosition = mix(prevPosition, nextPosition, ease);\n  float mixOpacity = mix(prevOpacity, nextOpacity, ease);\n\n  // calculate shake moving.\n  float now = time * 10.0 + length(mixPosition);\n  mat4 rotateMat = calcRotateMat4(vec3(now));\n  vec3 shake = (rotateMat * vec4(vec3(0.0, sin(now) * 5.0, 0.0), 1.0)).xyz;\n\n  // coordinate transformation\n  vec4 mvPosition = modelViewMatrix * vec4(mixPosition + shake, 1.0);\n\n  vOpacity = mixOpacity;\n\n  gl_Position = projectionMatrix * mvPosition;\n  gl_PointSize = 8.0;\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "precision highp float;\n#define GLSLIFY 1\n\nvarying float vOpacity;\n\nvoid main() {\n  // Round the point\n  vec3 n;\n  n.xy = gl_PointCoord * 2.0 - 1.0;\n  n.z = 1.0 - dot(n.xy, n.xy);\n  if (n.z < 0.0) discard;\n\n  gl_FragColor = vec4(vec3(1.0), vOpacity);\n}\n"
}, function(e, t, n) {
    "use strict";

    function r(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }
    n.r(t), n.d(t, "default", (function() {
        return o
    }));
    var i = n(0),
        o = (n(1), function() {
            function e() {
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, e), this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    }
                }, this.obj
            }
            var t, o, a;
            return t = e, (o = [{
                key: "createObj",
                value: function() {
                    var e = new i.SphereBufferGeometry(1e4, 128, 128),
                        t = new i.RawShaderMaterial({
                            uniforms: this.uniforms,
                            vertexShader: n(455).default,
                            fragmentShader: n(456).default,
                            side: i.BackSide
                        });
                    this.obj = new i.Mesh(e, t)
                }
            }, {
                key: "render",
                value: function(e) {
                    this.uniforms.time.value += e
                }
            }]) && r(t.prototype, o), a && r(t, a), e
        }())
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\nvarying vec3 vColor;\n\nconst vec3 hsv1 = vec3(0.0, 0.6, 0.4);\nconst vec3 hsv2 = vec3(0.24, 0.6, 0.4);\n\nvec3 convertHsvToRgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main(void) {\n  // calculate gradation with position.y\n  vec3 rgb = convertHsvToRgb(mix(hsv1, hsv2, (normalize(position).y + 1.0) / 2.0));\n\n  // coordinate transformation\n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n\n  vPosition = position;\n  vUv = uv;\n  vColor = rgb;\n\n  gl_Position = projectionMatrix * mvPosition;\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\nuniform sampler2D tex;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\nvarying vec3 vColor;\n\nfloat random(vec2 c){\n  return fract(sin(dot(c.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid main() {\n  float noise = random(vUv) * 0.08;\n\n  gl_FragColor = vec4(vColor + noise, 1.0);\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t);
    var r = n(0),
        i = n(3),
        o = n(106).default,
        a = n(458).default;
    t.default = function() {
        var e = new r.Vector2,
            t = new r.Vector2,
            n = document.getElementById("canvas-webgl"),
            s = new r.WebGLRenderer({
                alpha: !0,
                antialias: !0,
                canvas: n
            }),
            c = new r.Scene,
            u = new r.PerspectiveCamera,
            l = new r.Clock;
        u.far = 5e4, u.setFocalLength(24);
        var f = {
                points: "../img/sketch/image_data/elephant.png"
            },
            d = new a,
            h = function e() {
                var n;
                n = l.getDelta(), d.render(n, u, t), s.render(c, u), requestAnimationFrame(e)
            },
            v = function() {
                e.set(document.body.clientWidth, window.innerHeight), n.width = e.x, n.height = e.y, u.aspect = e.x / e.y, u.updateProjectionMatrix(), s.setSize(e.x, e.y)
            },
            p = function(n) {
                t.set(n.clientX / e.x * 2 - 1, -n.clientY / e.y * 2 + 1)
            };
        o(f, (function(e) {
            s.setClearColor(8037324, 1), u.position.set(0, 0, 1e3), u.lookAt(0, 0, 0), l.start(), d.createObj(e.points), c.add(d.obj), window.addEventListener("resize", i(v, 1e3)), window.addEventListener("mousemove", p), v(), h()
        }))
    }
}, function(e, t, n) {
    "use strict";

    function r(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }
    n.r(t), n.d(t, "default", (function() {
        return o
    }));
    var i = n(0),
        o = (n(1), function() {
            function e() {
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, e), this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    },
                    tex: {
                        type: "t",
                        value: null
                    },
                    mouse: {
                        type: "v3",
                        value: new i.Vector3
                    }
                }, this.obj
            }
            var t, o, a;
            return t = e, (o = [{
                key: "createObj",
                value: function(e) {
                    var t = new i.PlaneBufferGeometry(800, 800, 200, 200),
                        r = new i.RawShaderMaterial({
                            uniforms: this.uniforms,
                            vertexShader: n(459).default,
                            fragmentShader: n(460).default,
                            transparent: !0
                        });
                    this.uniforms.tex.value = e, this.obj = new i.Points(t, r)
                }
            }, {
                key: "render",
                value: function(e, t, n) {
                    this.uniforms.time.value += e;
                    var r = new i.Vector3;
                    r.set(n.x, n.y, -1), r.unproject(t);
                    var o = r.sub(t.position).normalize(),
                        a = -t.position.z / o.z,
                        s = t.position.clone().add(o.multiplyScalar(a));
                    this.uniforms.mouse.value.copy(s)
                }
            }]) && r(t.prototype, o), a && r(t, a), e
        }())
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nuniform vec3 mouse;\n\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\n\nvarying vec2 vUv;\n\nvec3 convertHsvToRgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // coordinate transformation\n  vec4 mPosition = modelMatrix * vec4(position, 1.0);\n  vec3 subPosition = mouse - mPosition.xyz;\n  float force = (1000.0 - clamp(length(subPosition), 0.0, 1000.0)) / 4.0;\n  mPosition = vec4(mPosition.xyz + force * normalize(-subPosition), 1.0);\n\n  vUv = uv;\n\n  gl_Position = projectionMatrix * viewMatrix * mPosition;\n  gl_PointSize = 3.0;\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "precision highp float;\n#define GLSLIFY 1\n\nuniform sampler2D tex;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vec4 texColor = texture2D(tex, vUv);\n  gl_FragColor = texColor;\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t);
    var r = n(0),
        i = n(3),
        o = n(1),
        a = n(104),
        s = n(105),
        c = n(107).default,
        u = n(462).default,
        l = n(463).default,
        f = n(466).default,
        d = n(469).default,
        h = n(472).default;
    t.default = function() {
        var e = new r.Vector2,
            t = new r.Vector2,
            n = document.getElementById("canvas-webgl"),
            v = new r.WebGLRenderer({
                alpha: !0,
                antialias: !0,
                canvas: n
            }),
            p = new r.Scene,
            m = new c,
            y = new u(m),
            g = new r.Clock;
        m.far = 5e4, m.setFocalLength(35);
        var x = new l,
            b = new f,
            w = new d,
            M = new h,
            _ = function e() {
                var n;
                n = g.getDelta(), x.render(n), b.render(n), w.render(n), M.render(n), y.render(n, t), v.render(p, m), requestAnimationFrame(e)
            },
            S = function() {
                e.set(document.body.clientWidth, window.innerHeight), n.width = e.x, n.height = e.y, m.aspect = e.x / e.y, m.updateProjectionMatrix(), v.setSize(e.x, e.y)
            };
        x.createObj(), b.createObj(), w.createObj(), M.createObj(), p.add(x.obj), p.add(b.obj), p.add(w.obj), p.add(M.obj), v.setClearColor(0, 1), y.init([0, 1500, 3e3], [0, -100, 0]), g.start(), window.addEventListener("resize", i(S, 1e3)), a() || s() ? window.addEventListener("deviceorientation", (function(n) {
            e.x / e.y < 1 ? t.set(n.gamma / 60, -.02 * o.clamp(Math.abs(n.beta) - 90, -90, 90)) : t.set(0, 0)
        })) : (window.addEventListener("mousemove", (function(n) {
            t.set(n.clientX / e.x * 2 - 1, -(n.clientY / e.y * 2 - 1))
        })), window.addEventListener("mouseout", (function(e) {
            t.set(0, 0)
        }))), S(), _()
    }
}, function(e, t, n) {
    "use strict";

    function r(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }
    n.r(t), n.d(t, "default", (function() {
        return o
    }));
    n(0);
    var i = n(75),
        o = (n(1), function() {
            function e(t, n) {
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, e), this.camera = t, this.anchorTilt = [0, 0, 0]
            }
            var t, n, o;
            return t = e, (n = [{
                key: "init",
                value: function(e, t) {
                    for (var n = 0; n < e.length; n++) this.camera.anchor[n] = this.camera.velocity[n] = e[n], this.camera.lookAnchor[n] = this.camera.lookVelocity[n] = t[n]
                }
            }, {
                key: "tilt",
                value: function(e) {
                    this.anchorTilt = [-200 * e.x, 200 * e.y, 0]
                }
            }, {
                key: "move",
                value: function(e, t, n) {
                    for (var r = 0; r < e.length; r++) this.camera.anchor[r] = e[r], this.camera.lookAnchor[r] = t[r];
                    n > 0 && this.focalLength.next !== n && (this.focalLength.prev = this.focalLength.next, this.focalLength.next = n, this.focalLength.time = 0)
                }
            }, {
                key: "render",
                value: function(e, t) {
                    this.tilt(t), i.vec3.add(this.camera.velocity, this.camera.velocity, this.anchorTilt), this.camera.render()
                }
            }]) && r(t.prototype, n), o && r(t, o), e
        }())
}, function(e, t, n) {
    "use strict";

    function r(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }
    n.r(t), n.d(t, "default", (function() {
        return o
    }));
    var i = n(0),
        o = (n(1), function() {
            function e() {
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, e), this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    }
                }, this.obj
            }
            var t, o, a;
            return t = e, (o = [{
                key: "createObj",
                value: function() {
                    var e = new i.OctahedronBufferGeometry(450, 3),
                        t = new i.RawShaderMaterial({
                            uniforms: this.uniforms,
                            vertexShader: n(464).default,
                            fragmentShader: n(465).default,
                            flatShading: !0
                        });
                    this.obj = new i.Mesh(e, t)
                }
            }, {
                key: "render",
                value: function(e) {
                    this.uniforms.time.value += e
                }
            }]) && r(t.prototype, o), a && r(t, a), e
        }())
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\n\nvoid main(void) {\n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n\n  vPosition = position;\n  vUv = uv;\n\n  gl_Position = projectionMatrix * mvPosition;\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "precision highp float;\n#define GLSLIFY 1\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\n\nconst vec3 light = vec3(0.0, 1.0, 0.0);\n\nvec3 convertHsvToRgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Flat Shading\n  vec3 normal = normalize(cross(dFdx(vPosition), dFdy(vPosition)));\n  float diff = (dot(normal, light) + 1.0) / 2.0;\n\n  vec3 hsv = vec3(0.88 + diff * 0.2, 1.0 - diff * 0.4, pow(diff, 3.0) * 0.88 + 0.12);\n  vec3 rgb = convertHsvToRgb(hsv);\n\n  gl_FragColor = vec4(rgb, 1.0);\n}\n"
}, function(e, t, n) {
    "use strict";

    function r(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }
    n.r(t), n.d(t, "default", (function() {
        return o
    }));
    var i = n(0),
        o = (n(1), function() {
            function e() {
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, e), this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    }
                }, this.obj
            }
            var t, o, a;
            return t = e, (o = [{
                key: "createObj",
                value: function() {
                    var e = new i.PlaneBufferGeometry(1e3, 3e3, 128, 128),
                        t = new i.RawShaderMaterial({
                            uniforms: this.uniforms,
                            vertexShader: n(467).default,
                            fragmentShader: n(468).default,
                            transparent: !0,
                            depthWrite: !1,
                            side: i.DoubleSide,
                            blending: i.AdditiveBlending
                        });
                    this.obj = new i.Mesh(e, t)
                }
            }, {
                key: "render",
                value: function(e) {
                    this.uniforms.time.value += e
                }
            }]) && r(t.prototype, o), a && r(t, a), e
        }())
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform float time;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\nvoid main(void) {\n  float roundRadius = (1.0 - smoothstep(0.1, 1.0, uv.y)* 1.2) * 480.0;\n  vec3 roundPosition = vec3(\n    sin(radians(uv.x * 360.0)) * roundRadius,\n    position.y + 900.0,\n    cos(radians(uv.x * 360.0)) * roundRadius\n    );\n\n  float noise = (snoise(roundPosition * vec3(0.01, 0.0001, 0.01) + time * 0.8) + 0.5);\n  float noiseRadius = noise * smoothstep(0.2, 0.3, uv.y) * 70.0;\n  vec3 noisePosition = vec3(\n    sin(radians(uv.x * 360.0)) * noiseRadius,\n    0.0,\n    cos(radians(uv.x * 360.0)) * noiseRadius\n    );\n\n  vec4 mvPosition = modelViewMatrix * vec4(roundPosition + noisePosition, 1.0);\n\n  vPosition = roundPosition;\n  vUv = uv;\n\n  gl_Position = projectionMatrix * mvPosition;\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\nvec3 convertHsvToRgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  float noise = snoise(\n    vPosition * vec3(0.005, 0.002, 0.004) + vec3(time * 2.6, -time * 3.6, time * 2.6)\n    );\n  float opacity = smoothstep(0.3, 0.8, (noise + 1.0) / 2.0 - (1.0 - smoothstep(0.0, 0.3, vUv.y) * (1.0 - smoothstep(0.3, 1.0, vUv.y))));\n  vec3 hsv = vec3(0.98 + opacity * 0.2, 1.0 - opacity * 0.6, 1.0);\n  vec3 rgb = convertHsvToRgb(hsv);\n\n  gl_FragColor = vec4(rgb, opacity);\n}\n"
}, function(e, t, n) {
    "use strict";

    function r(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }
    n.r(t), n.d(t, "default", (function() {
        return a
    }));
    var i = n(0),
        o = n(1),
        a = function() {
            function e() {
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, e), this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    }
                }, this.num = 5e3, this.obj
            }
            var t, a, s;
            return t = e, (a = [{
                key: "createObj",
                value: function() {
                    var e = new i.InstancedBufferGeometry,
                        t = new i.BoxBufferGeometry(16, 800, 200);
                    e.copy(t);
                    for (var r = new i.InstancedBufferAttribute(new Float32Array(3 * this.num), 3), a = new i.InstancedBufferAttribute(new Float32Array(this.num), 1), s = new i.InstancedBufferAttribute(new Float32Array(this.num), 1), c = new i.InstancedBufferAttribute(new Float32Array(this.num), 1), u = 0, l = this.num; u < l; u++) {
                        o.radians(o.randomArbitrary(0, 360));
                        var f = o.randomArbitrary(1e3, 7e3),
                            d = (7e3 - f) / 7e3 * .75 + .25,
                            h = o.randomArbitrary(.1, .4);
                        r.setXYZ(u, f, o.randomArbitrary(-1e4, -100), 0), a.setXYZ(u, d), s.setXYZ(u, u), c.setXYZ(u, h)
                    }
                    e.addAttribute("instancePosition", r), e.addAttribute("scale", a), e.addAttribute("rotate", s), e.addAttribute("speed", c);
                    var v = new i.RawShaderMaterial({
                        uniforms: this.uniforms,
                        vertexShader: n(470).default,
                        fragmentShader: n(471).default,
                        flatShading: !0
                    });
                    this.obj = new i.Mesh(e, v)
                }
            }, {
                key: "render",
                value: function(e) {
                    this.uniforms.time.value += e
                }
            }]) && r(t.prototype, a), s && r(t, s), e
        }()
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\nattribute vec3 instancePosition;\nattribute float scale;\nattribute float rotate;\nattribute float speed;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform float time;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\nvarying float vDistance;\n\nmat4 calcRotateMat4X(float radian) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, cos(radian), -sin(radian), 0.0,\n    0.0, sin(radian), cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4Y(float radian) {\n  return mat4(\n    cos(radian), 0.0, sin(radian), 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    -sin(radian), 0.0, cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4Z(float radian) {\n  return mat4(\n    cos(radian), -sin(radian), 0.0, 0.0,\n    sin(radian), cos(radian), 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4(vec3 radian) {\n  return calcRotateMat4X(radian.x) * calcRotateMat4Y(radian.y) * calcRotateMat4Z(radian.z);\n}\n\nmat4 calcScaleMat4(vec3 scale) {\n  return mat4(\n    scale.x, 0.0, 0.0, 0.0,\n    0.0, scale.y, 0.0, 0.0,\n    0.0, 0.0, scale.z, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nvoid main(void) {\n  mat4 scaleMat = calcScaleMat4(vec3(scale));\n  mat4 rotateMatWorld = calcRotateMat4(vec3(0.0, rotate + time * speed * 0.2, 0.0));\n  vec3 updatePosition = (scaleMat * vec4(position, 1.0)).xyz;\n  vec4 mvPosition = modelViewMatrix * rotateMatWorld * vec4(updatePosition + instancePosition, 1.0);\n  float distanceFromCenter = 1.0 - clamp(length(instancePosition) / 6000.0, 0.0, 0.8);\n\n  vPosition = updatePosition + instancePosition;\n  vUv = uv;\n  vDistance = distanceFromCenter;\n\n  gl_Position = projectionMatrix * mvPosition;\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "precision highp float;\n#define GLSLIFY 1\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\nvarying float vDistance;\n\nvec3 convertHsvToRgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Flat Shading\n  vec3 light = normalize(-vPosition);\n  vec3 normal = normalize(cross(dFdx(vPosition), dFdy(vPosition)));\n  float diff = (dot(normal, light) + 1.0) / 2.0;\n\n  vec3 hsv = vec3(\n    0.86 + diff * 0.24,\n    1.0 - diff * 0.4,\n    (diff * 0.88 + 0.12) * vDistance\n    );\n  vec3 rgb = convertHsvToRgb(hsv);\n\n  gl_FragColor = vec4(rgb, 1.0);\n}\n"
}, function(e, t, n) {
    "use strict";

    function r(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }
    n.r(t), n.d(t, "default", (function() {
        return o
    }));
    var i = n(0),
        o = (n(1), function() {
            function e() {
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, e), this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    }
                }, this.obj
            }
            var t, o, a;
            return t = e, (o = [{
                key: "createObj",
                value: function() {
                    var e = new i.SphereBufferGeometry(1e4, 128, 128),
                        t = new i.RawShaderMaterial({
                            uniforms: this.uniforms,
                            vertexShader: n(473).default,
                            fragmentShader: n(474).default,
                            side: i.BackSide
                        });
                    this.obj = new i.Mesh(e, t)
                }
            }, {
                key: "render",
                value: function(e) {
                    this.uniforms.time.value += e
                }
            }]) && r(t.prototype, o), a && r(t, a), e
        }())
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\nvarying vec3 vColor;\n\nconst vec3 hsv1 = vec3(0.98, 0.9, 0.05);\nconst vec3 hsv2 = vec3(1.13, 0.9, 0.8);\n\nvec3 convertHsvToRgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main(void) {\n  // calculate gradation with position.y\n  vec3 rgb = convertHsvToRgb(mix(hsv1, hsv2, (normalize(position).y + 1.0) / 2.0));\n\n  // coordinate transformation\n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n\n  vPosition = position;\n  vUv = uv;\n  vColor = rgb;\n\n  gl_Position = projectionMatrix * mvPosition;\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\nuniform sampler2D tex;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\nvarying vec3 vColor;\n\nfloat random(vec2 c){\n  return fract(sin(dot(c.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid main() {\n  float noise = random(vUv) * 0.08;\n\n  gl_FragColor = vec4(vColor + noise, 1.0);\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t);
    var r = n(0),
        i = n(3),
        o = n(1),
        a = n(104),
        s = n(105),
        c = n(107).default,
        u = n(106).default,
        l = n(476).default,
        f = n(477).default,
        d = n(480).default,
        h = n(483).default,
        v = n(488).default,
        p = n(491).default,
        m = n(494).default;
    t.default = function() {
        var e = new r.Vector2,
            t = new r.Vector2,
            n = document.getElementById("canvas-webgl"),
            y = new r.WebGLRenderer({
                alpha: !0,
                antialias: !0,
                canvas: n
            }),
            g = new r.Scene,
            x = new c,
            b = new l(x),
            w = new r.Clock;
        x.far = 5e4, x.setFocalLength(24);
        var M = new f,
            _ = new d,
            S = new h,
            P = new v,
            T = new p,
            E = new m,
            z = new m,
            L = function e() {
                var n;
                n = w.getDelta(), M.render(n), _.render(n), S.render(n), P.render(n), T.render(n), E.render(n, .1, .1, .3), z.render(n, -.2, .02, -.8), b.render(n, t), y.render(g, x), requestAnimationFrame(e)
            },
            A = function() {
                e.set(document.body.clientWidth, window.innerHeight), n.width = e.x, n.height = e.y, x.aspect = e.x / e.y, x.updateProjectionMatrix(), y.setSize(e.x, e.y)
            };
        u({
            gui1: "../img/sketch/cyberspace/tex_gui01.png",
            gui2: "../img/sketch/cyberspace/tex_gui02.png",
            gui3: "../img/sketch/cyberspace/tex_gui03.png"
        }, (function(n) {
            M.createObj([n.gui1, n.gui2, n.gui3]), _.createObj(), S.createObj(), P.createObj(), T.createObj(), E.createObj(1200, 284.1, 398.6, 601.2, 828.4), z.createObj(2400, 222.6, 412.4, 683.9, 961.2), g.add(M.obj), g.add(_.obj), g.add(S.obj), g.add(S.objWire), g.add(S.objPoints), g.add(P.obj), g.add(T.obj), g.add(E.obj), g.add(z.obj), T.obj.position.set(0, 0, -2e3), y.setClearColor(0, 1), b.init([0, 0, 1e3], [0, 0, 0]), w.start(), window.addEventListener("resize", i(A, 1e3)), a() || s() ? window.addEventListener("deviceorientation", (function(n) {
                e.x / e.y < 1 ? t.set(n.gamma / 60, o.clamp(Math.abs(n.beta) - 90, -90, 90) / -30) : t.set(0, 0)
            })) : (window.addEventListener("mousemove", (function(n) {
                t.set(n.clientX / e.x * 2 - 1, -(n.clientY / e.y * 2 - 1))
            })), window.addEventListener("mouseout", (function(e) {
                t.set(0, 0)
            }))), A(), L()
        }))
    }
}, function(e, t, n) {
    "use strict";

    function r(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }
    n.r(t), n.d(t, "default", (function() {
        return o
    }));
    n(0);
    var i = n(75),
        o = (n(1), function() {
            function e(t, n) {
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, e), this.camera = t, this.anchorTilt = [0, 0, 0]
            }
            var t, n, o;
            return t = e, (n = [{
                key: "init",
                value: function(e, t) {
                    for (var n = 0; n < e.length; n++) this.camera.anchor[n] = this.camera.velocity[n] = e[n], this.camera.lookAnchor[n] = this.camera.lookVelocity[n] = t[n]
                }
            }, {
                key: "tilt",
                value: function(e) {
                    this.anchorTilt = [-50 * e.x, 25 * e.y, 0]
                }
            }, {
                key: "move",
                value: function(e, t, n) {
                    for (var r = 0; r < e.length; r++) this.camera.anchor[r] = e[r], this.camera.lookAnchor[r] = t[r];
                    n > 0 && this.focalLength.next !== n && (this.focalLength.prev = this.focalLength.next, this.focalLength.next = n, this.focalLength.time = 0)
                }
            }, {
                key: "render",
                value: function(e, t) {
                    this.tilt(t), i.vec3.add(this.camera.velocity, this.camera.velocity, this.anchorTilt), this.camera.render()
                }
            }]) && r(t.prototype, n), o && r(t, o), e
        }())
}, function(e, t, n) {
    "use strict";

    function r(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }
    n.r(t), n.d(t, "default", (function() {
        return o
    }));
    var i = n(0),
        o = (n(1), function() {
            function e() {
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, e), this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    },
                    texture1: {
                        type: "t",
                        value: null
                    },
                    texture2: {
                        type: "t",
                        value: null
                    },
                    texture3: {
                        type: "t",
                        value: null
                    }
                }, this.num = 6, this.obj
            }
            var t, o, a;
            return t = e, (o = [{
                key: "createObj",
                value: function(e) {
                    var t = new i.InstancedBufferGeometry,
                        r = new i.PlaneBufferGeometry(1200, 1200, 2, 2);
                    t.copy(r);
                    for (var o = new i.InstancedBufferAttribute(new Float32Array(3 * this.num), 3), a = new i.InstancedBufferAttribute(new Float32Array(this.num), 1), s = new i.InstancedBufferAttribute(new Float32Array(this.num), 1), c = new i.InstancedBufferAttribute(new Float32Array(this.num), 1), u = new i.InstancedBufferAttribute(new Float32Array(this.num), 1), l = 0, f = this.num; l < f; l++) o.setXYZ(l, 0, 0, -150 * (this.num - l)), a.setXYZ(l, 2 * Math.random() - 1), s.setXYZ(l, 2 * Math.random() - 1), c.setXYZ(l, 2 * Math.random() - 1), u.setXYZ(l, .15 * (2 * Math.random() - 1));
                    t.addAttribute("instancePosition", o), t.addAttribute("rotate1", a), t.addAttribute("rotate2", s), t.addAttribute("rotate3", c), t.addAttribute("h", u);
                    var d = new i.RawShaderMaterial({
                        uniforms: this.uniforms,
                        vertexShader: n(478).default,
                        fragmentShader: n(479).default,
                        transparent: !0,
                        blending: i.AdditiveBlending
                    });
                    this.uniforms.texture1.value = e[0], this.uniforms.texture2.value = e[1], this.uniforms.texture3.value = e[2], this.obj = new i.Mesh(t, d)
                }
            }, {
                key: "render",
                value: function(e) {
                    this.uniforms.time.value += e
                }
            }]) && r(t.prototype, o), a && r(t, a), e
        }())
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nattribute vec3 instancePosition;\nattribute float rotate1;\nattribute float rotate2;\nattribute float rotate3;\nattribute float h;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform float time;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\nvarying vec3 vColor;\nvarying float vRotate1;\nvarying float vRotate2;\nvarying float vRotate3;\n\nvec3 convertHsvToRgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main(void) {\n  // calculate colors\n  vec3 hsv = vec3(h + time * 0.1 + 0.5, 0.4, 1.0);\n  vec3 rgb = convertHsvToRgb(hsv);\n\n  // coordinate transformation\n  vec4 mvPosition = modelViewMatrix * vec4(position + instancePosition, 1.0);\n\n  vPosition = position;\n  vUv = uv;\n  vColor = rgb;\n  vRotate1 = rotate1;\n  vRotate2 = rotate2;\n  vRotate3 = rotate3;\n\n  gl_Position = projectionMatrix * mvPosition;\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\nuniform sampler2D texture1;\nuniform sampler2D texture2;\nuniform sampler2D texture3;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\nvarying vec3 vColor;\nvarying float vRotate1;\nvarying float vRotate2;\nvarying float vRotate3;\n\nmat3 rotateMat3(float radian) {\n  return mat3(\n    cos(radian), -sin(radian), 0.0,\n    sin(radian), cos(radian), 0.0,\n    0.0, 0.0, 1.0\n  );\n}\n\nvoid main() {\n  // rotate textures\n  vec2 uv1 = ((vec3(vUv - 0.5, 1.0) * rotateMat3(time * vRotate1)).xy + 0.5);\n  vec2 uv2 = ((vec3(vUv - 0.5, 1.0) * rotateMat3(time * vRotate2)).xy + 0.5);\n  vec2 uv3 = ((vec3(vUv - 0.5, 1.0) * rotateMat3(time * vRotate3)).xy + 0.5);\n  vec4 texColor1 = texture2D(texture1, uv1);\n  vec4 texColor2 = texture2D(texture2, uv2);\n  vec4 texColor3 = texture2D(texture3, uv3);\n  vec4 color = texColor1 + texColor2 + texColor3;\n\n  // discard low alpha value\n  if (color.a <= 0.1) discard;\n\n  gl_FragColor = vec4(vColor, color.a * 0.35);\n}\n"
}, function(e, t, n) {
    "use strict";

    function r(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }
    n.r(t), n.d(t, "default", (function() {
        return a
    }));
    var i = n(0),
        o = n(1),
        a = function() {
            function e() {
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, e), this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    }
                }, this.instances = 2e3, this.obj
            }
            var t, a, s;
            return t = e, (a = [{
                key: "createObj",
                value: function() {
                    var e = new i.InstancedBufferGeometry,
                        t = new i.BoxBufferGeometry(100, 4e3, 2, 2, 2);
                    e.copy(t);
                    for (var r = new i.InstancedBufferAttribute(new Float32Array(3 * this.instances), 3), a = new i.InstancedBufferAttribute(new Float32Array(this.instances), 1), s = new i.InstancedBufferAttribute(new Float32Array(this.instances), 1), c = 0, u = this.instances; c < u; c++) r.setXYZ(c, o.randomArbitrary(-5e3, 5e3), 0, o.randomArbitrary(-500, 500) + 700 * (2 * o.randomInt(0, 1) - 1)), a.setXYZ(c, 2 * Math.random()), s.setXYZ(c, .3 * Math.random());
                    e.addAttribute("instancePosition", r), e.addAttribute("delay", a), e.addAttribute("h", s);
                    var l = new i.RawShaderMaterial({
                        uniforms: this.uniforms,
                        vertexShader: n(481).default,
                        fragmentShader: n(482).default,
                        depthWrite: !1,
                        transparent: !0,
                        side: i.DoubleSide,
                        blending: i.AdditiveBlending
                    });
                    this.obj = new i.Mesh(e, l)
                }
            }, {
                key: "render",
                value: function(e) {
                    this.uniforms.time.value += e
                }
            }]) && r(t.prototype, a), s && r(t, s), e
        }()
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\nattribute vec3 instancePosition;\nattribute float delay;\nattribute float h;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform float time;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\nvarying float vDelay;\nvarying vec3 vColor;\n\nmat4 calcRotateMat4X(float radian) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, cos(radian), -sin(radian), 0.0,\n    0.0, sin(radian), cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4Y(float radian) {\n  return mat4(\n    cos(radian), 0.0, sin(radian), 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    -sin(radian), 0.0, cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4Z(float radian) {\n  return mat4(\n    cos(radian), -sin(radian), 0.0, 0.0,\n    sin(radian), cos(radian), 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4(vec3 radian) {\n  return calcRotateMat4X(radian.x) * calcRotateMat4Y(radian.y) * calcRotateMat4Z(radian.z);\n}\n\nvec3 convertHsvToRgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main(void) {\n  // update positions\n  vec3 updatePosition = position + instancePosition;\n  mat4 rotateMat = calcRotateMat4(vec3(radians(90.0), 0.0, radians(180.0)));\n\n  // calculate colors\n  vec3 hsv = vec3(h + time * 0.1, 0.35, 0.6);\n  vec3 rgb = convertHsvToRgb(hsv);\n\n  // coordinate transformation\n  vec4 mvPosition = modelViewMatrix * rotateMat * vec4(updatePosition, 1.0);\n\n  vPosition = position;\n  vUv = uv;\n  vDelay = delay;\n  vColor = rgb;\n\n  gl_Position = projectionMatrix * mvPosition;\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\nvarying float vDelay;\nvarying vec3 vColor;\n\nconst float duration = 10.0;\n\nvoid main() {\n  // calculate interval time from 0 to 1\n  float now = mod(time + vDelay * duration, duration) / duration;\n\n  float opacityBothEnds = smoothstep(-2000.0, -1800.0, vPosition.y) * (1.0 - smoothstep(1800.0, 2000.0, vPosition.y));\n  float opacity = smoothstep(0.85, 1.0, mod(vUv.y - now, 1.0));\n\n  gl_FragColor = vec4(vColor, opacity * opacityBothEnds * 0.08);\n}\n"
}, function(e, t, n) {
    "use strict";

    function r(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }
    n.r(t), n.d(t, "default", (function() {
        return a
    }));
    var i = n(0),
        o = n(1),
        a = function() {
            function e() {
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, e), this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    }
                }, this.obj, this.objWire = null, this.objPoints = null
            }
            var t, a, s;
            return t = e, (a = [{
                key: "createObj",
                value: function() {
                    var e = new i.RingBufferGeometry(1550, 1600, 36, 2, o.radians(135), o.radians(270)),
                        t = new i.RawShaderMaterial({
                            uniforms: this.uniforms,
                            vertexShader: n(147).default,
                            fragmentShader: n(484).default,
                            depthWrite: !1,
                            transparent: !0,
                            blending: i.AdditiveBlending,
                            flatShading: !0
                        }),
                        r = new i.RawShaderMaterial({
                            uniforms: this.uniforms,
                            vertexShader: n(147).default,
                            fragmentShader: n(485).default,
                            depthWrite: !1,
                            transparent: !0,
                            blending: i.AdditiveBlending,
                            wireframe: !0
                        }),
                        a = new i.RawShaderMaterial({
                            uniforms: this.uniforms,
                            vertexShader: n(486).default,
                            fragmentShader: n(487).default,
                            depthWrite: !1,
                            transparent: !0,
                            blending: i.AdditiveBlending
                        });
                    this.obj = new i.Mesh(e, t), this.objWire = new i.Mesh(e, r), this.objPoints = new i.Points(e, a), this.obj.position.set(0, 0, -1200), this.objWire.position.set(0, 0, -1200), this.objPoints.position.set(0, 0, -1200)
                }
            }, {
                key: "render",
                value: function(e) {
                    this.uniforms.time.value += e;
                    var t = [o.radians(20 * Math.sin(.1 * this.uniforms.time.value) + 90), o.radians(20 * Math.sin(.05 * this.uniforms.time.value)), 0];
                    this.obj.rotation.set(t[0], t[1], t[2]), this.objWire.rotation.set(t[0], t[1], t[2]), this.objPoints.rotation.set(t[0], t[1], t[2])
                }
            }]) && r(t.prototype, a), s && r(t, s), e
        }()
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\n\nvarying vec3 vPosition;\nvarying vec3 vColor;\n\nvoid main() {\n  // flat shading\n  vec3 light = normalize(vec3(0.0, 1.0, 1.0));\n  vec3 normal = normalize(cross(dFdx(vPosition), dFdy(vPosition)));\n  float diff = pow((dot(normal, light) + 1.0) / 2.0, 10.0);\n\n  gl_FragColor = vec4(vColor, diff * 0.4 + 0.03);\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "precision highp float;\n#define GLSLIFY 1\n\nvarying vec3 vColor;\n\nvoid main() {\n  gl_FragColor = vec4(vColor, 0.15);\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform float time;\nuniform float timeShow;\nuniform float durationShow;\n\nvec3 convertHsvToRgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nmat4 calcRotateMat4X(float radian) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, cos(radian), -sin(radian), 0.0,\n    0.0, sin(radian), cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4Y(float radian) {\n  return mat4(\n    cos(radian), 0.0, sin(radian), 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    -sin(radian), 0.0, cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4Z(float radian) {\n  return mat4(\n    cos(radian), -sin(radian), 0.0, 0.0,\n    sin(radian), cos(radian), 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4(vec3 radian) {\n  return calcRotateMat4X(radian.x) * calcRotateMat4Y(radian.y) * calcRotateMat4Z(radian.z);\n}\n\nvarying vec3 vPosition;\nvarying vec3 vColor;\n\nvoid main() {\n  // convert uv to range from -1.0 to 1.0\n  vec2 p = uv * 2.0 - 1.0;\n\n  // update rotation\n  float rotateX = p.x * 100.0 + time / 2.0;\n  float rotateY = p.y * 200.0 + time / 2.0;\n  float rotateZ = length(p.xy) * 150.0 + time / 2.0;\n  mat4 rotateMat = calcRotateMat4(vec3(rotateX, rotateY, rotateZ));\n  vec3 rotatePosition = (rotateMat * vec4(vec3(sin(time * 0.1 + p.x * 10.0) * 150.0), 1.0)).xyz;\n\n  // update position\n  vec3 wavePosition = vec3(0.0, 0.0, sin(time * 0.1 + (p.x + p.y) * 5.6) * 300.0);\n  vec3 updatePosition = position + rotatePosition + wavePosition;\n\n  // update size\n  float size = (pow(sin(rotateX * 10.0), 3.0) + 1.0) * 2.0 + 3.0;\n\n  // calculate colors\n  vec3 hsv = vec3(time * 0.1, 0.35, 0.6);\n  vec3 rgb = convertHsvToRgb(hsv);\n\n  // coordinate transformation\n  vec4 mvPosition = modelViewMatrix * vec4(updatePosition, 1.0);\n\n  vPosition = updatePosition;\n  vColor = rgb;\n\n  gl_Position = projectionMatrix * mvPosition;\n  gl_PointSize = size;\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "precision highp float;\n#define GLSLIFY 1\n\nvarying vec3 vColor;\n\nvoid main() {\n  // make round\n  vec2 p = gl_PointCoord * 2.0 - 1.0;\n  float radius = length(p);\n  float r = 1.0 - smoothstep(0.95, 1.0, radius);\n\n  gl_FragColor = vec4(vColor, r * 0.1);\n}\n"
}, function(e, t, n) {
    "use strict";

    function r(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }
    n.r(t), n.d(t, "default", (function() {
        return a
    }));
    var i = n(0),
        o = n(1),
        a = function() {
            function e() {
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, e), this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    }
                }, this.num = 2e3, this.obj
            }
            var t, a, s;
            return t = e, (a = [{
                key: "createObj",
                value: function() {
                    for (var e = new i.BufferGeometry, t = new i.BufferAttribute(new Float32Array(3 * this.num), 3, 1), r = new i.BufferAttribute(new Float32Array(this.num), 1, 1), a = new i.BufferAttribute(new Float32Array(this.num), 1, 1), s = 0, c = this.num; s < c; s++) {
                        var u = o.radians(o.randomArbitrary(0, 150) - 75),
                            l = o.radians(o.randomArbitrary(0, 360)),
                            f = o.randomArbitrary(600, 2500),
                            d = o.spherical(u, l, f);
                        t.setXYZ(s, d[0], d[1], d[2]), r.setXYZ(s, Math.random()), a.setXYZ(s, o.randomArbitrary(5, 10) * (2 * o.randomInt(0, 1) - 1))
                    }
                    e.addAttribute("position", t), e.addAttribute("delay", r), e.addAttribute("speed", a);
                    var h = new i.RawShaderMaterial({
                        uniforms: this.uniforms,
                        vertexShader: n(489).default,
                        fragmentShader: n(490).default,
                        transparent: !0,
                        depthWrite: !1,
                        blending: i.AdditiveBlending
                    });
                    this.obj = new i.Points(e, h)
                }
            }, {
                key: "render",
                value: function(e) {
                    this.uniforms.time.value += e
                }
            }]) && r(t.prototype, a), s && r(t, s), e
        }()
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nattribute vec3 position;\nattribute float delay;\nattribute float speed;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform float time;\n\nvarying vec3 vColor1;\nvarying vec3 vColor2;\nvarying float vOpacity;\n\nvec3 convertHsvToRgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nmat4 calcRotateMat4X(float radian) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, cos(radian), -sin(radian), 0.0,\n    0.0, sin(radian), cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4Y(float radian) {\n  return mat4(\n    cos(radian), 0.0, sin(radian), 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    -sin(radian), 0.0, cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4Z(float radian) {\n  return mat4(\n    cos(radian), -sin(radian), 0.0, 0.0,\n    sin(radian), cos(radian), 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4(vec3 radian) {\n  return calcRotateMat4X(radian.x) * calcRotateMat4Y(radian.y) * calcRotateMat4Z(radian.z);\n}\n\nconst float duration = 3.0;\n\nvoid main() {\n  // calculate interval time from 0 to 1\n  float interval = mod(time + delay * duration, duration) / duration;\n\n  // update position and size\n  float size = 10.0 * sin(interval * 4.0);\n  float blink = max(sin(interval * 4.0) * 2.0 - 1.0, 0.0);\n  mat4 rotateMat = calcRotateMat4(vec3(\n    radians(time * speed * 0.3),\n    radians(time * speed),\n    radians(time * speed * 0.3)\n    ));\n\n  // calculate colors\n  vec3 hsv1 = vec3(time * 0.1, 0.6, 1.0);\n  vec3 rgb1 = convertHsvToRgb(hsv1);\n  vec3 hsv2 = vec3(time * 0.1 + 0.2, 0.6, 1.0);\n  vec3 rgb2 = convertHsvToRgb(hsv2);\n\n  // coordinate transformation\n  vec4 mvPosition = modelViewMatrix * rotateMat * vec4(position, 1.0);\n  float distanceFromCamera = 1000.0 / length(mvPosition.xyz);\n\n  vColor1 = rgb1;\n  vColor2 = rgb2;\n  vOpacity = blink * clamp(distanceFromCamera, 0.1, 0.8);\n\n  gl_Position = projectionMatrix * mvPosition;\n  gl_PointSize = distanceFromCamera * size;\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "precision highp float;\n#define GLSLIFY 1\n\nuniform sampler2D texture;\n\nvarying vec3 vColor1;\nvarying vec3 vColor2;\nvarying float vOpacity;\n\nvoid main() {\n  // convert PointCoord to range from -1.0 to 1.0\n  vec2 p = gl_PointCoord * 2.0 - 1.0;\n\n  // draw double circle\n  float radius = length(p);\n  float r1 = (1.0 - smoothstep(0.95, 1.0, radius));\n  float r2 = (1.0 - smoothstep(0.45, 0.5, radius));\n  vec3 color1 = vColor1 * (r1 - r2);\n  vec3 color2 = vColor2 * r2;\n  vec3 color = color1 + color2;\n  float opacity = ((r1 - r2) * 0.25 + r2 * 0.5) * vOpacity;\n\n  gl_FragColor = vec4(color, opacity);\n}\n"
}, function(e, t, n) {
    "use strict";

    function r(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }
    n.r(t), n.d(t, "default", (function() {
        return o
    }));
    var i = n(0),
        o = (n(1), function() {
            function e() {
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, e), this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    }
                }, this.isShown = !1, this.obj
            }
            var t, o, a;
            return t = e, (o = [{
                key: "createObj",
                value: function() {
                    var e = new i.SphereBufferGeometry(1e4, 32, 32),
                        t = new i.RawShaderMaterial({
                            uniforms: this.uniforms,
                            vertexShader: n(492).default,
                            fragmentShader: n(493).default,
                            side: i.BackSide
                        });
                    this.obj = new i.Mesh(e, t)
                }
            }, {
                key: "render",
                value: function(e) {
                    this.uniforms.time.value += e
                }
            }]) && r(t.prototype, o), a && r(t, a), e
        }())
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\n\nvarying vec3 vPosition;\n\nvoid main() {\n  // coordinate transformation\n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n\n  vPosition = position;\n\n  gl_Position = projectionMatrix * mvPosition;\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\n\nvarying vec3 vPosition;\n\nvec3 convertHsvToRgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // calculate colors\n  vec3 hsv = vec3(time * 0.1 + 0.5, 1.0, (1.0 - abs(vPosition.y / 10000.0)) * 0.08);\n  vec3 rgb = convertHsvToRgb(hsv);\n\n  gl_FragColor = vec4(rgb, 1.0);\n}\n"
}, function(e, t, n) {
    "use strict";

    function r(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }
    n.r(t), n.d(t, "default", (function() {
        return o
    }));
    var i = n(0),
        o = (n(1), function() {
            function e() {
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, e), this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    },
                    wave1: {
                        type: "f",
                        value: 0
                    },
                    wave2: {
                        type: "f",
                        value: 0
                    },
                    wave3: {
                        type: "f",
                        value: 0
                    },
                    wave4: {
                        type: "f",
                        value: 0
                    }
                }, this.obj
            }
            var t, o, a;
            return t = e, (o = [{
                key: "createObj",
                value: function(e, t, r, o, a) {
                    var s = new i.SphereBufferGeometry(e, 64, 64),
                        c = new i.RawShaderMaterial({
                            uniforms: this.uniforms,
                            vertexShader: n(495).default,
                            fragmentShader: n(496).default,
                            transparent: !0,
                            depthWrite: !1,
                            side: i.BackSide,
                            blending: i.AdditiveBlending
                        });
                    this.uniforms.wave1.value = t, this.uniforms.wave2.value = r, this.uniforms.wave3.value = o, this.uniforms.wave4.value = a, this.obj = new i.Mesh(s, c)
                }
            }, {
                key: "render",
                value: function(e, t, n, r) {
                    this.uniforms.time.value += e, this.obj.rotation.set(t, this.uniforms.time.value * n, r)
                }
            }]) && r(t.prototype, o), a && r(t, a), e
        }())
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\n\nvoid main(void) {\n  // coordinate transformation\n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n\n  vPosition = position;\n  vUv = uv;\n\n  gl_Position = projectionMatrix * mvPosition;\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\nuniform float wave1;\nuniform float wave2;\nuniform float wave3;\nuniform float wave4;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\n\nvoid main() {\n  // draw lines\n  float v1 = sin(vUv.y * wave1 + time * 0.2);\n  float v2 = sin(vUv.y * wave2 + time * 0.2);\n  float v3 = sin(vUv.y * wave3 + time * 0.2);\n  float v4 = sin(vUv.y * wave4 + time * 0.2);\n  float v = smoothstep(0.65, 0.7, (v1 + v2 + v3 + v4) / 4.0);\n  vec3 color = vec3(v);\n\n  gl_FragColor = vec4(color, v * 0.08);\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t);
    var r = n(0),
        i = n(3),
        o = n(498).default;
    t.default = function() {
        var e = new r.Vector2,
            t = document.getElementById("canvas-webgl"),
            n = new r.WebGLRenderer({
                antialias: !0,
                canvas: t
            }),
            a = new r.Scene,
            s = new r.PerspectiveCamera(120, 1, 1, 1e4),
            c = new r.Clock,
            u = new r.Vector2,
            l = new r.Vector2,
            f = new r.Vector2,
            d = new o,
            h = function e() {
                var t;
                t = c.getDelta(), d.render(t), n.render(a, s), requestAnimationFrame(e)
            },
            v = function() {
                e.set(document.body.clientWidth, window.innerHeight), t.width = e.x, t.height = e.y, s.aspect = e.x / e.y, s.updateProjectionMatrix(), n.setSize(e.x, e.y)
            },
            p = function(e) {
                !0
            },
            m = function(e) {
                !1
            };
        window.addEventListener("resize", i(v, 1e3)), t.addEventListener("mousedown", (function(e) {
            e.preventDefault(), u.set(e.clientX, e.clientY), p()
        })), document.addEventListener("mousemove", (function(e) {
            e.preventDefault(), l.set(e.clientX, e.clientY)
        })), document.addEventListener("mouseup", (function(e) {
            e.preventDefault(), f.set(e.clientX, e.clientY), m()
        })), t.addEventListener("touchstart", (function(e) {
            e.preventDefault(), u.set(e.touches[0].clientX, e.touches[0].clientY), p()
        })), t.addEventListener("touchmove", (function(e) {
            e.preventDefault(), l.set(e.touches[0].clientX, e.touches[0].clientY)
        })), t.addEventListener("touchend", (function(e) {
            e.preventDefault(), f.set(e.changedTouches[0].clientX, e.changedTouches[0].clientY), m()
        })), v(), d.createObj(), a.add(d.obj), n.setClearColor(921102, 1), s.position.set(0, 0, 100), s.lookAt(new r.Vector3(0, 0, 0)), h()
    }
}, function(e, t, n) {
    "use strict";

    function r(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }
    n.r(t), n.d(t, "default", (function() {
        return a
    }));
    var i = n(0),
        o = n(1),
        a = function() {
            function e() {
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, e), this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    }
                }, this.instances = 500, this.obj
            }
            var t, a, s;
            return t = e, (a = [{
                key: "createObj",
                value: function() {
                    var e = new i.InstancedBufferGeometry,
                        t = new i.BoxBufferGeometry(1, 1e3, 1, 2, 128);
                    e.copy(t);
                    for (var r = new i.InstancedBufferAttribute(new Float32Array(3 * this.instances), 3), a = new i.InstancedBufferAttribute(new Float32Array(this.instances), 1), s = new i.InstancedBufferAttribute(new Float32Array(this.instances), 1), c = 0, u = this.instances; c < u; c++) r.setXYZ(c, 300 * ((Math.random() + Math.random() + Math.random()) / 3 * 2 - 1), 0, 150 * ((Math.random() + Math.random() + Math.random()) / 3 * 2 - 1)), a.setXYZ(c, 90 * (2 * o.randomInt(0, 1) - 1) + 60 * (2 * Math.random() - 1)), s.setXYZ(c, 2 * Math.random());
                    e.addAttribute("instancePosition", r), e.addAttribute("rotate", a), e.addAttribute("delay", s);
                    var l = new i.RawShaderMaterial({
                        uniforms: this.uniforms,
                        vertexShader: n(499).default,
                        fragmentShader: n(500).default,
                        depthWrite: !1,
                        transparent: !0,
                        side: i.DoubleSide,
                        blending: i.AdditiveBlending
                    });
                    this.obj = new i.Mesh(e, l)
                }
            }, {
                key: "render",
                value: function(e) {
                    this.uniforms.time.value += e
                }
            }]) && r(t.prototype, a), s && r(t, s), e
        }()
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = '#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\nattribute vec3 instancePosition;\nattribute float rotate;\nattribute float delay;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform float time;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\nvarying float vDelay;\nvarying vec3 vColor;\n\nmat4 calcRotateMat4X(float radian) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, cos(radian), -sin(radian), 0.0,\n    0.0, sin(radian), cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4Y(float radian) {\n  return mat4(\n    cos(radian), 0.0, sin(radian), 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    -sin(radian), 0.0, cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4Z(float radian) {\n  return mat4(\n    cos(radian), -sin(radian), 0.0, 0.0,\n    sin(radian), cos(radian), 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4(vec3 radian) {\n  return calcRotateMat4X(radian.x) * calcRotateMat4Y(radian.y) * calcRotateMat4Z(radian.z);\n}\n\n//\n// GLSL textureless classic 3D noise "cnoise",\n// with an RSL-style periodic variant "pnoise".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-10-11\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec3 fade(vec3 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise(vec3 P)\n{\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod289(Pi0);\n  Pi1 = mod289(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n  return 2.2 * n_xyz;\n}\n\nvec3 convertHsvToRgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main(void) {\n  // calculate posiitons of instances.\n  vec3 wavePosition = vec3(0.0, 0.0, sin(radians(position.y / 3.6) + time * 0.1 + delay * 9.0) * 50.0);\n  vec3 updatePosition = position + instancePosition + wavePosition;\n  mat4 rotateMat = calcRotateMat4(vec3(radians(90.0), 0.0, radians(rotate)));\n  vec4 mvPosition = modelViewMatrix * rotateMat * vec4(updatePosition, 1.0);\n\n  // calculate interval for uv animation and setting color.\n  float noise = cnoise(updatePosition / 100.0) * 0.5 + time * 0.1;\n  vec3 hsv = vec3(noise, 0.45, 1.0);\n  vec3 rgb = convertHsvToRgb(hsv);\n\n  vPosition = position;\n  vUv = uv;\n  vDelay = delay;\n  vColor = rgb;\n\n  gl_Position = projectionMatrix * mvPosition;\n}\n'
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\nvarying float vDelay;\nvarying vec3 vColor;\n\nconst float duration = 3.0;\n\nvoid main() {\n  float now = mod(time + vDelay * duration, duration) / duration;\n  float opacityBothEnds = smoothstep(-500.0, -400.0, vPosition.y) * (1.0 - smoothstep(400.0, 500.0, vPosition.y));\n  float opacity = smoothstep(0.95, 1.0, mod(vUv.y - now, 1.0));\n\n  gl_FragColor = vec4(vColor, opacity * opacityBothEnds * 0.9);\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t);
    var r = n(0),
        i = n(3),
        o = n(502).default;
    t.default = function() {
        var e = new r.Vector2,
            t = document.getElementById("canvas-webgl"),
            n = new r.WebGLRenderer({
                antialias: !1,
                canvas: t
            }),
            a = new r.Scene,
            s = new r.PerspectiveCamera(90, 1, 1, 1e4),
            c = new r.Clock,
            u = new r.Vector2,
            l = new r.Vector2,
            f = new r.Vector2,
            d = new o,
            h = function e() {
                var t;
                t = c.getDelta(), d.render(t), n.render(a, s), requestAnimationFrame(e)
            },
            v = function() {
                e.set(document.body.clientWidth, window.innerHeight), t.width = e.x, t.height = e.y, s.aspect = e.x / e.y, s.updateProjectionMatrix(), n.setSize(e.x, e.y)
            },
            p = function(e) {
                !0
            },
            m = function(e) {
                !1
            };
        window.addEventListener("resize", i(v, 1e3)), t.addEventListener("mousedown", (function(e) {
            e.preventDefault(), u.set(e.clientX, e.clientY), p()
        })), document.addEventListener("mousemove", (function(e) {
            e.preventDefault(), l.set(e.clientX, e.clientY)
        })), document.addEventListener("mouseup", (function(e) {
            e.preventDefault(), f.set(e.clientX, e.clientY), m()
        })), t.addEventListener("touchstart", (function(e) {
            e.preventDefault(), u.set(e.touches[0].clientX, e.touches[0].clientY), p()
        })), t.addEventListener("touchmove", (function(e) {
            e.preventDefault(), l.set(e.touches[0].clientX, e.touches[0].clientY)
        })), t.addEventListener("touchend", (function(e) {
            e.preventDefault(), f.set(e.changedTouches[0].clientX, e.changedTouches[0].clientY), m()
        })), v(), d.createObj(), a.add(d.obj), n.setClearColor(15329769, 1), s.position.set(10, 10, 50), s.lookAt(new r.Vector3), h()
    }
}, function(e, t, n) {
    "use strict";

    function r(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }
    n.r(t), n.d(t, "default", (function() {
        return o
    }));
    var i = n(0),
        o = function() {
            function e() {
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, e), this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    }
                }, this.obj
            }
            var t, o, a;
            return t = e, (o = [{
                key: "createObj",
                value: function() {
                    for (var e = new i.BufferGeometry, t = [], r = 0; r < 50; r++)
                        for (var o = 0; o < 50; o++)
                            for (var a = 0; a < 50; a++) {
                                var s = 70 * (a / 50 * 2 - 1),
                                    c = 70 * (o / 50 * 2 - 1),
                                    u = 70 * (r / 50 * 2 - 1);
                                t.push(s, c, u)
                            }
                    var l = new i.BufferAttribute(new Float32Array(t), 3);
                    e.addAttribute("position", l);
                    var f = new i.RawShaderMaterial({
                        uniforms: this.uniforms,
                        vertexShader: n(503).default,
                        fragmentShader: n(504).default,
                        transparent: !0,
                        depthWrite: !1
                    });
                    this.obj = new i.Points(e, f)
                }
            }, {
                key: "render",
                value: function(e) {
                    this.uniforms.time.value += e, this.obj.rotation.set(.005 * this.uniforms.time.value, .02 * this.uniforms.time.value, .004 * this.uniforms.time.value)
                }
            }]) && r(t.prototype, o), a && r(t, a), e
        }()
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nattribute vec3 position;\n\nuniform vec3 cameraPosition;\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 modelMatrix;\nuniform float time;\n\nvarying vec3 vColor;\nvarying float vOpacity;\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\nvec3 convertHsvToRgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n\n  float noise1 = snoise(mvPosition.xyz * 0.046 + vec3(-time, time, time) * 0.3);\n  float noise2 = snoise(mvPosition.xyz * 0.0012 + vec3(time, -time, time) * 0.01);\n\n  vec3 hsv = vec3(noise2 * 0.2 + time * 0.1, 1.0, 0.6);\n  vec3 rgb = convertHsvToRgb(hsv);\n\n  vColor = rgb;\n  vOpacity = pow(40.0 / length(mvPosition.xyz) * noise1, 2.0);\n\n  gl_Position = projectionMatrix * mvPosition;\n  gl_PointSize = 600.0 / length(mvPosition.xyz) * noise1;\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "precision highp float;\n#define GLSLIFY 1\n\nvarying vec3 vColor;\nvarying float vOpacity;\n\nvoid main() {\n  // to round.\n  vec3 n;\n  n.xy = gl_PointCoord * 2.0 - 1.0;\n  n.z = 1.0 - dot(n.xy, n.xy);\n  if (n.z < 0.0) discard;\n\n  gl_FragColor = vec4(vColor, vOpacity);\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t);
    var r = n(0),
        i = n(3),
        o = n(15).default,
        a = n(506).default,
        s = n(509).default,
        c = n(512).default,
        u = n(516).default,
        l = n(148).default,
        f = n(518).default;
    t.default = function() {
        var e = {
                x: 0,
                y: 0
            },
            t = document.getElementById("canvas-webgl"),
            n = new r.WebGLRenderer({
                antialias: !0,
                canvas: t,
                alpha: !0
            }),
            d = new r.WebGLRenderTarget(0, 0),
            h = new r.WebGLRenderTarget(0, 0),
            v = new r.WebGLRenderTarget(0, 0),
            p = new r.Scene,
            m = new r.Scene,
            y = new r.OrthographicCamera(-1, 1, 1, -1, 0, 1),
            g = new r.PerspectiveCamera(30, 1, 1, 15e3),
            x = new r.Clock,
            b = new r.TextureLoader,
            w = new r.Vector2,
            M = new r.Vector2,
            _ = new r.Vector2,
            S = [],
            P = new s(32),
            T = new c(e),
            E = new u(.7, d.texture),
            z = new l(h.texture, 1, 0, 1),
            L = new l(v.texture, 0, 1, 1),
            A = new f(.7, d.texture, h.texture),
            C = ["/sketch-threejs/img/sketch/transform/tex.png", "/sketch-threejs/img/sketch/transform/flower.jpg"],
            R = [],
            O = function() {
                e.x = document.body.clientWidth, e.y = window.innerHeight, t.width = e.x, t.height = e.y, g.aspect = e.x / e.y, g.updateProjectionMatrix(), T.resize(e), z.resize(e), L.resize(e), d.setSize(e.x, e.y), h.setSize(e.x, e.y), v.setSize(e.x, e.y), n.setSize(e.x, e.y)
            },
            j = function e() {
                ! function() {
                    for (var e = x.getDelta(), t = 0; t < S.length; t++) S[t].render(n, e);
                    P.render(e), T.render(n, p, m, y, e), n.setRenderTarget(d), n.render(m, g), E.render(n, p, y, h), z.render(n, p, y, v), L.render(n, p, y, h), A.render(n, p, y)
                }(), requestAnimationFrame(e)
            },
            I = function(e) {
                !0, S[0].isTransform = !S[0].isTransform
            },
            D = function(e) {
                !1
            },
            k = function() {
                window.addEventListener("resize", i(O), 1e3), t.addEventListener("mousedown", (function(e) {
                    e.preventDefault(), w.set(e.clientX, e.clientY), o(w), I()
                })), t.addEventListener("mousemove", (function(e) {
                    e.preventDefault(), M.set(e.clientX, e.clientY), o(M)
                })), t.addEventListener("mouseup", (function(e) {
                    e.preventDefault(), _.set(e.clientX, e.clientY), o(_), D()
                })), t.addEventListener("touchstart", (function(e) {
                    e.preventDefault(), w.set(e.touches[0].clientX, e.touches[0].clientY), o(w), I(e.touches[0].clientX, e.touches[0].clientY)
                })), t.addEventListener("touchmove", (function(e) {
                    e.preventDefault(), M.set(e.touches[0].clientX, e.touches[0].clientY), o(M)
                })), t.addEventListener("touchend", (function(e) {
                    e.preventDefault(), _.set(e.changedTouches[0].clientX, e.changedTouches[0].clientY), o(_), D()
                })), window.addEventListener("mouseout", (function() {
                    event.preventDefault(), _.set(0, 0), !1
                }))
            };
        ! function() {
            O(), k(), n.setClearColor(16382457, 1), g.position.set(400.1, 60, -400), T.mirrorCamera.position.set(g.position.x, -1 * g.position.y, g.position.z), g.lookAt(new r.Vector3(0, 60, 0)), T.mirrorCamera.lookAt(new r.Vector3(0, -60, 0));
            for (var e = 0, t = function() {
                    var t = i;
                    b.load(C[i], (function(n) {
                        if (n.magFilter = r.NearestFilter, n.minFilter = r.NearestFilter, n.repeat = r.RepeatWrapping, R[t] = n, ++e >= C.length) {
                            for (var i = 0; i < 1; i++) S[i] = new a(i, R[0], R[1]), m.add(S[i].obj);
                            P.addButterflies(S), m.add(P.obj), T.add(p, m), p.add(E.obj), p.add(z.obj), p.add(L.obj), p.add(A.obj), j()
                        }
                    }))
                }, i = 0; i < C.length; i++) t()
        }()
    }
}, function(e, t, n) {
    "use strict";

    function r(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }
    n.r(t), n.d(t, "default", (function() {
        return o
    }));
    var i = n(0),
        o = function() {
            function e(t, n, r) {
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, e), this.size = 280, this.interval = 1.2, this.uniforms = {
                    index: {
                        type: "f",
                        value: t
                    },
                    time: {
                        type: "f",
                        value: 0
                    },
                    timeTransform: {
                        type: "f",
                        value: 0
                    },
                    interval: {
                        type: "f",
                        value: this.interval
                    },
                    size: {
                        type: "f",
                        value: this.size
                    },
                    texButterfly: {
                        type: "t",
                        value: n
                    },
                    texPicture: {
                        type: "t",
                        value: r
                    },
                    colorH: {
                        type: "f",
                        value: .08
                    }
                }, this.obj, this.isTransform = !1, this.createObj()
            }
            var t, o, a;
            return t = e, (o = [{
                key: "createObj",
                value: function() {
                    var e = new i.PlaneBufferGeometry(this.size, this.size / 2, 64, 32),
                        t = new i.SphereBufferGeometry(.1 * this.size, 64, 32, -.5 * Math.PI, 2 * Math.PI),
                        r = new i.PlaneBufferGeometry(1.1 * this.size, .55 * this.size, 64, 32);
                    e.addAttribute("spherePosition", t.attributes.position), e.addAttribute("squarePosition", r.attributes.position);
                    var o = new i.RawShaderMaterial({
                        uniforms: this.uniforms,
                        vertexShader: n(507).default,
                        fragmentShader: n(508).default,
                        side: i.DoubleSide,
                        transparent: !0
                    });
                    this.obj = new i.Mesh(e, o), this.obj.position.y = .3 * this.size, this.obj.renderOrder = 10
                }
            }, {
                key: "render",
                value: function(e, t) {
                    this.uniforms.time.value += t, this.uniforms.timeTransform.value < this.interval && !0 === this.isTransform ? this.uniforms.timeTransform.value = Math.min(this.uniforms.timeTransform.value + t, this.interval) : this.uniforms.timeTransform.value > 0 && !1 === this.isTransform && (this.uniforms.timeTransform.value = Math.max(this.uniforms.timeTransform.value - t, 0))
                }
            }]) && r(t.prototype, o), a && r(t, a), e
        }()
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = '#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\nattribute vec3 spherePosition;\nattribute vec3 squarePosition;\n\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\nuniform float index;\nuniform float time;\nuniform float timeTransform;\nuniform float interval;\nuniform float size;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\nvarying float vOpacity;\nvarying float vStep1;\nvarying float vStep2;\nvarying float vStep3;\n\nfloat exponentialInOut(float t) {\n  return t == 0.0 || t == 1.0\n    ? t\n    : t < 0.5\n      ? +0.5 * pow(2.0, (20.0 * t) - 10.0)\n      : -0.5 * pow(2.0, 10.0 - (t * 20.0)) + 1.0;\n}\n\n//\n// GLSL textureless classic 3D noise "cnoise",\n// with an RSL-style periodic variant "pnoise".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-10-11\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec3 fade(vec3 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise(vec3 P)\n{\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod289(Pi0);\n  Pi1 = mod289(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n  return 2.2 * n_xyz;\n}\n\nmat4 calcRotateMat4X(float radian) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, cos(radian), -sin(radian), 0.0,\n    0.0, sin(radian), cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4Y(float radian) {\n  return mat4(\n    cos(radian), 0.0, sin(radian), 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    -sin(radian), 0.0, cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4Z(float radian) {\n  return mat4(\n    cos(radian), -sin(radian), 0.0, 0.0,\n    sin(radian), cos(radian), 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4(vec3 radian) {\n  return calcRotateMat4X(radian.x) * calcRotateMat4Y(radian.y) * calcRotateMat4Z(radian.z);\n}\n\nvoid main() {\n  // Calcurate time of tranforming\n  float t = timeTransform / interval;\n  float transformTime1 = max((1.0 - t) * 2.0 - 1.0, 0.0);\n  float transformTime2 = min((t) * 2.0, 1.0) * min((1.0 - t) * 2.0, 1.0);\n  float transformTime3 = max((t) * 2.0 - 1.0, 0.0);\n\n  // Position of Butterfly\n  float flapTime = radians(sin(time * 4.0 - length(position.xy) / size * 2.0 + index * 2.0) * 45.0 + 30.0);\n  vec3 flapPosition = vec3(\n    cos(flapTime) * position.x,\n    position.y + sin(time) * 10.0,\n    sin(flapTime) * abs(position.x) + sin(time) * 10.0\n  );\n  mat4 flapRotateMat = calcRotateMat4(vec3(radians(45.0), 0.0, 0.0));\n  vec3 position1 = (flapRotateMat * vec4(flapPosition, 1.0)).xyz;\n\n  // Position of Sphere on transforming\n  float sphereNoise = cnoise(spherePosition * 0.02 + time * 2.4);\n  vec3 sphereNoisePosition = normalize(spherePosition) * sphereNoise * 30.0;\n  mat4 sphereRotateMat = calcRotateMat4(vec3(t * 4.0, 0.0, 0.0));\n  vec3 position2 = (sphereRotateMat * vec4(spherePosition + sphereNoisePosition, 1.0)).xyz;\n\n  // Position of Picture\n  mat4 pictureRotateMat = calcRotateMat4(vec3(0.0, radians(45.0), 0.0));\n  vec3 position3 = (pictureRotateMat * vec4(squarePosition, 1.0)).xyz;;\n\n  // Total of All Position\n  vec3 updatePosition = position1 * exponentialInOut(transformTime1) + position2 * exponentialInOut(transformTime2) + position3 * exponentialInOut(transformTime3);\n\n  // varying\n  vPosition = updatePosition;\n  vUv = uv;\n  vStep1 = clamp((1.0 - t) * 6.0 - 2.0, 0.0, 1.0);\n  vStep2 = clamp((t) * 6.0 - 1.0, 0.0, 1.0) * clamp((1.0 - t) * 6.0 - 1.0, 0.0, 1.0);\n  vStep3 = clamp((t) * 6.0 - 3.0, 0.0, 1.0);\n\n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(updatePosition, 1.0);\n}\n'
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\nuniform float size;\nuniform sampler2D texButterfly;\nuniform sampler2D texPicture;\nuniform float colorH;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\nvarying float vOpacity;\nvarying float vStep1;\nvarying float vStep2;\nvarying float vStep3;\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\nfloat random(vec2 c){\n  return fract(sin(dot(c.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 convertHsvToRgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nconst float rgbDiff = 0.01;\n\nvoid main() {\n  // Glitch Noise.\n  float bnStrength = sin(time) * 0.05;\n  float bnTime = floor(time * 18.0) * 200.0;\n  float noiseX = step(0.87 + bnStrength, (snoise(vec3(0.0, vUv.x * 1.8, bnTime)) + 1.0) / 2.0);\n  float noiseY = step(0.87 + bnStrength, (snoise(vec3(0.0, vUv.y * 4.2, bnTime)) + 1.0) / 2.0);\n  float bnMask = noiseX * noiseY;\n  float bnUvX = mod(vUv.x + sin(bnTime) + rgbDiff, 1.0);\n  vec4 bnDiff = (1.0 - texture2D(texPicture, vec2(bnUvX, vUv.y))) * bnMask;\n\n  // White Noise.\n  float whiteNoise = (random(vUv + mod(time, 10.0)) * 2.0 - 1.0) * 0.15;\n  vec4 wnColor = vec4(vec3(whiteNoise), 0.0);\n\n  // Color Noise for BUterfly.\n  float noise = snoise(vPosition / vec3(size * 0.25) + vec3(0.0, 0.0, time));\n  vec3 hsv = vec3(colorH + noise * 0.2, 0.4, 1.0);\n  vec3 rgb = convertHsvToRgb(hsv);\n\n  // Butterly Color.\n  vec4 texButterflyColor = texture2D(texButterfly, vUv);\n  vec4 color1 = vec4(rgb, 1.0) * texButterflyColor;\n\n  // Sphere color on transforming.\n  vec4 color2 = vec4(rgb, 1.0) * vec4((1.0 - texButterflyColor.rgb * 0.5), texButterflyColor.a) + wnColor;\n\n  // Picture Color.\n  vec2 pictUv = vUv * 1.1 - 0.05;\n  vec4 texPictureColor = texture2D(texPicture, pictUv);\n  float pictAlpha = step(0.0, pictUv.x) * (1.0 - step(1.0, pictUv.x)) * step(0.0, pictUv.y) * (1.0 - step(1.0, pictUv.y));\n  vec4 pictColor = texPictureColor * (1.0 - bnMask) * vec4(vec3(1.0), pictAlpha);\n  vec4 bnColor = vec4(bnDiff.rgb * 1.2, bnMask);\n  vec4 color3 = pictColor + bnColor + wnColor;\n\n  // total of colors.\n  vec4 color = (color1 * vStep1 + color2 * vStep2) + color3 * vStep3;\n\n  if (color.a < 0.5) discard;\n\n  gl_FragColor = color;\n}\n"
}, function(e, t, n) {
    "use strict";

    function r(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }
    n.r(t), n.d(t, "default", (function() {
        return a
    }));
    var i = n(0),
        o = n(1),
        a = function() {
            function e(t) {
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, e), this.interval = 4, this.attr = {
                    position: new i.BufferAttribute(new Float32Array(3 * t), 3),
                    colorH: new i.BufferAttribute(new Float32Array(t), 1),
                    index: new i.BufferAttribute(new Float32Array(t), 1),
                    opacity: new i.BufferAttribute(new Float32Array(t), 1),
                    valid: new i.BufferAttribute(new Float32Array(t), 1)
                }, this.uniforms = {
                    size: {
                        type: "f",
                        value: t
                    },
                    interval: {
                        type: "f",
                        value: this.interval
                    },
                    time: {
                        type: "f",
                        value: 0
                    }
                }, this.butterflies = null, this.butterfliesLengh = 0, this.obj, this.createObj()
            }
            var t, a, s;
            return t = e, (a = [{
                key: "createObj",
                value: function() {
                    for (var e = new i.BufferGeometry, t = 0; t < this.uniforms.size.value; t++) this.attr.index.setX(t, t);
                    e.addAttribute("position", this.attr.position), e.addAttribute("colorH", this.attr.colorH), e.addAttribute("i", this.attr.index), e.addAttribute("opacity", this.attr.opacity), e.addAttribute("valid", this.attr.valid);
                    var r = new i.RawShaderMaterial({
                        uniforms: this.uniforms,
                        vertexShader: n(510).default,
                        fragmentShader: n(511).default,
                        depthWrite: !1,
                        transparent: !0
                    });
                    this.obj = new i.Points(e, r), this.obj.renderOrder = 20
                }
            }, {
                key: "addButterflies",
                value: function(e) {
                    this.butterflies = e, this.butterfliesLengh = e.length
                }
            }, {
                key: "render",
                value: function(e) {
                    this.uniforms.time.value += e;
                    for (var t = 0; t < this.uniforms.size.value; t++) {
                        var n = (this.uniforms.time.value + this.attr.index.getX(t) / this.uniforms.size.value * this.interval) % this.interval,
                            r = this.attr.valid.getX(t);
                        if (n >= .9 * this.interval && 1 == r) this.attr.valid.setX(t, 0);
                        else if (n <= .9 * this.interval && 0 == r) {
                            var i = Math.floor(Math.random() * this.butterfliesLengh),
                                a = this.butterflies[i],
                                s = (-90 * Math.random() - 90) * Math.PI / 180,
                                c = -180 * Math.random() * Math.PI / 180,
                                u = Math.random() * a.uniforms.size.value / 4 + a.uniforms.size.value / 8,
                                l = o.spherical(s, c, u),
                                f = a.uniforms.timeTransform.value > 0 ? 0 : 1;
                            this.attr.position.setXYZ(t, l[0] + a.obj.position.x, .2 * l[1] + a.obj.position.y + 20 * Math.sin(a.uniforms.time.value), .5 * l[2] + a.obj.position.z), this.attr.colorH.setX(t, a.uniforms.colorH.value), this.attr.opacity.setX(t, f), this.attr.valid.setX(t, 1)
                        }
                    }
                    this.attr.position.needsUpdate = !0, this.attr.colorH.needsUpdate = !0, this.attr.opacity.needsUpdate = !0, this.attr.valid.needsUpdate = !0
                }
            }]) && r(t.prototype, a), s && r(t, s), e
        }()
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nattribute vec3 position;\nattribute float colorH;\nattribute float i;\nattribute float opacity;\nattribute float valid;\n\nuniform vec3 cameraPosition;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\nuniform float size;\nuniform float interval;\nuniform float time;\n\nvarying vec3 vColor;\nvarying float vOpacity;\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\nvec3 convertHsvToRgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  float thisTime = mod(time + i / size * interval, interval);\n\n  vec3 updatePosition = position + vec3(\n    cos(thisTime * 3.0 + i) * 3.0,\n    thisTime * -20.0,\n    sin(thisTime * 3.0 + i) * 3.0\n  );\n  vec4 mvPosition = viewMatrix * modelMatrix * vec4(updatePosition, 1.0);\n\n  vec3 hsv = vec3(colorH + sin(i) * 0.075, 0.8, 1.0);\n\n  vColor = convertHsvToRgb(hsv);\n  vOpacity = (\n    smoothstep(interval * 0.0, interval * 0.1, thisTime)\n    * (1.0 - smoothstep(interval * 0.2, interval * 0.9, thisTime))\n  ) * opacity;\n\n  gl_PointSize = 5000.0 / length(mvPosition.xyz);\n  gl_Position = projectionMatrix * mvPosition;\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "precision highp float;\n#define GLSLIFY 1\n\nvarying vec3 vColor;\nvarying float vOpacity;\n\nvoid main() {\n  // to round.\n  vec3 n;\n  n.xy = gl_PointCoord * 2.0 - 1.0;\n  n.z = 1.0 - dot(n.xy, n.xy);\n  if (n.z < 0.0) discard;\n\n  gl_FragColor = vec4(vColor, vOpacity * 0.5);\n}\n"
}, function(e, t, n) {
    "use strict";

    function r(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }
    n.r(t), n.d(t, "default", (function() {
        return a
    }));
    var i = n(0),
        o = n(148).default,
        a = function() {
            function e(t) {
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, e), this.mirrorCamera = new i.PerspectiveCamera(30, t.x / t.y, 1, 15e3), this.mirrorRender = new i.WebGLRenderTarget(t.x, t.y), this.textureMatrix = new i.Matrix4, this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    },
                    texture: {
                        type: "t",
                        value: this.mirrorRender.texture
                    },
                    textureMatrix: {
                        type: "m4",
                        value: this.textureMatrix
                    }
                }, this.renderBack1 = new i.WebGLRenderTarget(t.x, t.y), this.renderBack2 = new i.WebGLRenderTarget(t.x, t.y), this.postEffectBlurX = new o(this.renderBack1.texture, 1, 0, 4), this.postEffectBlurY = new o(this.renderBack2.texture, 0, 1, 4), this.mirrorCamera.up.set(0, -1, 0), this.obj, this.createObj()
            }
            var t, a, s;
            return t = e, (a = [{
                key: "add",
                value: function(e, t) {
                    t.add(this.obj), e.add(this.postEffectBlurX.obj), e.add(this.postEffectBlurY.obj)
                }
            }, {
                key: "createObj",
                value: function() {
                    var e = new i.PlaneBufferGeometry(4e3, 4e3),
                        t = new i.RawShaderMaterial({
                            uniforms: this.uniforms,
                            vertexShader: n(514).default,
                            fragmentShader: n(515).default,
                            transparent: !0
                        });
                    this.obj = new i.Mesh(e, t), this.obj.rotation.set(-.5 * Math.PI, 0, 0)
                }
            }, {
                key: "updateTextureMatrix",
                value: function() {
                    this.textureMatrix.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, 1, 0, 0, 0, 0, 1), this.textureMatrix.multiply(this.mirrorCamera.projectionMatrix), this.textureMatrix.multiply(this.mirrorCamera.matrixWorldInverse)
                }
            }, {
                key: "render",
                value: function(e, t, n, r, i) {
                    this.uniforms.time.value += i, this.updateTextureMatrix(), this.obj.visible = !1, e.setRenderTarget(this.renderBack1), e.render(n, this.mirrorCamera), this.obj.visible = !0, this.postEffectBlurX.render(e, t, r, this.renderBack2), this.postEffectBlurY.render(e, t, r, this.mirrorRender)
                }
            }, {
                key: "resize",
                value: function(e) {
                    this.mirrorCamera.aspect = e.x / e.y, this.mirrorCamera.updateProjectionMatrix(), this.mirrorRender.setSize(e.x, e.y), this.renderBack1.setSize(e.x, e.y), this.renderBack2.setSize(e.x, e.y), this.postEffectBlurX.resize(e), this.postEffectBlurY.resize(e)
                }
            }]) && r(t.prototype, a), s && r(t, s), e
        }()
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "precision highp float;\n#define GLSLIFY 1\n\nuniform vec2 resolution;\nuniform vec2 direction;\nuniform float radius;\nuniform sampler2D texture;\n\nvarying vec2 vUv;\n\nvec4 gaussianBlur(sampler2D texture, vec2 uv, float radius, vec2 resolution, vec2 direction) {\n  vec4 color = vec4(0.0);\n  vec2 step = radius / resolution * direction;\n  color += texture2D(texture, uv - 4.0 * step) * 0.02699548325659403;\n  color += texture2D(texture, uv - 3.0 * step) * 0.06475879783294587;\n  color += texture2D(texture, uv - 2.0 * step) * 0.12098536225957168;\n  color += texture2D(texture, uv - 1.0 * step) * 0.17603266338214976;\n  color += texture2D(texture, uv) * 0.19947114020071635;\n  color += texture2D(texture, uv + 1.0 * step) * 0.17603266338214976;\n  color += texture2D(texture, uv + 2.0 * step) * 0.12098536225957168;\n  color += texture2D(texture, uv + 3.0 * step) * 0.06475879783294587;\n  color += texture2D(texture, uv + 4.0 * step) * 0.02699548325659403;\n  return color;\n}\n\nvoid main() {\n  vec4 color = gaussianBlur(texture, vUv, radius, resolution, direction);\n  gl_FragColor = color;\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec3 normal;\n\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\nuniform mat4 textureMatrix;\n\nvarying vec3 vPosition;\nvarying vec4 vUv;\n\nvoid main(void) {\n  vec4 worldPosition = modelMatrix * vec4(position, 1.0);\n\n  vPosition = worldPosition.xyz;\n  vUv = textureMatrix * worldPosition;\n\n  gl_Position = projectionMatrix * viewMatrix * worldPosition;\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "precision highp float;\n#define GLSLIFY 1\n\nuniform vec3 cameraPosition;\nuniform sampler2D texture;\n\nvarying vec3 vPosition;\nvarying vec4 vUv;\n\nconst float mirrorOpacity = 0.2;\n\nvoid main() {\n  float opacity = 1.0 - length(vPosition - cameraPosition) / 700.0;\n\n  vec4 mirrorColor = vec4(vec3(0.9), 1.0) * (1.0 - mirrorOpacity);\n\n  vec4 projectorColor = texture2DProj(texture, vUv) * mirrorOpacity;\n\n  gl_FragColor = (mirrorColor + projectorColor) * vec4(vec3(1.0), opacity);\n}\n"
}, function(e, t, n) {
    "use strict";

    function r(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }
    n.r(t), n.d(t, "default", (function() {
        return o
    }));
    var i = n(0),
        o = function() {
            function e(t, n) {
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, e), this.uniforms = {
                    brightMin: {
                        type: "f",
                        value: t
                    },
                    texture: {
                        type: "t",
                        value: n
                    }
                }, this.obj, this.createObj()
            }
            var t, o, a;
            return t = e, (o = [{
                key: "createObj",
                value: function() {
                    var e = new i.PlaneBufferGeometry(2, 2),
                        t = new i.RawShaderMaterial({
                            uniforms: this.uniforms,
                            vertexShader: n(108).default,
                            fragmentShader: n(517).default
                        });
                    this.obj = new i.Mesh(e, t), this.obj.visible = !1
                }
            }, {
                key: "render",
                value: function(e, t, n) {
                    var r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null;
                    this.obj.visible = !0, e.setRenderTarget(r), e.render(t, n), this.obj.visible = !1
                }
            }]) && r(t.prototype, o), a && r(t, a), e
        }()
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "precision highp float;\n#define GLSLIFY 1\n\nuniform float brightMin;\nuniform sampler2D texture;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vec4 bright = max(vec4(0.0), (texture2D(texture, vUv) - brightMin));\n  gl_FragColor = bright;\n}\n"
}, function(e, t, n) {
    "use strict";

    function r(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }
    n.r(t), n.d(t, "default", (function() {
        return o
    }));
    var i = n(0),
        o = function() {
            function e(t, n, r) {
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, e), this.uniforms = {
                    brightMin: {
                        type: "f",
                        value: t
                    },
                    texture1: {
                        type: "t",
                        value: n
                    },
                    texture2: {
                        type: "t",
                        value: r
                    }
                }, this.obj, this.createObj()
            }
            var t, o, a;
            return t = e, (o = [{
                key: "createObj",
                value: function() {
                    var e = new i.PlaneBufferGeometry(2, 2),
                        t = new i.RawShaderMaterial({
                            uniforms: this.uniforms,
                            vertexShader: n(108).default,
                            fragmentShader: n(519).default
                        });
                    this.obj = new i.Mesh(e, t), this.obj.visible = !1
                }
            }, {
                key: "render",
                value: function(e, t, n) {
                    var r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null;
                    this.obj.visible = !0, e.setRenderTarget(r), e.render(t, n), this.obj.visible = !1
                }
            }]) && r(t.prototype, o), a && r(t, a), e
        }()
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "precision highp float;\n#define GLSLIFY 1\n\nuniform float brightMin;\nuniform sampler2D texture1;\nuniform sampler2D texture2;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vec4 color1 = texture2D(texture1, vUv);\n  vec4 color2 = texture2D(texture2, vUv);\n  gl_FragColor = color1 * brightMin + color2;\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t);
    var r = n(0),
        i = n(3),
        o = n(521).default;
    t.default = function() {
        var e = {
                x: 0,
                y: 0
            },
            t = document.getElementById("canvas-webgl"),
            n = new r.WebGLRenderer({
                antialias: !1,
                canvas: t
            }),
            a = new r.Scene,
            s = new r.OrthographicCamera(-1, 1, 1, -1, 1, 1e4),
            c = new r.Clock,
            u = new r.Vector2,
            l = new r.Vector2,
            f = new r.Vector2,
            d = new o,
            h = function e() {
                var t;
                t = c.getDelta(), d.render(t), n.render(a, s), requestAnimationFrame(e)
            },
            v = function() {
                var r, i;
                e.x = document.body.clientWidth, e.y = window.innerHeight, t.width = e.x, t.height = e.y, r = 640 * Math.min(e.x / e.y / (640 / 480), 1), i = 480 * Math.min(e.y / e.x / .75, 1), s.left = -.5 * r, s.right = .5 * r, s.top = .5 * i, s.bottom = -.5 * i, s.updateProjectionMatrix(), n.setSize(e.x, e.y)
            },
            p = function(e) {
                !0
            },
            m = function(e) {
                !1
            };
        window.addEventListener("resize", i(v, 1e3)), t.addEventListener("mousedown", (function(e) {
            e.preventDefault(), u.set(e.clientX, e.clientY), p()
        })), document.addEventListener("mousemove", (function(e) {
            e.preventDefault(), l.set(e.clientX, e.clientY)
        })), document.addEventListener("mouseup", (function(e) {
            e.preventDefault(), f.set(e.clientX, e.clientY), m()
        })), t.addEventListener("touchstart", (function(e) {
            e.preventDefault(), u.set(e.touches[0].clientX, e.touches[0].clientY), p()
        })), t.addEventListener("touchmove", (function(e) {
            e.preventDefault(), l.set(e.touches[0].clientX, e.touches[0].clientY)
        })), t.addEventListener("touchend", (function(e) {
            e.preventDefault(), f.set(e.changedTouches[0].clientX, e.changedTouches[0].clientY), m()
        })), v(), n.setClearColor(16711406, 1), s.position.set(0, 0, 100), s.lookAt(new r.Vector3), a.add(d.obj), h()
    }
}, function(e, t, n) {
    "use strict";

    function r(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }
    n.r(t), n.d(t, "default", (function() {
        return o
    }));
    var i = n(0),
        o = function() {
            function e() {
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, e), this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    },
                    noiseRange: {
                        type: "f",
                        value: 3 * Math.random()
                    },
                    speed: {
                        type: "f",
                        value: .08
                    },
                    circleOutStepMin: {
                        type: "f",
                        value: .1
                    },
                    circleOutStepMax: {
                        type: "f",
                        value: 1
                    },
                    circleInStepMin: {
                        type: "f",
                        value: 0
                    },
                    circleInStepMax: {
                        type: "f",
                        value: .3
                    },
                    noisePosition: {
                        type: "f",
                        value: .8
                    },
                    noiseSize: {
                        type: "f",
                        value: .5
                    }
                }, this.obj = this.createObj()
            }
            var t, o, a;
            return t = e, (o = [{
                key: "createObj",
                value: function() {
                    var e = new i.Mesh(new i.PlaneBufferGeometry(640, 640), new i.RawShaderMaterial({
                        uniforms: this.uniforms,
                        vertexShader: n(522).default,
                        fragmentShader: n(523).default,
                        transparent: !0
                    }));
                    return e.position.set(80, 0, 0), e
                }
            }, {
                key: "render",
                value: function(e) {
                    this.obj.visible && (this.uniforms.time.value += e)
                }
            }]) && r(t.prototype, o), a && r(t, a), e
        }()
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\n\nvoid main() {\n  vPosition = position;\n  vUv = uv;\n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "precision highp float;\n#define GLSLIFY 1\n\nuniform vec3 cameraPosition;\nuniform float time;\nuniform float noiseRange;\nuniform sampler2D texEgg1;\nuniform sampler2D texEgg2;\nuniform sampler2D texDiffSpace;\n\nuniform float speed;\nuniform float circleOutStepMin;\nuniform float circleOutStepMax;\nuniform float circleInStepMin;\nuniform float circleInStepMax;\nuniform float noisePosition;\nuniform float noiseSize;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\nvec3 convertHsvToRgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat exponentialOut(float t) {\n  return t == 1.0 ? t : 1.0 - pow(2.0, -10.0 * t);\n}\n\nvoid main() {\n  float t1 = exponentialOut(min(time, 2.0) / 2.0);\n  float t2 = (1.0 - exponentialOut(min(time, 2.0) / 2.0)) * 3.0;\n  vec2 pos = vUv * 2.0 - vec2(1.0);\n\n  float circleOut = smoothstep(circleOutStepMin, circleOutStepMax, t1 - length(pos));\n  float circleIn = smoothstep(circleInStepMin, circleInStepMax, t1 * 0.5 - length(pos)) * 0.5;\n  float circleLight = smoothstep(0.0, 0.1, (t1 - t2) * 0.3 - length(pos)) * smoothstep(0.0, 0.1, (t1 - t2) * 0.2 - length(pos + vec2(0.2, -0.2)));\n\n  float noiseTime = time * speed + t2;\n  float noise = (\n    snoise(\n      vec3(pos * (noisePosition + noiseRange * 0.1) + vec2(sin(noiseTime),\n      cos(noiseTime)),\n      noiseTime + noiseRange * 100.0\n      )\n    ) + 1.0) / 2.0 * noiseSize;\n\n  float mask = circleOut * noise + circleIn;\n  float maskHighLight = circleLight * (noise + 0.12);\n  float mask0 = 1.0 - step(maskHighLight, 0.13);\n  float mask1 = (1.0 - step(mask, 0.6)) * step(maskHighLight, 0.13);\n  float mask2 = (1.0 - step(mask, 0.28)) * step(mask, 0.6) * step(maskHighLight, 0.23);\n  float mask3 = (1.0 - step(mask, 0.014)) * step(mask, 0.28);\n  float mask4 = (1.0 - step(mask, 0.01)) * step(mask, 0.014);\n\n  vec4 rgba0 = vec4(convertHsvToRgb(vec3(0.125, 0.2, 1.0)), 1.0) * mask0;\n  vec4 rgba1 = vec4(convertHsvToRgb(vec3(0.125, 0.76, 1.0)), 1.0) * mask1;\n  vec4 rgba2 = vec4(convertHsvToRgb(vec3(0.108, 0.91, 1.0)), 1.0) * mask2;\n  vec4 rgba3 = vec4(convertHsvToRgb(vec3(0.1, 0.02, 0.99)), 1.0) * mask3;\n  vec4 rgba4 = vec4(convertHsvToRgb(vec3(0.1, 0.2, 0.9)), 1.0) * mask4;\n\n  float patternNoise1 = step(0.0, snoise(vPosition * 0.015 + vec3(0.0, 0.0, time * 0.1))) * 0.05;\n  float patternNoise2 = step(0.2, snoise(vPosition * 0.025 + vec3(0.0, 1.0, time * 0.3))) * 0.03;\n  vec4 patternColor = vec4(vec3(patternNoise1), 1.0) * mask1 + vec4(vec3(patternNoise2), 1.0) * mask2;\n\n  vec4 eggColor = rgba0 + rgba1 + rgba2 + rgba3 + rgba4 + patternColor;\n\n  gl_FragColor = eggColor;\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t);
    var r = n(0),
        i = n(3),
        o = n(15).default,
        a = n(525).default,
        s = n(528).default,
        c = n(531).default,
        u = n(535).default,
        l = n(149).default,
        f = n(537).default;
    t.default = function() {
        var e = {
                x: 0,
                y: 0
            },
            t = document.getElementById("canvas-webgl"),
            n = new r.WebGLRenderer({
                antialias: !1,
                canvas: t,
                alpha: !0
            }),
            d = new r.WebGLRenderTarget(0, 0),
            h = new r.WebGLRenderTarget(0, 0),
            v = new r.WebGLRenderTarget(0, 0),
            p = new r.Scene,
            m = new r.Scene,
            y = new r.OrthographicCamera(-1, 1, 1, -1, 0, 1),
            g = new r.PerspectiveCamera(30, 1, 1, 15e3),
            x = new r.Clock,
            b = new r.TextureLoader,
            w = new r.Vector2,
            M = new r.Vector2,
            _ = new r.Vector2,
            S = [],
            P = new s(720),
            T = new c(e),
            E = new u(d.texture),
            z = new l(h.texture, 1, 0, 1),
            L = new l(v.texture, 0, 1, 1),
            A = new f(d.texture, h.texture),
            C = function() {
                e.x = document.body.clientWidth, e.y = window.innerHeight, t.width = e.x, t.height = e.y, g.aspect = e.x / e.y, g.updateProjectionMatrix(), T.resize(e), z.resize(e), L.resize(e), d.setSize(e.x, e.y), h.setSize(e.x, e.y), v.setSize(e.x, e.y), n.setSize(e.x, e.y)
            },
            R = function e() {
                ! function() {
                    for (var e = x.getDelta(), t = 0; t < S.length; t++) S[t].render(n, e);
                    P.render(e), T.render(n, p, m, y, e), n.render(m, g, d), E.render(n, p, y, h), z.render(n, p, y, v), L.render(n, p, y, h), A.render(n, p, y)
                }(), requestAnimationFrame(e)
            },
            O = function(e) {
                !0
            },
            j = function(e) {
                !1
            },
            I = function() {
                window.addEventListener("resize", i(C, 1e3)), t.addEventListener("mousedown", (function(e) {
                    e.preventDefault(), w.set(e.clientX, e.clientY), o(w), O()
                })), t.addEventListener("mousemove", (function(e) {
                    e.preventDefault(), M.set(e.clientX, e.clientY), o(M)
                })), t.addEventListener("mouseup", (function(e) {
                    e.preventDefault(), _.set(e.clientX, e.clientY), o(_), j()
                })), t.addEventListener("touchstart", (function(e) {
                    e.preventDefault(), w.set(e.touches[0].clientX, e.touches[0].clientY), o(w), O(e.touches[0].clientX, e.touches[0].clientY)
                })), t.addEventListener("touchmove", (function(e) {
                    e.preventDefault(), M.set(e.touches[0].clientX, e.touches[0].clientY), o(M)
                })), t.addEventListener("touchend", (function(e) {
                    e.preventDefault(), _.set(e.changedTouches[0].clientX, e.changedTouches[0].clientY), o(_), j()
                })), window.addEventListener("mouseout", (function() {
                    event.preventDefault(), _.set(0, 0), !1
                }))
            };
        C(), I(), n.setClearColor(15658734, 1), g.position.set(400, 500, 800), T.mirrorCamera.position.set(g.position.x, -1 * g.position.y, g.position.z), g.lookAt(new r.Vector3(0, 100, 0)), T.mirrorCamera.lookAt(new r.Vector3(0, -100, 0)), b.load("/sketch-threejs/img/sketch/butterfly/tex.png", (function(e) {
            e.magFilter = r.NearestFilter, e.minFilter = r.NearestFilter;
            for (var t = 0; t < 12; t++) S[t] = new a(t, e), S[t].obj.position.x = 280 * (2 * Math.random() - 1), S[t].obj.position.z = 150 * t, m.add(S[t].obj);
            P.addButterflies(S), m.add(P.obj), T.add(p, m), p.add(E.obj), p.add(z.obj), p.add(L.obj), p.add(A.obj), R()
        }))
    }
}, function(e, t, n) {
    "use strict";

    function r(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }
    n.r(t), n.d(t, "default", (function() {
        return a
    }));
    var i = n(0),
        o = 280,
        a = function() {
            function e(t, n) {
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, e), this.uniforms = {
                    index: {
                        type: "f",
                        value: t
                    },
                    time: {
                        type: "f",
                        value: 0
                    },
                    size: {
                        type: "f",
                        value: o
                    },
                    texture: {
                        type: "t",
                        value: n
                    },
                    colorH: {
                        type: "f",
                        value: Math.random()
                    }
                }, this.obj = this.createObj(), this.obj.renderOrder = 10
            }
            var t, a, s;
            return t = e, (a = [{
                key: "createObj",
                value: function() {
                    var e = new i.PlaneBufferGeometry(o, o / 2, 24, 12),
                        t = new i.Mesh(e, new i.RawShaderMaterial({
                            uniforms: this.uniforms,
                            vertexShader: n(526).default,
                            fragmentShader: n(527).default,
                            side: i.DoubleSide,
                            transparent: !0
                        }));
                    return t.position.y = .5 * o + (2 * Math.random() - 1) * o * .1, t.rotation.set(-45 * Math.PI / 180, 0, 0), t
                }
            }, {
                key: "render",
                value: function(e, t) {
                    this.uniforms.time.value += t, this.obj.position.z -= 4, this.obj.position.z < -900 && (this.obj.position.x = 280 * (2 * Math.random() - 1), this.obj.position.z = 900, this.uniforms.colorH.value = Math.random())
                }
            }]) && r(t.prototype, a), s && r(t, s), e
        }()
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\nuniform float index;\nuniform float time;\nuniform float size;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\nvarying float vOpacity;\n\nvoid main() {\n  float flapTime = radians(sin(time * 4.0 - length(position.xy) / size * 2.0 + index * 2.0) * 45.0 + 30.0);\n  float hovering = cos(time * 2.0 + index * 3.0) * size / 16.0;\n  vec3 updatePosition = vec3(\n    cos(flapTime) * position.x,\n    position.y + hovering,\n    sin(flapTime) * abs(position.x) + hovering\n  );\n\n  vPosition = position;\n  vUv = uv;\n  vOpacity = (1.0 - smoothstep(0.75, 1.0, abs((modelMatrix * vec4(updatePosition, 1.0)).z) / 900.0)) * 0.85;\n\n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(updatePosition, 1.0);\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\nuniform float size;\nuniform sampler2D texture;\nuniform float colorH;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\nvarying float vOpacity;\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\nvec3 convertHsvToRgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  vec4 texColor = texture2D(texture, vUv);\n\n  float noise = snoise(vPosition / vec3(size * 0.25) + vec3(0.0, 0.0, time));\n  vec3 hsv = vec3(colorH + noise * 0.2, 0.4, 1.0);\n  vec3 rgb = convertHsvToRgb(hsv);\n\n  if (texColor.a < 0.5) discard;\n\n  gl_FragColor = vec4(rgb, vOpacity) * texColor;\n}\n"
}, function(e, t, n) {
    "use strict";

    function r(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }
    n.r(t), n.d(t, "default", (function() {
        return a
    }));
    var i = n(0),
        o = n(1),
        a = function() {
            function e(t) {
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, e), this.interval = 4, this.attr = {
                    position: new i.BufferAttribute(new Float32Array(3 * t), 3),
                    colorH: new i.BufferAttribute(new Float32Array(t), 1),
                    index: new i.BufferAttribute(new Float32Array(t), 1),
                    valid: new i.BufferAttribute(new Float32Array(t), 1)
                }, this.geometry = new i.BufferGeometry, this.uniforms = {
                    size: {
                        type: "f",
                        value: t
                    },
                    interval: {
                        type: "f",
                        value: this.interval
                    },
                    time: {
                        type: "f",
                        value: 0
                    }
                }, this.butterflies = null, this.butterfliesLengh = 0, this.obj = this.createObj(), this.obj.renderOrder = 20
            }
            var t, a, s;
            return t = e, (a = [{
                key: "createObj",
                value: function() {
                    for (var e = 0; e < this.uniforms.size.value; e++) this.attr.index.setX(e, e);
                    return this.geometry.addAttribute("position", this.attr.position), this.geometry.addAttribute("colorH", this.attr.colorH), this.geometry.addAttribute("i", this.attr.index), this.geometry.addAttribute("valid", this.attr.valid), new i.Points(this.geometry, new i.RawShaderMaterial({
                        uniforms: this.uniforms,
                        vertexShader: n(529).default,
                        fragmentShader: n(530).default,
                        depthWrite: !1,
                        transparent: !0
                    }))
                }
            }, {
                key: "addButterflies",
                value: function(e) {
                    this.butterflies = e, this.butterfliesLengh = e.length
                }
            }, {
                key: "render",
                value: function(e) {
                    this.uniforms.time.value += e;
                    for (var t = 0; t < this.uniforms.size.value; t++) {
                        var n = (this.uniforms.time.value + this.attr.index.getX(t) / this.uniforms.size.value * this.interval) % this.interval,
                            r = this.attr.valid.getX(t);
                        if (n >= .9 * this.interval && 1 == r) this.attr.valid.setX(t, 0);
                        else if (n <= .9 * this.interval && 0 == r) {
                            var i = Math.floor(Math.random() * this.butterfliesLengh),
                                a = this.butterflies[i],
                                s = (-90 * Math.random() - 90) * Math.PI / 180,
                                c = -180 * Math.random() * Math.PI / 180,
                                u = Math.random() * a.uniforms.size.value / 4 + a.uniforms.size.value / 8,
                                l = o.spherical(s, c, u);
                            this.attr.position.setXYZ(t, l[0] + a.obj.position.x, .2 * l[1] + a.obj.position.y + 20 * Math.sin(a.uniforms.time.value), .5 * l[2] + a.obj.position.z), this.attr.colorH.setX(t, a.uniforms.colorH.value), this.attr.valid.setX(t, 1)
                        }
                    }
                    this.attr.position.needsUpdate = !0, this.attr.colorH.needsUpdate = !0
                }
            }]) && r(t.prototype, a), s && r(t, s), e
        }()
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nattribute vec3 position;\nattribute float colorH;\nattribute float i;\nattribute float valid;\n\nuniform vec3 cameraPosition;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\nuniform float size;\nuniform float interval;\nuniform float time;\n\nvarying vec3 vColor;\nvarying float vOpacity;\n\nvec3 convertHsvToRgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  float thisTime = mod(time + i / size * interval, interval);\n\n  vec3 updatePosition = position + vec3(\n    cos(thisTime * 3.0 + i) * 3.0,\n    thisTime * -16.0,\n    sin(thisTime * 3.0 + i) * 3.0\n  );\n  vec4 mvPosition = viewMatrix * modelMatrix * vec4(updatePosition, 1.0);\n\n  vec3 hsv = vec3(colorH + sin(i) * 0.075, 0.8, 1.0);\n\n  vColor = convertHsvToRgb(hsv);\n  vOpacity = smoothstep(interval * 0.0, interval * 0.1, thisTime)\n    * (1.0 - smoothstep(interval * 0.2, interval * 0.9, thisTime));\n\n  gl_PointSize = 12000.0 / length(mvPosition.xyz);\n  gl_Position = projectionMatrix * mvPosition;\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "precision highp float;\n#define GLSLIFY 1\n\nvarying vec3 vColor;\nvarying float vOpacity;\n\nvoid main() {\n  // to round.\n  vec3 n;\n  n.xy = gl_PointCoord * 2.0 - 1.0;\n  n.z = 1.0 - dot(n.xy, n.xy);\n  if (n.z < 0.0) discard;\n\n  gl_FragColor = vec4(vColor, vOpacity * 0.5);\n}\n"
}, function(e, t, n) {
    "use strict";

    function r(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }
    n.r(t), n.d(t, "default", (function() {
        return a
    }));
    var i = n(0),
        o = n(149).default,
        a = function() {
            function e(t) {
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, e), this.mirrorCamera = new i.PerspectiveCamera(30, t.x / t.y, 1, 15e3), this.mirrorRender = new i.WebGLRenderTarget(t.x, t.y), this.textureMatrix = new i.Matrix4, this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    },
                    texture: {
                        type: "t",
                        value: this.mirrorRender.texture
                    },
                    textureMatrix: {
                        type: "m4",
                        value: this.textureMatrix
                    }
                }, this.renderBack1 = new i.WebGLRenderTarget(t.x, t.y), this.renderBack2 = new i.WebGLRenderTarget(t.x, t.y), this.postEffectBlurX = new o(this.renderBack1.texture, 1, 0, 4), this.postEffectBlurY = new o(this.renderBack2.texture, 0, 1, 4), this.mirrorCamera.up.set(0, -1, 0), this.obj = this.createObj()
            }
            var t, a, s;
            return t = e, (a = [{
                key: "add",
                value: function(e, t) {
                    t.add(this.obj), e.add(this.postEffectBlurX.obj), e.add(this.postEffectBlurY.obj)
                }
            }, {
                key: "createObj",
                value: function() {
                    var e = new i.Mesh(new i.PlaneBufferGeometry(1e3, 2e3), new i.RawShaderMaterial({
                        uniforms: this.uniforms,
                        vertexShader: n(533).default,
                        fragmentShader: n(534).default,
                        transparent: !0
                    }));
                    return e.rotation.set(-.5 * Math.PI, 0, 0), e
                }
            }, {
                key: "updateTextureMatrix",
                value: function() {
                    this.textureMatrix.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, 1, 0, 0, 0, 0, 1), this.textureMatrix.multiply(this.mirrorCamera.projectionMatrix), this.textureMatrix.multiply(this.mirrorCamera.matrixWorldInverse)
                }
            }, {
                key: "render",
                value: function(e, t, n, r, i) {
                    this.uniforms.time.value += i, this.updateTextureMatrix(), this.obj.visible = !1, e.render(n, this.mirrorCamera, this.renderBack1), this.obj.visible = !0, this.postEffectBlurX.render(e, t, r, this.renderBack2), this.postEffectBlurY.render(e, t, r, this.mirrorRender)
                }
            }, {
                key: "resize",
                value: function(e) {
                    this.mirrorCamera.aspect = e.x / e.y, this.mirrorCamera.updateProjectionMatrix(), this.mirrorRender.setSize(e.x, e.y), this.renderBack1.setSize(e.x, e.y), this.renderBack2.setSize(e.x, e.y), this.postEffectBlurX.resize(e), this.postEffectBlurY.resize(e)
                }
            }]) && r(t.prototype, a), s && r(t, s), e
        }()
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "precision highp float;\n#define GLSLIFY 1\n\nuniform vec2 resolution;\nuniform vec2 direction;\nuniform float radius;\nuniform sampler2D texture;\n\nvarying vec2 vUv;\n\nvec4 gaussianBlur(sampler2D texture, vec2 uv, float radius, vec2 resolution, vec2 direction) {\n  vec4 color = vec4(0.0);\n  vec2 step = radius / resolution * direction;\n  color += texture2D(texture, uv - 4.0 * step) * 0.02699548325659403;\n  color += texture2D(texture, uv - 3.0 * step) * 0.06475879783294587;\n  color += texture2D(texture, uv - 2.0 * step) * 0.12098536225957168;\n  color += texture2D(texture, uv - 1.0 * step) * 0.17603266338214976;\n  color += texture2D(texture, uv) * 0.19947114020071635;\n  color += texture2D(texture, uv + 1.0 * step) * 0.17603266338214976;\n  color += texture2D(texture, uv + 2.0 * step) * 0.12098536225957168;\n  color += texture2D(texture, uv + 3.0 * step) * 0.06475879783294587;\n  color += texture2D(texture, uv + 4.0 * step) * 0.02699548325659403;\n  return color;\n}\n\nvoid main() {\n  vec4 color = gaussianBlur(texture, vUv, radius, resolution, direction);\n  gl_FragColor = color;\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec3 normal;\n\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\nuniform mat4 textureMatrix;\n\nvarying vec4 vUv;\n\nvoid main(void) {\n  vec4 worldPosition = modelMatrix * vec4(position, 1.0);\n  vUv = textureMatrix * worldPosition;\n  gl_Position = projectionMatrix * viewMatrix * worldPosition;\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "precision highp float;\n#define GLSLIFY 1\n\nuniform sampler2D texture;\n\nvarying vec4 vUv;\n\nvoid main() {\n  vec4 projectorColor;\n  if (all(bvec4(vUv.x >= 0.0, vUv.y >= 0.0, vUv.x <= vUv.z, vUv.y <= vUv.z))) {\n    projectorColor = texture2DProj(texture, vUv);\n  }\n  gl_FragColor = vec4(vec3(1.0), 0.3) * projectorColor;\n}\n"
}, function(e, t, n) {
    "use strict";

    function r(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }
    n.r(t), n.d(t, "default", (function() {
        return o
    }));
    var i = n(0),
        o = function() {
            function e(t) {
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, e), this.uniforms = {
                    minBright: {
                        type: "f",
                        value: .3
                    },
                    texture: {
                        type: "t",
                        value: t
                    }
                }, this.obj = this.createObj(), this.obj.visible = !1
            }
            var t, o, a;
            return t = e, (o = [{
                key: "createObj",
                value: function() {
                    return new i.Mesh(new i.PlaneBufferGeometry(2, 2), new i.RawShaderMaterial({
                        uniforms: this.uniforms,
                        vertexShader: n(109).default,
                        fragmentShader: n(536).default
                    }))
                }
            }, {
                key: "render",
                value: function(e, t, n, r) {
                    this.obj.visible = !0, e.setRenderTarget(r), e.render(t, n), this.obj.visible = !1
                }
            }]) && r(t.prototype, o), a && r(t, a), e
        }()
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "precision highp float;\n#define GLSLIFY 1\n\nuniform float minBright;\nuniform sampler2D texture;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vec4 bright = max(vec4(0.0), (texture2D(texture, vUv) - minBright));\n  gl_FragColor = bright;\n}\n"
}, function(e, t, n) {
    "use strict";

    function r(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }
    n.r(t), n.d(t, "default", (function() {
        return o
    }));
    var i = n(0),
        o = function() {
            function e(t, n) {
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, e), this.uniforms = {
                    texture1: {
                        type: "t",
                        value: t
                    },
                    texture2: {
                        type: "t",
                        value: n
                    }
                }, this.obj = this.createObj(), this.obj.visible = !1
            }
            var t, o, a;
            return t = e, (o = [{
                key: "createObj",
                value: function() {
                    return new i.Mesh(new i.PlaneBufferGeometry(2, 2), new i.RawShaderMaterial({
                        uniforms: this.uniforms,
                        vertexShader: n(109).default,
                        fragmentShader: n(538).default
                    }))
                }
            }, {
                key: "render",
                value: function(e, t, n) {
                    var r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null;
                    this.obj.visible = !0, e.setRenderTarget(r), e.render(t, n), this.obj.visible = !1
                }
            }]) && r(t.prototype, o), a && r(t, a), e
        }()
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "precision highp float;\n#define GLSLIFY 1\n\nuniform sampler2D texture1;\nuniform sampler2D texture2;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vec4 color1 = texture2D(texture1, vUv);\n  vec4 color2 = texture2D(texture2, vUv);\n  gl_FragColor = color1 * 0.5 + color2;\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t);
    var r = n(0),
        i = n(3),
        o = n(15).default,
        a = n(540).default;
    t.default = function() {
        for (var e = document.getElementById("canvas-webgl"), t = new r.WebGLRenderer({
                antialias: !1,
                canvas: e,
                alpha: !0
            }), n = new r.Scene, s = new r.PerspectiveCamera(90, document.body.clientWidth / window.innerHeight, 1, 1e4), c = new r.Clock, u = new r.Vector2, l = new r.Vector2, f = new r.Vector2, d = 0, h = 0, v = [], p = 0; p < 20; p++) v[p] = new a, n.add(v[p].obj);
        var m = function() {
                e.width = document.body.clientWidth, e.height = window.innerHeight, s.aspect = document.body.clientWidth / window.innerHeight, s.updateProjectionMatrix(), t.setSize(document.body.clientWidth, window.innerHeight)
            },
            y = function() {
                var e = c.getDelta();
                ! function(e) {
                    (h += e) > 1 && (v[d].show(), d = d + 1 >= v.length - 1 ? 0 : d + 1, h = 0)
                }(e);
                for (var r = 0; r < v.length; r++) v[r].render(e);
                t.render(n, s)
            },
            g = function(e) {
                !0
            },
            x = function(e) {
                !1
            };
        t.setSize(document.body.clientWidth, window.innerHeight), t.setClearColor(15856113, 1), s.position.set(0, 0, 1e3), s.lookAt(new r.Vector3), window.addEventListener("resize", i((function() {
                m()
            })), 1e3), e.addEventListener("mousedown", (function(e) {
                e.preventDefault(), u.set(e.clientX, e.clientY), o(u), g()
            })), document.addEventListener("mousemove", (function(e) {
                e.preventDefault(), l.set(e.clientX, e.clientY), o(l)
            })), document.addEventListener("mouseup", (function(e) {
                e.preventDefault(), f.set(e.clientX, e.clientY), o(f), x()
            })), e.addEventListener("touchstart", (function(e) {
                e.preventDefault(), u.set(e.touches[0].clientX, e.touches[0].clientY), o(u), g(e.touches[0].clientX, e.touches[0].clientY)
            })), e.addEventListener("touchmove", (function(e) {
                e.preventDefault(), l.set(e.touches[0].clientX, e.touches[0].clientY), o(l)
            })), e.addEventListener("touchend", (function(e) {
                e.preventDefault(), f.set(e.changedTouches[0].clientX, e.changedTouches[0].clientY), o(f), x()
            })), m(),
            function e() {
                y(), requestAnimationFrame(e)
            }()
    }
}, function(e, t, n) {
    "use strict";

    function r(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }
    n.r(t), n.d(t, "default", (function() {
        return o
    }));
    var i = n(0),
        o = function() {
            function e() {
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, e), this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    },
                    colorH: {
                        type: "f",
                        value: 0
                    },
                    noiseRange: {
                        type: "f",
                        value: 0
                    }
                }, this.obj = this.createObj(), this.obj.visible = !1
            }
            var t, o, a;
            return t = e, (o = [{
                key: "createObj",
                value: function() {
                    return new i.Mesh(new i.PlaneBufferGeometry(1500, 1500), new i.RawShaderMaterial({
                        uniforms: this.uniforms,
                        vertexShader: n(541).default,
                        fragmentShader: n(542).default,
                        transparent: !0
                    }))
                }
            }, {
                key: "show",
                value: function(e) {
                    this.uniforms.time.value = 0, this.uniforms.colorH.value = Math.random(), this.uniforms.noiseRange.value = 3 * Math.random(), this.obj.visible = !0, this.obj.position.set((2 * Math.random() - 1) * window.innerWidth, (2 * Math.random() - 1) * window.innerHeight, 0)
                }
            }, {
                key: "render",
                value: function(e) {
                    this.obj.visible && (this.uniforms.time.value += e, this.obj.position.z -= 3)
                }
            }]) && r(t.prototype, o), a && r(t, a), e
        }()
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\nuniform float colorH;\nuniform float noiseRange;\n\nvarying vec2 vUv;\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\nvec3 convertHsvToRgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat exponentialOut(float t) {\n  return t == 1.0 ? t : 1.0 - pow(2.0, -10.0 * t);\n}\n\nvoid main() {\n  float t1 = exponentialOut(min(time, 1.0) / 1.0);\n  float t2 = exponentialOut(clamp(time - 14.0, 0.0, 1.0) / 1.0);\n  vec2 pos = vUv * 2.0 - vec2(1.0);\n  float circleOut = smoothstep(0.0, 0.5, t1 - t2 - length(pos));\n  float circleIn = smoothstep(0.0, 0.5, (t1 - t2) * 0.5 - length(pos));\n  float noise = (snoise(vec3(pos * (1.4 + noiseRange * 0.1) + vec2(sin(time), cos(time)), time + noiseRange * 100.0)) + 1.0) / 2.0;\n  float mask = circleOut * noise + circleIn;\n  float opacity = 1.0 - step(mask, 0.3);\n  float h1 = step(mask, 0.99) * 0.4 - time * 0.05;\n  float h2 = step(mask, 0.4) * 0.5;\n  vec3 hsv = vec3(h1 - h2 + colorH, 0.45, 0.8);\n  vec3 rgb = convertHsvToRgb(hsv);\n  gl_FragColor = vec4(rgb, opacity);\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t);
    var r = n(0),
        i = n(3),
        o = (n(15).default, n(544).default),
        a = n(553).default,
        s = n(556).default;
    t.default = function() {
        var e = document.getElementById("canvas-webgl"),
            t = new r.WebGLRenderer({
                antialias: !0,
                canvas: e
            }),
            n = new r.WebGLRenderTarget(document.body.clientWidth, window.innerHeight),
            c = new r.Scene,
            u = new r.Scene,
            l = new r.PerspectiveCamera(24, document.body.clientWidth / window.innerHeight, 1, 15e3),
            f = new r.Clock,
            d = new r.Vector2,
            h = new r.Vector2,
            v = new r.Vector2,
            p = new r.Vector2,
            m = new Uint8Array(4),
            y = !1,
            g = new o,
            x = new a,
            b = new s,
            w = function() {
                e.width = document.body.clientWidth, e.height = window.innerHeight, l.aspect = document.body.clientWidth / window.innerHeight, l.updateProjectionMatrix(), t.setSize(document.body.clientWidth, window.innerHeight), n.setSize(document.body.clientWidth, window.innerHeight), x.resize()
            },
            M = function e() {
                var n;
                n = f.getDelta(), t.setClearColor(15856113, 1), g.render(n), x.render(t, c, n), b.render(t, c, n), t.setRenderTarget(null), t.render(c, l), requestAnimationFrame(e)
            },
            _ = function(e) {
                y = !0
            },
            S = function(e) {
                y ? e && g.rotate(2 * (h.x - v.x)) : (t.setClearColor(16777215, 1), t.render(u, l, n), t.readRenderTargetPixels(n, h.x, n.height - h.y, 1, 1, m), g.picked(m[0] << 16 | m[1] << 8 | m[2]))
            },
            P = function(e) {
                y = !1
            },
            T = function() {
                window.addEventListener("resize", i((function() {
                    w()
                })), 1e3), e.addEventListener("mousedown", (function(e) {
                    e.preventDefault(), d.set(e.clientX, e.clientY), _()
                })), document.addEventListener("mousemove", (function(e) {
                    e.preventDefault(), h.set(e.clientX, e.clientY), S(!1)
                })), document.addEventListener("mouseup", (function(e) {
                    e.preventDefault(), p.set(e.clientX, e.clientY), P()
                })), e.addEventListener("wheel", (function(e) {
                    e.preventDefault(),
                        function(e) {
                            g.rotate(e.deltaY)
                        }(e)
                })), e.addEventListener("touchstart", (function(e) {
                    e.preventDefault(), d.set(e.touches[0].clientX, e.touches[0].clientY), h.set(e.touches[0].clientX, e.touches[0].clientY), v.set(e.touches[0].clientX, e.touches[0].clientY), _(e.touches[0].clientX, e.touches[0].clientY)
                })), e.addEventListener("touchmove", (function(e) {
                    e.preventDefault(), h.set(e.touches[0].clientX, e.touches[0].clientY), S(!0), v.set(e.touches[0].clientX, e.touches[0].clientY)
                })), e.addEventListener("touchend", (function(e) {
                    e.preventDefault(), p.set(e.changedTouches[0].clientX, e.changedTouches[0].clientY), P()
                }))
            };
        t.setSize(document.body.clientWidth, window.innerHeight), l.position.set(0, 400, -3e3), l.lookAt(new r.Vector3(0, 0, 0)), x.mirrorCamera.position.set(0, -400, -3e3), x.mirrorCamera.lookAt(new r.Vector3(0, 0, 0)), g.core.obj.position.set(0, 80, 0), g.wire.obj.position.set(0, 80, 0), g.wire.objPicked.position.set(0, 80, 0), x.obj.rotation.set(-.5 * Math.PI, 0, 0), c.add(g.core.obj), c.add(g.wire.obj), c.add(x.obj), c.add(b.obj), c.add(b.cubeCamera), u.add(g.wire.objPicked), T(), w(), M()
    }
}, function(e, t, n) {
    "use strict";

    function r(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }
    n.r(t), n.d(t, "default", (function() {
        return s
    }));
    n(0), n(1), n(3);
    var i = n(70).default,
        o = n(545).default,
        a = n(548).default,
        s = function() {
            function e() {
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, e), this.velocity = [0, 0, 0], this.acceleration = [0, 0, 0], this.anchor = [0, 0, 0], this.instances = 36, this.core = new o(this.instances), this.wire = new a(this.instances)
            }
            var t, n, s;
            return t = e, (n = [{
                key: "updateRotation",
                value: function() {
                    i.applyHook(this.velocity, this.acceleration, this.anchor, 0, .02), i.applyDrag(this.acceleration, .3), i.updateVelocity(this.velocity, this.acceleration, 1), this.core.uniforms.rotate.value = this.velocity[0], this.wire.uniforms.rotate.value = this.velocity[0]
                }
            }, {
                key: "rotate",
                value: function(e) {
                    e && (this.anchor[0] -= .05 * e)
                }
            }, {
                key: "picked",
                value: function(e) {
                    this.core.uniforms.pickedId.value = e, this.wire.uniforms.pickedId.value = e, e < this.instances && e > -1 ? document.body.classList.add("is-picked") : document.body.classList.remove("is-picked")
                }
            }, {
                key: "render",
                value: function(e) {
                    this.core.uniforms.time.value += e, this.wire.render(e), this.updateRotation()
                }
            }]) && r(t.prototype, n), s && r(t, s), e
        }()
}, function(e, t, n) {
    "use strict";

    function r(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }
    n.r(t), n.d(t, "default", (function() {
        return a
    }));
    var i = n(0),
        o = n(1),
        a = function() {
            function e(t) {
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, e), this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    },
                    rotate: {
                        type: "f",
                        value: 0
                    },
                    pickedId: {
                        type: "f",
                        value: -1
                    }
                }, this.instances = t, this.obj = this.createObj()
            }
            var t, a, s;
            return t = e, (a = [{
                key: "createObj",
                value: function() {
                    var e = new i.InstancedBufferGeometry,
                        t = new i.OctahedronBufferGeometry(30, 4);
                    e.copy(t);
                    for (var r = new i.InstancedBufferAttribute(new Float32Array(this.instances), 1), a = new i.InstancedBufferAttribute(new Float32Array(3 * this.instances), 3), s = new i.InstancedBufferAttribute(new Float32Array(this.instances), 1), c = new i.InstancedBufferAttribute(new Float32Array(this.instances), 1), u = 0; u < this.instances; u++) r.setXYZ(u, o.radians(u / this.instances * 360)), a.setXYZ(u, u / this.instances - .25, .2, .9), s.setXYZ(u, Math.random()), c.setXYZ(u, .5 * (Math.random() + 1));
                    return e.addAttribute("radian", r), e.addAttribute("hsv", a), e.addAttribute("noiseDiff", s), e.addAttribute("speed", c), new i.Mesh(e, new i.RawShaderMaterial({
                        uniforms: this.uniforms,
                        vertexShader: n(546).default,
                        fragmentShader: n(547).default,
                        transparent: !0
                    }))
                }
            }]) && r(t.prototype, a), s && r(t, s), e
        }()
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec3 normal;\nattribute float radian;\nattribute vec3 hsv;\nattribute float noiseDiff;\nattribute float speed;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform float time;\nuniform float rotate;\n\nvarying vec3 vPosition;\nvarying vec3 vNormal;\nvarying vec3 vColor;\n\nmat4 calcTranslateMat4(vec3 v) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    v.x, v.y, v.z, 1.0\n  );\n}\n\nmat4 calcRotateMat4X(float radian) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, cos(radian), -sin(radian), 0.0,\n    0.0, sin(radian), cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4Y(float radian) {\n  return mat4(\n    cos(radian), 0.0, sin(radian), 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    -sin(radian), 0.0, cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4Z(float radian) {\n  return mat4(\n    cos(radian), -sin(radian), 0.0, 0.0,\n    sin(radian), cos(radian), 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4(vec3 radian) {\n  return calcRotateMat4X(radian.x) * calcRotateMat4Y(radian.y) * calcRotateMat4Z(radian.z);\n}\n\nvec3 convertHsvToRgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\nvoid main(void) {\n  float noise = snoise(position * 0.02 + time * speed + noiseDiff);\n  mat4 rotateMatWorld = calcRotateMat4(vec3(0.0, radian + radians(rotate), 0.0));\n  mat4 translateMat = calcTranslateMat4(vec3(1000.0, 0.0, 0.0));\n  vec4 updatePosition = rotateMatWorld * translateMat * vec4(\n    position + normalize(position) * noise * 5.0,\n    1.0\n    );\n  vPosition = updatePosition.xyz;\n  vNormal = normal;\n  vColor = convertHsvToRgb(hsv);\n  gl_Position = projectionMatrix * modelViewMatrix * updatePosition;\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\nuniform vec3 cameraPosition;\n\nvarying vec3 vPosition;\nvarying vec3 vNormal;\nvarying vec3 vColor;\n\nconst vec3 light = vec3(0.7);\n\nvoid main() {\n  float diff = (dot(vNormal, light) + 1.0) / 2.0 * 0.25 + 0.75;\n  float opacity = (1.0 - (vPosition.z / 1000.0)) * 0.8 + 0.2;\n  gl_FragColor = vec4(vColor * diff, opacity);\n}\n"
}, function(e, t, n) {
    "use strict";

    function r(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }
    n.r(t), n.d(t, "default", (function() {
        return a
    }));
    var i = n(0),
        o = n(1),
        a = (n(70).default, function() {
            function e(t) {
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, e), this.size = 120, this.baseGeometry = new i.BoxBufferGeometry(this.size, this.size, this.size), this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    },
                    rotate: {
                        type: "f",
                        value: 0
                    },
                    pickedId: {
                        type: "f",
                        value: -1
                    }
                }, this.instances = t, this.obj = this.createObj(), this.objPicked = this.createObjPicked()
            }
            var t, a, s;
            return t = e, (a = [{
                key: "createObj",
                value: function() {
                    var e = new i.InstancedBufferGeometry;
                    e.copy(this.baseGeometry);
                    for (var t = new i.InstancedBufferAttribute(new Float32Array(this.instances), 1), r = new i.InstancedBufferAttribute(new Float32Array(3 * this.instances), 3), a = new i.InstancedBufferAttribute(new Float32Array(this.instances), 1), s = 0; s < this.instances; s++) t.setXYZ(s, o.radians(s / this.instances * 360)), r.setXYZ(s, s / this.instances - .25, .2, 1), a.setXYZ(s, 0);
                    return e.addAttribute("radian", t), e.addAttribute("hsv", r), e.addAttribute("timeHover", a), new i.Mesh(e, new i.RawShaderMaterial({
                        uniforms: this.uniforms,
                        vertexShader: n(549).default,
                        fragmentShader: n(550).default,
                        depthWrite: !1,
                        transparent: !0,
                        side: i.DoubleSide,
                        flatShading: !0
                    }))
                }
            }, {
                key: "createObjPicked",
                value: function() {
                    var e = new i.InstancedBufferGeometry;
                    e.copy(this.baseGeometry);
                    for (var t = new i.InstancedBufferAttribute(new Float32Array(this.instances), 1), r = new i.InstancedBufferAttribute(new Float32Array(3 * this.instances), 3), a = new i.Color, s = new i.InstancedBufferAttribute(new Float32Array(this.instances), 1), c = 0; c < this.instances; c++) t.setXYZ(c, o.radians(c / this.instances * 360)), a.setHex(c), r.setXYZ(c, a.r, a.g, a.b), s.setXYZ(c, 0);
                    return e.addAttribute("radian", t), e.addAttribute("pickedColor", r), e.addAttribute("timeHover", s), new i.Mesh(e, new i.RawShaderMaterial({
                        uniforms: this.uniforms,
                        vertexShader: n(551).default,
                        fragmentShader: n(552).default
                    }))
                }
            }, {
                key: "render",
                value: function(e) {
                    var t = this.obj.geometry.attributes.timeHover,
                        n = this.objPicked.geometry.attributes.timeHover;
                    this.uniforms.time.value += e;
                    for (var r = 0; r < t.array.length; r++) this.uniforms.pickedId.value == r ? (t.array[r] = Math.min(t.array[r] + e, .3), n.array[r] = Math.min(n.array[r] + e, .3)) : (t.array[r] = Math.max(t.array[r] - e, 0), n.array[r] = Math.max(n.array[r] - e, 0));
                    t.needsUpdate = !0, n.needsUpdate = !0
                }
            }]) && r(t.prototype, a), s && r(t, s), e
        }())
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec3 normal;\nattribute float radian;\nattribute vec3 hsv;\nattribute float timeHover;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform float time;\nuniform float rotate;\n\nvarying vec3 vPosition;\nvarying vec3 vNormal;\nvarying vec3 vColor;\nvarying mat4 vInvertMatrix;\n\nfloat inverse(float m) {\n  return 1.0 / m;\n}\n\nmat2 inverse(mat2 m) {\n  return mat2(m[1][1],-m[0][1],\n             -m[1][0], m[0][0]) / (m[0][0]*m[1][1] - m[0][1]*m[1][0]);\n}\n\nmat3 inverse(mat3 m) {\n  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2];\n  float a10 = m[1][0], a11 = m[1][1], a12 = m[1][2];\n  float a20 = m[2][0], a21 = m[2][1], a22 = m[2][2];\n\n  float b01 = a22 * a11 - a12 * a21;\n  float b11 = -a22 * a10 + a12 * a20;\n  float b21 = a21 * a10 - a11 * a20;\n\n  float det = a00 * b01 + a01 * b11 + a02 * b21;\n\n  return mat3(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11),\n              b11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10),\n              b21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)) / det;\n}\n\nmat4 inverse(mat4 m) {\n  float\n      a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\n      a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\n      a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\n      a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3],\n\n      b00 = a00 * a11 - a01 * a10,\n      b01 = a00 * a12 - a02 * a10,\n      b02 = a00 * a13 - a03 * a10,\n      b03 = a01 * a12 - a02 * a11,\n      b04 = a01 * a13 - a03 * a11,\n      b05 = a02 * a13 - a03 * a12,\n      b06 = a20 * a31 - a21 * a30,\n      b07 = a20 * a32 - a22 * a30,\n      b08 = a20 * a33 - a23 * a30,\n      b09 = a21 * a32 - a22 * a31,\n      b10 = a21 * a33 - a23 * a31,\n      b11 = a22 * a33 - a23 * a32,\n\n      det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  return mat4(\n      a11 * b11 - a12 * b10 + a13 * b09,\n      a02 * b10 - a01 * b11 - a03 * b09,\n      a31 * b05 - a32 * b04 + a33 * b03,\n      a22 * b04 - a21 * b05 - a23 * b03,\n      a12 * b08 - a10 * b11 - a13 * b07,\n      a00 * b11 - a02 * b08 + a03 * b07,\n      a32 * b02 - a30 * b05 - a33 * b01,\n      a20 * b05 - a22 * b02 + a23 * b01,\n      a10 * b10 - a11 * b08 + a13 * b06,\n      a01 * b08 - a00 * b10 - a03 * b06,\n      a30 * b04 - a31 * b02 + a33 * b00,\n      a21 * b02 - a20 * b04 - a23 * b00,\n      a11 * b07 - a10 * b09 - a12 * b06,\n      a00 * b09 - a01 * b07 + a02 * b06,\n      a31 * b01 - a30 * b03 - a32 * b00,\n      a20 * b03 - a21 * b01 + a22 * b00) / det;\n}\n\nfloat circularOut(float t) {\n  return sqrt((2.0 - t) * t);\n}\n\nmat4 calcTranslateMat4(vec3 v) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    v.x, v.y, v.z, 1.0\n  );\n}\n\nmat4 calcRotateMat4X(float radian) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, cos(radian), -sin(radian), 0.0,\n    0.0, sin(radian), cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4Y(float radian) {\n  return mat4(\n    cos(radian), 0.0, sin(radian), 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    -sin(radian), 0.0, cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4Z(float radian) {\n  return mat4(\n    cos(radian), -sin(radian), 0.0, 0.0,\n    sin(radian), cos(radian), 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4(vec3 radian) {\n  return calcRotateMat4X(radian.x) * calcRotateMat4Y(radian.y) * calcRotateMat4Z(radian.z);\n}\n\nmat4 calcScaleMat4(vec3 scale) {\n  return mat4(\n    scale.x, 0.0, 0.0, 0.0,\n    0.0, scale.y, 0.0, 0.0,\n    0.0, 0.0, scale.z, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nvec3 convertHsvToRgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main(void) {\n  float easeStep = circularOut(timeHover / 0.3);\n  mat4 rotateMatWorld = calcRotateMat4(vec3(0.0, radian + radians(rotate), 0.0));\n  mat4 scaleMat = calcScaleMat4(vec3(1.0 + easeStep * 0.2));\n  mat4 translateMat = calcTranslateMat4(vec3(1000.0, 0.0, 0.0));\n  vec4 updatePosition = rotateMatWorld * translateMat * scaleMat * vec4(position, 1.0);\n  vPosition = updatePosition.xyz;\n  vInvertMatrix = inverse(rotateMatWorld * translateMat);\n  vColor = convertHsvToRgb(hsv * vec3(1.0, 1.0 - easeStep, 1.0));\n  gl_Position = projectionMatrix * modelViewMatrix * updatePosition;\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\nuniform vec3 cameraPosition;\n\nvarying vec3 vPosition;\nvarying vec3 vColor;\nvarying mat4 vInvertMatrix;\n\nconst vec3 color = vec3(0.9);\n\nvoid main() {\n  vec3 normal = normalize(cross(dFdx(vPosition), dFdy(vPosition)));\n  if(!gl_FrontFacing) {\n      normal = -normal;\n  }\n  vec3 light = normalize(vInvertMatrix * vec4(vec3(-1000.0, 1000.0, -1000.0), 1.0)).xyz;\n  float diff = (dot(normal, light) + 1.0) / 2.0 * 0.2 + 0.8;\n  float opacity = (1.0 - (vPosition.z / 1000.0)) * 0.1 + 0.1;\n  gl_FragColor = vec4(color * diff * vColor, opacity);\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nattribute vec3 position;\nattribute float radian;\nattribute vec3 pickedColor;\nattribute float timeHover;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform float time;\nuniform float rotate;\n\nvarying vec3 vColor;\n\nfloat circularOut(float t) {\n  return sqrt((2.0 - t) * t);\n}\n\nmat4 calcTranslateMat4(vec3 v) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    v.x, v.y, v.z, 1.0\n  );\n}\n\nmat4 calcRotateMat4X(float radian) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, cos(radian), -sin(radian), 0.0,\n    0.0, sin(radian), cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4Y(float radian) {\n  return mat4(\n    cos(radian), 0.0, sin(radian), 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    -sin(radian), 0.0, cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4Z(float radian) {\n  return mat4(\n    cos(radian), -sin(radian), 0.0, 0.0,\n    sin(radian), cos(radian), 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4(vec3 radian) {\n  return calcRotateMat4X(radian.x) * calcRotateMat4Y(radian.y) * calcRotateMat4Z(radian.z);\n}\n\nmat4 calcScaleMat4(vec3 scale) {\n  return mat4(\n    scale.x, 0.0, 0.0, 0.0,\n    0.0, scale.y, 0.0, 0.0,\n    0.0, 0.0, scale.z, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nvoid main(void) {\n  float easeStep = circularOut(timeHover / 0.3);\n  mat4 rotateMatWorld = calcRotateMat4(vec3(0.0, radian + radians(rotate), 0.0));\n  mat4 scaleMat = calcScaleMat4(vec3(1.0 + easeStep * 0.2));\n  mat4 translateMat = calcTranslateMat4(vec3(1000.0, 0.0, 0.0));\n  vec4 updatePosition = rotateMatWorld * translateMat * scaleMat * vec4(position, 1.0);\n  vColor = pickedColor;\n  gl_Position = projectionMatrix * modelViewMatrix * updatePosition;\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\n\nvarying vec3 vColor;\n\nvoid main() {\n  gl_FragColor = vec4(vColor, 1.0);\n}\n"
}, function(e, t, n) {
    "use strict";

    function r(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }
    n.r(t), n.d(t, "default", (function() {
        return o
    }));
    var i = n(0),
        o = function() {
            function e() {
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, e), this.mirrorCamera = new i.PerspectiveCamera(24, document.body.clientWidth / window.innerHeight, 1, 15e3), this.mirrorRender = new i.WebGLRenderTarget(document.body.clientWidth, window.innerHeight), this.textureMatrix = new i.Matrix4, this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    },
                    texture: {
                        type: "t",
                        value: this.mirrorRender.texture
                    },
                    textureMatrix: {
                        type: "m4",
                        value: this.textureMatrix
                    },
                    mirrorPosition: {
                        type: "v3",
                        value: this.mirrorCamera.position
                    }
                }, this.mirrorCamera.up.set(0, -1, 0), this.obj = this.createObj()
            }
            var t, o, a;
            return t = e, (o = [{
                key: "createObj",
                value: function() {
                    return new i.Mesh(new i.PlaneBufferGeometry(4e3, 4e3), new i.RawShaderMaterial({
                        uniforms: this.uniforms,
                        vertexShader: n(554).default,
                        fragmentShader: n(555).default,
                        transparent: !0
                    }))
                }
            }, {
                key: "updateTextureMatrix",
                value: function() {
                    this.textureMatrix.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, 1, 0, 0, 0, 0, 1), this.textureMatrix.multiply(this.mirrorCamera.projectionMatrix), this.textureMatrix.multiply(this.mirrorCamera.matrixWorldInverse)
                }
            }, {
                key: "render",
                value: function(e, t, n) {
                    this.uniforms.time.value += n, this.updateTextureMatrix(), this.obj.visible = !1, e.setRenderTarget(this.mirrorRender), e.render(t, this.mirrorCamera), this.obj.visible = !0
                }
            }, {
                key: "resize",
                value: function() {
                    this.mirrorCamera.aspect = document.body.clientWidth / window.innerHeight, this.mirrorCamera.updateProjectionMatrix(), this.mirrorRender.setSize(document.body.clientWidth, window.innerHeight)
                }
            }]) && r(t.prototype, o), a && r(t, a), e
        }()
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec3 normal;\n\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\nuniform mat3 normalMatrix;\nuniform mat4 textureMatrix;\n\nvarying vec3 vPosition;\nvarying vec3 vNormal;\nvarying vec4 vUv;\nvarying mat4 vInvertMatrix;\n\nfloat inverse(float m) {\n  return 1.0 / m;\n}\n\nmat2 inverse(mat2 m) {\n  return mat2(m[1][1],-m[0][1],\n             -m[1][0], m[0][0]) / (m[0][0]*m[1][1] - m[0][1]*m[1][0]);\n}\n\nmat3 inverse(mat3 m) {\n  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2];\n  float a10 = m[1][0], a11 = m[1][1], a12 = m[1][2];\n  float a20 = m[2][0], a21 = m[2][1], a22 = m[2][2];\n\n  float b01 = a22 * a11 - a12 * a21;\n  float b11 = -a22 * a10 + a12 * a20;\n  float b21 = a21 * a10 - a11 * a20;\n\n  float det = a00 * b01 + a01 * b11 + a02 * b21;\n\n  return mat3(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11),\n              b11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10),\n              b21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)) / det;\n}\n\nmat4 inverse(mat4 m) {\n  float\n      a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\n      a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\n      a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\n      a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3],\n\n      b00 = a00 * a11 - a01 * a10,\n      b01 = a00 * a12 - a02 * a10,\n      b02 = a00 * a13 - a03 * a10,\n      b03 = a01 * a12 - a02 * a11,\n      b04 = a01 * a13 - a03 * a11,\n      b05 = a02 * a13 - a03 * a12,\n      b06 = a20 * a31 - a21 * a30,\n      b07 = a20 * a32 - a22 * a30,\n      b08 = a20 * a33 - a23 * a30,\n      b09 = a21 * a32 - a22 * a31,\n      b10 = a21 * a33 - a23 * a31,\n      b11 = a22 * a33 - a23 * a32,\n\n      det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  return mat4(\n      a11 * b11 - a12 * b10 + a13 * b09,\n      a02 * b10 - a01 * b11 - a03 * b09,\n      a31 * b05 - a32 * b04 + a33 * b03,\n      a22 * b04 - a21 * b05 - a23 * b03,\n      a12 * b08 - a10 * b11 - a13 * b07,\n      a00 * b11 - a02 * b08 + a03 * b07,\n      a32 * b02 - a30 * b05 - a33 * b01,\n      a20 * b05 - a22 * b02 + a23 * b01,\n      a10 * b10 - a11 * b08 + a13 * b06,\n      a01 * b08 - a00 * b10 - a03 * b06,\n      a30 * b04 - a31 * b02 + a33 * b00,\n      a21 * b02 - a20 * b04 - a23 * b00,\n      a11 * b07 - a10 * b09 - a12 * b06,\n      a00 * b09 - a01 * b07 + a02 * b06,\n      a31 * b01 - a30 * b03 - a32 * b00,\n      a20 * b03 - a21 * b01 + a22 * b00) / det;\n}\n\nvoid main(void) {\n  vec4 worldPosition = modelMatrix * vec4(position, 1.0);\n  vPosition = worldPosition.xyz;\n  vNormal = normal;\n  vUv = textureMatrix * worldPosition;\n  vInvertMatrix = inverse(modelMatrix);\n  gl_Position = projectionMatrix * viewMatrix * worldPosition;\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "precision highp float;\n#define GLSLIFY 1\n\nuniform sampler2D texture;\n\nvarying vec3 vPosition;\nvarying vec3 vNormal;\nvarying vec4 vUv;\nvarying mat4 vInvertMatrix;\n\nvoid main() {\n  vec4 projectorColor;\n  if (all(bvec4(vUv.x >= 0.0, vUv.y >= 0.0, vUv.x <= vUv.z, vUv.y <= vUv.z))) {\n    projectorColor = texture2DProj(texture, vUv);\n  }\n  gl_FragColor = vec4(1.0, 1.0, 1.0, 0.35) * projectorColor;\n}\n"
}, function(e, t, n) {
    "use strict";

    function r(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }
    n.r(t), n.d(t, "default", (function() {
        return o
    }));
    var i = n(0),
        o = function() {
            function e() {
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, e), this.cubeCamera = new i.CubeCamera(1, 15e3, 1024), this.instances = 6, this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    }
                }, this.obj = this.createObj(), this.obj.rotation.set(0, .3 * Math.PI, 0)
            }
            var t, o, a;
            return t = e, (o = [{
                key: "createObj",
                value: function() {
                    var e = new i.InstancedBufferGeometry,
                        t = new i.BoxBufferGeometry(40, 1, 10);
                    e.copy(t);
                    for (var r = new i.InstancedBufferAttribute(new Float32Array(this.instances), 1), o = new i.InstancedBufferAttribute(new Float32Array(this.instances), 1), a = 0, s = this.instances; a < s; a++) r.setXYZ(a, 150 * (a + 1) + 200), o.setXYZ(a, 120 * (a - (this.instances - 1) / 2));
                    return e.addAttribute("height", r), e.addAttribute("offsetX", o), new i.Mesh(e, new i.RawShaderMaterial({
                        uniforms: this.uniforms,
                        vertexShader: n(557).default,
                        fragmentShader: n(558).default,
                        flatShading: !0
                    }))
                }
            }, {
                key: "render",
                value: function(e, t, n) {
                    this.uniforms.time.value += n, this.obj.visible = !1, this.cubeCamera.update(e, t), this.obj.visible = !0
                }
            }]) && r(t.prototype, o), a && r(t, a), e
        }()
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec3 normal;\nattribute float height;\nattribute float offsetX;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 modelMatrix;\n\nvarying vec3 vPosition;\nvarying mat4 vInvertMatrix;\n\nmat4 calcTranslateMat4(vec3 v) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    v.x, v.y, v.z, 1.0\n  );\n}\n\nmat4 calcScaleMat4(vec3 scale) {\n  return mat4(\n    scale.x, 0.0, 0.0, 0.0,\n    0.0, scale.y, 0.0, 0.0,\n    0.0, 0.0, scale.z, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nfloat inverse(float m) {\n  return 1.0 / m;\n}\n\nmat2 inverse(mat2 m) {\n  return mat2(m[1][1],-m[0][1],\n             -m[1][0], m[0][0]) / (m[0][0]*m[1][1] - m[0][1]*m[1][0]);\n}\n\nmat3 inverse(mat3 m) {\n  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2];\n  float a10 = m[1][0], a11 = m[1][1], a12 = m[1][2];\n  float a20 = m[2][0], a21 = m[2][1], a22 = m[2][2];\n\n  float b01 = a22 * a11 - a12 * a21;\n  float b11 = -a22 * a10 + a12 * a20;\n  float b21 = a21 * a10 - a11 * a20;\n\n  float det = a00 * b01 + a01 * b11 + a02 * b21;\n\n  return mat3(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11),\n              b11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10),\n              b21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)) / det;\n}\n\nmat4 inverse(mat4 m) {\n  float\n      a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\n      a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\n      a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\n      a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3],\n\n      b00 = a00 * a11 - a01 * a10,\n      b01 = a00 * a12 - a02 * a10,\n      b02 = a00 * a13 - a03 * a10,\n      b03 = a01 * a12 - a02 * a11,\n      b04 = a01 * a13 - a03 * a11,\n      b05 = a02 * a13 - a03 * a12,\n      b06 = a20 * a31 - a21 * a30,\n      b07 = a20 * a32 - a22 * a30,\n      b08 = a20 * a33 - a23 * a30,\n      b09 = a21 * a32 - a22 * a31,\n      b10 = a21 * a33 - a23 * a31,\n      b11 = a22 * a33 - a23 * a32,\n\n      det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  return mat4(\n      a11 * b11 - a12 * b10 + a13 * b09,\n      a02 * b10 - a01 * b11 - a03 * b09,\n      a31 * b05 - a32 * b04 + a33 * b03,\n      a22 * b04 - a21 * b05 - a23 * b03,\n      a12 * b08 - a10 * b11 - a13 * b07,\n      a00 * b11 - a02 * b08 + a03 * b07,\n      a32 * b02 - a30 * b05 - a33 * b01,\n      a20 * b05 - a22 * b02 + a23 * b01,\n      a10 * b10 - a11 * b08 + a13 * b06,\n      a01 * b08 - a00 * b10 - a03 * b06,\n      a30 * b04 - a31 * b02 + a33 * b00,\n      a21 * b02 - a20 * b04 - a23 * b00,\n      a11 * b07 - a10 * b09 - a12 * b06,\n      a00 * b09 - a01 * b07 + a02 * b06,\n      a31 * b01 - a30 * b03 - a32 * b00,\n      a20 * b03 - a21 * b01 + a22 * b00) / det;\n}\n\nvoid main(void) {\n  mat4 translateMat = calcTranslateMat4(vec3(offsetX, 0.0, 0.0));\n  mat4 scaleMat = calcScaleMat4(vec3(1.0, (position.y + 0.5) * height, 1.0));\n  vec4 updatePosition = scaleMat * translateMat * vec4(position, 1.0);\n  vPosition = (modelMatrix * updatePosition).xyz;\n  vInvertMatrix = inverse(modelMatrix);\n  gl_Position = projectionMatrix * modelViewMatrix * updatePosition;\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "precision highp float;\n#define GLSLIFY 1\n\nuniform vec3 cameraPosition;\nuniform float time;\n\nvarying vec3 vPosition;\nvarying mat4 vInvertMatrix;\n\nvoid main() {\n  vec3 normal = normalize(cross(dFdx(vPosition), dFdy(vPosition)));\n  vec3 light = vec3(-0.7, 0.7, -0.7);\n  float diff = (dot(normal, light) + 1.0) / 2.0 * 0.2 + 0.8;\n  gl_FragColor = vec4(vec3(0.98) * diff, 1.0);\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t);
    var r = n(0),
        i = n(3),
        o = n(15).default,
        a = n(560).default,
        s = n(563).default;
    t.default = function() {
        var e = document.getElementById("canvas-webgl"),
            t = new r.WebGLRenderer({
                antialias: !1,
                canvas: e
            }),
            n = new r.WebGLRenderTarget(document.body.clientWidth, window.innerHeight),
            c = new r.Scene,
            u = new r.Scene,
            l = new r.OrthographicCamera(-1, 1, 1, -1, 0, 1),
            f = new r.PerspectiveCamera(45, document.body.clientWidth / window.innerHeight, 1, 2),
            d = new r.Clock,
            h = new r.Vector2,
            v = new r.Vector2,
            p = new r.Vector2,
            m = new a,
            y = new s(n.texture),
            g = function() {
                e.width = document.body.clientWidth, e.height = window.innerHeight, f.aspect = document.body.clientWidth / window.innerHeight, f.updateProjectionMatrix(), m.resize(), y.resize(), n.setSize(document.body.clientWidth, window.innerHeight), t.setSize(document.body.clientWidth, window.innerHeight)
            },
            x = function e() {
                var r;
                r = d.getDelta(), t.setRenderTarget(n), t.render(u, f), y.render(r), t.setRenderTarget(null), t.render(c, l), requestAnimationFrame(e)
            },
            b = function(e) {
                !0
            },
            w = function(e) {
                !1
            };
        t.setSize(document.body.clientWidth, window.innerHeight), t.setClearColor(5592405, 1), m.init((function() {
            u.add(m.obj), c.add(y.obj)
        })), window.addEventListener("resize", i((function() {
            g()
        })), 1e3), e.addEventListener("mousedown", (function(e) {
            e.preventDefault(), h.set(e.clientX, e.clientY), o(h), b()
        })), document.addEventListener("mousemove", (function(e) {
            e.preventDefault(), v.set(e.clientX, e.clientY), o(v)
        })), document.addEventListener("mouseup", (function(e) {
            e.preventDefault(), p.set(e.clientX, e.clientY), o(p), w()
        })), e.addEventListener("touchstart", (function(e) {
            e.preventDefault(), h.set(e.touches[0].clientX, e.touches[0].clientY), o(h), b(e.touches[0].clientX, e.touches[0].clientY)
        })), e.addEventListener("touchmove", (function(e) {
            e.preventDefault(), v.set(e.touches[0].clientX, e.touches[0].clientY), o(v)
        })), e.addEventListener("touchend", (function(e) {
            e.preventDefault(), p.set(e.changedTouches[0].clientX, e.changedTouches[0].clientY), o(p), w()
        })), g(), x()
    }
}, function(e, t, n) {
    "use strict";

    function r(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }
    n.r(t), n.d(t, "default", (function() {
        return o
    }));
    var i = n(0),
        o = function() {
            function e() {
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, e), this.uniforms = {
                    resolution: {
                        type: "v2",
                        value: new i.Vector2(document.body.clientWidth, window.innerHeight)
                    },
                    imageResolution: {
                        type: "v2",
                        value: new i.Vector2(2048, 1356)
                    },
                    texture: {
                        type: "t",
                        value: null
                    }
                }, this.obj
            }
            var t, o, a;
            return t = e, (o = [{
                key: "init",
                value: function(e) {
                    var t = this;
                    (new i.TextureLoader).load("/sketch-threejs/img/sketch/glitch/osaka.jpg", (function(n) {
                        n.magFilter = i.NearestFilter, n.minFilter = i.NearestFilter, t.uniforms.texture.value = n, t.obj = t.createObj(), e()
                    }))
                }
            }, {
                key: "createObj",
                value: function() {
                    return new i.Mesh(new i.PlaneBufferGeometry(2, 2), new i.RawShaderMaterial({
                        uniforms: this.uniforms,
                        vertexShader: n(561).default,
                        fragmentShader: n(562).default
                    }))
                }
            }, {
                key: "resize",
                value: function() {
                    this.uniforms.resolution.value.set(document.body.clientWidth, window.innerHeight)
                }
            }]) && r(t.prototype, o), a && r(t, a), e
        }()
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nvarying vec2 vUv;\n\nvoid main(void) {\n  vUv = uv;\n  gl_Position = vec4(position, 1.0);\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "precision highp float;\n#define GLSLIFY 1\n\nuniform vec2 resolution;\nuniform vec2 imageResolution;\nuniform sampler2D texture;\n\nvarying vec2 vUv;\n\nvoid main(void) {\n  vec2 ratio = vec2(\n      min((resolution.x / resolution.y) / (imageResolution.x / imageResolution.y), 1.0),\n      min((resolution.y / resolution.x) / (imageResolution.y / imageResolution.x), 1.0)\n    );\n\n  vec2 uv = vec2(\n      vUv.x * ratio.x + (1.0 - ratio.x) * 0.5,\n      vUv.y * ratio.y + (1.0 - ratio.y) * 0.5\n    );\n  gl_FragColor = texture2D(texture, uv);\n}\n"
}, function(e, t, n) {
    "use strict";

    function r(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }
    n.r(t), n.d(t, "default", (function() {
        return o
    }));
    var i = n(0),
        o = function() {
            function e(t) {
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, e), this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    },
                    resolution: {
                        type: "v2",
                        value: new i.Vector2(document.body.clientWidth, window.innerHeight)
                    },
                    texture: {
                        type: "t",
                        value: t
                    }
                }, this.obj = this.createObj()
            }
            var t, o, a;
            return t = e, (o = [{
                key: "createObj",
                value: function() {
                    return new i.Mesh(new i.PlaneBufferGeometry(2, 2), new i.RawShaderMaterial({
                        uniforms: this.uniforms,
                        vertexShader: n(564).default,
                        fragmentShader: n(565).default
                    }))
                }
            }, {
                key: "render",
                value: function(e) {
                    this.uniforms.time.value += e
                }
            }, {
                key: "resize",
                value: function() {
                    this.uniforms.resolution.value.set(document.body.clientWidth, window.innerHeight)
                }
            }]) && r(t.prototype, o), a && r(t, a), e
        }()
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  gl_Position = vec4(position, 1.0);\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\nuniform vec2 resolution;\nuniform sampler2D texture;\n\nvarying vec2 vUv;\n\nfloat random(vec2 c){\n  return fract(sin(dot(c.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g_0 = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g_0;\n  vec3 i1 = min( g_0.xyz, l.zxy );\n  vec3 i2 = max( g_0.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\nconst float interval = 3.0;\n\nvoid main(void){\n  float strength = smoothstep(interval * 0.5, interval, interval - mod(time, interval));\n  vec2 shake = vec2(strength * 8.0 + 0.5) * vec2(\n    random(vec2(time)) * 2.0 - 1.0,\n    random(vec2(time * 2.0)) * 2.0 - 1.0\n  ) / resolution;\n\n  float y = vUv.y * resolution.y;\n  float rgbWave = (\n      snoise(vec3(0.0, y * 0.01, time * 400.0)) * (2.0 + strength * 32.0)\n      * snoise(vec3(0.0, y * 0.02, time * 200.0)) * (1.0 + strength * 4.0)\n      + step(0.9995, sin(y * 0.005 + time * 1.6)) * 12.0\n      + step(0.9999, sin(y * 0.005 + time * 2.0)) * -18.0\n    ) / resolution.x;\n  float rgbDiff = (6.0 + sin(time * 500.0 + vUv.y * 40.0) * (20.0 * strength + 1.0)) / resolution.x;\n  float rgbUvX = vUv.x + rgbWave;\n  float r = texture2D(texture, vec2(rgbUvX + rgbDiff, vUv.y) + shake).r;\n  float g = texture2D(texture, vec2(rgbUvX, vUv.y) + shake).g;\n  float b = texture2D(texture, vec2(rgbUvX - rgbDiff, vUv.y) + shake).b;\n\n  float whiteNoise = (random(vUv + mod(time, 10.0)) * 2.0 - 1.0) * (0.15 + strength * 0.15);\n\n  float bnTime = floor(time * 20.0) * 200.0;\n  float noiseX = step((snoise(vec3(0.0, vUv.x * 3.0, bnTime)) + 1.0) / 2.0, 0.12 + strength * 0.3);\n  float noiseY = step((snoise(vec3(0.0, vUv.y * 3.0, bnTime)) + 1.0) / 2.0, 0.12 + strength * 0.3);\n  float bnMask = noiseX * noiseY;\n  float bnUvX = vUv.x + sin(bnTime) * 0.2 + rgbWave;\n  float bnR = texture2D(texture, vec2(bnUvX + rgbDiff, vUv.y)).r * bnMask;\n  float bnG = texture2D(texture, vec2(bnUvX, vUv.y)).g * bnMask;\n  float bnB = texture2D(texture, vec2(bnUvX - rgbDiff, vUv.y)).b * bnMask;\n  vec4 blockNoise = vec4(bnR, bnG, bnB, 1.0);\n\n  float bnTime2 = floor(time * 25.0) * 300.0;\n  float noiseX2 = step((snoise(vec3(0.0, vUv.x * 2.0, bnTime2)) + 1.0) / 2.0, 0.12 + strength * 0.5);\n  float noiseY2 = step((snoise(vec3(0.0, vUv.y * 8.0, bnTime2)) + 1.0) / 2.0, 0.12 + strength * 0.3);\n  float bnMask2 = noiseX2 * noiseY2;\n  float bnR2 = texture2D(texture, vec2(bnUvX + rgbDiff, vUv.y)).r * bnMask2;\n  float bnG2 = texture2D(texture, vec2(bnUvX, vUv.y)).g * bnMask2;\n  float bnB2 = texture2D(texture, vec2(bnUvX - rgbDiff, vUv.y)).b * bnMask2;\n  vec4 blockNoise2 = vec4(bnR2, bnG2, bnB2, 1.0);\n\n  float waveNoise = (sin(vUv.y * 1200.0) + 1.0) / 2.0 * (0.15 + strength * 0.2);\n\n  gl_FragColor = vec4(r, g, b, 1.0) * (1.0 - bnMask - bnMask2) + (whiteNoise + blockNoise + blockNoise2 - waveNoise);\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t);
    var r = n(0),
        i = n(3),
        o = n(15).default,
        a = n(107).default,
        s = n(567).default,
        c = n(568).default,
        u = n(571).default,
        l = n(574).default;
    t.default = function() {
        var e = document.getElementById("canvas-webgl"),
            t = new r.WebGLRenderer({
                antialias: !1,
                canvas: e,
                alpha: !0
            }),
            n = new r.WebGLRenderTarget(document.body.clientWidth, window.innerHeight),
            f = new r.Scene,
            d = new r.Scene,
            h = new r.OrthographicCamera(-1, 1, 1, -1, 0, 1),
            v = new a(45, document.body.clientWidth / window.innerHeight, 1, 1e5),
            p = new s(v),
            m = new r.Clock,
            y = new r.Vector2,
            g = new r.Vector2,
            x = new r.Vector2,
            b = !1,
            w = new r.CubeTextureLoader,
            M = new c,
            _ = new u,
            S = new l(n.texture),
            P = function() {
                e.width = document.body.clientWidth, e.height = window.innerHeight, v.aspect = document.body.clientWidth / window.innerHeight, v.updateProjectionMatrix(), S.resize(), t.setSize(document.body.clientWidth, window.innerHeight), n.setSize(document.body.clientWidth, window.innerHeight)
            },
            T = function e() {
                var r;
                r = m.getDelta(), p.render(), M.render(r), _.render(r), S.render(r), S.uniforms.strengthZoom.value = p.computeZoomLength(), S.uniforms.strengthGlitch.value = p.computeAcceleration(), t.setRenderTarget(n), t.render(d, v), t.setRenderTarget(null), t.render(f, h), requestAnimationFrame(e)
            },
            E = function(e) {
                b = !0
            },
            z = function(e) {
                b && p.rotate(y.x - g.x, y.y - g.y)
            },
            L = function(e) {
                b = !1, p.touchEnd()
            },
            A = function() {
                window.addEventListener("resize", i((function() {
                    P()
                })), 1e3), e.addEventListener("mousedown", (function(e) {
                    e.preventDefault(), y.set(e.clientX, e.clientY), o(y), E()
                })), document.addEventListener("mousemove", (function(e) {
                    e.preventDefault(), g.set(e.clientX, e.clientY), o(g), z()
                })), document.addEventListener("mouseup", (function(e) {
                    e.preventDefault(), x.set(e.clientX, e.clientY), o(x), L()
                })), e.addEventListener("wheel", (function(e) {
                    e.preventDefault(),
                        function(e) {
                            p.zoom(e.deltaY)
                        }(e)
                })), e.addEventListener("touchstart", (function(e) {
                    e.preventDefault(), y.set(e.touches[0].clientX, e.touches[0].clientY), o(y), E(e.touches[0].clientX, e.touches[0].clientY)
                })), e.addEventListener("touchmove", (function(e) {
                    e.preventDefault(), g.set(e.touches[0].clientX, e.touches[0].clientY), o(g), z()
                })), e.addEventListener("touchend", (function(e) {
                    e.preventDefault(), x.set(e.changedTouches[0].clientX, e.changedTouches[0].clientY), o(x), L()
                }))
            };
        t.setSize(document.body.clientWidth, window.innerHeight), t.setClearColor(15658734, 1), w.setPath("../img/sketch/instancing/").load(["cubemap_px.png", "cubemap_nx.png", "cubemap_py.png", "cubemap_ny.png", "cubemap_pz.png", "cubemap_nz.png"], (function(e) {
            M.init(e), _.init(e), f.add(S.obj), d.add(M.obj), d.add(_.obj)
        })), A(), P(), T()
    }
}, function(e, t, n) {
    "use strict";

    function r(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }
    n.r(t), n.d(t, "default", (function() {
        return a
    }));
    n(0);
    var i = n(75),
        o = n(1),
        a = function() {
            function e(t) {
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, e), this.camera = t, this.radian1 = 0, this.radian1Base = 0, this.radian2 = 0, this.radian2Base = 0, this.radius = 2500, this.isZoom = !1
            }
            var t, n, a;
            return t = e, (n = [{
                key: "rotate",
                value: function(e, t) {
                    !0 === this.isZoom && (this.isZoom = !1), this.radian1 = o.clamp(this.radian1Base + t, o.radians(-75), o.radians(75)), this.radian2 = this.radian2Base - 2 * e
                }
            }, {
                key: "zoom",
                value: function(e) {
                    if (e) {
                        !1 === this.isZoom && (this.isZoom = !0);
                        this.radius;
                        this.radius -= e / Math.abs(e) * 200, this.radius = o.clamp(this.radius, 700, 8e3), this.radius
                    }
                }
            }, {
                key: "touchEnd",
                value: function() {
                    this.radian1Base = this.radian1, this.radian2Base = this.radian2
                }
            }, {
                key: "render",
                value: function() {
                    this.camera.anchor = o.spherical(this.radian1, this.radian2, this.radius), this.camera.render()
                }
            }, {
                key: "computeZoomLength",
                value: function() {
                    return this.isZoom ? .05 * i.vec3.length(this.camera.acceleration) : 0
                }
            }, {
                key: "computeAcceleration",
                value: function() {
                    return .05 * i.vec3.length(this.camera.acceleration)
                }
            }]) && r(t.prototype, n), a && r(t, a), e
        }()
}, function(e, t, n) {
    "use strict";

    function r(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }
    n.r(t), n.d(t, "default", (function() {
        return a
    }));
    var i = n(0),
        o = n(1),
        a = function() {
            function e() {
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, e), this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    },
                    cubeTex: {
                        type: "t",
                        value: null
                    }
                }, this.instances = 1e3, this.obj
            }
            var t, a, s;
            return t = e, (a = [{
                key: "init",
                value: function(e) {
                    this.uniforms.cubeTex.value = e, this.obj = this.createObj()
                }
            }, {
                key: "createObj",
                value: function() {
                    var e = new i.InstancedBufferGeometry,
                        t = new i.BoxBufferGeometry(10, 10, 10);
                    e.copy(t);
                    for (var r = new i.InstancedBufferAttribute(new Float32Array(3 * this.instances), 3), a = new i.InstancedBufferAttribute(new Float32Array(this.instances), 1), s = new i.InstancedBufferAttribute(new Float32Array(3 * this.instances), 3), c = 0, u = a.count; c < u; c++) {
                        var l = o.spherical(2 * Math.random() * Math.PI, 2 * Math.random() * Math.PI, 3e3 * Math.random() + 100);
                        r.setXYZ(c, l[0], l[1], l[2]), a.setXYZ(c, 100 * Math.random()), s.setXYZ(c, Math.random() - .5, Math.random() - .5, Math.random() - .5)
                    }
                    return e.addAttribute("translate", r), e.addAttribute("offset", a), e.addAttribute("rotate", s), new i.Mesh(e, new i.RawShaderMaterial({
                        uniforms: this.uniforms,
                        vertexShader: n(569).default,
                        fragmentShader: n(570).default,
                        transparent: !0,
                        side: i.DoubleSide
                    }))
                }
            }, {
                key: "render",
                value: function(e) {
                    this.uniforms.time.value += e
                }
            }]) && r(t.prototype, a), s && r(t, s), e
        }()
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec3 translate;\nattribute float offset;\nattribute vec3 rotate;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 modelMatrix;\nuniform float time;\n\nvarying vec3 vPosition;\nvarying vec3 vNormal;\n\nmat4 calcTranslateMat4(vec3 v) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    v.x, v.y, v.z, 1.0\n  );\n}\n\nmat4 calcRotateMat4X(float radian) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, cos(radian), -sin(radian), 0.0,\n    0.0, sin(radian), cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4Y(float radian) {\n  return mat4(\n    cos(radian), 0.0, sin(radian), 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    -sin(radian), 0.0, cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4Z(float radian) {\n  return mat4(\n    cos(radian), -sin(radian), 0.0, 0.0,\n    sin(radian), cos(radian), 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4(vec3 radian) {\n  return calcRotateMat4X(radian.x) * calcRotateMat4Y(radian.y) * calcRotateMat4Z(radian.z);\n}\n\nvoid main(void) {\n  float radian = radians(time);\n  mat4 rotateWorld = calcRotateMat4(vec3(radian) * vec3(5.0, 20.0, 1.0) + rotate);\n  mat4 rotateSelf = calcRotateMat4(vec3(radian) * rotate * 100.0);\n  vec4 updatePosition =\n    rotateWorld\n    * calcTranslateMat4(translate)\n    * rotateSelf\n    * vec4(position + normalize(position) * offset, 1.0);\n  vPosition = (modelMatrix * updatePosition).xyz;\n  vNormal = (modelMatrix * rotateWorld * rotateSelf * vec4(normal, 0.0)).xyz;\n  gl_Position = projectionMatrix * modelViewMatrix * updatePosition;\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "precision highp float;\n#define GLSLIFY 1\n\nuniform vec3 cameraPosition;\nuniform float time;\nuniform samplerCube cubeTex;\n\nvarying vec3 vPosition;\nvarying vec3 vNormal;\n\nvoid main() {\n  vec3 ref = reflect(vPosition - cameraPosition, vNormal);\n  vec4 envColor = textureCube(cubeTex, ref);\n  gl_FragColor = envColor * vec4(0.8, 1.0, 0.95, 0.7);\n}\n"
}, function(e, t, n) {
    "use strict";

    function r(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }
    n.r(t), n.d(t, "default", (function() {
        return o
    }));
    var i = n(0),
        o = function() {
            function e() {
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, e), this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    },
                    cubeTex: {
                        type: "t",
                        value: null
                    }
                }, this.obj
            }
            var t, o, a;
            return t = e, (o = [{
                key: "init",
                value: function(e) {
                    this.uniforms.cubeTex.value = e, this.obj = this.createObj()
                }
            }, {
                key: "createObj",
                value: function() {
                    return new i.Mesh(new i.BoxBufferGeometry(3e4, 3e4, 3e4, 1, 1, 1), new i.RawShaderMaterial({
                        uniforms: this.uniforms,
                        vertexShader: n(572).default,
                        fragmentShader: n(573).default,
                        side: i.BackSide
                    }))
                }
            }, {
                key: "render",
                value: function(e) {
                    this.uniforms.time.value += e
                }
            }]) && r(t.prototype, o), a && r(t, a), e
        }()
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform float time;\n\nvarying vec3 vPosition;\n\nvoid main(void) {\n  vPosition = position;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "precision highp float;\n#define GLSLIFY 1\n\nuniform samplerCube cubeTex;\n\nvarying vec3 vPosition;\n\nvoid main() {\n  vec3 normal = normalize(vPosition);\n  vec4 color = textureCube(cubeTex, normal);\n  gl_FragColor = color;\n}\n"
}, function(e, t, n) {
    "use strict";

    function r(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }
    n.r(t), n.d(t, "default", (function() {
        return o
    }));
    var i = n(0),
        o = function() {
            function e(t) {
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, e), this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    },
                    resolution: {
                        type: "v2",
                        value: new i.Vector2(document.body.clientWidth, window.innerHeight)
                    },
                    texture: {
                        type: "t",
                        value: t
                    },
                    strengthZoom: {
                        type: "f",
                        value: 0
                    },
                    strengthGlitch: {
                        type: "f",
                        value: 0
                    }
                }, this.obj = this.createObj()
            }
            var t, o, a;
            return t = e, (o = [{
                key: "createObj",
                value: function() {
                    return new i.Mesh(new i.PlaneBufferGeometry(2, 2), new i.RawShaderMaterial({
                        uniforms: this.uniforms,
                        vertexShader: n(575).default,
                        fragmentShader: n(576).default
                    }))
                }
            }, {
                key: "render",
                value: function(e) {
                    this.uniforms.time.value += e
                }
            }, {
                key: "resize",
                value: function() {
                    this.uniforms.resolution.value.set(document.body.clientWidth, window.innerHeight)
                }
            }]) && r(t.prototype, o), a && r(t, a), e
        }()
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  gl_Position = vec4(position, 1.0);\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\nuniform vec2 resolution;\nuniform sampler2D texture;\nuniform float strengthZoom;\nuniform float strengthGlitch;\n\nvarying vec2 vUv;\n\nfloat random(vec2 c){\n  return fract(sin(dot(c.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\nvoid main(void){\n  // zoom blur\n  vec2 tFrag = 1.0 / resolution;\n  float nFrag = 1.0 / 30.0;\n  vec2 centerOffset = resolution / 2.0;\n  vec3 destColor = vec3(0.0);\n  vec2 fcc = gl_FragCoord.xy - centerOffset;\n  float totalWeight = 0.0;\n\n  for(float i = 0.0; i <= 30.0; i++){\n    float percent = (i + random(gl_FragCoord.xy)) * nFrag;\n    float weight = percent - percent * percent;\n    vec2  t = gl_FragCoord.xy - fcc * percent * strengthZoom * nFrag;\n    destColor += texture2D(texture, t * tFrag).rgb * weight;\n    totalWeight += weight;\n  }\n  vec4 zoomColor = vec4(destColor / totalWeight, 1.0);\n\n  // glitch\n  float strengthWhiteNoise = min(strengthGlitch * 0.05, 0.1);\n  float whiteNoise = (random(gl_FragCoord.xy + time) * 2.0 - 1.0) * (0.05 + strengthWhiteNoise);\n\n  float strengthBlockNoise = min(strengthGlitch * 0.15, 1.2);\n  float noiseX = step((snoise(vec3(0.0, gl_FragCoord.x / resolution.x * 1.0, time * 600.0)) + 1.0) / 2.0, strengthBlockNoise * 0.6);\n  float noiseY = step((snoise(vec3(0.0, gl_FragCoord.y / resolution.y * 3.0, time * 200.0)) + 1.0) / 2.0, strengthBlockNoise * 0.3);\n  float blockNoiseMask = noiseX * noiseY;\n  vec4 blockNoise = texture2D(texture, 1.0 - vUv) * blockNoiseMask;\n\n  gl_FragColor = zoomColor + whiteNoise + blockNoise;\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t);
    var r = n(0),
        i = n(3),
        o = n(15).default,
        a = n(578).default,
        s = n(580).default,
        c = n(582).default,
        u = n(584).default;
    t.default = function() {
        var e = document.getElementById("canvas-webgl"),
            t = new r.WebGLRenderer({
                antialias: !1,
                canvas: e
            }),
            n = new r.WebGLRenderTarget(document.body.clientWidth, window.innerHeight),
            l = new r.WebGLRenderTarget(document.body.clientWidth, window.innerHeight),
            f = new r.WebGLRenderTarget(document.body.clientWidth, window.innerHeight),
            d = new r.Scene,
            h = new r.Scene,
            v = new r.OrthographicCamera(-1, 1, 1, -1, 0, 1),
            p = new r.PerspectiveCamera(45, document.body.clientWidth / window.innerHeight, 1, 1e4),
            m = new r.Clock,
            y = new r.Vector2,
            g = new r.Vector2,
            x = new r.Vector2,
            b = !1,
            w = new u,
            M = new a(n.texture),
            _ = new s(l.texture, 1, 0),
            S = new s(f.texture, 0, 1),
            P = new c(n.texture, l.texture);
        w.init(t);
        var T = function() {
                e.width = document.body.clientWidth, e.height = window.innerHeight, p.aspect = document.body.clientWidth / window.innerHeight, p.updateProjectionMatrix(), _.resize(), S.resize(), n.setSize(document.body.clientWidth, window.innerHeight), l.setSize(document.body.clientWidth, window.innerHeight), f.setSize(document.body.clientWidth, window.innerHeight), t.setSize(document.body.clientWidth, window.innerHeight)
            },
            E = function e() {
                var r;
                r = m.getDelta(), w.render(t, r), t.setRenderTarget(n), t.render(h, p), d.add(M.obj), t.setRenderTarget(l), t.render(d, p), d.remove(M.obj), d.add(_.obj), t.setRenderTarget(f), t.render(d, p), d.remove(_.obj), d.add(S.obj), t.setRenderTarget(l), t.render(d, p), d.remove(S.obj), d.add(P.obj), t.setRenderTarget(null), t.render(d, v), d.remove(P.obj), requestAnimationFrame(e)
            },
            z = function(e) {
                b = !0, w.touchStart(y)
            },
            L = function(e) {
                b && w.touchMove(g)
            },
            A = function(e) {
                b = !1, w.touchEnd()
            },
            C = function() {
                window.addEventListener("resize", i((function() {
                    T()
                })), 1e3), e.addEventListener("mousedown", (function(e) {
                    e.preventDefault(), y.set(e.clientX, e.clientY), o(y), z()
                })), e.addEventListener("mousemove", (function(e) {
                    e.preventDefault(), g.set(e.clientX, e.clientY), o(g), L()
                })), e.addEventListener("mouseup", (function(e) {
                    e.preventDefault(), x.set(e.clientX, e.clientY), o(x), A()
                })), e.addEventListener("touchstart", (function(e) {
                    e.preventDefault(), y.set(e.touches[0].clientX, e.touches[0].clientY), o(y), z(e.touches[0].clientX, e.touches[0].clientY)
                })), e.addEventListener("touchmove", (function(e) {
                    e.preventDefault(), g.set(e.touches[0].clientX, e.touches[0].clientY), o(g), L()
                })), e.addEventListener("touchend", (function(e) {
                    e.preventDefault(), o(x), x.set(e.changedTouches[0].clientX, e.changedTouches[0].clientY), A()
                })), window.addEventListener("mouseout", (function() {
                    event.preventDefault(), x.set(0, 0), b = !1, w.touchEnd()
                }))
            };
        t.setSize(document.body.clientWidth, window.innerHeight), t.setClearColor(1118481, 1), p.position.set(0, 0, 1e3), p.lookAt(new r.Vector3), h.add(w.obj), C(), T(), E()
    }
}, function(e, t, n) {
    "use strict";

    function r(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }
    n.r(t), n.d(t, "default", (function() {
        return o
    }));
    var i = n(0),
        o = function() {
            function e(t) {
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, e), this.uniforms = {
                    minBright: {
                        type: "f",
                        value: .3
                    },
                    texture: {
                        type: "t",
                        value: t
                    }
                }, this.obj = this.createObj()
            }
            var t, o, a;
            return t = e, (o = [{
                key: "createObj",
                value: function() {
                    return new i.Mesh(new i.PlaneBufferGeometry(2, 2), new i.RawShaderMaterial({
                        uniforms: this.uniforms,
                        vertexShader: n(110).default,
                        fragmentShader: n(579).default
                    }))
                }
            }]) && r(t.prototype, o), a && r(t, a), e
        }()
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "precision highp float;\n#define GLSLIFY 1\n\nuniform float minBright;\nuniform sampler2D texture;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vec4 bright = max(vec4(0.0), (texture2D(texture, vUv) - minBright));\n  gl_FragColor = bright;\n}\n"
}, function(e, t, n) {
    "use strict";

    function r(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }
    n.r(t), n.d(t, "default", (function() {
        return o
    }));
    var i = n(0),
        o = function() {
            function e(t, n, r) {
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, e), this.uniforms = {
                    resolution: {
                        type: "v2",
                        value: new i.Vector2(document.body.clientWidth, window.innerHeight)
                    },
                    direction: {
                        type: "v2",
                        value: new i.Vector2(n, r)
                    },
                    texture: {
                        type: "t",
                        value: t
                    }
                }, this.obj = this.createObj()
            }
            var t, o, a;
            return t = e, (o = [{
                key: "createObj",
                value: function() {
                    return new i.Mesh(new i.PlaneBufferGeometry(2, 2), new i.RawShaderMaterial({
                        uniforms: this.uniforms,
                        vertexShader: n(110).default,
                        fragmentShader: n(581).default
                    }))
                }
            }, {
                key: "resize",
                value: function() {
                    this.uniforms.resolution.value.set(document.body.clientWidth, window.innerHeight)
                }
            }]) && r(t.prototype, o), a && r(t, a), e
        }()
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "precision highp float;\n#define GLSLIFY 1\n\nuniform vec2 resolution;\nuniform vec2 direction;\nuniform sampler2D texture;\n\nvarying vec2 vUv;\n\nvec4 gaussianBlur(sampler2D texture, vec2 uv, float radius, vec2 resolution, vec2 direction) {\n  vec4 color = vec4(0.0);\n  vec2 step = radius / resolution * direction;\n  color += texture2D(texture, uv - 4.0 * step) * 0.02699548325659403;\n  color += texture2D(texture, uv - 3.0 * step) * 0.06475879783294587;\n  color += texture2D(texture, uv - 2.0 * step) * 0.12098536225957168;\n  color += texture2D(texture, uv - 1.0 * step) * 0.17603266338214976;\n  color += texture2D(texture, uv) * 0.19947114020071635;\n  color += texture2D(texture, uv + 1.0 * step) * 0.17603266338214976;\n  color += texture2D(texture, uv + 2.0 * step) * 0.12098536225957168;\n  color += texture2D(texture, uv + 3.0 * step) * 0.06475879783294587;\n  color += texture2D(texture, uv + 4.0 * step) * 0.02699548325659403;\n  return color;\n}\n\nvoid main() {\n  vec4 color = gaussianBlur(texture, vUv, 1.0, resolution, direction);\n  gl_FragColor = color;\n}\n"
}, function(e, t, n) {
    "use strict";

    function r(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }
    n.r(t), n.d(t, "default", (function() {
        return o
    }));
    var i = n(0),
        o = function() {
            function e(t, n) {
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, e), this.uniforms = {
                    texture1: {
                        type: "t",
                        value: t
                    },
                    texture2: {
                        type: "t",
                        value: n
                    }
                }, this.obj = this.createObj()
            }
            var t, o, a;
            return t = e, (o = [{
                key: "createObj",
                value: function() {
                    return new i.Mesh(new i.PlaneBufferGeometry(2, 2), new i.RawShaderMaterial({
                        uniforms: this.uniforms,
                        vertexShader: n(110).default,
                        fragmentShader: n(583).default
                    }))
                }
            }]) && r(t.prototype, o), a && r(t, a), e
        }()
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "precision highp float;\n#define GLSLIFY 1\n\nuniform sampler2D texture1;\nuniform sampler2D texture2;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vec4 color1 = texture2D(texture1, vUv);\n  vec4 color2 = texture2D(texture2, vUv);\n  gl_FragColor = color1 * 0.6 + color2;\n}\n"
}, function(e, t, n) {
    "use strict";

    function r(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }
    n.r(t), n.d(t, "default", (function() {
        return a
    }));
    var i = n(0),
        o = n(150).default,
        a = function() {
            function e() {
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, e), this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    },
                    velocity: {
                        type: "t",
                        value: null
                    },
                    acceleration: {
                        type: "t",
                        value: null
                    }
                }, this.physicsRenderer = null, this.vectorTouchMove = new i.Vector2(0, 0), this.vectorTouchMoveDiff = new i.Vector2(0, 0), this.obj
            }
            var t, a, s;
            return t = e, (a = [{
                key: "init",
                value: function(e) {
                    this.obj = this.createObj(e)
                }
            }, {
                key: "createObj",
                value: function(e) {
                    for (var t = window.innerWidth > 768 ? 8 : 6, r = new i.OctahedronBufferGeometry(100, t), a = r.attributes.position.array, s = [], c = 0; c < a.length; c += 3) s[c + 0] = a[c + 0] + 10 * (2 * Math.random() - 1), s[c + 1] = a[c + 1] + 10 * (2 * Math.random() - 1), s[c + 2] = a[c + 2] + 10 * (2 * Math.random() - 1);
                    return this.physicsRenderer = new o(n(587).default, n(588).default, n(589).default, n(590).default), this.physicsRenderer.init(e, s), this.physicsRenderer.mergeAUniforms({
                        vTouchMove: {
                            type: "v2",
                            value: this.vectorTouchMoveDiff
                        }
                    }), this.uniforms.velocity.value = this.physicsRenderer.getCurrentVelocity(), this.uniforms.acceleration.value = this.physicsRenderer.getCurrentAcceleration(), r.addAttribute("uvVelocity", this.physicsRenderer.getBufferAttributeUv()), new i.Points(r, new i.RawShaderMaterial({
                        uniforms: this.uniforms,
                        vertexShader: n(591).default,
                        fragmentShader: n(592).default,
                        transparent: !0,
                        depthWrite: !1,
                        blending: i.AdditiveBlending
                    }))
                }
            }, {
                key: "render",
                value: function(e, t) {
                    this.physicsRenderer.render(e, t), this.uniforms.time.value += t
                }
            }, {
                key: "touchStart",
                value: function(e) {
                    this.vectorTouchMove.copy(e)
                }
            }, {
                key: "touchMove",
                value: function(e) {
                    this.vectorTouchMoveDiff.set(e.x - this.vectorTouchMove.x, e.y - this.vectorTouchMove.y), this.vectorTouchMove.copy(e)
                }
            }, {
                key: "touchEnd",
                value: function() {
                    this.vectorTouchMove.set(0, 0), this.vectorTouchMoveDiff.set(0, 0)
                }
            }, {
                key: "resize",
                value: function() {
                    this.physicsRenderer && this.physicsRenderer.resize()
                }
            }]) && r(t.prototype, a), s && r(t, s), e
        }()
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nvarying vec2 vUv;\n\nvoid main(void) {\n  vUv = uv;\n  gl_Position = vec4(position, 1.0);\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nuniform sampler2D velocity;\n\nvarying vec2 vUv;\n\nvoid main(void) {\n  gl_FragColor = texture2D(velocity, vUv);\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nvarying vec2 vUv;\n\nvoid main(void) {\n  vUv = uv;\n  gl_Position = vec4(position, 1.0);\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = '#define GLSLIFY 1\nuniform vec2 resolution;\nuniform sampler2D velocity;\nuniform sampler2D acceleration;\nuniform float time;\nuniform vec2 vTouchMove;\n\nvarying vec2 vUv;\n\n//\n// GLSL textureless classic 3D noise "cnoise",\n// with an RSL-style periodic variant "pnoise".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-10-11\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec3 fade(vec3 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise(vec3 P)\n{\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod289(Pi0);\n  Pi1 = mod289(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n  return 2.2 * n_xyz;\n}\n\n#ifndef PRECISION\n#define PRECISION 0.000001\n#endif\n\nvec3 drag(vec3 a, float value) {\n  return normalize(a * -1.0 + PRECISION) * length(a) * value;\n}\n\nvoid main(void) {\n  vec3 v = texture2D(velocity, vUv).xyz;\n  vec3 a = texture2D(acceleration, vUv).xyz;\n  float noise = sqrt(length(v)) * 10.0;\n  vec3 d = drag(a, 0.028);\n  float fx = cnoise(vec3(time * 0.1, v.y / noise, v.z / noise));\n  float fy = cnoise(vec3(v.x / noise, time * 0.1, v.z / noise));\n  float fz = cnoise(vec3(v.x / noise, v.y / noise, time * 0.1));\n  vec3 f1 = vec3(fx, fy, fz) * 0.24;\n  vec3 f2 = vec3(vTouchMove * 16.0 * (resolution / 640.0), 0.0);\n  vec3 f3 = a + f1 + f2 + d;\n  float vStep = 1.0 - step(1000.0, length(v + f3));\n  gl_FragColor = vec4(f3 * vStep, 1.0);\n}\n'
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nvarying vec2 vUv;\n\nvoid main(void) {\n  vUv = uv;\n  gl_Position = vec4(position, 1.0);\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nuniform sampler2D velocity;\nuniform sampler2D acceleration;\nuniform float time;\n\nvarying vec2 vUv;\n\nvec3 spherical(float radian1, float radian2, float radius) {\n  return vec3(\n    cos(radian1) * cos(radian2) * radius,\n    sin(radian1) * radius,\n    cos(radian1) * sin(radian2) * radius\n  );\n}\n\nconst float radius = 100.0;\n\nvoid main(void) {\n  vec3 a = texture2D(acceleration, vUv).xyz;\n  vec3 v = texture2D(velocity, vUv).xyz;\n  float vStep = step(0.000001, length(a));\n  gl_FragColor = vec4(\n    (a + v) * vStep + normalize(v + spherical(time, -time, 1.0)) * radius * (1.0 - vStep),\n    1.0\n  );\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uvVelocity;\n\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform float time;\nuniform sampler2D acceleration;\nuniform sampler2D velocity;\n\nvarying vec3 vAcceleration;\n\nvoid main() {\n  vec3 a = texture2D(acceleration, uvVelocity).xyz;\n  vec3 v = texture2D(velocity, uvVelocity).xyz;\n  vec4 mvPosition = modelViewMatrix * vec4(v, 1.0);\n  vAcceleration = a;\n  gl_PointSize = 500.0 / length(mvPosition.xyz);\n  gl_Position = projectionMatrix * mvPosition;\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\n\nvarying vec3 vAcceleration;\n\nvec3 convertHsvToRgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  float start = smoothstep(time, 0.0, 1.0);\n  vec3 n;\n  n.xy = gl_PointCoord * 2.0 - 1.0;\n  n.z = 1.0 - dot(n.xy, n.xy);\n  if (n.z < 0.0) discard;\n  float aLength = length(vAcceleration);\n  vec3 color = convertHsvToRgb(vec3(aLength * 0.08 + time * 0.05, 0.5, 0.8));\n  gl_FragColor = vec4(color, 0.15 * start);\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t);
    var r = n(0),
        i = n(3),
        o = n(15).default,
        a = n(150).default;
    t.default = function() {
        var e = n(16),
            t = n(33),
            s = document.getElementById("canvas-webgl"),
            c = new r.WebGLRenderer({
                antialias: !0,
                canvas: s
            }),
            u = new r.Scene,
            l = new t(35, window.innerWidth / window.innerHeight, 1, 1e4),
            f = (new r.Clock, null),
            d = function() {
                for (var t = new r.BufferGeometry, i = [], o = [], a = [], s = [], c = 0; c < Math.pow(1e3, 2); c++) i.push(0, 0, 0), o.push(c % 1e3 * (1 / 999), Math.floor(c / 1e3) * (1 / 999)), a.push(e.getRandomInt(0, 120) / 360, .8, 1), s.push(e.getRandomInt(1, 100));
                var u = new Float32Array(i);
                t.addAttribute("position", new r.BufferAttribute(u, 3));
                var l = new Float32Array(o);
                t.addAttribute("uv2", new r.BufferAttribute(l, 2));
                var f = new Float32Array(a);
                t.addAttribute("color", new r.BufferAttribute(f, 3));
                var d = new Float32Array(s);
                t.addAttribute("mass", new r.BufferAttribute(d, 1));
                var h = new r.ShaderMaterial({
                    uniforms: {
                        time: {
                            type: "f",
                            value: 0
                        },
                        velocity: {
                            type: "t",
                            value: new r.Texture
                        },
                        acceleration: {
                            type: "t",
                            value: new r.Texture
                        }
                    },
                    vertexShader: n(594).default,
                    fragmentShader: n(595).default,
                    transparent: !0,
                    depthWrite: !1,
                    blending: r.AdditiveBlending
                });
                return new r.Points(t, h)
            }(),
            h = function() {
                (f = new a(n(596).default, n(597).default, n(598).default, n(599).default)).init(c, function() {
                    for (var t = [], n = 0; n < Math.pow(1e3, 2); n++) {
                        var r = e.getPolarCoord(e.getRadian(e.getRandomInt(0, 360)), e.getRadian(e.getRandomInt(0, 360)), e.getRandomInt(10, 1e3));
                        t.push(r.x, r.y / 10, r.z)
                    }
                    return t
                }()), f.accelerationMesh.material.uniforms.anchor = {
                    type: "v2",
                    value: new r.Vector2
                }, u.add(d), l.force.position.anchor.set(0, 15, 600), l.force.look.anchor.set(0, 0, 0)
            },
            v = function() {
                s.width = window.innerWidth, s.height = window.innerHeight, l.aspect = window.innerWidth / window.innerHeight, l.updateProjectionMatrix(), c.setSize(window.innerWidth, window.innerHeight)
            },
            p = function e() {
                f.render(c), d.material.uniforms.time.value++, d.material.uniforms.velocity.value = f.getCurrentVelocity(), d.material.uniforms.acceleration.value = f.getCurrentAcceleration(), l.force.position.applyHook(0, .025), l.force.position.applyDrag(.2), l.force.position.updateVelocity(), l.updatePosition(), l.force.look.applyHook(0, .2), l.force.look.applyDrag(.4), l.force.look.updateVelocity(), l.updateLook(), c.setRenderTarget(null), c.render(u, l), requestAnimationFrame(e)
            },
            m = function() {
                var e = new r.Vector2,
                    t = new r.Vector2,
                    n = new r.Vector2,
                    a = function(t, n, r) {
                        e.set(t, n), o(e)
                    },
                    c = function(e, n, r) {
                        t.set(e, n), o(t), f.accelerationMesh.material.uniforms.anchor.value.copy(t)
                    },
                    u = function(e, t, r) {
                        n.set(e, t)
                    };
                window.addEventListener("resize", i((function() {
                    v()
                })), 1e3), s.addEventListener("mousedown", (function(e) {
                    e.preventDefault(), a(e.clientX, e.clientY)
                })), s.addEventListener("mousemove", (function(e) {
                    e.preventDefault(), c(e.clientX, e.clientY)
                })), s.addEventListener("mouseup", (function(e) {
                    e.preventDefault(), u(e.clientX, e.clientY)
                })), s.addEventListener("touchstart", (function(e) {
                    e.preventDefault(), a(e.touches[0].clientX, e.touches[0].clientY)
                })), s.addEventListener("touchmove", (function(e) {
                    e.preventDefault(), c(e.touches[0].clientX, e.touches[0].clientY)
                })), s.addEventListener("touchend", (function(e) {
                    e.preventDefault(), u(e.changedTouches[0].clientX, e.changedTouches[0].clientY)
                })), window.addEventListener("mouseout", (function() {
                    event.preventDefault(), n.set(0, 0), f.accelerationMesh.material.uniforms.anchor.value.set(0, 0, 0)
                }))
            };
        c.setSize(window.innerWidth, window.innerHeight), c.setClearColor(1118481, 1), l.position.set(1e3, 1e3, 1e3), l.lookAt(new r.Vector3), m(), h(), v(), p()
    }
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nattribute vec2 uv2;\nattribute vec3 color;\nattribute float mass;\n\nuniform sampler2D velocity;\nuniform sampler2D acceleration;\n\nvarying float vAcceleration;\nvarying vec3 vColor;\nvarying float vOpacity;\n\nvoid main(void) {\n  vec4 update_position = modelViewMatrix * texture2D(velocity, uv2);\n  vAcceleration = length(texture2D(acceleration, uv2).xyz) * mass;\n  vColor = color;\n  vOpacity = 0.6 * (300.0 / length(update_position.xyz));\n  gl_PointSize = 2.0 * (300.0 / length(update_position.xyz));\n  gl_Position = projectionMatrix * update_position;\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nvarying float vAcceleration;\nvarying vec3 vColor;\nvarying float vOpacity;\n\nuniform float time;\n\nvec3 hsv2rgb(vec3 c){\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main(void) {\n  vec3 n;\n  n.xy = gl_PointCoord * 2.0 - 1.0;\n  n.z = 1.0 - dot(n.xy, n.xy);\n  if (n.z < 0.0) discard;\n  gl_FragColor = vec4(hsv2rgb(vec3(vColor.x + time / 3600.0, vColor.y, vColor.z)), vOpacity);\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nvarying vec2 vUv;\n\nvoid main(void) {\n  vUv = uv;\n  gl_Position = vec4(position, 1.0);\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nuniform vec2 resolution;\nuniform sampler2D velocity;\nuniform sampler2D acceleration;\nuniform vec2 anchor;\n\nvarying vec2 vUv;\n\n#define PRECISION 0.000001\n\n#ifndef PRECISION\n#define PRECISION 0.000001\n#endif\n\nvec3 drag(vec3 a, float value) {\n  return normalize(a * -1.0 + PRECISION) * length(a) * value;\n}\n\nvoid main(void) {\n  vec3 v = texture2D(velocity, vUv).xyz;\n  vec3 a = texture2D(acceleration, vUv).xyz;\n  vec3 a2 = a + normalize(vec3(\n    anchor.x * resolution.x / 6.0 + PRECISION,\n    0.0,\n    anchor.y * resolution.y / -2.0 + PRECISION\n  ) - v) / 2.0;\n  vec3 a3 = a2 + drag(a2, 0.003);\n  gl_FragColor = vec4(a3, 1.0);\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nvarying vec2 vUv;\n\nvoid main(void) {\n  vUv = uv;\n  gl_Position = vec4(position, 1.0);\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nuniform float time;\nuniform sampler2D velocity;\nuniform sampler2D acceleration;\n\nvarying vec2 vUv;\n\nvoid main(void) {\n  gl_FragColor = vec4(texture2D(acceleration, vUv).xyz + texture2D(velocity, vUv).xyz, 1.0);\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t);
    var r = n(0),
        i = n(3),
        o = n(15).default;
    t.default = function() {
        var e = n(16),
            t = n(111),
            a = n(33),
            s = document.getElementById("canvas-webgl"),
            c = new r.WebGLRenderer({
                antialias: !0,
                canvas: s
            }),
            u = new r.Scene,
            l = new a(35, window.innerWidth / window.innerHeight, 1, 1e4),
            f = (new r.Clock, null),
            d = null,
            h = null,
            v = null,
            p = new r.DirectionalLight(16777215, 1),
            m = new r.Scene,
            y = new a(45, 1, 1, 1e4),
            g = new r.WebGLRenderTarget(1200, 1200),
            x = null,
            b = new r.Scene,
            w = new a(45, 1, 1, 1e4),
            M = new r.HemisphereLight(268435455, 13421772, 1),
            _ = new r.WebGLRenderTarget(1200, 1200),
            S = null,
            P = null,
            T = new t,
            E = function() {
                var t, i;
                T.anchor.set(1, 0), w.force.position.anchor.set(1e3, 300, 0), w.force.look.anchor.set(0, 0, 0), S = function() {
                    var e = new r.SphereGeometry(1e3, 128, 128),
                        t = new r.BufferGeometry;
                    t.fromGeometry(e);
                    var i = new r.ShaderMaterial({
                        uniforms: {
                            time: {
                                type: "f",
                                value: 0
                            }
                        },
                        vertexShader: n(609).default,
                        fragmentShader: n(610).default,
                        side: r.BackSide
                    });
                    return new r.Mesh(t, i)
                }(), P = function() {
                    for (var t = new r.BufferGeometry, i = [], o = 0; o < 2e3; o++) i.push(e.getRadian(e.getRandomInt(0, 120) + 120), e.getRadian(e.getRandomInt(0, 3600) / 10), e.getRandomInt(200, 1e3));
                    var a = new Float32Array(i);
                    t.addAttribute("position", new r.BufferAttribute(a, 3));
                    var s = new r.ShaderMaterial({
                        uniforms: {
                            time: {
                                type: "f",
                                value: 0
                            }
                        },
                        vertexShader: n(607).default,
                        fragmentShader: n(608).default
                    });
                    return new r.Points(t, s)
                }(), b.add(S), b.add(P), b.add(M), f = function() {
                    for (var t = new r.BufferGeometry, i = [], o = [], a = 0; a < 32; a++) {
                        i.push(0, 0, 0);
                        var s = e.getRadian(e.getRandomInt(0, 360)),
                            c = e.getRadian(e.getRandomInt(0, 360)),
                            u = e.getRadian(e.getRandomInt(0, 360));
                        o.push(s, c, u)
                    }
                    var l = new Float32Array(i);
                    t.addAttribute("position", new r.BufferAttribute(l, 3));
                    var f = new Float32Array(o);
                    t.addAttribute("radian", new r.BufferAttribute(f, 3));
                    var d = new r.ShaderMaterial({
                        uniforms: {
                            time: {
                                type: "f",
                                value: 0
                            },
                            resolution: {
                                type: "v2",
                                value: new r.Vector2(window.innerWidth, window.innerHeight)
                            },
                            size: {
                                type: "f",
                                value: 28
                            },
                            force: {
                                type: "v2",
                                value: T.velocity
                            }
                        },
                        vertexShader: n(601).default,
                        fragmentShader: n(602).default,
                        transparent: !0,
                        depthWrite: !1,
                        blending: r.AdditiveBlending
                    });
                    return new r.Points(t, d)
                }(), m.add(f), y.position.set(0, 0, 3e3), y.force.look.anchor.set(0, 0, 0), x = function() {
                    var e = new r.PlaneGeometry(1e3, 1e3),
                        t = new r.BufferGeometry;
                    t.fromGeometry(e);
                    var i = new r.ShaderMaterial({
                        uniforms: {
                            time: {
                                type: "f",
                                value: 0
                            },
                            resolution: {
                                type: "v2",
                                value: new r.Vector2(window.innerWidth, window.innerHeight)
                            },
                            texture: {
                                type: "t",
                                value: g.texture
                            },
                            texture2: {
                                type: "t",
                                value: _.texture
                            }
                        },
                        vertexShader: n(611).default,
                        fragmentShader: n(612).default,
                        transparent: !0
                    });
                    return new r.Mesh(t, i)
                }(), u.add(x), t = new r.SphereGeometry(1200, 64, 64), i = new r.ShaderMaterial({
                    uniforms: {
                        time: {
                            type: "f",
                            value: 0
                        }
                    },
                    vertexShader: n(605).default,
                    fragmentShader: n(606).default,
                    side: r.BackSide
                }), d = new r.Mesh(t, i), u.add(d), h = function() {
                    var e = new r.SphereGeometry(1100, 64, 64),
                        t = new r.MeshBasicMaterial({
                            color: 14540253,
                            wireframe: !0
                        });
                    return new r.Mesh(e, t)
                }(), u.add(h), v = function() {
                    for (var t = new r.SphereBufferGeometry(2, 4, 4), i = t.attributes, o = new r.BufferGeometry, a = [], s = [], c = [], u = [], l = [], f = function(n) {
                            for (y = e.getRandomInt(300, 1e3), h = e.getRadian(e.getRandomInt(0, 3600) / 10), v = e.getRandomInt(60, 120) / 100, p = 0; p < i.position.array.length; p += 3) a.push(i.position.array[p + 0], i.position.array[p + 1], i.position.array[p + 2]), s.push(y), c.push(h), u.push(v);
                            t.index.array.map((function(e) {
                                l.push(e + n * i.position.array.length / 3)
                            }))
                        }, d = 0; d < 16; d++) {
                        var h, v, p;
                        f(d)
                    }
                    var m = new Float32Array(a);
                    o.addAttribute("position", new r.BufferAttribute(m, 3));
                    var y = new Float32Array(s);
                    o.addAttribute("radius", new r.BufferAttribute(y, 1));
                    var g = new Float32Array(c);
                    o.addAttribute("radian", new r.BufferAttribute(g, 1));
                    var x = new Float32Array(u);
                    o.addAttribute("scale", new r.BufferAttribute(x, 1));
                    var b = new Uint32Array(l);
                    o.setIndex(new r.BufferAttribute(b, 1));
                    var w = new r.ShaderMaterial({
                        uniforms: r.UniformsUtils.merge([r.UniformsLib.lights, {
                            time: {
                                type: "f",
                                value: 0
                            }
                        }]),
                        vertexShader: n(603).default,
                        fragmentShader: n(604).default,
                        flatShading: !0,
                        lights: !0
                    });
                    return new r.Mesh(o, w)
                }(), u.add(v), p.position.set(0, 1, 0), u.add(p), l.force.position.anchor.set(1e3, 300, 0), l.force.look.anchor.set(0, 0, 0)
            },
            z = function() {
                s.width = window.innerWidth, s.height = window.innerHeight, l.aspect = window.innerWidth / window.innerHeight, l.updateProjectionMatrix(), c.setSize(window.innerWidth, window.innerHeight), f.material.uniforms.resolution.value.set(window.innerWidth, window.innerHeight), x.material.uniforms.resolution.value.set(window.innerWidth, window.innerHeight)
            },
            L = function e() {
                f.material.uniforms.time.value++, x.lookAt(l.position), x.material.uniforms.time.value++, S.material.uniforms.time.value++, P.material.uniforms.time.value++, h.rotation.y = f.material.uniforms.time.value / 1e3, v.material.uniforms.time.value++, T.applyHook(0, .12), T.applyDrag(.18), T.updateVelocity(), l.force.position.applyHook(0, .025), l.force.position.applyDrag(.2), l.force.position.updateVelocity(), l.updatePosition(), l.force.look.anchor.y = 100 * Math.sin(f.material.uniforms.time.value / 100), l.force.look.applyHook(0, .2), l.force.look.applyDrag(.4), l.updateLook(), w.force.position.applyHook(0, .1), w.force.position.applyDrag(.2), w.force.position.updateVelocity(), w.updatePosition(), w.force.look.applyHook(0, .2), w.force.look.applyDrag(.4), w.force.look.updateVelocity(), w.updateLook(), c.setRenderTarget(_), c.render(b, w), c.setRenderTarget(g), c.render(m, y), c.setRenderTarget(null), c.render(u, l), requestAnimationFrame(e)
            },
            A = function() {
                var e = new r.Vector2,
                    t = new r.Vector2,
                    n = new r.Vector2,
                    a = function(t, n, r) {
                        e.set(t, n), o(e), T.anchor.set(2, 30)
                    },
                    c = function(e, n, r) {
                        t.set(e, n), o(t)
                    },
                    u = function(e, t, r) {
                        n.set(e, t), T.anchor.set(1, 0)
                    };
                window.addEventListener("resize", i((function() {
                    z()
                })), 1e3), s.addEventListener("mousedown", (function(e) {
                    e.preventDefault(), a(e.clientX, e.clientY)
                })), s.addEventListener("mousemove", (function(e) {
                    e.preventDefault(), c(e.clientX, e.clientY)
                })), s.addEventListener("mouseup", (function(e) {
                    e.preventDefault(), u(e.clientX, e.clientY)
                })), s.addEventListener("touchstart", (function(e) {
                    e.preventDefault(), a(e.touches[0].clientX, e.touches[0].clientY)
                })), s.addEventListener("touchmove", (function(e) {
                    e.preventDefault(), c(e.touches[0].clientX, e.touches[0].clientY)
                })), s.addEventListener("touchend", (function(e) {
                    e.preventDefault(), u(e.changedTouches[0].clientX, e.changedTouches[0].clientY)
                })), window.addEventListener("mouseout", (function() {
                    event.preventDefault(), n.set(0, 0), T.anchor.set(1, 0)
                }))
            };
        c.setSize(window.innerWidth, window.innerHeight), c.setClearColor(15658734, 0), l.position.set(1e3, 1e3, 1e3), l.lookAt(new r.Vector3), A(), E(), z(), L()
    }
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nattribute vec3 radian;\n\nuniform float time;\nuniform vec2 resolution;\nuniform float size;\nuniform vec2 force;\n\nvoid main() {\n  float radius = 300.0;\n  float radian_base = radians(time * 2.0);\n  vec3 update_positon = position + vec3(\n    cos(radian_base + radian.x) * cos(radian_base + radian.y) * radius,\n    cos(radian_base + radian.x) * sin(radian_base + radian.y) * radius,\n    sin(radian_base + radian.x) * radius\n  ) * force.x;\n  vec4 mvPosition = modelViewMatrix * vec4(update_positon, 1.0);\n\n  gl_PointSize = (size + force.y) * (abs(sin(radian_base + radian.z))) * (size / length(mvPosition.xyz)) * 480.0;\n  gl_Position = projectionMatrix * mvPosition;\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nuniform float size;\n\nvoid main() {\n  vec3 n;\n  n.xy = gl_PointCoord.xy * 2.0 - 1.0;\n  n.z = 1.0 - dot(n.xy, n.xy);\n  if (n.z < 0.0) discard;\n  gl_FragColor = vec4(1.0);\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nattribute float radius;\nattribute float radian;\nattribute float scale;\n\nuniform float time;\n\nvarying vec3 vPosition;\nvarying mat4 vInvertMatrix;\n\nfloat inverse(float m) {\n  return 1.0 / m;\n}\n\nmat2 inverse(mat2 m) {\n  return mat2(m[1][1],-m[0][1],\n             -m[1][0], m[0][0]) / (m[0][0]*m[1][1] - m[0][1]*m[1][0]);\n}\n\nmat3 inverse(mat3 m) {\n  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2];\n  float a10 = m[1][0], a11 = m[1][1], a12 = m[1][2];\n  float a20 = m[2][0], a21 = m[2][1], a22 = m[2][2];\n\n  float b01 = a22 * a11 - a12 * a21;\n  float b11 = -a22 * a10 + a12 * a20;\n  float b21 = a21 * a10 - a11 * a20;\n\n  float det = a00 * b01 + a01 * b11 + a02 * b21;\n\n  return mat3(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11),\n              b11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10),\n              b21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)) / det;\n}\n\nmat4 inverse(mat4 m) {\n  float\n      a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\n      a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\n      a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\n      a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3],\n\n      b00 = a00 * a11 - a01 * a10,\n      b01 = a00 * a12 - a02 * a10,\n      b02 = a00 * a13 - a03 * a10,\n      b03 = a01 * a12 - a02 * a11,\n      b04 = a01 * a13 - a03 * a11,\n      b05 = a02 * a13 - a03 * a12,\n      b06 = a20 * a31 - a21 * a30,\n      b07 = a20 * a32 - a22 * a30,\n      b08 = a20 * a33 - a23 * a30,\n      b09 = a21 * a32 - a22 * a31,\n      b10 = a21 * a33 - a23 * a31,\n      b11 = a22 * a33 - a23 * a32,\n\n      det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  return mat4(\n      a11 * b11 - a12 * b10 + a13 * b09,\n      a02 * b10 - a01 * b11 - a03 * b09,\n      a31 * b05 - a32 * b04 + a33 * b03,\n      a22 * b04 - a21 * b05 - a23 * b03,\n      a12 * b08 - a10 * b11 - a13 * b07,\n      a00 * b11 - a02 * b08 + a03 * b07,\n      a32 * b02 - a30 * b05 - a33 * b01,\n      a20 * b05 - a22 * b02 + a23 * b01,\n      a10 * b10 - a11 * b08 + a13 * b06,\n      a01 * b08 - a00 * b10 - a03 * b06,\n      a30 * b04 - a31 * b02 + a33 * b00,\n      a21 * b02 - a20 * b04 - a23 * b00,\n      a11 * b07 - a10 * b09 - a12 * b06,\n      a00 * b09 - a01 * b07 + a02 * b06,\n      a31 * b01 - a30 * b03 - a32 * b00,\n      a20 * b03 - a21 * b01 + a22 * b00) / det;\n}\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\nmat4 translateMatrix(vec3 v) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    v.x, v.y, v.z, 1.0\n  );\n}\n\nmat4 rotationMatrixX(float radian) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, cos(radian), -sin(radian), 0.0,\n    0.0, sin(radian), cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 rotationMatrixY(float radian) {\n  return mat4(\n    cos(radian), 0.0, sin(radian), 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    -sin(radian), 0.0, cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 rotationMatrixZ(float radian) {\n  return mat4(\n    cos(radian), -sin(radian), 0.0, 0.0,\n    sin(radian), cos(radian), 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 rotationMatrix(float radian_x, float radian_y, float radian_z) {\n  return rotationMatrixX(radian_x) * rotationMatrixY(radian_y) * rotationMatrixZ(radian_z);\n}\n\nmat4 scaleMatrix(vec3 scale) {\n  return mat4(\n    scale.x, 0.0, 0.0, 0.0,\n    0.0, scale.y, 0.0, 0.0,\n    0.0, 0.0, scale.z, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nvec4 move(vec3 position) {\n  return translateMatrix(\n    vec3(\n      cos(radians(time * 0.5) + radian) * radius,\n      sin(radians(time * 0.5) + radian * 10.0) * radius * 0.3,\n      sin(radians(time * 0.5) + radian) * radius\n    )\n  ) * rotationMatrix(\n    radians(time * radian) + radian, radians(time) + radian, radians(time) + radian\n  ) * scaleMatrix(\n    vec3(20.0 * scale) + vec3(10.0) * snoise((position + sin(radian)))\n  ) * vec4(position, 1.0);\n}\n\nvoid main() {\n  vec4 update_position = move(position);\n  vPosition = position;\n  vInvertMatrix = inverse(rotationMatrix(\n    radians(time * radian) + radian, radians(time) + radian, radians(time) + radian\n  ));\n  gl_Position = projectionMatrix * modelViewMatrix * update_position;\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nstruct DirectionalLight {\n  vec3 color;\n  vec3 direction;\n};\nuniform DirectionalLight directionalLights[1];\n\nvarying vec3 vPosition;\nvarying mat4 vInvertMatrix;\n\nvoid main() {\n  vec3 normal = normalize(cross(dFdx(vPosition), dFdy(vPosition)));\n  vec3 inv_light = normalize(vInvertMatrix * vec4(directionalLights[0].direction, 1.0)).xyz;\n  float diff = (dot(normal, inv_light) + 1.0) / 2.0 * 0.25 + 0.75;\n  gl_FragColor = vec4(vec3(1.0) * diff, 1.0);\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nuniform float time;\n\nvarying vec3 vColor;\n\nvoid main() {\n  vColor = vec3((position.y / 1000.0 + 1.0) * 0.12 + 0.88);\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nvarying vec3 vColor;\n\nvoid main() {\n  gl_FragColor = vec4(vColor, 1.0);\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nuniform float time;\n\nvec3 getPolarCoord(float rad1, float rad2, float r) {\n  return vec3(\n    cos(rad1) * cos(rad2) * r,\n    sin(rad1) * r,\n    cos(rad1) * sin(rad2) * r\n  );\n}\n\nvoid main() {\n  vec3 update_position = getPolarCoord(\n    position.x,\n    position.y + radians(time / 2.0),\n    position.z + sin(radians(time * 2.0) + position.x + position.y) * position.z / 4.0\n  );\n  vec4 mv_position = modelViewMatrix * vec4(update_position, 1.0);\n\n  gl_PointSize = 2.0 * (1000.0 / length(mv_position.xyz));\n  gl_Position = projectionMatrix * mv_position;\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nvoid main() {\n  vec3 n;\n  n.xy = gl_PointCoord.xy * 2.0 - 1.0;\n  n.z = 1.0 - dot(n.xy, n.xy);\n  if (n.z < 0.0) discard;\n  gl_FragColor = vec4(1.0);\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nuniform float time;\n\nvarying vec3 vColor;\n\nvec3 hsv2rgb(vec3 c){\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\nvoid main() {\n  float noise = snoise(\n    vec3(position.x + time * 10.0, position.y + cos(time / 20.0) * 100.0, position.z + time * 10.0) / 800.0\n  );\n  vColor = hsv2rgb(vec3(noise * 0.2 + 0.75, 0.4, noise * 0.3 + 0.5));\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nvarying vec3 vColor;\n\nvoid main() {\n  gl_FragColor = vec4(vColor, 1.0);\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nvarying vec2 vUv;\n\nvoid main(void) {\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nuniform float time;\nuniform vec2 resolution;\nuniform sampler2D texture;\nuniform sampler2D texture2;\n\nconst float blur = 20.0;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vec4 color = vec4(0.0);\n  for (float x = 0.0; x < blur; x++){\n    for (float y = 0.0; y < blur; y++){\n      color += texture2D(texture, vUv - (vec2(x, y) - vec2(blur / 2.0)) / resolution);\n    }\n  }\n  vec4 color2 = color / pow(blur, 2.0);\n  vec4 color3 = texture2D(texture2, vUv);\n  gl_FragColor = vec4(color3.rgb, floor(length(color2.rgb)));\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t);
    var r = n(0),
        i = n(3),
        o = n(15).default;
    t.default = function() {
        var e = n(16),
            t = n(46),
            a = n(33),
            s = document.getElementById("canvas-webgl"),
            c = new r.WebGLRenderer({
                antialias: !0,
                canvas: s
            }),
            u = new r.Scene,
            l = new a(35, window.innerWidth / window.innerHeight, 1, 1e4),
            f = (new r.Clock, new r.Raycaster),
            d = null,
            h = new t,
            v = new t,
            p = null;
        h.mass = 1.4;
        var m, y, g, x = (m = new r.PlaneBufferGeometry(6, 6), y = new r.ShaderMaterial({
                uniforms: {
                    time: {
                        type: "f",
                        value: 0
                    },
                    time2: {
                        type: "f",
                        value: 0
                    },
                    acceleration: {
                        type: "f",
                        value: 0
                    },
                    resolution: {
                        type: "v2",
                        value: new r.Vector2(window.innerWidth, window.innerHeight)
                    }
                },
                vertexShader: n(614).default,
                fragmentShader: n(615).default,
                transparent: !0
            }), (g = new r.Mesh(m, y)).name = "MetalCube", g),
            b = function() {
                var e = new r.OctahedronGeometry(30, 4),
                    t = new r.BufferGeometry;
                t.fromGeometry(e);
                var i = new r.ShaderMaterial({
                        uniforms: {
                            time: {
                                type: "f",
                                value: 0
                            },
                            acceleration: {
                                type: "f",
                                value: 0
                            }
                        },
                        vertexShader: n(616).default,
                        fragmentShader: n(617).default,
                        flatShading: !0,
                        side: r.BackSide
                    }),
                    o = new r.Mesh(t, i);
                return o.name = "Background", o
            }(),
            w = function() {
                s.width = window.innerWidth, s.height = window.innerHeight, l.aspect = window.innerWidth / window.innerHeight, l.updateProjectionMatrix(), c.setSize(window.innerWidth, window.innerHeight), x.material.uniforms.resolution.value.set(window.innerWidth, window.innerHeight)
            },
            M = function() {
                ! function(t, n, i) {
                    h.acceleration.length() > .1 || !i || (f.setFromCamera(i, n), (d = f.intersectObjects(t.children)[0]) && "MetalCube" == d.object.name && (h.anchor.copy(e.getPolarCoord(e.getRadian(e.getRandomInt(-20, 20)), e.getRadian(e.getRandomInt(0, 360)), e.getRandomInt(30, 90) / 10)), v.applyForce(new r.Vector3(1, 0, 0))))
                }(u, l, p), h.applyHook(0, .12), h.applyDrag(.01), h.updateVelocity(), v.applyHook(0, .005), v.applyDrag(.2), v.updateVelocity(), x.position.copy(h.velocity), x.material.uniforms.time.value++, x.material.uniforms.time2.value += 1 + Math.floor(4 * h.acceleration.length()), x.material.uniforms.acceleration.value = h.acceleration.length(), b.material.uniforms.time.value++, b.material.uniforms.acceleration.value = v.velocity.length(), l.force.position.applyHook(0, .025), l.force.position.applyDrag(.2), l.force.position.updateVelocity(), l.updatePosition(), l.lookAtCenter(), c.render(u, l)
            },
            _ = function() {
                var e = new r.Vector2,
                    t = new r.Vector2,
                    n = new r.Vector2,
                    a = function(t, n, r) {
                        e.set(t, n), o(e)
                    },
                    c = function(e, n, r) {
                        t.set(e, n), o(t), p = t
                    },
                    u = function(e, t, r) {
                        n.set(e, t)
                    };
                window.addEventListener("resize", i((function() {
                    w()
                })), 1e3), s.addEventListener("mousedown", (function(e) {
                    e.preventDefault(), a(e.clientX, e.clientY)
                })), s.addEventListener("mousemove", (function(e) {
                    e.preventDefault(), c(e.clientX, e.clientY)
                })), s.addEventListener("mouseup", (function(e) {
                    e.preventDefault(), u(e.clientX, e.clientY)
                })), s.addEventListener("touchstart", (function(e) {
                    e.preventDefault(), a(e.touches[0].clientX, e.touches[0].clientY)
                })), s.addEventListener("touchmove", (function(e) {
                    e.preventDefault(), c(e.touches[0].clientX, e.touches[0].clientY)
                })), s.addEventListener("touchend", (function(e) {
                    e.preventDefault(), u(e.changedTouches[0].clientX, e.changedTouches[0].clientY)
                })), window.addEventListener("mouseout", (function() {
                    event.preventDefault(), n.set(0, 0)
                }))
            };
        c.setSize(window.innerWidth, window.innerHeight), c.setClearColor(15658734, 1), l.position.set(1e3, 1e3, 1e3), l.lookAt(new r.Vector3), _(), u.add(x), u.add(b), l.setPolarCoord(0, e.getRadian(90), 24), w(),
            function e() {
                M(), requestAnimationFrame(e)
            }()
    }
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nvarying mat4 m_matrix;\n\nfloat inverse(float m) {\n  return 1.0 / m;\n}\n\nmat2 inverse(mat2 m) {\n  return mat2(m[1][1],-m[0][1],\n             -m[1][0], m[0][0]) / (m[0][0]*m[1][1] - m[0][1]*m[1][0]);\n}\n\nmat3 inverse(mat3 m) {\n  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2];\n  float a10 = m[1][0], a11 = m[1][1], a12 = m[1][2];\n  float a20 = m[2][0], a21 = m[2][1], a22 = m[2][2];\n\n  float b01 = a22 * a11 - a12 * a21;\n  float b11 = -a22 * a10 + a12 * a20;\n  float b21 = a21 * a10 - a11 * a20;\n\n  float det = a00 * b01 + a01 * b11 + a02 * b21;\n\n  return mat3(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11),\n              b11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10),\n              b21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)) / det;\n}\n\nmat4 inverse(mat4 m) {\n  float\n      a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\n      a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\n      a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\n      a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3],\n\n      b00 = a00 * a11 - a01 * a10,\n      b01 = a00 * a12 - a02 * a10,\n      b02 = a00 * a13 - a03 * a10,\n      b03 = a01 * a12 - a02 * a11,\n      b04 = a01 * a13 - a03 * a11,\n      b05 = a02 * a13 - a03 * a12,\n      b06 = a20 * a31 - a21 * a30,\n      b07 = a20 * a32 - a22 * a30,\n      b08 = a20 * a33 - a23 * a30,\n      b09 = a21 * a32 - a22 * a31,\n      b10 = a21 * a33 - a23 * a31,\n      b11 = a22 * a33 - a23 * a32,\n\n      det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  return mat4(\n      a11 * b11 - a12 * b10 + a13 * b09,\n      a02 * b10 - a01 * b11 - a03 * b09,\n      a31 * b05 - a32 * b04 + a33 * b03,\n      a22 * b04 - a21 * b05 - a23 * b03,\n      a12 * b08 - a10 * b11 - a13 * b07,\n      a00 * b11 - a02 * b08 + a03 * b07,\n      a32 * b02 - a30 * b05 - a33 * b01,\n      a20 * b05 - a22 * b02 + a23 * b01,\n      a10 * b10 - a11 * b08 + a13 * b06,\n      a01 * b08 - a00 * b10 - a03 * b06,\n      a30 * b04 - a31 * b02 + a33 * b00,\n      a21 * b02 - a20 * b04 - a23 * b00,\n      a11 * b07 - a10 * b09 - a12 * b06,\n      a00 * b09 - a01 * b07 + a02 * b06,\n      a31 * b01 - a30 * b03 - a32 * b00,\n      a20 * b03 - a21 * b01 + a22 * b00) / det;\n}\n\nvoid main(void) {\n  m_matrix = inverse(modelMatrix);\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nuniform float time;\nuniform float time2;\nuniform float acceleration;\nuniform vec2 resolution;\n\nvarying mat4 m_matrix;\n\n// const vec3 cPos = vec3(0.0, 0.0, 10.0);\nconst float targetDepth = 3.5;\nconst vec3 lightDir = vec3(0.577, -0.577, 0.577);\n\nvec3 hsv2rgb(vec3 c){\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\nvec3 rotate(vec3 p, float radian_x, float radian_y, float radian_z) {\n  mat3 mx = mat3(\n    1.0, 0.0, 0.0,\n    0.0, cos(radian_x), -sin(radian_x),\n    0.0, sin(radian_x), cos(radian_x)\n  );\n  mat3 my = mat3(\n    cos(radian_y), 0.0, sin(radian_y),\n    0.0, 1.0, 0.0,\n    -sin(radian_y), 0.0, cos(radian_y)\n  );\n  mat3 mz = mat3(\n    cos(radian_z), -sin(radian_z), 0.0,\n    sin(radian_z), cos(radian_z), 0.0,\n    0.0, 0.0, 1.0\n  );\n  return mx * my * mz * p;\n}\n\nfloat dBox(vec3 p, vec3 size) {\n  return length(max(abs(p) - size, 0.0));\n}\n\nfloat getNoise(vec3 p) {\n  return snoise(p * (0.4 + acceleration * 0.1) + time / 100.0);\n}\n\nvec3 getRotate(vec3 p) {\n  return rotate(p, radians(time2), radians(time2 * 2.0), radians(time2));\n}\n\nfloat distanceFunc(vec3 p) {\n  vec4 p1 = m_matrix * vec4(p, 1.0);\n  float n1 = getNoise(p1.xyz);\n  vec3 p2 = getRotate(p1.xyz);\n  float d1 = dBox(p2, vec3(0.8 - min(acceleration, 0.8))) - 0.2;\n  float d2 = dBox(p2, vec3(1.0)) - n1;\n  float d3 = dBox(p2, vec3(0.5 + acceleration * 0.4)) - n1;\n  return min(max(d1, -d2), d3);\n}\n\nfloat distanceFuncForFill(vec3 p) {\n  vec4 p1 = m_matrix * vec4(p, 1.0);\n  float n = getNoise(p1.xyz);\n  vec3 p2 = getRotate(p1.xyz);\n  return dBox(p2, vec3(0.5 + acceleration * 0.4)) - n;\n}\n\nvec3 getNormal(vec3 p) {\n  const float d = 0.1;\n  return normalize(vec3(\n    distanceFunc(p + vec3(d, 0.0, 0.0)) - distanceFunc(p + vec3(-d, 0.0, 0.0)),\n    distanceFunc(p + vec3(0.0, d, 0.0)) - distanceFunc(p + vec3(0.0, -d, 0.0)),\n    distanceFunc(p + vec3(0.0, 0.0, d)) - distanceFunc(p + vec3(0.0, 0.0, -d))\n  ));\n}\n\nvoid main() {\n  vec2 p = (gl_FragCoord.xy * 2.0 - resolution) / min(resolution.x, resolution.y);\n\n  vec3 cDir = normalize(cameraPosition * -1.0);\n  vec3 cUp  = vec3(0.0, 1.0, 0.0);\n  vec3 cSide = cross(cDir, cUp);\n\n  vec3 ray = normalize(cSide * p.x + cUp * p.y + cDir * targetDepth);\n\n  float distance = 0.0;\n  float rLen = 0.0;\n  vec3 rPos = cameraPosition;\n  for(int i = 0; i < 64; i++){\n    distance = distanceFunc(rPos);\n    rLen += distance;\n    rPos = cameraPosition + ray * rLen * 0.2;\n  }\n\n  vec3 normal = getNormal(rPos);\n  if(abs(distance) < 0.5){\n    if (distanceFuncForFill(rPos) > 0.5) {\n      gl_FragColor = vec4(hsv2rgb(vec3(dot(normal, cUp) * 0.8 + time / 400.0, 0.2, dot(normal, cUp) * 0.8 + 0.1)), 1.0);\n    } else {\n      gl_FragColor = vec4(hsv2rgb(vec3(dot(normal, cUp) * 0.1 + time / 400.0, 0.8, dot(normal, cUp) * 0.2 + 0.8)), 1.0);\n    }\n  } else {\n    gl_FragColor = vec4(0.0);\n  }\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nuniform float time;\nuniform float acceleration;\n\nvarying vec3 vPosition;\nvarying vec3 vColor;\nvarying mat4 invertMatrix;\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\nvec3 hsv2rgb(vec3 c){\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat inverse(float m) {\n  return 1.0 / m;\n}\n\nmat2 inverse(mat2 m) {\n  return mat2(m[1][1],-m[0][1],\n             -m[1][0], m[0][0]) / (m[0][0]*m[1][1] - m[0][1]*m[1][0]);\n}\n\nmat3 inverse(mat3 m) {\n  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2];\n  float a10 = m[1][0], a11 = m[1][1], a12 = m[1][2];\n  float a20 = m[2][0], a21 = m[2][1], a22 = m[2][2];\n\n  float b01 = a22 * a11 - a12 * a21;\n  float b11 = -a22 * a10 + a12 * a20;\n  float b21 = a21 * a10 - a11 * a20;\n\n  float det = a00 * b01 + a01 * b11 + a02 * b21;\n\n  return mat3(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11),\n              b11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10),\n              b21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)) / det;\n}\n\nmat4 inverse(mat4 m) {\n  float\n      a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\n      a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\n      a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\n      a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3],\n\n      b00 = a00 * a11 - a01 * a10,\n      b01 = a00 * a12 - a02 * a10,\n      b02 = a00 * a13 - a03 * a10,\n      b03 = a01 * a12 - a02 * a11,\n      b04 = a01 * a13 - a03 * a11,\n      b05 = a02 * a13 - a03 * a12,\n      b06 = a20 * a31 - a21 * a30,\n      b07 = a20 * a32 - a22 * a30,\n      b08 = a20 * a33 - a23 * a30,\n      b09 = a21 * a32 - a22 * a31,\n      b10 = a21 * a33 - a23 * a31,\n      b11 = a22 * a33 - a23 * a32,\n\n      det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  return mat4(\n      a11 * b11 - a12 * b10 + a13 * b09,\n      a02 * b10 - a01 * b11 - a03 * b09,\n      a31 * b05 - a32 * b04 + a33 * b03,\n      a22 * b04 - a21 * b05 - a23 * b03,\n      a12 * b08 - a10 * b11 - a13 * b07,\n      a00 * b11 - a02 * b08 + a03 * b07,\n      a32 * b02 - a30 * b05 - a33 * b01,\n      a20 * b05 - a22 * b02 + a23 * b01,\n      a10 * b10 - a11 * b08 + a13 * b06,\n      a01 * b08 - a00 * b10 - a03 * b06,\n      a30 * b04 - a31 * b02 + a33 * b00,\n      a21 * b02 - a20 * b04 - a23 * b00,\n      a11 * b07 - a10 * b09 - a12 * b06,\n      a00 * b09 - a01 * b07 + a02 * b06,\n      a31 * b01 - a30 * b03 - a32 * b00,\n      a20 * b03 - a21 * b01 + a22 * b00) / det;\n}\n\nvec3 rotate(vec3 p, float radian_x, float radian_y, float radian_z) {\n  mat3 mx = mat3(\n    1.0, 0.0, 0.0,\n    0.0, cos(radian_x), -sin(radian_x),\n    0.0, sin(radian_x), cos(radian_x)\n  );\n  mat3 my = mat3(\n    cos(radian_y), 0.0, sin(radian_y),\n    0.0, 1.0, 0.0,\n    -sin(radian_y), 0.0, cos(radian_y)\n  );\n  mat3 mz = mat3(\n    cos(radian_z), -sin(radian_z), 0.0,\n    sin(radian_z), cos(radian_z), 0.0,\n    0.0, 0.0, 1.0\n  );\n  return mx * my * mz * p;\n}\n\nvec3 getRotate(vec3 p) {\n  return rotate(p, radians(time / 6.0), radians(time / 7.0), radians(time / 8.0));\n}\n\nvoid main() {\n  float updateTime = time / 400.0;\n  vec3 p_rotate = getRotate(position);\n  float noise = snoise(vec3(p_rotate / 12.1 + updateTime * 0.5));\n  vec3 p_noise = p_rotate + p_rotate * noise / 20.0 * (min(acceleration, 6.0) + 1.0);\n\n  vPosition = p_noise;\n  vColor = hsv2rgb(vec3(updateTime + position.y / 400.0, 0.05 + min(acceleration / 10.0, 0.25), 1.0));\n  invertMatrix = inverse(modelMatrix);\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(p_noise, 1.0);\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nuniform float time;\nuniform float acceleration;\n\nvarying vec3 vPosition;\nvarying vec3 vColor;\nvarying mat4 invertMatrix;\n\nvoid main() {\n  vec3 normal = normalize(cross(dFdx(vPosition), dFdy(vPosition)));\n  vec3 inv_light = normalize(invertMatrix * vec4(0.7, -0.7, 0.7, 1.0)).xyz;\n  float diff = (dot(normal, inv_light) + 1.0) / 4.0 + 0.4;\n  gl_FragColor = vec4(vColor * diff, 1.0);\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t);
    var r = n(0),
        i = n(3),
        o = n(15).default;
    t.default = function() {
        n(16);
        var e = n(111),
            t = n(33),
            a = document.getElementById("canvas-webgl"),
            s = new r.WebGLRenderer({
                antialias: !0,
                canvas: a
            }),
            c = new r.Scene,
            u = new t(35, window.innerWidth / window.innerHeight, 1, 1e4),
            l = (new r.Clock, null),
            f = null,
            d = new r.HemisphereLight(16777215, 6710886, 1),
            h = new r.Scene,
            v = new t(45, window.innerWidth / window.innerHeight, 1, 1e4),
            p = new r.HemisphereLight(16777215, 6710886, 1),
            m = new e,
            y = 1,
            g = new r.WebGLRenderTarget(window.innerWidth, window.innerHeight, {
                magFilter: r.NearestFilter,
                minFilter: r.NearestFilter,
                wrapS: r.ClampToEdgeWrapping,
                wrapT: r.ClampToEdgeWrapping
            }),
            x = null,
            b = function() {
                var e, t;
                document.body.className = "bg-white", l = function() {
                    var e = new r.BufferGeometry;
                    e.fromGeometry(new r.OctahedronGeometry(200, 5));
                    var t = new r.ShaderMaterial({
                        uniforms: r.UniformsUtils.merge([r.UniformsLib.lights, {
                            time: {
                                type: "f",
                                value: 0
                            },
                            radius: {
                                type: "f",
                                value: 1
                            },
                            distort: {
                                type: "f",
                                value: .4
                            }
                        }]),
                        vertexShader: n(619).default,
                        fragmentShader: n(620).default,
                        lights: !0
                    });
                    return new r.Mesh(e, t)
                }(), h.add(l), e = new r.SphereGeometry(1800), t = new r.MeshPhongMaterial({
                    side: r.BackSide
                }), f = new r.Mesh(e, t), h.add(f), h.add(p), v.force.position.anchor.set(1800, 1800, 0), v.force.look.anchor.set(0, 0, 0), x = function() {
                    var e = new r.PlaneGeometry(2, 2),
                        t = new r.BufferGeometry;
                    t.fromGeometry(e);
                    var i = new r.ShaderMaterial({
                        uniforms: {
                            time: {
                                type: "f",
                                value: 0
                            },
                            resolution: {
                                type: "v2",
                                value: new r.Vector2(window.innerWidth, window.innerHeight)
                            },
                            acceleration: {
                                type: "f",
                                value: 0
                            },
                            texture: {
                                type: "t",
                                value: g
                            }
                        },
                        vertexShader: n(621).default,
                        fragmentShader: n(622).default
                    });
                    return new r.Mesh(t, i)
                }(), c.add(x), c.add(d), u.force.position.anchor.set(1800, 1800, 0), u.force.look.anchor.set(0, 0, 0), m.anchor.set(1, 0), m.anchor.set(1, 0), m.velocity.set(1, 0), m.k = .045, m.d = .16
            },
            w = function() {
                a.width = window.innerWidth, a.height = window.innerHeight, u.aspect = window.innerWidth / window.innerHeight, u.updateProjectionMatrix(), s.setSize(window.innerWidth, window.innerHeight), g.setSize(window.innerWidth, window.innerHeight), v.resize(window.innerWidth, window.innerHeight), x.material.uniforms.resolution.value.set(window.innerWidth, window.innerHeight)
            },
            M = function e() {
                m.applyHook(0, m.k), m.applyDrag(m.d), m.updateVelocity(), l.material.uniforms.time.value += y, l.material.uniforms.radius.value = m.velocity.x, l.material.uniforms.distort.value = m.velocity.x / 2 - .1, v.force.position.applyHook(0, .025), v.force.position.applyDrag(.2), v.force.position.updateVelocity(), v.updatePosition(), v.force.look.applyHook(0, .2), v.force.look.applyDrag(.4), v.force.look.updateVelocity(), v.updateLook(), x.material.uniforms.time.value += y, x.material.uniforms.acceleration.value = m.acceleration.length(), u.force.position.applyHook(0, .025), u.force.position.applyDrag(.2), u.force.position.updateVelocity(), u.updatePosition(), u.force.look.applyHook(0, .2), u.force.look.applyDrag(.4), u.force.look.updateVelocity(), u.lookAt(u.force.look.velocity), s.setRenderTarget(g), s.render(h, v), s.setRenderTarget(null), s.render(c, u), requestAnimationFrame(e)
            },
            _ = function() {
                var e = new r.Vector2,
                    t = new r.Vector2,
                    n = new r.Vector2,
                    s = function(t, n, r) {
                        e.set(t, n), o(e), m.anchor.x < 3 ? (m.k += .005, m.d -= .02, m.anchor.x += .8, y += .4) : (m.k = .05, m.d = .16, m.anchor.x = 1, y = 1)
                    },
                    c = function(e, n, r) {
                        t.set(e, n), o(t)
                    },
                    u = function(e, t, r) {
                        n.set(e, t)
                    };
                window.addEventListener("resize", i((function() {
                    w()
                })), 1e3), a.addEventListener("mousedown", (function(e) {
                    e.preventDefault(), s(e.clientX, e.clientY)
                })), a.addEventListener("mousemove", (function(e) {
                    e.preventDefault(), c(e.clientX, e.clientY)
                })), a.addEventListener("mouseup", (function(e) {
                    e.preventDefault(), u(e.clientX, e.clientY)
                })), a.addEventListener("touchstart", (function(e) {
                    e.preventDefault(), s(e.touches[0].clientX, e.touches[0].clientY)
                })), a.addEventListener("touchmove", (function(e) {
                    e.preventDefault(), c(e.touches[0].clientX, e.touches[0].clientY)
                })), a.addEventListener("touchend", (function(e) {
                    e.preventDefault(), u(e.changedTouches[0].clientX, e.changedTouches[0].clientY)
                })), window.addEventListener("mouseout", (function() {
                    event.preventDefault(), n.set(0, 0)
                }))
            };
        s.setSize(window.innerWidth, window.innerHeight), s.setClearColor(15658734, 1), u.position.set(1e3, 1e3, 1e3), u.lookAt(new r.Vector3), _(), b(), w(), M()
    }
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nuniform float time;\nuniform float radius;\nuniform float distort;\n\nvarying vec3 vColor;\nvarying vec3 vNormal;\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\nvec3 hsv2rgb(vec3 c){\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  float updateTime = time / 1000.0;\n  float noise = snoise(vec3(position / 400.1 + updateTime * 5.0));\n  vec4 mvPosition = modelViewMatrix * vec4(position * (noise * pow(distort, 2.0) + radius), 1.0);\n\n  vColor = hsv2rgb(vec3(noise * distort * 0.3 + updateTime, 0.2, 1.0));\n  vNormal = normal;\n\n  gl_Position = projectionMatrix * mvPosition;\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nvarying vec3 vColor;\nvarying vec3 vNormal;\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\nvec3 hsv2rgb(vec3 c){\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nstruct HemisphereLight {\n  vec3 direction;\n  vec3 groundColor;\n  vec3 skyColor;\n};\nuniform HemisphereLight hemisphereLights[NUM_HEMI_LIGHTS];\n\nvoid main() {\n  vec3 light = vec3(0.0);\n  light += (dot(hemisphereLights[0].direction, vNormal) + 1.0) * hemisphereLights[0].skyColor * 0.5;\n  light += (-dot(hemisphereLights[0].direction, vNormal) + 1.0) * hemisphereLights[0].groundColor * 0.5;\n  gl_FragColor = vec4(vColor * light, 1.0);\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nvarying vec2 vUv;\n\nvoid main(void) {\n  vUv = uv;\n  gl_Position = vec4(position, 1.0);\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t), t.default = "#define GLSLIFY 1\nuniform float time;\nuniform vec2 resolution;\nuniform float acceleration;\nuniform sampler2D texture;\n\nconst float blur = 16.0;\n\nvarying vec2 vUv;\n\nfloat random2(vec2 c){\n    return fract(sin(dot(c.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n//\n// Description : Array and textureless GLSL 2D simplex noise function.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 mod289(vec2 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 permute(vec3 x) {\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nfloat snoise(vec2 v)\n  {\n  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                     -0.577350269189626,  // -1.0 + 2.0 * C.x\n                      0.024390243902439); // 1.0 / 41.0\n// First corner\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n\n// Other corners\n  vec2 i1;\n  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n  //i1.y = 1.0 - i1.x;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  // x0 = x0 - 0.0 + 0.0 * C.xx ;\n  // x1 = x0 - i1 + 1.0 * C.xx ;\n  // x2 = x0 - 1.0 + 2.0 * C.xx ;\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n\n// Permutations\n  i = mod289(i); // Avoid truncation effects in permutation\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n    + i.x + vec3(0.0, i1.x, 1.0 ));\n\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n\n// Gradients: 41 points uniformly over a line, mapped onto a diamond.\n// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n\n// Normalise gradients implicitly by scaling m\n// Approximation of: m *= inversesqrt( a0*a0 + h*h );\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n// Compute final noise value at P\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\nvec2 diffUv(float v, float diff) {\n  return vUv + (vec2(v + snoise(vec2(gl_FragCoord.y + time) / 100.0), 0.0) * diff + vec2(v * 3.0, 0.0)) / resolution;\n}\n\nfloat randomNoise(vec2 p) {\n  return (random2(p - vec2(sin(time))) * 2.0 - 1.0) * max(length(acceleration), 0.08);\n}\n\nvoid main() {\n  float diff = 300.0 * length(acceleration);\n  vec2 uv_r = diffUv(0.0, diff);\n  vec2 uv_g = diffUv(1.0, diff);\n  vec2 uv_b = diffUv(-1.0, diff);\n  float r = texture2D(texture, uv_r).r + randomNoise(uv_r);\n  float g = texture2D(texture, uv_g).g + randomNoise(uv_g);\n  float b = texture2D(texture, uv_b).b + randomNoise(uv_b);\n  gl_FragColor = vec4(r, g, b, 1.0);\n}\n"
}, function(e, t, n) {
    "use strict";
    n.r(t);
    var r = n(0),
        i = n(3),
        o = n(15).default;
    t.default = function() {
        var e = n(16),
            t = n(71),
            a = n(72),
            s = n(33),
            c = document.getElementById("canvas-webgl"),
            u = new r.WebGLRenderer({
                antialias: !0,
                canvas: c
            }),
            l = new r.Scene,
            f = new s(35, window.innerWidth / window.innerHeight, 1, 1e4),
            d = (new r.Clock, new Image),
            h = [],
            v = [],
            p = null,
            m = null,
            y = null,
            g = null,
            x = new a,
            b = !1,
            w = function() {
                var e = document.createElement("canvas"),
                    t = e.getContext("2d"),
                    n = null,
                    i = null;
                return e.width = 200, e.height = 200, (n = t.createRadialGradient(100, 100, 20, 100, 100, 100)).addColorStop(.2, "rgba(255, 255, 255, 1)"), n.addColorStop(.5, "rgba(255, 255, 255, 0.3)"), n.addColorStop(1, "rgba(255, 255, 255, 0)"), t.fillStyle = n, t.arc(100, 100, 100, 0, Math.PI / 180, !0), t.fill(), (i = new r.Texture(e)).minFilter = r.NearestFilter, i.needsUpdate = !0, i
            },
            M = function() {
                var e;
                e = function() {
                    ! function() {
                        var e = document.createElement("canvas"),
                            t = e.getContext("2d");
                        e.width = 400, e.height = 400, t.drawImage(d, 0, 0);
                        for (var n = t.getImageData(0, 0, 400, 400), r = 0; r < 400; r++)
                            if (!(r % 3 > 0))
                                for (var i = 0; i < 400; i++) i % 3 > 0 || n.data[4 * (i + 400 * r)] > 0 && h.push(0, -1 * (r - 200), -1 * (i - 200))
                    }(),
                    function(e) {
                        p = new Float32Array(h), m = new Float32Array(h.length), y = new Float32Array(h.length / 3), g = new Float32Array(h.length / 3);
                        for (var i = 0; i < h.length / 3; i++) {
                            var o = new t,
                                a = new r.Color("hsl(" + (h[3 * i + 2] + h[3 * i + 1] + 400) / 5 + ", 60%, 80%)");
                            o.init(new r.Vector3(h[3 * i], h[3 * i + 1], h[3 * i + 2])), o.is_activate = !0, v.push(o), a.toArray(m, 3 * i), y[i] = 1, g[i] = 12
                        }
                        x.init({
                            scene: e,
                            vs: n(73).default,
                            fs: n(74).default,
                            positions: p,
                            colors: m,
                            opacities: y,
                            sizes: g,
                            texture: w(),
                            blending: r.NormalBlending
                        }), b = !0
                    }(l)
                }, d.src = "../img/sketch/image_data/elephant.png", d.onload = function() {
                    e()
                }, f.setPolarCoord(0, 0, 1400)
            },
            _ = function() {
                c.width = window.innerWidth, c.height = window.innerHeight, f.aspect = window.innerWidth / window.innerHeight, f.updateProjectionMatrix(), u.setSize(window.innerWidth, window.innerHeight)
            },
            S = function() {
                b && (! function() {
                    for (var t = 0; t < v.length; t++) {
                        var n = v[t];
                        n.time++, n.acceleration.length() < 1 && (n.is_activate = !0), n.is_activate ? (n.applyHook(0, .18), n.applyDrag(.26)) : n.applyDrag(.035), n.updateVelocity(), n.velocity.sub(x.velocity), p[3 * t + 0] = n.velocity.x - x.velocity.x, p[3 * t + 1] = n.velocity.y - x.velocity.x, p[3 * t + 2] = n.velocity.z - x.velocity.x, n.size = Math.log(e.getRandomInt(1, 128)) / Math.log(128) * Math.sqrt(document.body.clientWidth), g[t] = n.size
                    }
                    x.updatePoints()
                }(), x.updatePoints()), f.force.position.applyHook(0, .025), f.force.position.applyDrag(.2), f.force.position.updateVelocity(), f.updatePosition(), f.lookAtCenter(), u.render(l, f)
            },
            P = function() {
                var t = new r.Vector2,
                    n = new r.Vector2,
                    a = new r.Vector2,
                    s = function(n, r, i) {
                        t.set(n, r), o(t),
                            function() {
                                for (var t = 0; t < v.length; t++) {
                                    var n = v[t],
                                        r = e.getRadian(e.getRandomInt(0, 360)),
                                        i = e.getRadian(e.getRandomInt(0, 360)),
                                        o = e.getRandomInt(40, 80);
                                    n.is_activate = !1, n.applyForce(e.getPolarCoord(r, i, o))
                                }
                            }()
                    },
                    u = function(e, t, r) {
                        n.set(e, t), o(n), f.force.position.anchor.z = 1e3 * n.x, f.force.position.anchor.y = -1e3 * n.y
                    },
                    l = function(e, t, n) {
                        a.set(e, t), f.force.position.anchor.z = 0, f.force.position.anchor.y = 0
                    };
                window.addEventListener("resize", i((function() {
                    _()
                })), 1e3), c.addEventListener("mousedown", (function(e) {
                    e.preventDefault(), s(e.clientX, e.clientY)
                })), c.addEventListener("mousemove", (function(e) {
                    e.preventDefault(), u(e.clientX, e.clientY)
                })), c.addEventListener("mouseup", (function(e) {
                    e.preventDefault(), l(e.clientX, e.clientY)
                })), c.addEventListener("touchstart", (function(e) {
                    e.preventDefault(), s(e.touches[0].clientX, e.touches[0].clientY)
                })), c.addEventListener("touchmove", (function(e) {
                    e.preventDefault(), u(e.touches[0].clientX, e.touches[0].clientY)
                })), c.addEventListener("touchend", (function(e) {
                    e.preventDefault(), l(e.changedTouches[0].clientX, e.changedTouches[0].clientY)
                })), window.addEventListener("mouseout", (function() {
                    event.preventDefault(), a.set(0, 0), f.force.position.anchor.z = 0, f.force.position.anchor.y = 0
                }))
            };
        u.setSize(window.innerWidth, window.innerHeight), u.setClearColor(1118481, 1), f.position.set(1e3, 1e3, 1e3), f.lookAt(new r.Vector3), P(), M(), _(),
            function e() {
                S(), requestAnimationFrame(e)
            }()
    }
}, function(e, t, n) {
    "use strict";
    n.r(t);
    var r = n(0),
        i = n(3),
        o = n(15).default;
    t.default = function() {
        var e = n(16),
            t = n(46),
            a = n(151),
            s = n(33),
            c = document.getElementById("canvas-webgl"),
            u = new r.WebGLRenderer({
                antialias: !0,
                canvas: c
            }),
            l = new r.Scene,
            f = new s(35, window.innerWidth / window.innerHeight, 1, 1e4),
            d = (new r.Clock, []),
            h = null,
            v = new r.Raycaster,
            p = -1,
            m = -1,
            y = !1,
            g = !1,
            x = !1,
            b = function() {
                this.rad = 0, this.obj, this.is_entered = !1, t.call(this)
            },
            w = new r.PlaneGeometry(100, 100);
        (b.prototype = Object.create(t.prototype)).constructor = b, b.prototype.init = function(t) {
            var n = new r.MeshPhongMaterial({
                side: r.DoubleSide,
                map: (new r.TextureLoader).load("../img/sketch/gallery/image0" + e.getRandomInt(1, 9) + ".jpg")
            });
            this.obj = new r.Mesh(w, n), this.velocity = t.clone(), this.anchor = t.clone(), this.acceleration.set(0, 0, 0)
        };
        var M = function(e) {
                if (!x) {
                    var t;
                    v.setFromCamera(e, f), (t = v.intersectObjects(l.children)).length > 0 && 0 == g ? (document.body.classList.add("is-pointed"), p = t[0].object.id) : S()
                }
            },
            _ = function(e, t) {
                x = !0, e.force.position.anchor.set(780 * Math.cos(t.rad), t.obj.position.y, 780 * Math.sin(t.rad)), e.force.look.anchor.copy(t.obj.position), S()
            },
            S = function() {
                document.body.classList.remove("is-pointed"), p = -1
            },
            P = function() {
                ! function(t) {
                    for (var n = 0; n < 300; n++) {
                        var i = null,
                            o = e.getRadian(n % 45 * 8 + 180),
                            a = 1e3 * Math.cos(o),
                            s = 5 * n - 750,
                            c = 1e3 * Math.sin(o),
                            u = new r.Vector3(a, s, c);
                        (i = new b).init(new r.Vector3), i.rad = o, i.obj.position.copy(u), t.add(i.obj), d.push(i)
                    }
                }(l), h = new a(16777215, 16777215, 1), l.add(h), f.force.position.anchor.set(0, 0, 0), f.rotate_rad1 = e.getRadian(-35), f.rotate_rad1_base = f.rotate_rad1, f.rotate_rad2 = e.getRadian(180), f.rotate_rad2_base = f.rotate_rad2
            },
            T = function() {
                c.width = window.innerWidth, c.height = window.innerHeight, f.aspect = window.innerWidth / window.innerHeight, f.updateProjectionMatrix(), u.setSize(window.innerWidth, window.innerHeight)
            },
            E = function t() {
                ! function() {
                    for (var t = 0; t < 300; t++) d[t].applyHook(0, .14), d[t].applyDrag(.4), d[t].updateVelocity(), d[t].obj.lookAt(0, d[t].obj.position.y, 0), d[t].obj.id == p && 0 == g && 0 == x ? 1 == y ? m = t : d[t].obj.material.color.set(11184810) : d[t].obj.material.color.set(16777215);
                    f.force.position.applyHook(0, .08), f.force.position.applyDrag(.4), f.force.position.updateVelocity(), f.updatePosition(), !1 === x && f.force.look.anchor.copy(e.getPolarCoord(f.rotate_rad1, f.rotate_rad2, 1e3)), f.force.look.applyHook(0, .08), f.force.look.applyDrag(.4), f.force.look.updateVelocity(), f.updateLook(), u.render(l, f)
                }(), requestAnimationFrame(t)
            },
            z = function() {
                var t = new r.Vector2,
                    n = new r.Vector2,
                    a = new r.Vector2,
                    s = function(e, n, r) {
                        t.set(e, n), o(t), M(t), y = !0
                    },
                    u = function(r, i, a) {
                        n.set(r, i), o(n), M(l), y && t.clone().sub(n).length() > .01 && (y = !1, g = !0), 1 == g && 0 == x && (f.rotate_rad1 = f.rotate_rad1_base + e.getRadian(50 * (t.y - n.y)), f.rotate_rad2 = f.rotate_rad2_base + e.getRadian(50 * (t.x - n.x)), f.rotate_rad1 < e.getRadian(-50) && (f.rotate_rad1 = e.getRadian(-50)), f.rotate_rad1 > e.getRadian(50) && (f.rotate_rad1 = e.getRadian(50)))
                    },
                    h = function(e, t, n) {
                        a.set(e, t), S(), x ? (f.force.position.anchor.set(0, 0, 0), m = -1, x = !1) : y && m > -1 ? _(f, d[m]) : g && (f.rotate_rad1_base = f.rotate_rad1, f.rotate_rad2_base = f.rotate_rad2), y = !1, g = !1
                    };
                window.addEventListener("resize", i((function() {
                    T()
                })), 1e3), c.addEventListener("mousedown", (function(e) {
                    e.preventDefault(), s(e.clientX, e.clientY)
                })), c.addEventListener("mousemove", (function(e) {
                    e.preventDefault(), u(e.clientX, e.clientY)
                })), c.addEventListener("mouseup", (function(e) {
                    e.preventDefault(), h(e.clientX, e.clientY)
                })), c.addEventListener("touchstart", (function(e) {
                    e.preventDefault(), s(e.touches[0].clientX, e.touches[0].clientY)
                })), c.addEventListener("touchmove", (function(e) {
                    e.preventDefault(), u(e.touches[0].clientX, e.touches[0].clientY)
                })), c.addEventListener("touchend", (function(e) {
                    e.preventDefault(), h(e.changedTouches[0].clientX, e.changedTouches[0].clientY)
                })), window.addEventListener("mouseout", (function() {
                    event.preventDefault(), a.set(0, 0), S(), x ? (f.force.position.anchor.set(0, 0, 0), m = -1, x = !1) : y && m > -1 ? _(f, d[m]) : g && (f.rotate_rad1_base = f.rotate_rad1, f.rotate_rad2_base = f.rotate_rad2), y = !1, g = !1
                }))
            };
        u.setSize(window.innerWidth, window.innerHeight), u.setClearColor(1118481, 1), f.position.set(1e3, 1e3, 1e3), f.lookAt(new r.Vector3), z(), P(), T(), E()
    }
}, function(e, t, n) {
    "use strict";
    n.r(t);
    var r = n(0),
        i = n(3),
        o = n(15).default;
    t.default = function() {
        var e = n(16),
            t = n(111),
            a = n(71),
            s = n(72),
            c = n(151),
            u = n(152),
            l = n(33),
            f = document.getElementById("canvas-webgl"),
            d = new r.WebGLRenderer({
                antialias: !0,
                canvas: f
            }),
            h = new r.Scene,
            v = new l(35, window.innerWidth / window.innerHeight, 1, 1e4),
            p = (new r.Clock, []),
            m = 2,
            y = new s,
            g = null,
            x = null,
            b = null,
            w = new Float32Array(3e4),
            M = new Float32Array(3e4),
            _ = new Float32Array(1e4),
            S = new Float32Array(1e4),
            P = null,
            T = new t,
            E = null,
            z = Date.now(),
            L = Date.now(),
            A = Date.now(),
            C = Date.now(),
            R = 0,
            O = !1,
            j = !1,
            I = !0,
            D = function() {
                var e = document.createElement("canvas"),
                    t = e.getContext("2d"),
                    n = null,
                    i = null;
                return e.width = 200, e.height = 200, (n = t.createRadialGradient(100, 100, 20, 100, 100, 100)).addColorStop(.9, "rgba(255, 255, 255, 1)"), n.addColorStop(1, "rgba(255, 255, 255, 0)"), t.fillStyle = n, t.arc(100, 100, 100, 0, Math.PI / 180, !0), t.fill(), (i = new r.Texture(e)).minFilter = r.NearestFilter, i.needsUpdate = !0, i
            },
            k = function() {
                var t, i;
                P = function() {
                    for (var e = new r.OctahedronGeometry(30, 2), t = new r.BufferGeometry, n = new r.MeshPhongMaterial({
                            color: new r.Color("hsl(140, 100%, 100%)"),
                            flatShading: !0
                        }), i = new Float32Array(3 * e.vertices.length), o = 0; o < e.vertices.length; o++) i[3 * o] = e.vertices[o].x, i[3 * o + 1] = e.vertices[o].y, i[3 * o + 2] = e.vertices[o].z;
                    for (var a = new Uint32Array(3 * e.faces.length), s = 0; s < e.faces.length; s++) a[3 * s] = e.faces[s].a, a[3 * s + 1] = e.faces[s].b, a[3 * s + 2] = e.faces[s].c;
                    return t.addAttribute("position", new r.BufferAttribute(i, 3)), t.attributes.position.dynamic = !0, t.setIndex(new r.BufferAttribute(a, 1)), t.index.dynamic = !0, new r.Mesh(t, n)
                }(), h.add(P), t = new r.OctahedronGeometry(250, 4), i = new r.MeshPhongMaterial({
                    color: 2236962,
                    flatShading: !0
                }), E = new r.Mesh(t, i), h.add(E);
                for (var o = 0; o < 1e4; o++) {
                    var s = new a,
                        l = e.getRandomInt(95, 185),
                        f = e.getRandomInt(60, 80);
                    s.init(new r.Vector3(e.getRandomInt(-100, 100), 0, 0)), s.color = new r.Color("hsl(" + l + ", " + f + "%, 70%)"), p.push(s), w[3 * o + 0] = s.velocity.x, w[3 * o + 1] = s.velocity.y, w[3 * o + 2] = s.velocity.z, M[3 * o + 0] = s.color.r, M[3 * o + 1] = s.color.g, M[3 * o + 2] = s.color.b, _[o] = s.a, S[o] = s.size
                }
                y.init({
                    scene: h,
                    vs: n(73).default,
                    fs: n(74).default,
                    positions: w,
                    colors: M,
                    opacities: _,
                    sizes: S,
                    texture: D(),
                    blending: r.NormalBlending
                }), y.rad1 = 0, y.rad1_base = 0, y.rad2 = 0, y.rad3 = 0, g = new c(new r.Color("hsl(95, 50%, 60%)").getHex(), new r.Color("hsl(185, 50%, 60%)").getHex(), 1), h.add(g), x = new u("hsl(95, 60%, 50%)", 1, 500, 1), h.add(x), b = new u("hsl(95, 60%, 50%)", 1, 500, 1), h.add(b), v.anchor = new r.Vector3(1500, 0, 0)
            },
            F = function() {
                f.width = window.innerWidth, f.height = window.innerHeight, v.aspect = window.innerWidth / window.innerHeight, v.updateProjectionMatrix(), d.setSize(window.innerWidth, window.innerHeight)
            },
            G = function() {
                O && R < 200 ? R += 1 : R > 0 && (R -= 1), y.velocity = (P.rotation.x += .03 + R / 1e3, P.rotation.y += .01 + R / 1e3, P.rotation.z += .01 + R / 1e3, y.rad1_base += e.getRadian(.6), y.rad1 = e.getRadian(45 * Math.sin(y.rad1_base) + R / 100), y.rad2 += e.getRadian(.8 + R / 100), y.rad3 += .01, e.getPolarCoord(y.rad1, y.rad2, 350)), !0 === I && (v.force.position.anchor.copy(y.velocity.clone().add(y.velocity.clone().sub(y.obj.position).normalize().multiplyScalar(-400))), v.force.position.anchor.y += 2 * y.velocity.y, v.force.look.anchor.copy(y.velocity)), y.updatePoints(), P.position.copy(y.velocity), g.color.setHSL((95 - R / 1.5) / 360, .5, .6), g.groundColor.setHSL((185 - R / 1.5) / 360, .5, .6), x.position.copy(y.velocity), x.color.setHSL((95 - R / 1.5) / 360, .5, .6), b.position.copy(y.velocity), b.color.setHSL((185 - R / 1.5) / 360, .5, .6),
                    function() {
                        var t = 0;
                        if (Date.now() - z > 10) {
                            for (var n = 0; n < p.length; n++) {
                                var r = p[n];
                                if (!r.is_active) {
                                    var i = e.getRadian(e.getRandomInt(0, 360)),
                                        o = e.getRadian(e.getRandomInt(0, 360)),
                                        a = e.getRandomInt(1, 30),
                                        s = e.getPolarCoord(i, o, a),
                                        c = e.getPolarCoord(i, o, a / 20),
                                        u = e.getRandomInt(95, 185) - R / 1.5,
                                        l = e.getRandomInt(60, 80);
                                    if (s.add(y.velocity), r.activate(), r.init(s), r.color.setHSL(u / 360, l / 100, .7), r.applyForce(c), r.a = 1, r.size = 25, ++t >= m) break
                                }
                            }
                            z = Date.now()
                        }
                    }(),
                    function() {
                        for (var e = 0; e < p.length; e++) {
                            var t = p[e];
                            new r.Vector3;
                            t.is_active && (t.time++, t.applyDrag(.1), t.updateVelocity(), t.time > 10 && (t.size -= 2), t.size <= 0 && (t.init(new r.Vector3(0, 0, 0)), t.time = 0, t.a = 0, t.inactivate())), w[3 * e + 0] = t.velocity.x - y.velocity.x, w[3 * e + 1] = t.velocity.y - y.velocity.y, w[3 * e + 2] = t.velocity.z - y.velocity.z, M[3 * e + 0] = t.color.r, M[3 * e + 1] = t.color.g, M[3 * e + 2] = t.color.b, _[e] = t.a, S[e] = t.size
                        }
                        y.updatePoints()
                    }(), v.force.position.applyHook(0, .025), v.force.position.applyDrag(.2), v.force.position.updateVelocity(), v.updatePosition(), v.force.look.applyHook(0, .2), v.force.look.applyDrag(.4), v.force.look.updateVelocity(), v.updateLook(), x.position.copy(e.getPolarCoord(e.getRadian(0), e.getRadian(0), 24).add(y.velocity)), b.position.copy(e.getPolarCoord(e.getRadian(180), e.getRadian(0), 24).add(y.velocity)), Date.now() - A > 1e3 - 3 * R && (T.applyForce(new r.Vector2(.08 + R / 5e3, 0)), A = Date.now(), j = !0, L = Date.now()), m = j && Date.now() - L < 500 ? 6 + Math.floor(R / 40) : 1 + Math.floor(R / 40), T.applyHook(0, .1), T.applyDrag(.12), T.updateVelocity(), P.scale.set(1 + T.velocity.x, 1 + T.velocity.x, 1 + T.velocity.x), d.render(h, v)
            },
            N = function() {
                var e = new r.Vector2,
                    t = new r.Vector2,
                    n = new r.Vector2,
                    a = function(t, n, r) {
                        e.set(t, n), o(e), O = !0, C = Date.now()
                    },
                    s = function(e, n, r) {
                        t.set(e, n), o(t)
                    },
                    c = function(e, t, r) {
                        n.set(e, t), O = !1, Date.now() - C < 100 && (!0 === I ? (v.force.position.anchor.set(1200, 1200, 0), v.force.look.anchor.set(0, 0, 0), I = !1) : I = !0)
                    };
                window.addEventListener("resize", i((function() {
                    F()
                })), 1e3), f.addEventListener("mousedown", (function(e) {
                    e.preventDefault(), a(e.clientX, e.clientY)
                })), f.addEventListener("mousemove", (function(e) {
                    e.preventDefault(), s(e.clientX, e.clientY)
                })), f.addEventListener("mouseup", (function(e) {
                    e.preventDefault(), c(e.clientX, e.clientY)
                })), f.addEventListener("touchstart", (function(e) {
                    e.preventDefault(), a(e.touches[0].clientX, e.touches[0].clientY)
                })), f.addEventListener("touchmove", (function(e) {
                    e.preventDefault(), s(e.touches[0].clientX, e.touches[0].clientY)
                })), f.addEventListener("touchend", (function(e) {
                    e.preventDefault(), c(e.changedTouches[0].clientX, e.changedTouches[0].clientY)
                })), window.addEventListener("mouseout", (function() {
                    event.preventDefault(), n.set(0, 0), O = !1, Date.now() - C < 100 && (!0 === I ? (v.force.position.anchor.set(1200, 1200, 0), v.force.look.anchor.set(0, 0, 0), I = !1) : I = !0)
                }))
            };
        d.setSize(window.innerWidth, window.innerHeight), d.setClearColor(0, 1), v.position.set(1e3, 1e3, 1e3), v.lookAt(new r.Vector3), N(), k(), F(),
            function e() {
                G(), requestAnimationFrame(e)
            }()
    }
}, function(e, t, n) {
    "use strict";
    n.r(t);
    var r = n(0),
        i = n(3),
        o = n(15).default;
    t.default = function() {
        var e = n(16),
            t = n(71),
            a = n(72),
            s = n(33),
            c = document.getElementById("canvas-webgl"),
            u = new r.WebGLRenderer({
                antialias: !0,
                canvas: c
            }),
            l = new r.Scene,
            f = new s(35, window.innerWidth / window.innerHeight, 1, 1e4),
            d = (new r.Clock, []),
            h = new a,
            v = new Float32Array(6e4),
            p = new Float32Array(6e4),
            m = new Float32Array(2e4),
            y = new Float32Array(2e4),
            g = new r.Vector3(1.5, 0, 0),
            x = Date.now(),
            b = !1,
            w = function() {
                var e = document.createElement("canvas"),
                    t = e.getContext("2d"),
                    n = null,
                    i = null;
                return e.width = 256, e.height = 256, (n = t.createRadialGradient(128, 128, 20, 128, 128, 128)).addColorStop(.2, "rgba(255, 255, 255, 1)"), n.addColorStop(.5, "rgba(255, 255, 255, 0.3)"), n.addColorStop(1, "rgba(255, 255, 255, 0)"), t.fillStyle = n, t.arc(128, 128, 128, 0, Math.PI / 180, !0), t.fill(), (i = new r.Texture(e)).needsUpdate = !0, i
            },
            M = function() {
                c.width = window.innerWidth, c.height = window.innerHeight, f.aspect = window.innerWidth / window.innerHeight, f.updateProjectionMatrix(), u.setSize(window.innerWidth, window.innerHeight)
            },
            _ = function() {
                b ? g.x < 6 && (g.x += .02) : g.x > 1.5 && (g.x -= .1),
                    function() {
                        var t = 0;
                        if (Date.now() - x > 16 * g.x) {
                            for (var n = 0; n < d.length; n++) {
                                var i = d[n];
                                if (!i.is_active) {
                                    var o = e.getRadian(3 * e.getRandomInt(0, 120)),
                                        a = Math.log(e.getRandomInt(2, 128)) / Math.log(128) * 160 + 60,
                                        s = Math.sin(o) * a,
                                        c = Math.cos(o) * a,
                                        u = new r.Vector3(-1e3, s, c);
                                    if (u.add(h.velocity), i.activate(), i.init(u), i.a = 0, i.size = e.getRandomInt(5, 60), ++t >= Math.pow(3 * g.x, .4 * g.x)) break
                                }
                            }
                            x = Date.now()
                        }
                    }(),
                    function() {
                        for (var e = 0; e < d.length; e++) {
                            var t = d[e];
                            t.is_active && (t.time++, t.applyForce(g), t.applyDrag(.1), t.updateVelocity(), t.a < .8 && (t.a += .02), t.velocity.x > 1e3 && (t.init(new r.Vector3(0, 0, 0)), t.time = 0, t.a = 0, t.inactivate())), v[3 * e + 0] = t.velocity.x, v[3 * e + 1] = t.velocity.y, v[3 * e + 2] = t.velocity.z, m[e] = t.a, y[e] = t.size
                        }
                        h.updatePoints()
                    }(), f.force.position.applyHook(0, .008), f.force.position.applyDrag(.1), f.force.position.updateVelocity(), f.updatePosition(), f.lookAtCenter(), u.render(l, f)
            },
            S = function() {
                var e = new r.Vector2,
                    t = new r.Vector2,
                    n = new r.Vector2,
                    a = function(t, n, r) {
                        e.set(t, n), o(e), b = !0
                    },
                    s = function(e, n, r) {
                        t.set(e, n), o(t), f.force.position.anchor.z = 120 * t.x, f.force.position.anchor.y = -120 * t.y
                    },
                    u = function(e, t, r) {
                        n.set(e, t), f.force.position.anchor.z = 0, f.force.position.anchor.y = 0, b = !1
                    };
                window.addEventListener("resize", i((function() {
                    M()
                })), 1e3), c.addEventListener("mousedown", (function(e) {
                    e.preventDefault(), a(e.clientX, e.clientY)
                })), c.addEventListener("mousemove", (function(e) {
                    e.preventDefault(), s(e.clientX, e.clientY)
                })), c.addEventListener("mouseup", (function(e) {
                    e.preventDefault(), u(e.clientX, e.clientY)
                })), c.addEventListener("touchstart", (function(e) {
                    e.preventDefault(), a(e.touches[0].clientX, e.touches[0].clientY)
                })), c.addEventListener("touchmove", (function(e) {
                    e.preventDefault(), s(e.touches[0].clientX, e.touches[0].clientY)
                })), c.addEventListener("touchend", (function(e) {
                    e.preventDefault(), u(e.changedTouches[0].clientX, e.changedTouches[0].clientY)
                })), window.addEventListener("mouseout", (function() {
                    event.preventDefault(), n.set(0, 0), f.force.position.anchor.z = 0, f.force.position.anchor.y = 0
                }))
            };
        u.setSize(window.innerWidth, window.innerHeight), u.setClearColor(0, 1), f.position.set(1e3, 1e3, 1e3), f.lookAt(new r.Vector3), S(),
            function() {
                for (var i = 0; i < 2e4; i++) {
                    var o = new t,
                        a = e.getRandomInt(60, 210),
                        s = e.getRandomInt(30, 90),
                        c = new r.Color("hsl(" + a + ", " + s + "%, 50%)");
                    o.init(new r.Vector3(e.getRandomInt(-100, 100), 0, 0)), d.push(o), v[3 * i + 0] = o.velocity.x, v[3 * i + 1] = o.velocity.y, v[3 * i + 2] = o.velocity.z, c.toArray(p, 3 * i), m[i] = o.a, y[i] = o.size
                }
                h.init({
                    scene: l,
                    vs: n(73).default,
                    fs: n(74).default,
                    positions: v,
                    colors: p,
                    opacities: m,
                    sizes: y,
                    texture: w(),
                    blending: r.AdditiveBlending
                }), f.force.position.anchor.set(800, 0, 0)
            }(), M(),
            function e() {
                _(), requestAnimationFrame(e)
            }()
    }
}, function(e, t, n) {
    "use strict";
    n.r(t);
    var r = n(0),
        i = n(3),
        o = n(15).default;
    t.default = function() {
        var e = n(16),
            t = n(71),
            a = n(72),
            s = n(152),
            c = n(33),
            u = document.getElementById("canvas-webgl"),
            l = new r.WebGLRenderer({
                antialias: !0,
                canvas: u
            }),
            f = new r.Scene,
            d = new c(35, window.innerWidth / window.innerHeight, 1, 1e4),
            h = (new r.Clock, []),
            v = new a,
            p = new s(16737792, 1, 1800, 1),
            m = new Float32Array(3e4),
            y = new Float32Array(3e4),
            g = new Float32Array(1e4),
            x = new Float32Array(1e4),
            b = new r.Vector3(0, .1, 0),
            w = null,
            M = Date.now(),
            _ = !1,
            S = function(e) {
                var t = e.y * window.innerHeight / 3,
                    n = e.x * window.innerWidth / -3;
                v.anchor.y = t, v.anchor.z = n, p.force.anchor.y = t, p.force.anchor.z = n
            },
            P = function() {
                var e = document.createElement("canvas"),
                    t = e.getContext("2d"),
                    n = null,
                    i = null;
                return e.width = 200, e.height = 200, (n = t.createRadialGradient(100, 100, 20, 100, 100, 100)).addColorStop(.2, "rgba(255, 255, 255, 1)"), n.addColorStop(.5, "rgba(255, 255, 255, 0.3)"), n.addColorStop(1, "rgba(255, 255, 255, 0)"), t.fillStyle = n, t.arc(100, 100, 100, 0, Math.PI / 180, !0), t.fill(), (i = new r.Texture(e)).minFilter = r.NearestFilter, i.needsUpdate = !0, i
            },
            T = function() {
                for (var i = 0; i < 1e4; i++) {
                    var o = new t,
                        a = e.getRandomInt(0, 45),
                        s = e.getRandomInt(60, 90),
                        c = new r.Color("hsl(" + a + ", " + s + "%, 50%)");
                    o.init(new r.Vector3(e.getRandomInt(-100, 100), 0, 0)), h.push(o), m[3 * i + 0] = o.velocity.x, m[3 * i + 1] = o.velocity.y, m[3 * i + 2] = o.velocity.z, c.toArray(y, 3 * i), g[i] = o.a, x[i] = o.size
                }
                var u, l;
                v.init({
                    scene: f,
                    vs: n(73).default,
                    fs: n(74).default,
                    positions: m,
                    colors: y,
                    opacities: g,
                    sizes: x,
                    texture: P(),
                    blending: r.AdditiveBlending
                }), f.add(p), u = new r.OctahedronGeometry(1500, 3), l = new r.MeshPhongMaterial({
                    color: 16777215,
                    flatShading: !0,
                    side: r.BackSide
                }), w = new r.Mesh(u, l), f.add(w), d.setPolarCoord(e.getRadian(25), 0, 1e3), p.setPolarCoord(e.getRadian(25), 0, 200)
            },
            E = function() {
                u.width = window.innerWidth, u.height = window.innerHeight, d.aspect = window.innerWidth / window.innerHeight, d.updateProjectionMatrix(), l.setSize(window.innerWidth, window.innerHeight)
            },
            z = function() {
                v.applyHook(0, .08), v.applyDrag(.2), v.updateVelocity(), p.force.applyHook(0, .08), p.force.applyDrag(.2), p.force.updateVelocity(), p.updatePosition(),
                    function() {
                        var t = 0;
                        if (Date.now() - M > 10) {
                            for (var n = 0; n < h.length; n++) {
                                var i = h[n];
                                if (!i.is_active) {
                                    var o = e.getRadian(Math.log(e.getRandomInt(0, 256)) / Math.log(256) * 260),
                                        a = e.getRadian(e.getRandomInt(0, 360)),
                                        s = 12 * (1 - Math.log(e.getRandomInt(32, 256)) / Math.log(256)),
                                        c = new r.Vector3,
                                        u = e.getPolarCoord(o, a, s);
                                    if (c.add(v.velocity), i.activate(), i.init(c), i.applyForce(u), i.a = .2, i.size = Math.pow(12 - s, 2) * e.getRandomInt(1, 24) / 10, ++t >= 6) break
                                }
                            }
                            M = Date.now()
                        }
                    }(),
                    function() {
                        for (var e = 0; e < h.length; e++) {
                            var t = h[e];
                            t.is_active && (t.time++, t.applyForce(b), t.applyDrag(.01), t.updateVelocity(), t.time > 50 && (t.size -= .7, t.a -= .009), t.a <= 0 && (t.init(new r.Vector3(0, 0, 0)), t.time = 0, t.a = 0, t.inactivate())), m[3 * e + 0] = t.velocity.x - v.velocity.x, m[3 * e + 1] = t.velocity.y - v.velocity.y, m[3 * e + 2] = t.velocity.z - v.velocity.z, g[e] = t.a, x[e] = t.size
                        }
                        v.updatePoints()
                    }(), d.force.position.applyHook(0, .004), d.force.position.applyDrag(.1), d.force.position.updateVelocity(), d.updatePosition(), d.lookAtCenter(), l.render(f, d)
            },
            L = function() {
                var e = new r.Vector2,
                    t = new r.Vector2,
                    n = new r.Vector2,
                    a = function(t, n, r) {
                        e.set(t, n), o(e), S(e), _ = !0
                    },
                    s = function(e, n, r) {
                        t.set(e, n), o(t), _ && S(t)
                    },
                    c = function(e, t, r) {
                        n.set(e, t), _ = !1, v.anchor.set(0, 0, 0), p.force.anchor.set(0, 0, 0)
                    };
                window.addEventListener("resize", i((function() {
                    E()
                })), 1e3), u.addEventListener("mousedown", (function(e) {
                    e.preventDefault(), a(e.clientX, e.clientY)
                })), u.addEventListener("mousemove", (function(e) {
                    e.preventDefault(), s(e.clientX, e.clientY)
                })), u.addEventListener("mouseup", (function(e) {
                    e.preventDefault(), c(e.clientX, e.clientY)
                })), u.addEventListener("touchstart", (function(e) {
                    e.preventDefault(), a(e.touches[0].clientX, e.touches[0].clientY)
                })), u.addEventListener("touchmove", (function(e) {
                    e.preventDefault(), s(e.touches[0].clientX, e.touches[0].clientY)
                })), u.addEventListener("touchend", (function(e) {
                    e.preventDefault(), c(e.changedTouches[0].clientX, e.changedTouches[0].clientY)
                })), window.addEventListener("mouseout", (function() {
                    event.preventDefault(), n.set(0, 0), _ = !1, v.anchor.set(0, 0, 0), p.force.anchor.set(0, 0, 0)
                }))
            };
        l.setSize(window.innerWidth, window.innerHeight), l.setClearColor(0, 1), d.position.set(1e3, 1e3, 1e3), d.lookAt(new r.Vector3), L(), T(), E(),
            function e() {
                z(), requestAnimationFrame(e)
            }()
    }
}, function(e, t, n) {
    "use strict";
    n.r(t);
    var r = n(0),
        i = n(3),
        o = n.n(i),
        a = n(1),
        s = n.n(a),
        c = (n(12), n(4)),
        u = n(47);

    function l(e) {
        return (l = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
            return typeof e
        } : function(e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
        })(e)
    }

    function f(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }

    function d(e, t) {
        return !t || "object" !== l(t) && "function" != typeof t ? function(e) {
            if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return e
        }(e) : t
    }

    function h(e) {
        return (h = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
            return e.__proto__ || Object.getPrototypeOf(e)
        })(e)
    }

    function v(e, t) {
        return (v = Object.setPrototypeOf || function(e, t) {
            return e.__proto__ = t, e
        })(e, t)
    }
    var p = function(e, t, n) {
            t.multiplyScalar(1 / n), e.add(t)
        },
        m = function(e, t, n) {
            n.copy(e.clone().multiplyScalar(-1)).normalize().multiplyScalar(e.length() * t), e.add(n)
        },
        y = function(e, t, n, r, i, o) {
            o.copy(e.clone().sub(n));
            var a = o.length() - r;
            o.normalize().multiplyScalar(-1 * i * a), t.add(o)
        },
        g = function(e) {
            function t(e, n, i, o) {
                var a;
                return function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, t), (a = d(this, h(t).call(this, e, n, i, o))).cameraResolution = new r.Vector2, a.drag = new r.Vector3, a.hook = new r.Vector3, a.k = .02, a.d = .3, a.velocity = new r.Vector3, a.acceleration = new r.Vector3, a.anchor = new r.Vector3, a.lookK = .02, a.lookD = .3, a.lookVelocity = new r.Vector3, a.lookAcceleration = new r.Vector3, a.lookAnchor = new r.Vector3, a
            }
            var n, i, o;
            return function(e, t) {
                if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
                e.prototype = Object.create(t && t.prototype, {
                    constructor: {
                        value: e,
                        writable: !0,
                        configurable: !0
                    }
                }), t && v(e, t)
            }(t, e), n = t, (i = [{
                key: "start",
                value: function() {
                    this.aspect = 1.5, this.far = 1e3, this.setFocalLength(50), this.position.set(0, 0, 50), this.lookAt(new r.Vector3)
                }
            }, {
                key: "update",
                value: function() {
                    y(this.velocity, this.acceleration, this.anchor, 0, this.k, this.hook), m(this.acceleration, this.d, this.drag), p(this.velocity, this.acceleration, 1), y(this.lookVelocity, this.lookAcceleration, this.lookAnchor, 0, this.lookK, this.hook), m(this.lookAcceleration, this.lookD, this.drag), p(this.lookVelocity, this.lookAcceleration, 1), this.position.copy(this.velocity), this.lookAt(this.lookVelocity)
                }
            }, {
                key: "resize",
                value: function(e) {
                    e.x > e.y ? this.cameraResolution.set(e.x >= 1200 ? 1200 : e.x, e.x >= 1200 ? 800 : .66 * e.x) : this.cameraResolution.set(.6 * (e.y >= 1200 ? 800 : .66 * e.y), .6 * (e.y >= 1200 ? 1200 : e.y)), this.setViewOffset(this.cameraResolution.x, this.cameraResolution.y, (e.x - this.cameraResolution.x) / -2, (e.y - this.cameraResolution.y) / -2, e.x, e.y), this.updateProjectionMatrix()
                }
            }]) && f(n.prototype, i), o && f(n, o), t
        }(r.PerspectiveCamera),
        x = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\n\nvoid main(void) {\n  // coordinate transformation\n  vec4 mPosition = modelMatrix * vec4(position, 1.0);\n\n  vPosition = mPosition.xyz;\n  vUv = uv;\n\n  gl_Position = projectionMatrix * viewMatrix * mPosition;\n}\n",
        b = "precision highp float;\n#define GLSLIFY 1\n\nuniform vec3 hsv;\nuniform float time;\nuniform sampler2D normalMap;\nuniform sampler2D surfaceTex;\nuniform sampler2D fogTex;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\n\nvec3 convertHsvToRgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Get normal vector from the normal map.\n  vec3 n = texture2D(normalMap, vUv).xyz;\n\n  // Flat Shading\n  vec3 light = normalize(vec3(-1.0, 1.0, -1.0));\n  vec3 normal = normalize(cross(dFdx(vPosition), dFdy(vPosition)));\n  float diff = (dot(normal + n, light) + 1.0) / 2.0;\n\n  // the pointyness color\n  vec3 surface = texture2D(surfaceTex, vUv).rgb;\n  vec4 fog1 = texture2D(fogTex, vUv + vec2(0.0, time * 0.06));\n  vec4 fog2 = texture2D(fogTex, vUv + vec2(0.0, time * -0.03));\n  vec4 fog3 = texture2D(fogTex, vUv + vec2(0.0, time * 0.03));\n  vec4 fog4 = texture2D(fogTex, vUv + vec2(0.0, time * -0.06));\n\n  vec3 rgb = convertHsvToRgb(hsv + vec3((fog3.r + fog4.r - 1.0) * 0.16, (1.0 - surface.r) * 0.05, surface.r + (fog1.r + fog2.g - 1.0) + 0.5));\n  vec3 color = rgb;\n\n  gl_FragColor = vec4(color, 1.0);\n}\n";

    function w(e) {
        return (w = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
            return typeof e
        } : function(e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
        })(e)
    }

    function M(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }

    function _(e, t) {
        return !t || "object" !== w(t) && "function" != typeof t ? function(e) {
            if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return e
        }(e) : t
    }

    function S(e) {
        return (S = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
            return e.__proto__ || Object.getPrototypeOf(e)
        })(e)
    }

    function P(e, t) {
        return (P = Object.setPrototypeOf || function(e, t) {
            return e.__proto__ = t, e
        })(e, t)
    }
    var T = function(e) {
            function t(e) {
                var n;
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, t);
                var i = new r.RawShaderMaterial({
                    uniforms: {
                        time: {
                            type: "f",
                            value: 0
                        },
                        hsv: {
                            type: "v3",
                            value: new r.Vector3
                        },
                        normalMap: {
                            type: "t",
                            value: null
                        },
                        surfaceTex: {
                            type: "t",
                            value: null
                        },
                        fogTex: {
                            type: "t",
                            value: null
                        }
                    },
                    vertexShader: x,
                    fragmentShader: b,
                    flatShading: !0
                });
                return (n = _(this, S(t).call(this, e, i))).name = "Mesh", n.rotation.set(s.a.radians(30 * (2 * Math.random() - 1)), 0, s.a.radians(30 * (2 * Math.random() - 1))), n.axisBodyRotate = (new r.Vector3).copy(n.up).applyEuler(n.rotation), n.quaternionPrev = new r.Quaternion, n
            }
            var n, i, o;
            return function(e, t) {
                if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
                e.prototype = Object.create(t && t.prototype, {
                    constructor: {
                        value: e,
                        writable: !0,
                        configurable: !0
                    }
                }), t && P(e, t)
            }(t, e), n = t, (i = [{
                key: "start",
                value: function(e, t, n, r) {
                    this.material.uniforms.hsv.value.set(e, .65, 0), this.material.uniforms.normalMap.value = t, this.material.uniforms.surfaceTex.value = n, this.material.uniforms.fogTex.value = r
                }
            }, {
                key: "update",
                value: function(e) {
                    this.material.uniforms.time.value += e, this.quaternionPrev.copy(this.quaternion), this.quaternion.setFromAxisAngle(this.axisBodyRotate, .1 * e).multiply(this.quaternionPrev)
                }
            }]) && M(n.prototype, i), o && M(n, o), t
        }(r.Mesh),
        E = "#define GLSLIFY 1\nattribute vec3 position;\nattribute float delay;\nattribute float speed;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform float time;\nuniform float pixelRatio;\nuniform float hex;\n\nvarying vec3 vColor;\nvarying float vOpacity;\n\nvec3 convertHsvToRgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nmat4 calcRotateMat4X(float radian) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, cos(radian), -sin(radian), 0.0,\n    0.0, sin(radian), cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4Y(float radian) {\n  return mat4(\n    cos(radian), 0.0, sin(radian), 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    -sin(radian), 0.0, cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4Z(float radian) {\n  return mat4(\n    cos(radian), -sin(radian), 0.0, 0.0,\n    sin(radian), cos(radian), 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4(vec3 radian) {\n  return calcRotateMat4X(radian.x) * calcRotateMat4Y(radian.y) * calcRotateMat4Z(radian.z);\n}\n\nconst float duration = 3.0;\n\nvoid main() {\n  // calculate interval time from 0 to 1\n  float interval = mod(time + delay * duration, duration) / duration;\n\n  // update position and size\n  float size = 3.0 * sin(interval * 4.0);\n  float blink = max(\n    (sin(interval * 4.0) + cos(interval * 27.0) * 0.3 + cos(interval * 36.0) * 0.2) / 1.5 * 2.0 - 1.0,\n    0.0\n    );\n  mat4 rotateMat = calcRotateMat4(vec3(\n    radians(time * speed * 0.3),\n    radians(time * speed),\n    radians(time * speed * 0.3)\n    ));\n\n  // calculate colors\n  vec3 hsv = vec3(hex, 0.6, 1.0);\n  vec3 rgb = convertHsvToRgb(hsv);\n\n  // coordinate transformation\n  vec4 mvPosition = modelViewMatrix * rotateMat * vec4(position, 1.0);\n  float distanceFromCamera = 35.0 / length(mvPosition.xyz);\n\n  vColor = rgb;\n  vOpacity = blink * clamp(distanceFromCamera, 0.5, 1.0);\n\n  gl_Position = projectionMatrix * mvPosition;\n  gl_PointSize = distanceFromCamera * pixelRatio * size;\n}\n",
        z = "precision highp float;\n#define GLSLIFY 1\n\nuniform sampler2D texture;\n\nvarying vec3 vColor;\nvarying float vOpacity;\n\nvoid main() {\n  // convert PointCoord to range from -1.0 to 1.0\n  vec2 p = gl_PointCoord * 2.0 - 1.0;\n\n  // draw double circle\n  float r = (1.0 - smoothstep(0.95, 1.0, length(p)));\n\n  gl_FragColor = vec4(vColor * r, vOpacity);\n}\n";

    function L(e) {
        return (L = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
            return typeof e
        } : function(e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
        })(e)
    }

    function A(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }

    function C(e, t) {
        return !t || "object" !== L(t) && "function" != typeof t ? function(e) {
            if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return e
        }(e) : t
    }

    function R(e) {
        return (R = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
            return e.__proto__ || Object.getPrototypeOf(e)
        })(e)
    }

    function O(e, t) {
        return (O = Object.setPrototypeOf || function(e, t) {
            return e.__proto__ = t, e
        })(e, t)
    }
    var j = 500,
        I = function(e) {
            function t() {
                var e;
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, t);
                for (var n = new r.BufferGeometry, i = new r.BufferAttribute(new Float32Array(3 * j), 3), o = new r.BufferAttribute(new Float32Array(j), 1, 1), a = new r.BufferAttribute(new Float32Array(j), 1, 1), c = 0, u = j; c < u; c++) {
                    var l = s.a.radians(s.a.randomArbitrary(0, 150) - 75),
                        f = s.a.radians(s.a.randomArbitrary(0, 360)),
                        d = Math.random() * Math.random() * 4 + 2,
                        h = s.a.spherical(l, f, d);
                    i.setXYZ(c, h[0], h[1], h[2]), o.setXYZ(c, Math.random()), a.setXYZ(c, s.a.randomArbitrary(1, 10) * (2 * s.a.randomInt(0, 1) - 1))
                }
                n.addAttribute("position", i), n.addAttribute("delay", o), n.addAttribute("speed", a);
                var v = new r.RawShaderMaterial({
                    uniforms: {
                        time: {
                            type: "f",
                            value: 0
                        },
                        pixelRatio: {
                            type: "f",
                            value: window.devicePixelRatio
                        },
                        hex: {
                            type: "f",
                            value: 0
                        }
                    },
                    vertexShader: E,
                    fragmentShader: z,
                    transparent: !0,
                    depthWrite: !1,
                    blending: r.AdditiveBlending
                });
                return (e = C(this, R(t).call(this, n, v))).name = "CrystalSparkle", e
            }
            var n, i, o;
            return function(e, t) {
                if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
                e.prototype = Object.create(t && t.prototype, {
                    constructor: {
                        value: e,
                        writable: !0,
                        configurable: !0
                    }
                }), t && O(e, t)
            }(t, e), n = t, (i = [{
                key: "start",
                value: function(e) {
                    this.material.uniforms.hex.value = e
                }
            }, {
                key: "update",
                value: function(e) {
                    this.material.uniforms.time.value += e
                }
            }]) && A(n.prototype, i), o && A(n, o), t
        }(r.Points),
        D = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\n\nvoid main(void) {\n  // coordinate transformation\n  vec4 mPosition = modelMatrix * vec4(position, 1.0);\n\n  vPosition = position;\n  vUv = uv;\n\n  gl_Position = projectionMatrix * viewMatrix * mPosition;\n}\n",
        k = "precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\nuniform float hex;\nuniform sampler2D fogTex;\nuniform vec2 direction;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\n\nvec3 convertHsvToRgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  vec2 p = vUv * 2.0 - 1.0;\n\n  vec4 fog1 = texture2D(fogTex, vUv - direction * time * 0.05);\n  vec4 fog2 = texture2D(\n    fogTex,\n    vUv\n    + direction * time * 0.025\n    + vec2(\n      cos(radians(fog1.g * 360.0)) * 0.01 * cos(radians(fog1.b * 360.0)),\n      sin(radians(fog1.g * 360.0)) * 0.01 * cos(radians(fog1.b * 360.0))\n    )\n  );\n  float opacity = (pow(fog2.r, 2.0) - smoothstep(0.5, 1.0, abs(p.x)) - smoothstep(0.25, 1.0, abs(p.y)));\n\n  vec3 hsv = vec3(hex + fog2.b * 0.16, 0.9, 0.24);\n  vec3 rgb = convertHsvToRgb(hsv);\n\n  gl_FragColor = vec4(rgb, opacity);\n}\n";

    function F(e) {
        return (F = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
            return typeof e
        } : function(e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
        })(e)
    }

    function G(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }

    function N(e, t) {
        return !t || "object" !== F(t) && "function" != typeof t ? function(e) {
            if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return e
        }(e) : t
    }

    function B(e) {
        return (B = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
            return e.__proto__ || Object.getPrototypeOf(e)
        })(e)
    }

    function U(e, t) {
        return (U = Object.setPrototypeOf || function(e, t) {
            return e.__proto__ = t, e
        })(e, t)
    }
    var H = function(e) {
            function t() {
                var e;
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, t);
                var n = new r.PlaneBufferGeometry(55, 55),
                    i = new r.RawShaderMaterial({
                        uniforms: {
                            time: {
                                type: "f",
                                value: 0
                            },
                            hex: {
                                type: "f",
                                value: 0
                            },
                            fogTex: {
                                type: "t",
                                value: null
                            },
                            maskTex: {
                                type: "t",
                                value: null
                            },
                            direction: {
                                type: "v2",
                                value: new r.Vector2
                            }
                        },
                        vertexShader: D,
                        fragmentShader: k,
                        transparent: !0,
                        blending: r.AdditiveBlending,
                        depthWrite: !1
                    });
                (e = N(this, B(t).call(this, n, i))).name = "Fog";
                var o = s.a.radians(360 * Math.random());
                return e.material.uniforms.direction.value.set(Math.cos(o), Math.sin(o)), e
            }
            var n, i, o;
            return function(e, t) {
                if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
                e.prototype = Object.create(t && t.prototype, {
                    constructor: {
                        value: e,
                        writable: !0,
                        configurable: !0
                    }
                }), t && U(e, t)
            }(t, e), n = t, (i = [{
                key: "start",
                value: function(e, t, n) {
                    this.material.uniforms.hex.value = e, this.material.uniforms.fogTex.value = t, this.material.uniforms.maskTex.value = n
                }
            }, {
                key: "update",
                value: function(e) {
                    this.material.uniforms.time.value += e
                }
            }]) && G(n.prototype, i), o && G(n, o), t
        }(r.Mesh),
        V = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\n\nvarying vec2 vUv;\n\nvoid main(void) {\n  // coordinate transformation\n  vec4 mPosition = modelMatrix * vec4(position, 1.0);\n\n  vUv = uv;\n\n  gl_Position = projectionMatrix * viewMatrix * mPosition;\n}\n",
        W = "precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\nuniform float hex;\n\nvarying vec2 vUv;\nvarying vec3 vColor;\n\nvec3 convertHsvToRgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  vec3 rgb = mix(\n    convertHsvToRgb(vec3(hex, 0.6, 0.6)),\n    convertHsvToRgb(vec3(hex, 0.4, 0.2)),\n    vUv.y * 4.0 - 1.0\n    );\n\n  gl_FragColor = vec4(rgb, 1.0);\n}\n";

    function Y(e) {
        return (Y = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
            return typeof e
        } : function(e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
        })(e)
    }

    function X(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }

    function q(e, t) {
        return !t || "object" !== Y(t) && "function" != typeof t ? function(e) {
            if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return e
        }(e) : t
    }

    function K(e) {
        return (K = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
            return e.__proto__ || Object.getPrototypeOf(e)
        })(e)
    }

    function Z(e, t) {
        return (Z = Object.setPrototypeOf || function(e, t) {
            return e.__proto__ = t, e
        })(e, t)
    }
    var J = function(e) {
            function t() {
                var e;
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, t);
                var n = new r.SphereBufferGeometry(100, 12, 12),
                    i = new r.RawShaderMaterial({
                        uniforms: {
                            time: {
                                type: "f",
                                value: 0
                            },
                            hex: {
                                type: "f",
                                value: 0
                            }
                        },
                        vertexShader: V,
                        fragmentShader: W,
                        side: r.BackSide,
                        depthTest: !1
                    });
                return (e = q(this, K(t).call(this, n, i))).name = "Background", e
            }
            var n, i, o;
            return function(e, t) {
                if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
                e.prototype = Object.create(t && t.prototype, {
                    constructor: {
                        value: e,
                        writable: !0,
                        configurable: !0
                    }
                }), t && Z(e, t)
            }(t, e), n = t, (i = [{
                key: "start",
                value: function() {}
            }, {
                key: "update",
                value: function(e, t) {
                    this.material.uniforms.time.value += e, this.material.uniforms.hex.value = t
                }
            }]) && X(n.prototype, i), o && X(n, o), t
        }(r.Mesh),
        Q = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n\n  gl_Position = vec4(position, 1.0);\n}\n",
        $ = "precision highp float;\n#define GLSLIFY 1\n\nuniform float minBright;\nuniform sampler2D texture;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vec4 bright = max(vec4(0.0), (texture2D(texture, vUv) - minBright));\n  gl_FragColor = bright;\n}\n";

    function ee(e) {
        return (ee = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
            return typeof e
        } : function(e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
        })(e)
    }

    function te(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }

    function ne(e, t) {
        return !t || "object" !== ee(t) && "function" != typeof t ? function(e) {
            if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return e
        }(e) : t
    }

    function re(e) {
        return (re = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
            return e.__proto__ || Object.getPrototypeOf(e)
        })(e)
    }

    function ie(e, t) {
        return (ie = Object.setPrototypeOf || function(e, t) {
            return e.__proto__ = t, e
        })(e, t)
    }
    var oe = function(e) {
            function t() {
                var e;
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, t);
                var n = new r.PlaneBufferGeometry(2, 2),
                    i = new r.RawShaderMaterial({
                        uniforms: {
                            minBright: {
                                type: "f",
                                value: .5
                            },
                            texture: {
                                type: "t",
                                value: null
                            }
                        },
                        vertexShader: Q,
                        fragmentShader: $
                    });
                return (e = ne(this, re(t).call(this, n, i))).name = "PostEffectBright", e
            }
            var n, i, o;
            return function(e, t) {
                if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
                e.prototype = Object.create(t && t.prototype, {
                    constructor: {
                        value: e,
                        writable: !0,
                        configurable: !0
                    }
                }), t && ie(e, t)
            }(t, e), n = t, (i = [{
                key: "start",
                value: function(e) {
                    this.material.uniforms.texture.value = e
                }
            }]) && te(n.prototype, i), o && te(n, o), t
        }(r.Mesh),
        ae = "precision highp float;\n#define GLSLIFY 1\n\nuniform vec2 resolution;\nuniform vec2 direction;\nuniform sampler2D texture;\n\nvarying vec2 vUv;\n\nvec4 gaussianBlur(sampler2D texture, vec2 uv, float radius, vec2 resolution, vec2 direction) {\n  vec4 color = vec4(0.0);\n  vec2 step = radius / resolution * direction;\n  color += texture2D(texture, uv - 4.0 * step) * 0.02699548325659403;\n  color += texture2D(texture, uv - 3.0 * step) * 0.06475879783294587;\n  color += texture2D(texture, uv - 2.0 * step) * 0.12098536225957168;\n  color += texture2D(texture, uv - 1.0 * step) * 0.17603266338214976;\n  color += texture2D(texture, uv) * 0.19947114020071635;\n  color += texture2D(texture, uv + 1.0 * step) * 0.17603266338214976;\n  color += texture2D(texture, uv + 2.0 * step) * 0.12098536225957168;\n  color += texture2D(texture, uv + 3.0 * step) * 0.06475879783294587;\n  color += texture2D(texture, uv + 4.0 * step) * 0.02699548325659403;\n  return color;\n}\n\nvoid main() {\n  vec4 color = gaussianBlur(texture, vUv, 1.0, resolution, direction);\n  gl_FragColor = color;\n}\n";

    function se(e) {
        return (se = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
            return typeof e
        } : function(e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
        })(e)
    }

    function ce(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }

    function ue(e, t) {
        return !t || "object" !== se(t) && "function" != typeof t ? function(e) {
            if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return e
        }(e) : t
    }

    function le(e) {
        return (le = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
            return e.__proto__ || Object.getPrototypeOf(e)
        })(e)
    }

    function fe(e, t) {
        return (fe = Object.setPrototypeOf || function(e, t) {
            return e.__proto__ = t, e
        })(e, t)
    }
    var de = function(e) {
            function t() {
                var e;
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, t);
                var n = new r.PlaneBufferGeometry(2, 2),
                    i = new r.RawShaderMaterial({
                        uniforms: {
                            resolution: {
                                type: "v2",
                                value: new r.Vector2
                            },
                            direction: {
                                type: "v2",
                                value: new r.Vector2
                            },
                            texture: {
                                type: "t",
                                value: null
                            }
                        },
                        vertexShader: Q,
                        fragmentShader: ae
                    });
                return (e = ue(this, le(t).call(this, n, i))).name = "PostEffectBlur", e
            }
            var n, i, o;
            return function(e, t) {
                if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
                e.prototype = Object.create(t && t.prototype, {
                    constructor: {
                        value: e,
                        writable: !0,
                        configurable: !0
                    }
                }), t && fe(e, t)
            }(t, e), n = t, (i = [{
                key: "start",
                value: function(e, t, n) {
                    this.material.uniforms.texture.value = e, this.material.uniforms.direction.value.set(t, n)
                }
            }, {
                key: "resize",
                value: function(e, t) {
                    this.material.uniforms.resolution.value.set(e, t)
                }
            }]) && ce(n.prototype, i), o && ce(n, o), t
        }(r.Mesh),
        he = "precision highp float;\n#define GLSLIFY 1\n\nuniform sampler2D texture1;\nuniform sampler2D texture2;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vec4 color1 = texture2D(texture1, vUv);\n  vec4 color2 = texture2D(texture2, vUv);\n  gl_FragColor = color1 + color2;\n}\n";

    function ve(e) {
        return (ve = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
            return typeof e
        } : function(e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
        })(e)
    }

    function pe(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }

    function me(e, t) {
        return !t || "object" !== ve(t) && "function" != typeof t ? function(e) {
            if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return e
        }(e) : t
    }

    function ye(e) {
        return (ye = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
            return e.__proto__ || Object.getPrototypeOf(e)
        })(e)
    }

    function ge(e, t) {
        return (ge = Object.setPrototypeOf || function(e, t) {
            return e.__proto__ = t, e
        })(e, t)
    }
    var xe, be = function(e) {
        function t() {
            var e;
            ! function(e, t) {
                if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
            }(this, t);
            var n = new r.PlaneBufferGeometry(2, 2),
                i = new r.RawShaderMaterial({
                    uniforms: {
                        texture1: {
                            type: "t",
                            value: null
                        },
                        texture2: {
                            type: "t",
                            value: null
                        }
                    },
                    vertexShader: Q,
                    fragmentShader: he
                });
            return (e = me(this, ye(t).call(this, n, i))).name = "PostEffectBloom", e
        }
        var n, i, o;
        return function(e, t) {
            if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
            e.prototype = Object.create(t && t.prototype, {
                constructor: {
                    value: e,
                    writable: !0,
                    configurable: !0
                }
            }), t && ge(e, t)
        }(t, e), n = t, (i = [{
            key: "start",
            value: function(e, t) {
                this.material.uniforms.texture1.value = e, this.material.uniforms.texture2.value = t
            }
        }]) && pe(n.prototype, i), o && pe(n, o), t
    }(r.Mesh);

    function we(e, t, n, r, i, o, a) {
        try {
            var s = e[o](a),
                c = s.value
        } catch (e) {
            return void n(e)
        }
        s.done ? t(c) : Promise.resolve(c).then(r, i)
    }

    function Me(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }
    var _e = new r.Scene,
        Se = new g,
        Pe = new r.Clock({
            autoStart: !1
        }),
        Te = new r.WebGLRenderTarget,
        Ee = new r.WebGLRenderTarget,
        ze = new r.WebGLRenderTarget,
        Le = new r.Scene,
        Ae = new r.OrthographicCamera(-1, 1, 1, -1, 1, 2),
        Ce = [],
        Re = [],
        Oe = [],
        je = new r.Vector3,
        Ie = new r.Vector3,
        De = new J,
        ke = new oe,
        Fe = new de,
        Ge = new de,
        Ne = new be,
        Be = function() {
            function e() {
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, e)
            }
            var t, n, i, o, a;
            return t = e, (n = [{
                key: "start",
                value: (o = regeneratorRuntime.mark((function e(t) {
                    var n, i, o, a, l, f, d, h;
                    return regeneratorRuntime.wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return (xe = new r.WebGLRenderer({
                                    alpha: !0,
                                    antialias: !0,
                                    canvas: t
                                })).setPixelRatio(window.devicePixelRatio), xe.setClearColor(921102, 1), Se.start(), ke.start(Te.texture), Fe.start(Ee.texture, 1, 0), Ge.start(ze.texture, 0, 1), Ne.start(Te.texture, Ee.texture), e.next = 10, Promise.all([Object(u.default)("/sketch-threejs/model/crystal/crystal.obj"), Object(c.default)("/sketch-threejs/img/sketch/crystal/normal.jpg"), Object(c.default)("/sketch-threejs/img/sketch/crystal/surface.jpg"), Object(c.default)("/sketch-threejs/img/sketch/crystal/fog.jpg")]).then((function(e) {
                                    n = e[0].children.map((function(e) {
                                        return e.geometry
                                    })), i = e[1], o = e[2], (a = e[3]).wrapS = r.RepeatWrapping, a.wrapT = r.RepeatWrapping
                                })).catch((function(e) {
                                    console.log(e)
                                }));
                            case 10:
                                for (l = 0; l < 20; l++) f = s.a.radians(l / 20 * 360), Ce[l] = new T(n[l % 3]), Ce[l].position.set(35 * Math.cos(f), 0, 35 * Math.sin(f)), Ce[l].start(l / 20, i, o, a), _e.add(Ce[l]), Re[l] = new I, Re[l].position.copy(Ce[l].position), Re[l].start(l / 20), _e.add(Re[l]);
                                for (l = 0; l < 40; l++) d = s.a.radians(l / 40 * 360), h = s.a.radians(l / 40 * -360 - 90), Oe[l] = new H, Oe[l].position.set(100 * Math.cos(d), -18 - 8 * Math.sin(s.a.radians(l / 40 * 360 * 8)), 100 * Math.sin(d)), Oe[l].rotation.set(0, h, 0), Oe[l].start(l / 40, a), _e.add(Oe[l]);
                                _e.add(De), je.copy(Ce[0].position);
                            case 14:
                            case "end":
                                return e.stop()
                        }
                    }), e)
                })), a = function() {
                    var e = this,
                        t = arguments;
                    return new Promise((function(n, r) {
                        var i = o.apply(e, t);

                        function a(e) {
                            we(i, n, r, a, s, "next", e)
                        }

                        function s(e) {
                            we(i, n, r, a, s, "throw", e)
                        }
                        a(void 0)
                    }))
                }, function(e) {
                    return a.apply(this, arguments)
                })
            }, {
                key: "stop",
                value: function() {
                    this.pause()
                }
            }, {
                key: "play",
                value: function(e) {
                    Pe.start(), this.update(e)
                }
            }, {
                key: "pause",
                value: function() {
                    Pe.stop()
                }
            }, {
                key: "update",
                value: function(e) {
                    if (!1 !== Pe.running) {
                        for (var t = Pe.getDelta(), n = 0; n < Ce.length; n++) Ce[n].update(t), Re[n].update(t);
                        for (n = 0; n < Oe.length; n++) Oe[n].update(t);
                        De.update(t, Math.atan2(Se.lookVelocity.z, Se.lookVelocity.x) / s.a.radians(360)), je.set(Math.cos(s.a.radians(.6 * -e.anchor.x)), 0, Math.sin(s.a.radians(.6 * -e.anchor.x))), Se.lookAnchor.copy(je.clone().add(Ie.clone().applyQuaternion(Se.quaternion))), Se.update(), xe.setRenderTarget(Te), xe.render(_e, Se), Le.add(ke), xe.setRenderTarget(Ee), xe.render(Le, Ae), Le.remove(ke), Le.add(Fe), xe.setRenderTarget(ze), xe.render(Le, Ae), Le.remove(Fe), Le.add(Ge), xe.setRenderTarget(Ee), xe.render(Le, Ae), Le.remove(Ge), Le.add(Ne), xe.setRenderTarget(null), xe.render(Le, Ae), Le.remove(Ne)
                    }
                }
            }, {
                key: "resize",
                value: function(e) {
                    Se.resize(e), xe.setSize(e.x, e.y), Te.setSize(e.x * xe.getPixelRatio(), e.y * xe.getPixelRatio()), Ee.setSize(e.x * xe.getPixelRatio(), e.y * xe.getPixelRatio()), ze.setSize(e.x * xe.getPixelRatio(), e.y * xe.getPixelRatio()), Ge.resize(e.x / 3, e.y / 3), Fe.resize(e.x / 3, e.y / 3)
                }
            }, {
                key: "pan",
                value: function(e) {
                    Ie.copy(e)
                }
            }]) && Me(t.prototype, n), i && Me(t, i), e
        }();

    function Ue(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }
    var He = function() {
        function e(t) {
            ! function(e, t) {
                if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
            }(this, e), this.resolution = t, this.vTouchStart = new r.Vector2, this.vPrev = new r.Vector2, this.v = new r.Vector2, this.a = new r.Vector2, this.anchor = new r.Vector2, this.isTouched = !1
        }
        var t, n, i;
        return t = e, (n = [{
            key: "update",
            value: function() {
                this.a.set((this.anchor.x - this.v.x) / 10, (this.anchor.y - this.v.y) / 10), this.v.add(this.a)
            }
        }, {
            key: "touchStart",
            value: function(e) {
                e.touches || e.preventDefault(), this.vPrev.copy(this.v), this.a.set(0, 0), this.vTouchStart.set(e.touches ? e.touches[0].clientX : e.clientX, e.touches ? e.touches[0].clientY : e.clientY), this.isTouched = !0
            }
        }, {
            key: "touchMove",
            value: function(e) {
                e.preventDefault();
                var t = e.touches ? e.touches[0].clientX : e.clientX,
                    n = e.touches ? e.touches[0].clientY : e.clientY;
                !1 !== this.isTouched && this.anchor.set((t - this.vTouchStart.x) / (this.resolution.x / 200) + this.vPrev.x, s.a.clamp((n - this.vTouchStart.y) / (this.resolution.y / 200) + this.vPrev.y, -90, 90))
            }
        }, {
            key: "touchEnd",
            value: function(e) {
                this.isTouched = !1
            }
        }]) && Ue(t.prototype, n), i && Ue(t, i), e
    }();

    function Ve(e, t, n, r, i, o, a) {
        try {
            var s = e[o](a),
                c = s.value
        } catch (e) {
            return void n(e)
        }
        s.done ? t(c) : Promise.resolve(c).then(r, i)
    }
    t.default = function() {
        return We.apply(this, arguments)
    };

    function We() {
        var e;
        return e = regeneratorRuntime.mark((function e() {
            var t, n, i, a, s, c, u, l, f, d, h, v;
            return regeneratorRuntime.wrap((function(e) {
                for (;;) switch (e.prev = e.next) {
                    case 0:
                        return t = new Be, n = new r.Vector2, i = new r.Vector3, a = document.getElementById("canvas-webgl"), s = document.querySelector(".p-preloader"), c = new He(n), u = function() {
                            n.set(document.body.clientWidth, window.innerHeight), a.width = n.x, a.height = n.y, t.resize(n)
                        }, l = function(e) {
                            c.touchStart(e)
                        }, f = function(e) {
                            c.touchMove(e)
                        }, d = function(e) {
                            c.touchEnd(e)
                        }, h = function() {
                            a.addEventListener("mousedown", l, {
                                passive: !1
                            }), window.addEventListener("mousemove", (function(e) {
                                f(e), i.set(.1 * (e.clientX / n.x * 2 - 1), .1 * (-e.clientY / n.y * 2 + 1), 0), t.pan(i)
                            })), document.addEventListener("mouseleave", (function(e) {
                                i.set(0, 0, 0), t.pan(i)
                            })), window.addEventListener("mouseup", d), a.addEventListener("touchstart", l, {
                                passive: !1
                            }), window.addEventListener("touchmove", f, {
                                passive: !1
                            }), window.addEventListener("touchend", d), window.addEventListener("resize", o()(u, 100))
                        }, v = function e() {
                            c.update(n), t.update(c), requestAnimationFrame(e)
                        }, e.next = 14, t.start(a);
                    case 14:
                        h(), u(), s.classList.add("is-hidden"), t.play(c), v();
                    case 19:
                    case "end":
                        return e.stop()
                }
            }), e)
        })), (We = function() {
            var t = this,
                n = arguments;
            return new Promise((function(r, i) {
                var o = e.apply(t, n);

                function a(e) {
                    Ve(o, r, i, a, s, "next", e)
                }

                function s(e) {
                    Ve(o, r, i, a, s, "throw", e)
                }
                a(void 0)
            }))
        }).apply(this, arguments)
    }
}, function(e, t, n) {
    "use strict";
    n.r(t);
    var r = n(0),
        i = n(3),
        o = n.n(i),
        a = (n(12), n(47)),
        s = n(4);

    function c(e) {
        return (c = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
            return typeof e
        } : function(e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
        })(e)
    }

    function u(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }

    function l(e, t) {
        return !t || "object" !== c(t) && "function" != typeof t ? function(e) {
            if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return e
        }(e) : t
    }

    function f(e) {
        return (f = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
            return e.__proto__ || Object.getPrototypeOf(e)
        })(e)
    }

    function d(e, t) {
        return (d = Object.setPrototypeOf || function(e, t) {
            return e.__proto__ = t, e
        })(e, t)
    }
    var h = function(e) {
            function t(e, n, r, i) {
                var o;
                return function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, t), (o = l(this, f(t).call(this, e, n, r, i))).time = 0, o.isActive = !1, o
            }
            var n, i, o;
            return function(e, t) {
                if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
                e.prototype = Object.create(t && t.prototype, {
                    constructor: {
                        value: e,
                        writable: !0,
                        configurable: !0
                    }
                }), t && d(e, t)
            }(t, e), n = t, (i = [{
                key: "start",
                value: function() {
                    this.aspect = 1.5, this.far = 1e3, this.setFocalLength(50), this.position.set(0, 10, 40), this.lookAt(new r.Vector3(0, 0, 0)), this.isActive = !0
                }
            }, {
                key: "update",
                value: function(e) {
                    !1 !== this.isActive && (this.time += e)
                }
            }, {
                key: "resize",
                value: function(e) {
                    this.aspect = e.x / e.y, this.updateProjectionMatrix()
                }
            }]) && u(n.prototype, i), o && u(n, o), t
        }(r.PerspectiveCamera),
        v = n(1),
        p = n.n(v);

    function m(e) {
        return (m = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
            return typeof e
        } : function(e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
        })(e)
    }

    function y(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }

    function g(e, t) {
        return !t || "object" !== m(t) && "function" != typeof t ? function(e) {
            if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return e
        }(e) : t
    }

    function x(e) {
        return (x = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
            return e.__proto__ || Object.getPrototypeOf(e)
        })(e)
    }

    function b(e, t) {
        return (b = Object.setPrototypeOf || function(e, t) {
            return e.__proto__ = t, e
        })(e, t)
    }
    var w = function(e) {
            function t(e, n, r, i) {
                var o;
                return function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, t), (o = g(this, x(t).call(this, e, n, r, i))).distance = 0, o
            }
            var n, i, o;
            return function(e, t) {
                if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
                e.prototype = Object.create(t && t.prototype, {
                    constructor: {
                        value: e,
                        writable: !0,
                        configurable: !0
                    }
                }), t && b(e, t)
            }(t, e), n = t, (i = [{
                key: "start",
                value: function() {
                    this.aspect = 1, this.far = 1e3, this.setFocalLength(50), this.distance = 20 * Math.abs(2 * Math.tan(p.a.radians(this.fov) / 2)) * 2
                }
            }, {
                key: "update",
                value: function(e) {
                    this.position.copy(e.position).normalize().multiplyScalar(this.distance), this.lookAt(new r.Vector3)
                }
            }]) && y(n.prototype, i), o && y(n, o), t
        }(r.PerspectiveCamera),
        M = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\n\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\nuniform vec3 cameraPosition;\nuniform float time;\nuniform float renderOutline;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\nvarying vec3 vColor;\n\nvoid main(void) {\n  // coordinate transformation\n  vec4 mPosition = modelMatrix * vec4(position + normal * renderOutline * 0.5, 1.0);\n\n  float angleToCamera = acos(dot(normalize(cameraPosition), normalize(mPosition.xyz)));\n\n  vPosition = mPosition.xyz;\n  vUv = uv;\n  vColor = vec3(smoothstep(0.8, 1.0, abs(sin(angleToCamera))));\n\n  gl_Position = projectionMatrix * viewMatrix * mPosition;\n}\n",
        _ = "precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\nuniform float renderOutline;\nuniform sampler2D noiseTex;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\nvarying vec3 vColor;\n\nvec3 convertHsvToRgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Flat Shading\n  vec3 light = normalize(vec3(-1.0, 1.0, 0.2));\n  vec3 normal = normalize(cross(dFdx(vPosition), dFdy(vPosition)));\n  float diff = dot(normal, light);\n\n  float noiseR = texture2D(\n    noiseTex,\n    normal.yz * 0.2 + vec2(time * 0.02, 0.0)\n    ).r * 2.0 - 1.0;\n  float noiseG = texture2D(\n    noiseTex,\n    normal.zx * 0.2 + vec2(0.0, time * 0.02)\n    ).g * 2.0 - 1.0;\n  float noiseB = texture2D(\n    noiseTex,\n    normal.xy * 0.2 - time * 0.02\n    ).b * 2.0 - 1.0;\n  float noise = length(vec3(noiseR, noiseG, noiseB));\n\n  vec3 hsvNoise = vec3(noise * 0.1, noise * 0.1, -noise * 0.1);\n  vec3 hsv1 = vec3(0.55, 0.55, 0.8) + hsvNoise;\n  vec3 hsv2 = vec3(0.88, 0.55, 1.0) + hsvNoise;\n  vec3 rgb = mix(convertHsvToRgb(hsv1), convertHsvToRgb(hsv2), diff);\n\n  vec3 hsv3 = vec3(0.55, 0.05, 0.95);\n  vec3 color = (rgb * (1.0 - vColor) + convertHsvToRgb(hsv3) * vColor) * (1.0 - renderOutline);\n  vec3 colorOutline = vec3(1.0) * renderOutline;\n\n  gl_FragColor = vec4(color + colorOutline, 1.0);\n}\n";

    function S(e) {
        return (S = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
            return typeof e
        } : function(e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
        })(e)
    }

    function P(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }

    function T(e, t) {
        return !t || "object" !== S(t) && "function" != typeof t ? function(e) {
            if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return e
        }(e) : t
    }

    function E(e) {
        return (E = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
            return e.__proto__ || Object.getPrototypeOf(e)
        })(e)
    }

    function z(e, t) {
        return (z = Object.setPrototypeOf || function(e, t) {
            return e.__proto__ = t, e
        })(e, t)
    }
    var L = function(e) {
            function t(e, n) {
                var i;
                return function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, t), (i = T(this, E(t).call(this))).material = new r.RawShaderMaterial({
                    uniforms: {
                        time: {
                            type: "f",
                            value: 0
                        },
                        renderOutline: {
                            type: "f",
                            value: 0
                        },
                        noiseTex: {
                            type: "t",
                            value: null
                        }
                    },
                    vertexShader: M,
                    fragmentShader: _,
                    flatShading: !0
                }), i.head = new r.Mesh(e, i.material), i.jaw = new r.Mesh(n, i.material), i.add(i.head), i.add(i.jaw), i.name = "Skull", i.isActive = !1, i
            }
            var n, i, o;
            return function(e, t) {
                if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
                e.prototype = Object.create(t && t.prototype, {
                    constructor: {
                        value: e,
                        writable: !0,
                        configurable: !0
                    }
                }), t && z(e, t)
            }(t, e), n = t, (i = [{
                key: "start",
                value: function(e) {
                    this.isActive = !0, this.material.uniforms.noiseTex.value = e
                }
            }, {
                key: "update",
                value: function(e, t) {
                    !1 !== this.isActive && (this.material.uniforms.time.value += e, this.head.rotation.set(p.a.radians(8 * -(.7 * Math.sin(this.material.uniforms.time.value) + .7)), 0, 0), this.jaw.rotation.set(p.a.radians(8 * (.7 * Math.sin(this.material.uniforms.time.value) + .7)), 0, 0))
                }
            }]) && P(n.prototype, i), o && P(n, o), t
        }(r.Group),
        A = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  gl_Position = vec4(position, 1.0);\n}\n",
        C = "precision highp float;\n#define GLSLIFY 1\n\nuniform vec2 resolution;\nuniform vec2 direction;\nuniform float radius;\nuniform sampler2D texture;\n\nvarying vec2 vUv;\n\nvec4 gaussianBlur(sampler2D texture, vec2 uv, float radius, vec2 resolution, vec2 direction) {\n  vec4 color = vec4(0.0);\n  vec2 step = radius / resolution * direction;\n  color += texture2D(texture, uv + -30.0 * step) * 0.000044463576696752694;\n  color += texture2D(texture, uv + -29.0 * step) * 0.00007045416494915056;\n  color += texture2D(texture, uv + -28.0 * step) * 0.0001099096126906708;\n  color += texture2D(texture, uv + -27.0 * step) * 0.00016880723998699519;\n  color += texture2D(texture, uv + -26.0 * step) * 0.00025525396029412817;\n  color += texture2D(texture, uv + -25.0 * step) * 0.0003799964739478872;\n  color += texture2D(texture, uv + -24.0 * step) * 0.0005569445069582366;\n  color += texture2D(texture, uv + -23.0 * step) * 0.0008036541345232365;\n  color += texture2D(texture, uv + -22.0 * step) * 0.0011416972770451463;\n  color += texture2D(texture, uv + -21.0 * step) * 0.001596823459247415;\n  color += texture2D(texture, uv + -20.0 * step) * 0.002198804676697693;\n  color += texture2D(texture, uv + -19.0 * step) * 0.0029808483791945177;\n  color += texture2D(texture, uv + -18.0 * step) * 0.003978472126807061;\n  color += texture2D(texture, uv + -17.0 * step) * 0.005227760816555183;\n  color += texture2D(texture, uv + -16.0 * step) * 0.006762976274064666;\n  color += texture2D(texture, uv + -15.0 * step) * 0.008613559380852844;\n  color += texture2D(texture, uv + -14.0 * step) * 0.010800652851120281;\n  color += texture2D(texture, uv + -13.0 * step) * 0.013333369986564198;\n  color += texture2D(texture, uv + -12.0 * step) * 0.016205128746770582;\n  color += texture2D(texture, uv + -11.0 * step) * 0.01939044575559005;\n  color += texture2D(texture, uv + -10.0 * step) * 0.022842624955526088;\n  color += texture2D(texture, uv + -9.0 * step) * 0.02649276597348318;\n  color += texture2D(texture, uv + -8.0 * step) * 0.030250448423666733;\n  color += texture2D(texture, uv + -7.0 * step) * 0.03400631888443281;\n  color += texture2D(texture, uv + -6.0 * step) * 0.037636625557126956;\n  color += texture2D(texture, uv + -5.0 * step) * 0.0410095302098648;\n  color += texture2D(texture, uv + -4.0 * step) * 0.04399280495100364;\n  color += texture2D(texture, uv + -3.0 * step) * 0.04646232452009806;\n  color += texture2D(texture, uv + -2.0 * step) * 0.048310624731385546;\n  color += texture2D(texture, uv + -1.0 * step) * 0.04945474015528432;\n  color += texture2D(texture, uv + 0.0 * step) * 0.049842336475142184;\n  color += texture2D(texture, uv + 1.0 * step) * 0.04945474015528432;\n  color += texture2D(texture, uv + 2.0 * step) * 0.048310624731385546;\n  color += texture2D(texture, uv + 3.0 * step) * 0.04646232452009806;\n  color += texture2D(texture, uv + 4.0 * step) * 0.04399280495100364;\n  color += texture2D(texture, uv + 5.0 * step) * 0.0410095302098648;\n  color += texture2D(texture, uv + 6.0 * step) * 0.037636625557126956;\n  color += texture2D(texture, uv + 7.0 * step) * 0.03400631888443281;\n  color += texture2D(texture, uv + 8.0 * step) * 0.030250448423666733;\n  color += texture2D(texture, uv + 9.0 * step) * 0.02649276597348318;\n  color += texture2D(texture, uv + 10.0 * step) * 0.022842624955526088;\n  color += texture2D(texture, uv + 11.0 * step) * 0.01939044575559005;\n  color += texture2D(texture, uv + 12.0 * step) * 0.016205128746770582;\n  color += texture2D(texture, uv + 13.0 * step) * 0.013333369986564198;\n  color += texture2D(texture, uv + 14.0 * step) * 0.010800652851120281;\n  color += texture2D(texture, uv + 15.0 * step) * 0.008613559380852844;\n  color += texture2D(texture, uv + 16.0 * step) * 0.006762976274064666;\n  color += texture2D(texture, uv + 17.0 * step) * 0.005227760816555183;\n  color += texture2D(texture, uv + 18.0 * step) * 0.003978472126807061;\n  color += texture2D(texture, uv + 19.0 * step) * 0.0029808483791945177;\n  color += texture2D(texture, uv + 20.0 * step) * 0.002198804676697693;\n  color += texture2D(texture, uv + 21.0 * step) * 0.001596823459247415;\n  color += texture2D(texture, uv + 22.0 * step) * 0.0011416972770451463;\n  color += texture2D(texture, uv + 23.0 * step) * 0.0008036541345232365;\n  color += texture2D(texture, uv + 24.0 * step) * 0.0005569445069582366;\n  color += texture2D(texture, uv + 25.0 * step) * 0.0003799964739478872;\n  color += texture2D(texture, uv + 26.0 * step) * 0.00025525396029412817;\n  color += texture2D(texture, uv + 27.0 * step) * 0.00016880723998699519;\n  color += texture2D(texture, uv + 28.0 * step) * 0.0001099096126906708;\n  color += texture2D(texture, uv + 29.0 * step) * 0.00007045416494915056;\n  color += texture2D(texture, uv + 30.0 * step) * 0.000044463576696752694;\n  return color;\n}\n\nvoid main() {\n  vec4 color = gaussianBlur(texture, vUv, radius, resolution, direction);\n  gl_FragColor = color;\n}\n";

    function R(e) {
        return (R = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
            return typeof e
        } : function(e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
        })(e)
    }

    function O(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }

    function j(e, t) {
        return !t || "object" !== R(t) && "function" != typeof t ? function(e) {
            if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return e
        }(e) : t
    }

    function I(e) {
        return (I = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
            return e.__proto__ || Object.getPrototypeOf(e)
        })(e)
    }

    function D(e, t) {
        return (D = Object.setPrototypeOf || function(e, t) {
            return e.__proto__ = t, e
        })(e, t)
    }
    var k = n(0),
        F = function(e) {
            function t() {
                var e;
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, t);
                var n = new k.PlaneBufferGeometry(2, 2),
                    r = new k.RawShaderMaterial({
                        uniforms: {
                            resolution: {
                                type: "v2",
                                value: new k.Vector2(512, 512)
                            },
                            direction: {
                                type: "v2",
                                value: new k.Vector2(0, 0)
                            },
                            radius: {
                                type: "f",
                                value: 1
                            },
                            texture: {
                                type: "t",
                                value: null
                            }
                        },
                        vertexShader: A,
                        fragmentShader: C
                    });
                return (e = j(this, I(t).call(this, n, r))).name = "AuraPostEffect", e
            }
            var n, r, i;
            return function(e, t) {
                if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
                e.prototype = Object.create(t && t.prototype, {
                    constructor: {
                        value: e,
                        writable: !0,
                        configurable: !0
                    }
                }), t && D(e, t)
            }(t, e), n = t, (r = [{
                key: "setDirection",
                value: function(e, t) {
                    this.material.uniforms.direction.value.set(e, t)
                }
            }, {
                key: "setTexture",
                value: function(e) {
                    this.material.uniforms.texture.value = e
                }
            }, {
                key: "update",
                value: function(e, t, n) {
                    var r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null;
                    this.obj.visible = !0, e.setRenderTarget(r), e.render(t, n), this.obj.visible = !1
                }
            }]) && O(n.prototype, r), i && O(n, i), t
        }(k.Mesh),
        G = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\n\nvoid main(void) {\n  // coordinate transformation\n  vec4 mPosition = modelMatrix * vec4(position, 1.0);\n\n  vPosition = position;\n  vUv = uv;\n\n  gl_Position = projectionMatrix * viewMatrix * mPosition;\n}\n",
        N = "precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\nuniform vec2 direction;\nuniform vec2 resolution;\nuniform float radius;\nuniform sampler2D postEffectTex;\nuniform sampler2D noiseTex;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\n\nconst float blurIteration = 12.0;\n\nvec3 convertHsvToRgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  vec4 texColor1 = texture2D(postEffectTex, vUv * 1.05 - 0.025);\n  vec4 texColor2 = texture2D(postEffectTex, vUv * vec2(0.8, 0.75) + vec2(0.1, 0.075));\n  vec4 texColor3 = texture2D(postEffectTex, vUv * vec2(0.6, 0.55) + vec2(0.2, 0.175));\n\n  float noise1 = texture2D(noiseTex, vUv - vec2(0.0, time * 0.6)).r;\n  float noise2 = texture2D(noiseTex, vUv * 2.0 - vec2(0.0, time * 0.7)).g;\n  float noise3 = texture2D(noiseTex, vUv * 3.0 + vec2(0.0, time * 0.8)).b;\n  float noise = (noise1 * 0.65 + noise2 * 0.3 + noise3 * 0.05);\n\n  float mask1 = (texColor1.r + noise) / 2.0;\n  float mask2 = (texColor2.r + (noise * 2.0 - 1.0)) * (1.0 - mask1);\n  float mask3 = smoothstep(0.5, 1.0, texColor3.r + noise * 0.5);\n  float mask = (mask1 * 2.0 + mask2) / 3.0 * mask3;\n\n  float strength = smoothstep(0.05, 0.17, pow(mask, 3.0));\n  vec3 hsv1 = vec3(0.84, 0.4, 0.85);\n  vec3 hsv2 = vec3(0.55, 0.05, 0.95);\n  vec3 rgb = convertHsvToRgb(mix(hsv1, hsv2, strength));\n\n  float opacity = smoothstep(0.05, 0.055, pow(mask, 3.0));\n\n  if (opacity < 0.01) {\n    discard;\n  }\n\n  gl_FragColor = vec4(rgb, opacity);\n}\n";

    function B(e) {
        return (B = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
            return typeof e
        } : function(e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
        })(e)
    }

    function U(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }

    function H(e, t) {
        return !t || "object" !== B(t) && "function" != typeof t ? function(e) {
            if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return e
        }(e) : t
    }

    function V(e) {
        return (V = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
            return e.__proto__ || Object.getPrototypeOf(e)
        })(e)
    }

    function W(e, t) {
        return (W = Object.setPrototypeOf || function(e, t) {
            return e.__proto__ = t, e
        })(e, t)
    }
    var Y = function(e) {
            function t() {
                var e;
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, t);
                var n = new r.PlaneBufferGeometry(20, 20),
                    i = new r.RawShaderMaterial({
                        uniforms: {
                            time: {
                                type: "f",
                                value: 0
                            },
                            postEffectTex: {
                                type: "t",
                                value: null
                            },
                            noiseTex: {
                                type: "t",
                                value: null
                            }
                        },
                        vertexShader: G,
                        fragmentShader: N,
                        transparent: !0
                    });
                return (e = H(this, V(t).call(this, n, i))).name = "Aura", e.isActive = !1, e
            }
            var n, i, o;
            return function(e, t) {
                if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
                e.prototype = Object.create(t && t.prototype, {
                    constructor: {
                        value: e,
                        writable: !0,
                        configurable: !0
                    }
                }), t && W(e, t)
            }(t, e), n = t, (i = [{
                key: "start",
                value: function(e, t) {
                    this.isActive = !0, this.material.uniforms.postEffectTex.value = e, this.material.uniforms.noiseTex.value = t
                }
            }, {
                key: "update",
                value: function(e, t) {
                    !1 !== this.isActive && (this.rotation.copy(t.rotation), this.material.uniforms.time.value += e)
                }
            }]) && U(n.prototype, i), o && U(n, o), t
        }(r.Mesh),
        X = "#define GLSLIFY 1\nattribute vec3 position;\nattribute float delay;\n\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\nuniform float time;\nuniform float duration;\nuniform vec2 resolution;\nuniform float pixelRatio;\nuniform sampler2D noiseTex;\n\nvarying vec3 vColor;\nvarying float vAlpha;\n\nvec3 convertHsvToRgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Coordinate transformation\n  float alpha = mod(time - delay, duration) / duration;\n  vec3 risePosition = vec3(0.0, alpha * 10.0 - 4.0, 0.0);\n\n  float noiseR = texture2D(\n    noiseTex,\n    position.yz * 0.4 + vec2(time * 0.02, 0.0)\n    ).r * 2.0 - 1.0;\n  float noiseG = texture2D(\n    noiseTex,\n    position.zx * 0.4 + vec2(0.0, time * 0.02)\n    ).g * 2.0 - 1.0;\n  float noiseB = texture2D(\n    noiseTex,\n    position.xy * 0.4 - time * 0.02\n    ).b * 2.0 - 1.0;\n  vec3 noisePosition = vec3(noiseR, noiseG, noiseB) * alpha * 12.0;\n\n  vec4 mvPosition = viewMatrix * modelMatrix * vec4(position + noisePosition + risePosition, 1.0);\n  float distanceFromCamera = length(mvPosition.xyz);\n\n  // Define the point size.\n  float pointSize = 7.0 * pixelRatio * 40.0 / distanceFromCamera * resolution.y / 1024.0;\n\n  vColor = convertHsvToRgb(\n    vec3(\n      0.55 + delay * 0.33,\n      0.8,\n      0.4\n      )\n    );\n  vAlpha = alpha;\n\n  gl_Position = projectionMatrix * mvPosition;\n  gl_PointSize = pointSize;\n}\n",
        q = "precision highp float;\n#define GLSLIFY 1\n\nuniform float alpha;\n\nvarying vec3 vColor;\nvarying float vAlpha;\n\nvoid main() {\n  // Convert PointCoord to the other vec2 has a range from -1.0 to 1.0.\n  vec2 p = gl_PointCoord * 2.0 - 1.0;\n\n  // Draw circle\n  float radius = length(p);\n  float opacity = smoothstep(0.0, 0.2, vAlpha)\n    * (1.0 - smoothstep(0.8, 1.0, vAlpha))\n    * (1.0 - smoothstep(0.5, 1.0, radius))\n    * 0.6;\n\n  // Define Colors\n  vec3 color = vColor;\n\n  gl_FragColor = vec4(color, opacity);\n}\n";

    function K(e) {
        return (K = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
            return typeof e
        } : function(e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
        })(e)
    }

    function Z(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }

    function J(e, t) {
        return !t || "object" !== K(t) && "function" != typeof t ? function(e) {
            if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return e
        }(e) : t
    }

    function Q(e) {
        return (Q = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
            return e.__proto__ || Object.getPrototypeOf(e)
        })(e)
    }

    function $(e, t) {
        return ($ = Object.setPrototypeOf || function(e, t) {
            return e.__proto__ = t, e
        })(e, t)
    }
    var ee = 4,
        te = 360,
        ne = function(e) {
            function t() {
                var e;
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, t);
                for (var n = new r.BufferGeometry, i = new r.BufferAttribute(new Float32Array(3 * te), 3), o = new r.BufferAttribute(new Float32Array(te), 1), a = 0, s = te; a < s; a++) {
                    var c = p.a.radians(360 * Math.random()),
                        u = 4 * Math.random() + 1;
                    i.setXYZ(a, Math.cos(c) * u, 0, Math.sin(c) * u), o.setX(a, Math.random() * ee)
                }
                n.addAttribute("position", i), n.addAttribute("delay", o);
                var l = new r.RawShaderMaterial({
                    uniforms: {
                        time: {
                            type: "f",
                            value: 0
                        },
                        duration: {
                            type: "f",
                            value: ee
                        },
                        resolution: {
                            type: "v2",
                            value: new r.Vector2
                        },
                        pixelRatio: {
                            type: "f",
                            value: window.devicePixelRatio
                        },
                        noiseTex: {
                            type: "t",
                            value: null
                        }
                    },
                    vertexShader: X,
                    fragmentShader: q,
                    transparent: !0,
                    blending: r.AdditiveBlending,
                    depthWrite: !1
                });
                return (e = J(this, Q(t).call(this, n, l))).name = "Points", e
            }
            var n, i, o;
            return function(e, t) {
                if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
                e.prototype = Object.create(t && t.prototype, {
                    constructor: {
                        value: e,
                        writable: !0,
                        configurable: !0
                    }
                }), t && $(e, t)
            }(t, e), n = t, (i = [{
                key: "start",
                value: function(e) {
                    this.material.uniforms.noiseTex.value = e
                }
            }, {
                key: "update",
                value: function(e) {
                    this.material.uniforms.time.value += e, this.rotation.set(0, .2 * this.material.uniforms.time.value, 0)
                }
            }, {
                key: "resize",
                value: function(e) {
                    this.material.uniforms.resolution.value.copy(e)
                }
            }]) && Z(n.prototype, i), o && Z(n, o), t
        }(r.Points);

    function re(e) {
        return (re = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
            return typeof e
        } : function(e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
        })(e)
    }

    function ie(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }

    function oe(e, t) {
        return !t || "object" !== re(t) && "function" != typeof t ? function(e) {
            if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return e
        }(e) : t
    }

    function ae(e) {
        return (ae = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
            return e.__proto__ || Object.getPrototypeOf(e)
        })(e)
    }

    function se(e, t) {
        return (se = Object.setPrototypeOf || function(e, t) {
            return e.__proto__ = t, e
        })(e, t)
    }
    var ce = function(e) {
            function t() {
                var e;
                return function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, t), (e = oe(this, ae(t).call(this))).name = "AuraSkull", e.skull, e.auraPostEffect, e.aura, e.points, e.renderTarget1 = new r.WebGLRenderTarget(256, 256), e.renderTarget2 = new r.WebGLRenderTarget(256, 256), e.time = 0, e.isActive = !1, e
            }
            var n, i, o;
            return function(e, t) {
                if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
                e.prototype = Object.create(t && t.prototype, {
                    constructor: {
                        value: e,
                        writable: !0,
                        configurable: !0
                    }
                }), t && se(e, t)
            }(t, e), n = t, (i = [{
                key: "start",
                value: function(e, t, n) {
                    this.skull = new L(e, t), this.auraPostEffect = new F, this.aura = new Y, this.points = new ne, this.add(this.skull), this.add(this.aura), this.add(this.points), this.skull.start(n), this.aura.start(this.renderTarget1.texture, n), this.points.start(n), this.isActive = !0
                }
            }, {
                key: "update",
                value: function(e, t, n, r, i, o) {
                    !1 !== this.isActive && (this.time += e, this.radian += e, o && this.skull.rotation.set(p.a.radians(o.v.y - 15), p.a.radians(o.v.x + 15), p.a.radians(-20)), this.skull.update(e, n), this.aura.update(e, n), this.points.update(e), t.setRenderTarget(this.renderTarget1), r.add(this.skull), this.skull.material.uniforms.renderOutline.value = 1, t.render(r, i), t.setRenderTarget(this.renderTarget2), r.remove(this.skull), r.add(this.auraPostEffect), this.auraPostEffect.setDirection(1, 0), this.auraPostEffect.setTexture(this.renderTarget1.texture), t.render(r, i), t.setRenderTarget(this.renderTarget1), this.auraPostEffect.setDirection(0, 1), this.auraPostEffect.setTexture(this.renderTarget2.texture), t.render(r, i), t.setRenderTarget(null), r.remove(this.auraPostEffect), this.add(this.skull), this.skull.material.uniforms.renderOutline.value = 0)
                }
            }, {
                key: "resize",
                value: function(e) {
                    this.points.resize(e)
                }
            }]) && ie(n.prototype, i), o && ie(n, o), t
        }(r.Group),
        ue = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\n\nvarying vec2 vUv;\n\nvoid main(void) {\n  // coordinate transformation\n  vec4 mPosition = modelMatrix * vec4(position, 1.0);\n\n  vUv = uv;\n\n  gl_Position = projectionMatrix * viewMatrix * mPosition;\n}\n",
        le = "precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\nuniform float hex;\n\nvarying vec2 vUv;\nvarying vec3 vColor;\n\nvec3 convertHsvToRgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  vec3 rgb = mix(\n    convertHsvToRgb(vec3(0.5, 0.8, 0.7)),\n    convertHsvToRgb(vec3(0.0, 0.2, 0.95)),\n    vUv.y * 4.0 - 1.15\n    );\n\n  gl_FragColor = vec4(rgb, 1.0);\n}\n";

    function fe(e) {
        return (fe = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
            return typeof e
        } : function(e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
        })(e)
    }

    function de(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }

    function he(e, t) {
        return !t || "object" !== fe(t) && "function" != typeof t ? function(e) {
            if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return e
        }(e) : t
    }

    function ve(e) {
        return (ve = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
            return e.__proto__ || Object.getPrototypeOf(e)
        })(e)
    }

    function pe(e, t) {
        return (pe = Object.setPrototypeOf || function(e, t) {
            return e.__proto__ = t, e
        })(e, t)
    }
    var me, ye = function(e) {
        function t() {
            var e;
            ! function(e, t) {
                if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
            }(this, t);
            var n = new r.SphereBufferGeometry(100, 12, 12),
                i = new r.RawShaderMaterial({
                    uniforms: {
                        time: {
                            type: "f",
                            value: 0
                        },
                        hex: {
                            type: "f",
                            value: 0
                        }
                    },
                    vertexShader: ue,
                    fragmentShader: le,
                    side: r.BackSide
                });
            return (e = he(this, ve(t).call(this, n, i))).name = "Background", e
        }
        var n, i, o;
        return function(e, t) {
            if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
            e.prototype = Object.create(t && t.prototype, {
                constructor: {
                    value: e,
                    writable: !0,
                    configurable: !0
                }
            }), t && pe(e, t)
        }(t, e), n = t, (i = [{
            key: "start",
            value: function() {}
        }, {
            key: "update",
            value: function() {}
        }]) && de(n.prototype, i), o && de(n, o), t
    }(r.Mesh);

    function ge(e, t, n, r, i, o, a) {
        try {
            var s = e[o](a),
                c = s.value
        } catch (e) {
            return void n(e)
        }
        s.done ? t(c) : Promise.resolve(c).then(r, i)
    }

    function xe(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }
    var be = new r.Scene,
        we = new h,
        Me = new r.Clock({
            autoStart: !1
        }),
        _e = new r.Scene,
        Se = new w,
        Pe = new ce,
        Te = new ye,
        Ee = function() {
            function e() {
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, e)
            }
            var t, n, i, o, c;
            return t = e, (n = [{
                key: "start",
                value: (o = regeneratorRuntime.mark((function e(t) {
                    return regeneratorRuntime.wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return (me = new r.WebGLRenderer({
                                    alpha: !0,
                                    antialias: !0,
                                    canvas: t
                                })).setPixelRatio(window.devicePixelRatio), me.setClearColor(0, 1), e.next = 5, Promise.all([Object(a.default)("/sketch-threejs/model/skull/SkullHead.obj"), Object(s.default)("/sketch-threejs/img/sketch/splash/noise.png")]).then((function(e) {
                                    var t = e[0].children[1].geometry,
                                        n = e[0].children[0].geometry,
                                        i = e[1];
                                    i.wrapS = r.RepeatWrapping, i.wrapT = r.RepeatWrapping, we.start(), Se.start(), Pe.start(t, n, i), Te.start(), be.add(Pe), be.add(Te)
                                }));
                            case 5:
                            case "end":
                                return e.stop()
                        }
                    }), e)
                })), c = function() {
                    var e = this,
                        t = arguments;
                    return new Promise((function(n, r) {
                        var i = o.apply(e, t);

                        function a(e) {
                            ge(i, n, r, a, s, "next", e)
                        }

                        function s(e) {
                            ge(i, n, r, a, s, "throw", e)
                        }
                        a(void 0)
                    }))
                }, function(e) {
                    return c.apply(this, arguments)
                })
            }, {
                key: "play",
                value: function() {
                    Me.start(), this.update()
                }
            }, {
                key: "pause",
                value: function() {
                    Me.stop()
                }
            }, {
                key: "update",
                value: function(e) {
                    if (!1 !== Me.running) {
                        var t = Me.getDelta();
                        we.update(t), Se.update(we), Pe.update(t, me, we, _e, Se, e), me.render(be, we)
                    }
                }
            }, {
                key: "resize",
                value: function(e) {
                    we.resize(e), Pe.resize(e), me.setSize(e.x, e.y)
                }
            }]) && xe(t.prototype, n), i && xe(t, i), e
        }();

    function ze(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }
    var Le = function() {
        function e(t) {
            ! function(e, t) {
                if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
            }(this, e), this.resolution = t, this.vTouchStart = new r.Vector2, this.vPrev = new r.Vector2, this.v = new r.Vector2, this.a = new r.Vector2, this.anchor = new r.Vector2, this.isTouched = !1
        }
        var t, n, i;
        return t = e, (n = [{
            key: "touchStart",
            value: function(e) {
                e.touches || e.preventDefault(), this.vPrev.copy(this.v), this.a.set(0, 0), this.vTouchStart.set(e.touches ? e.touches[0].clientX : e.clientX, e.touches ? e.touches[0].clientY : e.clientY), this.isTouched = !0
            }
        }, {
            key: "touchMove",
            value: function(e) {
                e.touches && e.preventDefault();
                var t = e.touches ? e.touches[0].clientX : e.clientX,
                    n = e.touches ? e.touches[0].clientY : e.clientY;
                !1 !== this.isTouched && this.anchor.set((t - this.vTouchStart.x) / (this.resolution.x / 200) + this.vPrev.x, p.a.clamp((n - this.vTouchStart.y) / (this.resolution.y / 200) + this.vPrev.y, -90, 90))
            }
        }, {
            key: "touchEnd",
            value: function(e) {
                this.isTouched = !1
            }
        }, {
            key: "update",
            value: function() {
                this.a.set((this.anchor.x - this.v.x) / 10, (this.anchor.y - this.v.y) / 10), this.v.add(this.a)
            }
        }]) && ze(t.prototype, n), i && ze(t, i), e
    }();

    function Ae(e, t, n, r, i, o, a) {
        try {
            var s = e[o](a),
                c = s.value
        } catch (e) {
            return void n(e)
        }
        s.done ? t(c) : Promise.resolve(c).then(r, i)
    }
    t.default = function() {
        return Ce.apply(this, arguments)
    };

    function Ce() {
        var e;
        return e = regeneratorRuntime.mark((function e() {
            var t, n, i, a, s, c, u, l;
            return regeneratorRuntime.wrap((function(e) {
                for (;;) switch (e.prev = e.next) {
                    case 0:
                        return t = new Ee, n = new r.Vector2, i = document.getElementById("canvas-webgl"), a = document.querySelector(".p-preloader"), s = new Le(n), c = function() {
                            n.set(document.body.clientWidth, window.innerHeight), i.width = n.x, i.height = n.y, t.resize(n)
                        }, u = function() {
                            var e = function(e) {
                                    s.touchStart(e)
                                },
                                n = function(e) {
                                    s.touchMove(e)
                                },
                                r = function(e) {
                                    s.touchEnd(e)
                                };
                            i.addEventListener("mousedown", e, {
                                passive: !1
                            }), window.addEventListener("mousemove", n, {
                                passive: !1
                            }), window.addEventListener("mouseup", r), i.addEventListener("touchstart", e, {
                                passive: !1
                            }), window.addEventListener("touchmove", n, {
                                passive: !1
                            }), window.addEventListener("touchend", r), window.addEventListener("blur", (function() {
                                t.pause()
                            })), window.addEventListener("focus", (function() {
                                t.play()
                            })), window.addEventListener("resize", o()(c, 100))
                        }, l = function e() {
                            s.update(n), t.update(s), requestAnimationFrame(e)
                        }, e.next = 10, t.start(i);
                    case 10:
                        u(), c(), a.classList.add("is-hidden"), t.play(), l();
                    case 15:
                    case "end":
                        return e.stop()
                }
            }), e)
        })), (Ce = function() {
            var t = this,
                n = arguments;
            return new Promise((function(r, i) {
                var o = e.apply(t, n);

                function a(e) {
                    Ae(o, r, i, a, s, "next", e)
                }

                function s(e) {
                    Ae(o, r, i, a, s, "throw", e)
                }
                a(void 0)
            }))
        }).apply(this, arguments)
    }
}, function(e, t, n) {
    "use strict";
    n.r(t);
    var r = n(0),
        i = n(3),
        o = n.n(i),
        a = n(12),
        s = n.n(a),
        c = n(4),
        u = n(1),
        l = n.n(u);

    function f(e) {
        return (f = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
            return typeof e
        } : function(e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
        })(e)
    }

    function d(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }

    function h(e, t) {
        return !t || "object" !== f(t) && "function" != typeof t ? function(e) {
            if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return e
        }(e) : t
    }

    function v(e) {
        return (v = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
            return e.__proto__ || Object.getPrototypeOf(e)
        })(e)
    }

    function p(e, t) {
        return (p = Object.setPrototypeOf || function(e, t) {
            return e.__proto__ = t, e
        })(e, t)
    }
    var m = function(e) {
            function t() {
                var e;
                return function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, t), (e = h(this, v(t).call(this))).time = 0, e.name = "Sun", e
            }
            var n, r, i;
            return function(e, t) {
                if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
                e.prototype = Object.create(t && t.prototype, {
                    constructor: {
                        value: e,
                        writable: !0,
                        configurable: !0
                    }
                }), t && p(e, t)
            }(t, e), n = t, (r = [{
                key: "start",
                value: function() {}
            }, {
                key: "update",
                value: function(e) {
                    this.time += e, this.rotation.set(0, l.a.radians(8 * this.time), 0)
                }
            }]) && d(n.prototype, r), i && d(n, i), t
        }(r.Group),
        y = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\nuniform vec3 cameraPosition;\nuniform float time;\n\nvarying vec2 vUv;\nvarying vec3 vColor;\n\nvoid main(void) {\n  // coordinate transformation\n  vec4 mPosition = modelMatrix * vec4(position, 1.0);\n\n  float angleToCamera = acos(dot(normalize(cameraPosition), normalize(mPosition.xyz)));\n\n  vUv = uv;\n  vColor = vec3(smoothstep(0.7, 1.0, abs(sin(angleToCamera)))) * 0.9;\n\n  gl_Position = projectionMatrix * viewMatrix * mPosition;\n}\n",
        g = "precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\nuniform sampler2D texture;\nuniform sampler2D textureNormal;\n\nvarying vec2 vUv;\nvarying vec3 vColor;\n\nvec3 convertHsvToRgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  vec2 p = vUv * 2.0 - 1.0;\n\n  vec2 normal = texture2D(textureNormal, vUv + vec2(0.5, 0.0)).xy;\n  vec2 updateUv = vUv + vec2(\n    cos(radians(normal.x * 360.0 + time * 60.0)) * 0.006,\n    sin(radians(normal.y * 360.0 + time * 60.0)) * 0.006\n    );\n\n  vec4 texColor = texture2D(texture, updateUv);\n  vec3 hsv = vec3(\n    texColor.r * 0.14 + 0.03,\n    0.95 - texColor.r * 0.7,\n    texColor.r * 0.4 + 0.8\n    );\n  vec3 rgb = convertHsvToRgb(hsv);\n\n  gl_FragColor = vec4(rgb + vColor, 1.0);\n}\n";

    function x(e) {
        return (x = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
            return typeof e
        } : function(e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
        })(e)
    }

    function b(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }

    function w(e, t) {
        return !t || "object" !== x(t) && "function" != typeof t ? function(e) {
            if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return e
        }(e) : t
    }

    function M(e) {
        return (M = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
            return e.__proto__ || Object.getPrototypeOf(e)
        })(e)
    }

    function _(e, t) {
        return (_ = Object.setPrototypeOf || function(e, t) {
            return e.__proto__ = t, e
        })(e, t)
    }
    var S = function(e) {
            function t() {
                var e;
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, t);
                var n = new r.SphereBufferGeometry(6, 32, 32),
                    i = new r.RawShaderMaterial({
                        uniforms: {
                            time: {
                                type: "f",
                                value: 0
                            },
                            texture: {
                                type: "t",
                                value: null
                            },
                            textureNormal: {
                                type: "t",
                                value: null
                            }
                        },
                        vertexShader: y,
                        fragmentShader: g
                    });
                return (e = w(this, M(t).call(this, n, i))).name = "Core", e
            }
            var n, i, o;
            return function(e, t) {
                if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
                e.prototype = Object.create(t && t.prototype, {
                    constructor: {
                        value: e,
                        writable: !0,
                        configurable: !0
                    }
                }), t && _(e, t)
            }(t, e), n = t, (i = [{
                key: "start",
                value: function(e, t) {
                    this.material.uniforms.texture.value = e, this.material.uniforms.textureNormal.value = t
                }
            }, {
                key: "update",
                value: function(e) {
                    this.material.uniforms.time.value += e
                }
            }]) && b(n.prototype, i), o && b(n, o), t
        }(r.Mesh),
        P = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\nuniform vec3 cameraPosition;\nuniform float time;\n\nvarying vec2 vUv;\nvarying float vOpacity;\n\nvoid main(void) {\n  float wave1 = sin((position.x + position.y) * 0.8 + time * 0.4);\n  float wave2 = sin((position.z - position.x) * 0.6 + time * 0.2);\n  float wave = wave1 * 0.4 + wave2 * 0.6;\n  vec3 wavePosition = normalize(position) * wave * 2.2;\n\n  // coordinate transformation\n  vec4 mPosition = modelMatrix * vec4(position + wavePosition, 1.0);\n\n  float angleToCamera = acos(dot(normalize(cameraPosition), normalize(mPosition.xyz)));\n\n  vUv = uv + vec2(0.5, 0.0);\n  vOpacity = smoothstep(0.1, 0.6, abs(sin(angleToCamera)));\n\n  gl_Position = projectionMatrix * viewMatrix * mPosition;\n}\n",
        T = "precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\nuniform sampler2D texture;\nuniform sampler2D textureNormal;\n\nvarying vec2 vUv;\nvarying float vOpacity;\n\nvec3 convertHsvToRgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  vec2 p = vUv * 2.0 - 1.0;\n\n  vec2 normal = texture2D(textureNormal, vUv + vec2(0.5, 0.0)).xy;\n  vec2 updateUv = vUv + vec2(\n    cos(radians(normal.x * 360.0 + time * 60.0)) * 0.018,\n    sin(radians(normal.y * 360.0 + time * 60.0)) * 0.018\n    );\n\n  vec4 texColor = texture2D(texture, updateUv);\n  float opacity = texColor.r * vOpacity;\n  vec3 hsv = vec3(\n    opacity * 0.1 + 0.03,\n    0.95 - opacity * 0.7,\n    opacity * 0.4 + 0.8\n    );\n  vec3 rgb = convertHsvToRgb(hsv);\n\n  gl_FragColor = vec4(rgb, smoothstep(0.3, 0.9, opacity) * 0.9);\n}\n";

    function E(e) {
        return (E = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
            return typeof e
        } : function(e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
        })(e)
    }

    function z(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }

    function L(e, t) {
        return !t || "object" !== E(t) && "function" != typeof t ? function(e) {
            if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return e
        }(e) : t
    }

    function A(e) {
        return (A = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
            return e.__proto__ || Object.getPrototypeOf(e)
        })(e)
    }

    function C(e, t) {
        return (C = Object.setPrototypeOf || function(e, t) {
            return e.__proto__ = t, e
        })(e, t)
    }
    var R = function(e) {
            function t() {
                var e;
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, t);
                var n = new r.SphereBufferGeometry(7.5, 128, 128),
                    i = new r.RawShaderMaterial({
                        uniforms: {
                            time: {
                                type: "f",
                                value: 0
                            },
                            texture: {
                                type: "t",
                                value: null
                            },
                            textureNormal: {
                                type: "t",
                                value: null
                            }
                        },
                        vertexShader: P,
                        fragmentShader: T,
                        transparent: !0,
                        depthWrite: !1,
                        side: r.DoubleSide
                    });
                return (e = L(this, A(t).call(this, n, i))).name = "Shell", e
            }
            var n, i, o;
            return function(e, t) {
                if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
                e.prototype = Object.create(t && t.prototype, {
                    constructor: {
                        value: e,
                        writable: !0,
                        configurable: !0
                    }
                }), t && C(e, t)
            }(t, e), n = t, (i = [{
                key: "start",
                value: function(e, t) {
                    this.material.uniforms.texture.value = e, this.material.uniforms.textureNormal.value = t
                }
            }, {
                key: "update",
                value: function(e) {
                    this.material.uniforms.time.value += e
                }
            }]) && z(n.prototype, i), o && z(n, o), t
        }(r.Mesh),
        O = "#define GLSLIFY 1\nattribute vec3 position;\nattribute float delay;\nattribute float speed;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform float time;\n\nvarying vec3 vColor;\nvarying float vOpacity;\n\nvec3 convertHsvToRgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nmat4 calcRotateMat4X(float radian) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, cos(radian), -sin(radian), 0.0,\n    0.0, sin(radian), cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4Y(float radian) {\n  return mat4(\n    cos(radian), 0.0, sin(radian), 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    -sin(radian), 0.0, cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4Z(float radian) {\n  return mat4(\n    cos(radian), -sin(radian), 0.0, 0.0,\n    sin(radian), cos(radian), 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4(vec3 radian) {\n  return calcRotateMat4X(radian.x) * calcRotateMat4Y(radian.y) * calcRotateMat4Z(radian.z);\n}\n\nconst float duration = 3.0;\n\nvoid main() {\n  // calculate interval time from 0 to 1\n  float interval = mod(time + delay * duration, duration) / duration;\n\n  // update position and size\n  float size = 10.0 * sin(interval * 4.0);\n  float blink = max(sin(interval * 4.0) * 2.0 - 1.0, 0.0);\n  mat4 rotateMat = calcRotateMat4(vec3(\n    radians(time * speed * 0.3),\n    radians(time * speed),\n    radians(time * speed * 0.3)\n    ));\n\n  // calculate colors\n  vec3 hsv = vec3(0.1 + sin(delay + time) * 0.05, 0.6, 1.0);\n  vec3 rgb = convertHsvToRgb(hsv);\n\n  // coordinate transformation\n  vec4 mvPosition = modelViewMatrix * rotateMat * vec4(position, 1.0);\n  float distanceFromCamera = 20.0 / length(mvPosition.xyz);\n\n  vColor = rgb;\n  vOpacity = blink * clamp(distanceFromCamera, 0.1, 0.3);\n\n  gl_Position = projectionMatrix * mvPosition;\n  gl_PointSize = distanceFromCamera * size;\n}\n",
        j = "precision highp float;\n#define GLSLIFY 1\n\nuniform sampler2D texture;\n\nvarying vec3 vColor;\nvarying float vOpacity;\n\nvoid main() {\n  // convert PointCoord to range from -1.0 to 1.0\n  vec2 p = gl_PointCoord * 2.0 - 1.0;\n\n  // draw double circle\n  float r = (1.0 - smoothstep(0.95, 1.0, length(p)));\n\n  gl_FragColor = vec4(vColor * r, vOpacity);\n}\n";

    function I(e) {
        return (I = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
            return typeof e
        } : function(e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
        })(e)
    }

    function D(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }

    function k(e, t) {
        return !t || "object" !== I(t) && "function" != typeof t ? function(e) {
            if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return e
        }(e) : t
    }

    function F(e) {
        return (F = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
            return e.__proto__ || Object.getPrototypeOf(e)
        })(e)
    }

    function G(e, t) {
        return (G = Object.setPrototypeOf || function(e, t) {
            return e.__proto__ = t, e
        })(e, t)
    }
    var N = function(e) {
            function t() {
                var e;
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, t);
                for (var n = new r.BufferGeometry, i = new r.BufferAttribute(new Float32Array(3600), 3), o = new r.BufferAttribute(new Float32Array(1200), 1, 1), a = new r.BufferAttribute(new Float32Array(1200), 1, 1), s = 0; s < 1200; s++) {
                    var c = l.a.radians(l.a.randomArbitrary(0, 150) - 75),
                        u = l.a.radians(l.a.randomArbitrary(0, 360)),
                        f = Math.random() * Math.random() * 8 + 6,
                        d = l.a.spherical(c, u, f);
                    i.setXYZ(s, d[0], d[1], d[2]), o.setXYZ(s, Math.random()), a.setXYZ(s, l.a.randomArbitrary(5, 10) * (2 * l.a.randomInt(0, 1) - 1))
                }
                n.addAttribute("position", i), n.addAttribute("delay", o), n.addAttribute("speed", a);
                var h = new r.RawShaderMaterial({
                    uniforms: {
                        time: {
                            type: "f",
                            value: 0
                        }
                    },
                    vertexShader: O,
                    fragmentShader: j,
                    transparent: !0,
                    depthWrite: !1,
                    blending: r.AdditiveBlending
                });
                return (e = k(this, F(t).call(this, n, h))).name = "Points", e
            }
            var n, i, o;
            return function(e, t) {
                if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
                e.prototype = Object.create(t && t.prototype, {
                    constructor: {
                        value: e,
                        writable: !0,
                        configurable: !0
                    }
                }), t && G(e, t)
            }(t, e), n = t, (i = [{
                key: "start",
                value: function() {}
            }, {
                key: "update",
                value: function(e) {
                    this.material.uniforms.time.value += e
                }
            }]) && D(n.prototype, i), o && D(n, o), t
        }(r.Points),
        B = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\n\nvoid main(void) {\n  // coordinate transformation\n  vec4 mPosition = modelMatrix * vec4(position, 1.0);\n\n  vPosition = position;\n  vUv = uv;\n\n  gl_Position = projectionMatrix * viewMatrix * mPosition;\n}\n",
        U = "precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\nuniform sampler2D texture;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\n\nmat3 calcRotateMat3(float radian) {\n  return mat3(\n    cos(radian), -sin(radian), 0.0,\n    sin(radian), cos(radian), 0.0,\n    0.0, 0.0, 1.0\n  );\n}\n\nvec3 convertHsvToRgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  vec2 p = vUv * 2.0 - 1.0;\n  vec2 rotateUv = (calcRotateMat3(time * 0.04) * vec3(p, 1.0)).xy * 0.5 + 0.5;\n  vec4 texColor = texture2D(texture, rotateUv);\n\n  float l = length(vPosition);\n  vec2 rotateMask = (calcRotateMat3(time * -0.02) * vec3(p, 1.0)).xy;\n  float opacityIn = pow(1.0 - smoothstep(6.0, 10.0, l), 2.0);\n  float opacityOut = 1.0 - smoothstep(8.0, 24.0, l);\n  float opacityRay = sin(acos(dot(normalize(rotateMask), vec2(1.0, 0.0))) * 2.4 + time) * 0.4 + 0.6;\n  float opacity = opacityIn * 0.7 + opacityOut * 0.1 + opacityRay * texColor.r;\n\n  vec3 hsv = vec3(\n    opacity * 0.12 + 0.98,\n    1.0 - opacity * 0.8,\n    opacity * 0.4 + 0.8\n    );\n  vec3 rgb = convertHsvToRgb(hsv);\n\n  gl_FragColor = vec4(rgb, opacity);\n}\n";

    function H(e) {
        return (H = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
            return typeof e
        } : function(e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
        })(e)
    }

    function V(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }

    function W(e, t) {
        return !t || "object" !== H(t) && "function" != typeof t ? function(e) {
            if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return e
        }(e) : t
    }

    function Y(e) {
        return (Y = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
            return e.__proto__ || Object.getPrototypeOf(e)
        })(e)
    }

    function X(e, t) {
        return (X = Object.setPrototypeOf || function(e, t) {
            return e.__proto__ = t, e
        })(e, t)
    }
    var q = function(e) {
            function t() {
                var e;
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, t);
                var n = new r.RingBufferGeometry(4, 24, 64),
                    i = new r.RawShaderMaterial({
                        uniforms: {
                            time: {
                                type: "f",
                                value: 0
                            },
                            texture: {
                                type: "t",
                                value: null
                            }
                        },
                        vertexShader: B,
                        fragmentShader: U,
                        transparent: !0
                    });
                return (e = W(this, Y(t).call(this, n, i))).position.z = -5, e.name = "SunShine", e
            }
            var n, i, o;
            return function(e, t) {
                if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
                e.prototype = Object.create(t && t.prototype, {
                    constructor: {
                        value: e,
                        writable: !0,
                        configurable: !0
                    }
                }), t && X(e, t)
            }(t, e), n = t, (i = [{
                key: "start",
                value: function(e) {
                    this.material.uniforms.texture.value = e
                }
            }, {
                key: "update",
                value: function(e) {
                    this.material.uniforms.time.value += e
                }
            }]) && V(n.prototype, i), o && V(n, o), t
        }(r.Mesh),
        K = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\n\nvarying vec2 vUv;\n\nvoid main(void) {\n  // coordinate transformation\n  vec4 mPosition = modelMatrix * vec4(position, 1.0);\n\n  vUv = uv;\n\n  gl_Position = projectionMatrix * viewMatrix * mPosition;\n}\n",
        Z = "precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\n\nvarying vec2 vUv;\nvarying vec3 vColor;\n\nfloat random(vec2 c){\n  return fract(sin(dot(c.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nconst vec3 rgb1 = vec3(24.0 / 255.0, 32.0 / 255.0, 76.0 / 255.0);\nconst vec3 rgb2 = vec3(5.0 / 255.0, 6.0 / 255.0, 15.0 / 255.0);\n\nvoid main() {\n  vec3 rgb = mix(rgb1, rgb2, vUv.y * 4.0 - 1.0);\n  float noise = random(vUv + vec2(0.0, time * 0.01)) * 0.04;\n\n  gl_FragColor = vec4(rgb + noise, 1.0);\n}\n";

    function J(e) {
        return (J = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
            return typeof e
        } : function(e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
        })(e)
    }

    function Q(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }

    function $(e, t) {
        return !t || "object" !== J(t) && "function" != typeof t ? function(e) {
            if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return e
        }(e) : t
    }

    function ee(e) {
        return (ee = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
            return e.__proto__ || Object.getPrototypeOf(e)
        })(e)
    }

    function te(e, t) {
        return (te = Object.setPrototypeOf || function(e, t) {
            return e.__proto__ = t, e
        })(e, t)
    }
    var ne = function(e) {
        function t() {
            var e;
            ! function(e, t) {
                if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
            }(this, t);
            var n = new r.SphereBufferGeometry(50, 12, 12),
                i = new r.RawShaderMaterial({
                    uniforms: {
                        time: {
                            type: "f",
                            value: 0
                        }
                    },
                    vertexShader: K,
                    fragmentShader: Z,
                    side: r.BackSide
                });
            return (e = $(this, ee(t).call(this, n, i))).name = "Background", e
        }
        var n, i, o;
        return function(e, t) {
            if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
            e.prototype = Object.create(t && t.prototype, {
                constructor: {
                    value: e,
                    writable: !0,
                    configurable: !0
                }
            }), t && te(e, t)
        }(t, e), n = t, (i = [{
            key: "start",
            value: function() {}
        }, {
            key: "update",
            value: function(e) {
                this.material.uniforms.time.value += e
            }
        }]) && Q(n.prototype, i), o && Q(n, o), t
    }(r.Mesh);

    function re(e, t, n, r, i, o, a) {
        try {
            var s = e[o](a),
                c = s.value
        } catch (e) {
            return void n(e)
        }
        s.done ? t(c) : Promise.resolve(c).then(r, i)
    }
    t.default = function() {
        return ie.apply(this, arguments)
    };

    function ie() {
        var e;
        return e = regeneratorRuntime.mark((function e() {
            var t, n, i, a, u, l, f, d, h, v, p, y, g, x, b, w, M, _, P, T;
            return regeneratorRuntime.wrap((function(e) {
                for (;;) switch (e.prev = e.next) {
                    case 0:
                        return t = new r.Vector2, n = document.getElementById("canvas-webgl"), (i = new r.WebGLRenderer({
                            alpha: !0,
                            antialias: !0,
                            canvas: n
                        })).setPixelRatio(window.devicePixelRatio), a = new r.Scene, u = new r.PerspectiveCamera, l = new r.Vector2, f = new r.Clock({
                            autoStart: !1
                        }), d = document.querySelector(".p-preloader"), h = new m, v = new S, p = new R, y = new N, g = new q, x = new ne, w = function() {
                            var e = f.getDelta();
                            h.update(e), v.update(e), p.update(e), y.update(e), g.update(e), i.render(a, u)
                        }, M = function e() {
                            w(), requestAnimationFrame(e)
                        }, _ = function() {
                            t.x > t.y ? l.set(t.x >= 1200 ? 1200 : t.x, t.x >= 1200 ? 800 : .66 * t.x) : l.set(.6 * (t.y >= 1200 ? 800 : .66 * t.y), .6 * (t.y >= 1200 ? 1200 : t.y)), u.setViewOffset(l.x, l.y, (t.x - l.x) / -2, (t.y - l.y) / -2, t.x, t.y), u.updateProjectionMatrix()
                        }, P = function() {
                            t.set(document.body.clientWidth, window.innerHeight), n.width = t.x, n.height = t.y, _(), i.setSize(t.x, t.y)
                        }, T = function() {
                            window.addEventListener("blur", (function() {
                                f.stop()
                            })), window.addEventListener("focus", (function() {
                                f.start()
                            })), window.addEventListener("resize", o()(P, 100))
                        }, i.setClearColor(15658734, 1), u.aspect = 1.5, u.far = 1e3, u.setFocalLength(50), u.position.set(0, 0, 50), u.lookAt(new r.Vector3), T(), P(), e.next = 30, Promise.all([Object(c.default)("../img/sketch/sun/core.png"), Object(c.default)("../img/sketch/sun/core_normal.png"), Object(c.default)("../img/sketch/sun/sunshine.png")]).then((function(e) {
                            b = e
                        }));
                    case 30:
                        return b && (b[0].wrapS = r.RepeatWrapping, b[0].wrapT = r.RepeatWrapping, b[1].wrapS = r.RepeatWrapping, b[1].wrapT = r.RepeatWrapping, v.start(b[0], b[1]), p.start(b[0], b[1]), g.start(b[2])), h.add(v), h.add(p), a.add(h), a.add(y), a.add(g), a.add(x), d.classList.add("is-hidden"), e.next = 40, s()(200);
                    case 40:
                        f.start(), M();
                    case 42:
                    case "end":
                        return e.stop()
                }
            }), e)
        })), (ie = function() {
            var t = this,
                n = arguments;
            return new Promise((function(r, i) {
                var o = e.apply(t, n);

                function a(e) {
                    re(o, r, i, a, s, "next", e)
                }

                function s(e) {
                    re(o, r, i, a, s, "throw", e)
                }
                a(void 0)
            }))
        }).apply(this, arguments)
    }
}, function(e, t, n) {
    "use strict";
    n.r(t);
    var r = n(0),
        i = n(3),
        o = n.n(i),
        a = (n(12), n(4));

    function s(e) {
        return (s = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
            return typeof e
        } : function(e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
        })(e)
    }

    function c(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }

    function u(e, t) {
        return !t || "object" !== s(t) && "function" != typeof t ? function(e) {
            if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return e
        }(e) : t
    }

    function l(e) {
        return (l = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
            return e.__proto__ || Object.getPrototypeOf(e)
        })(e)
    }

    function f(e, t) {
        return (f = Object.setPrototypeOf || function(e, t) {
            return e.__proto__ = t, e
        })(e, t)
    }
    var d = function(e) {
            function t(e, n, r, i) {
                var o;
                return function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, t), (o = u(this, l(t).call(this, e, n, r, i))).time = 0, o.isActive = !1, o
            }
            var n, i, o;
            return function(e, t) {
                if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
                e.prototype = Object.create(t && t.prototype, {
                    constructor: {
                        value: e,
                        writable: !0,
                        configurable: !0
                    }
                }), t && f(e, t)
            }(t, e), n = t, (i = [{
                key: "start",
                value: function() {
                    this.aspect = 1.5, this.far = 1e3, this.setFocalLength(50), this.position.set(0, 14, 45), this.lookAt(new r.Vector3(0, -1, 0)), this.isActive = !0
                }
            }, {
                key: "update",
                value: function(e) {
                    !1 !== this.isActive && (this.time += e)
                }
            }, {
                key: "resize",
                value: function(e) {
                    this.aspect = e.x / e.y, this.updateProjectionMatrix()
                }
            }]) && c(n.prototype, i), o && c(n, o), t
        }(r.PerspectiveCamera),
        h = n(1),
        v = n.n(h);

    function p(e) {
        return (p = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
            return typeof e
        } : function(e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
        })(e)
    }

    function m(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }

    function y(e, t) {
        return !t || "object" !== p(t) && "function" != typeof t ? function(e) {
            if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return e
        }(e) : t
    }

    function g(e) {
        return (g = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
            return e.__proto__ || Object.getPrototypeOf(e)
        })(e)
    }

    function x(e, t) {
        return (x = Object.setPrototypeOf || function(e, t) {
            return e.__proto__ = t, e
        })(e, t)
    }
    var b = function(e) {
            function t(e, n, r, i) {
                var o;
                return function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, t), (o = y(this, g(t).call(this, e, n, r, i))).distance = 0, o
            }
            var n, i, o;
            return function(e, t) {
                if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
                e.prototype = Object.create(t && t.prototype, {
                    constructor: {
                        value: e,
                        writable: !0,
                        configurable: !0
                    }
                }), t && x(e, t)
            }(t, e), n = t, (i = [{
                key: "start",
                value: function() {
                    this.aspect = 1, this.far = 1e3, this.setFocalLength(50), this.distance = 30 * Math.abs(2 * Math.tan(v.a.radians(this.fov) / 2))
                }
            }, {
                key: "update",
                value: function(e) {
                    this.position.copy(e.position).normalize().multiplyScalar(this.distance), this.lookAt(new r.Vector3)
                }
            }]) && m(n.prototype, i), o && m(n, o), t
        }(r.PerspectiveCamera),
        w = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\n\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\nuniform float time;\nuniform float renderOutline;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\n\nvoid main(void) {\n  // coordinate transformation\n  vec4 mPosition = modelMatrix * vec4(position + normal * renderOutline * 0.3, 1.0);\n\n  vPosition = mPosition.xyz;\n  vUv = uv;\n\n  gl_Position = projectionMatrix * viewMatrix * mPosition;\n}\n",
        M = "precision highp float;\n#define GLSLIFY 1\n\nuniform float alpha;\nuniform float renderOutline;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\n\nvec3 convertHsvToRgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Flat Shading\n  vec3 light = normalize(vec3(-1.0, 1.0, -1.0));\n  vec3 normal = normalize(cross(dFdx(vPosition), dFdy(vPosition)));\n  float diff = dot(normal, light) * 0.5;\n\n  vec3 hsv = vec3(0.5 + alpha + diff * 0.8, 0.4, 0.8);\n  vec3 rgb = convertHsvToRgb(hsv);\n\n  vec3 color = (rgb + diff) * (1.0 - renderOutline);\n  vec3 colorOutline = vec3(1.0) * renderOutline;\n\n  gl_FragColor = vec4(color + colorOutline, 1.0);\n}\n";

    function _(e) {
        return (_ = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
            return typeof e
        } : function(e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
        })(e)
    }

    function S(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }

    function P(e, t) {
        return !t || "object" !== _(t) && "function" != typeof t ? function(e) {
            if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return e
        }(e) : t
    }

    function T(e) {
        return (T = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
            return e.__proto__ || Object.getPrototypeOf(e)
        })(e)
    }

    function E(e, t) {
        return (E = Object.setPrototypeOf || function(e, t) {
            return e.__proto__ = t, e
        })(e, t)
    }
    var z = function(e) {
            function t() {
                var e;
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, t);
                var n = new r.TorusKnotBufferGeometry(2, .5, 60, 4),
                    i = new r.RawShaderMaterial({
                        uniforms: {
                            time: {
                                type: "f",
                                value: 0
                            },
                            alpha: {
                                type: "f",
                                value: 0
                            },
                            renderOutline: {
                                type: "f",
                                value: 0
                            }
                        },
                        vertexShader: w,
                        fragmentShader: M,
                        flatShading: !0
                    });
                return (e = P(this, T(t).call(this, n, i))).name = "TorusKnot", e.isActive = !1, e
            }
            var n, i, o;
            return function(e, t) {
                if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
                e.prototype = Object.create(t && t.prototype, {
                    constructor: {
                        value: e,
                        writable: !0,
                        configurable: !0
                    }
                }), t && E(e, t)
            }(t, e), n = t, (i = [{
                key: "start",
                value: function(e) {
                    this.isActive = !0, this.rotation.set(v.a.radians(360 * Math.random()), v.a.radians(360 * Math.random()), v.a.radians(360 * Math.random())), this.material.uniforms.alpha.value = e
                }
            }, {
                key: "update",
                value: function(e, t) {
                    !1 !== this.isActive && (this.rotation.set(this.rotation.x + e, this.rotation.y + e, this.rotation.z), this.material.uniforms.time.value += e)
                }
            }]) && S(n.prototype, i), o && S(n, o), t
        }(r.Mesh),
        L = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\n\nvoid main(void) {\n  // coordinate transformation\n  vec4 mPosition = modelMatrix * vec4(position, 1.0);\n\n  vPosition = position;\n  vUv = uv;\n\n  gl_Position = projectionMatrix * viewMatrix * mPosition;\n}\n",
        A = "precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\nuniform float alpha;\nuniform sampler2D outlineTex;\nuniform sampler2D noiseTex;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\n\nconst float blurIteration = 8.0;\n\nvec3 convertHsvToRgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // calculate blur mask.\n  vec4 destColor = vec4(0.0);\n  for (float i = 0.0; i < blurIteration; i++) {\n    for (float j = 0.0; j < blurIteration; j++) {\n      vec2 p = (vec2(i, j) / blurIteration * 2.0 - 1.0) / 512.0 * 60.0;\n      destColor += texture2D(outlineTex, vUv + p) / pow(blurIteration, 2.0);\n    }\n  }\n  float blurMask = smoothstep(0.0, 0.8, destColor.r) * (1.0 - smoothstep(0.5, 1.0, destColor.r));\n\n  float noise1 = texture2D(noiseTex, vUv + vec2(0.0, time * 0.1 + alpha)).r;\n  float noise2 = texture2D(noiseTex, vUv * 2.0 - vec2(0.0, time * 0.4 + alpha)).g;\n  float noise3 = texture2D(noiseTex, vUv * 3.0 + vec2(0.0, time * 0.8 + alpha)).b;\n  float noise = noise1 * 0.65 + noise2 * 0.3 + noise3 * 0.05;\n\n  float mask = blurMask * pow(smoothstep(0.2, 1.0, noise), 3.0) * 15.0;\n\n  vec3 hsv = vec3(1.0 + mask * 0.5 + alpha, 0.8 - mask * 0.6, 0.5 + mask * 0.5);\n\n  gl_FragColor = vec4(convertHsvToRgb(hsv), mask);\n}\n";

    function C(e) {
        return (C = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
            return typeof e
        } : function(e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
        })(e)
    }

    function R(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }

    function O(e, t) {
        return !t || "object" !== C(t) && "function" != typeof t ? function(e) {
            if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return e
        }(e) : t
    }

    function j(e) {
        return (j = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
            return e.__proto__ || Object.getPrototypeOf(e)
        })(e)
    }

    function I(e, t) {
        return (I = Object.setPrototypeOf || function(e, t) {
            return e.__proto__ = t, e
        })(e, t)
    }
    var D = function(e) {
        function t() {
            var e;
            ! function(e, t) {
                if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
            }(this, t);
            var n = new r.PlaneBufferGeometry(15, 15),
                i = new r.RawShaderMaterial({
                    uniforms: {
                        time: {
                            type: "f",
                            value: 0
                        },
                        alpha: {
                            type: "f",
                            value: 0
                        },
                        outlineTex: {
                            type: "t",
                            value: null
                        },
                        noiseTex: {
                            type: "t",
                            value: null
                        }
                    },
                    vertexShader: L,
                    fragmentShader: A,
                    transparent: !0
                });
            return (e = O(this, j(t).call(this, n, i))).name = "Aura", e.isActive = !1, e
        }
        var n, i, o;
        return function(e, t) {
            if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
            e.prototype = Object.create(t && t.prototype, {
                constructor: {
                    value: e,
                    writable: !0,
                    configurable: !0
                }
            }), t && I(e, t)
        }(t, e), n = t, (i = [{
            key: "start",
            value: function(e, t, n) {
                this.isActive = !0, this.material.uniforms.alpha.value = e, this.material.uniforms.outlineTex.value = t, this.material.uniforms.noiseTex.value = n
            }
        }, {
            key: "update",
            value: function(e, t) {
                !1 !== this.isActive && (this.rotation.copy(t.rotation), this.material.uniforms.time.value += e)
            }
        }]) && R(n.prototype, i), o && R(n, o), t
    }(r.Mesh);

    function k(e) {
        return (k = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
            return typeof e
        } : function(e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
        })(e)
    }

    function F(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }

    function G(e, t) {
        return !t || "object" !== k(t) && "function" != typeof t ? function(e) {
            if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return e
        }(e) : t
    }

    function N(e) {
        return (N = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
            return e.__proto__ || Object.getPrototypeOf(e)
        })(e)
    }

    function B(e, t) {
        return (B = Object.setPrototypeOf || function(e, t) {
            return e.__proto__ = t, e
        })(e, t)
    }
    var U = function(e) {
            function t(e) {
                var n;
                return function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, t), (n = G(this, N(t).call(this))).name = "AuraObject", n.obj = new z, n.aura = new D, n.add(n.aura), n.add(n.obj), n.renderTarget = new r.WebGLRenderTarget(512, 512), n.alpha = e, n.radian = v.a.radians(360 * e), n.time = 0, n.isActive = !1, n
            }
            var n, i, o;
            return function(e, t) {
                if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
                e.prototype = Object.create(t && t.prototype, {
                    constructor: {
                        value: e,
                        writable: !0,
                        configurable: !0
                    }
                }), t && B(e, t)
            }(t, e), n = t, (i = [{
                key: "start",
                value: function(e) {
                    this.obj.start(this.alpha), this.aura.start(this.alpha, this.renderTarget.texture, e), this.isActive = !0
                }
            }, {
                key: "update",
                value: function(e, t, n, r, i) {
                    !1 !== this.isActive && (this.time += e, this.radian += e, this.obj.update(e, r), this.aura.update(e, r), t.setRenderTarget(this.renderTarget), n.add(this.obj), this.obj.material.uniforms.renderOutline.value = 1, t.render(n, i), t.setRenderTarget(null), n.remove(this.obj), this.add(this.obj), this.obj.material.uniforms.renderOutline.value = 0, this.position.set(11 * Math.cos(this.radian), 0, 11 * Math.sin(this.radian)))
                }
            }, {
                key: "resize",
                value: function(e) {}
            }]) && F(n.prototype, i), o && F(n, o), t
        }(r.Group),
        H = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\n\nvarying vec2 vUv;\n\nvoid main(void) {\n  // coordinate transformation\n  vec4 mPosition = modelMatrix * vec4(position, 1.0);\n\n  vUv = uv;\n\n  gl_Position = projectionMatrix * viewMatrix * mPosition;\n}\n",
        V = "precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\nuniform float hex;\n\nvarying vec2 vUv;\nvarying vec3 vColor;\n\nvec3 convertHsvToRgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  vec3 rgb = mix(\n    convertHsvToRgb(vec3(0.5, 0.8, 0.05)),\n    convertHsvToRgb(vec3(0.0, 0.4, 0.4)),\n    vUv.y * 4.0 - 1.15\n    );\n\n  gl_FragColor = vec4(rgb, 1.0);\n}\n";

    function W(e) {
        return (W = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
            return typeof e
        } : function(e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
        })(e)
    }

    function Y(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }

    function X(e, t) {
        return !t || "object" !== W(t) && "function" != typeof t ? function(e) {
            if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return e
        }(e) : t
    }

    function q(e) {
        return (q = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
            return e.__proto__ || Object.getPrototypeOf(e)
        })(e)
    }

    function K(e, t) {
        return (K = Object.setPrototypeOf || function(e, t) {
            return e.__proto__ = t, e
        })(e, t)
    }
    var Z, J = function(e) {
        function t() {
            var e;
            ! function(e, t) {
                if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
            }(this, t);
            var n = new r.SphereBufferGeometry(100, 12, 12),
                i = new r.RawShaderMaterial({
                    uniforms: {
                        time: {
                            type: "f",
                            value: 0
                        },
                        hex: {
                            type: "f",
                            value: 0
                        }
                    },
                    vertexShader: H,
                    fragmentShader: V,
                    side: r.BackSide
                });
            return (e = X(this, q(t).call(this, n, i))).name = "Background", e
        }
        var n, i, o;
        return function(e, t) {
            if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
            e.prototype = Object.create(t && t.prototype, {
                constructor: {
                    value: e,
                    writable: !0,
                    configurable: !0
                }
            }), t && K(e, t)
        }(t, e), n = t, (i = [{
            key: "start",
            value: function() {}
        }, {
            key: "update",
            value: function() {}
        }]) && Y(n.prototype, i), o && Y(n, o), t
    }(r.Mesh);

    function Q(e, t, n, r, i, o, a) {
        try {
            var s = e[o](a),
                c = s.value
        } catch (e) {
            return void n(e)
        }
        s.done ? t(c) : Promise.resolve(c).then(r, i)
    }

    function $(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }
    for (var ee = new r.Scene, te = new d, ne = new r.Clock({
            autoStart: !1
        }), re = new r.Scene, ie = new b, oe = new Array(7), ae = 0; ae < oe.length; ae++) {
        var se = ae / oe.length;
        oe[ae] = new U(se)
    }
    var ce = new J,
        ue = function() {
            function e() {
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, e)
            }
            var t, n, i, o, s;
            return t = e, (n = [{
                key: "start",
                value: (o = regeneratorRuntime.mark((function e(t) {
                    return regeneratorRuntime.wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return (Z = new r.WebGLRenderer({
                                    alpha: !0,
                                    antialias: !0,
                                    canvas: t
                                })).setPixelRatio(window.devicePixelRatio), Z.setClearColor(0, 1), e.next = 5, Promise.all([Object(a.default)("/sketch-threejs/img/sketch/splash/noise.png")]).then((function(e) {
                                    var t = e[0];
                                    t.wrapS = r.RepeatWrapping, t.wrapT = r.RepeatWrapping, te.start(), ie.start();
                                    for (var n = 0; n < oe.length; n++) oe[n].start(t), ee.add(oe[n]);
                                    ce.start(), ee.add(ce)
                                }));
                            case 5:
                            case "end":
                                return e.stop()
                        }
                    }), e)
                })), s = function() {
                    var e = this,
                        t = arguments;
                    return new Promise((function(n, r) {
                        var i = o.apply(e, t);

                        function a(e) {
                            Q(i, n, r, a, s, "next", e)
                        }

                        function s(e) {
                            Q(i, n, r, a, s, "throw", e)
                        }
                        a(void 0)
                    }))
                }, function(e) {
                    return s.apply(this, arguments)
                })
            }, {
                key: "play",
                value: function() {
                    ne.start(), this.update()
                }
            }, {
                key: "pause",
                value: function() {
                    ne.stop()
                }
            }, {
                key: "update",
                value: function() {
                    if (!1 !== ne.running) {
                        var e = ne.getDelta();
                        te.update(e), ie.update(te);
                        for (var t = 0; t < oe.length; t++) oe[t].update(e, Z, re, te, ie);
                        Z.render(ee, te)
                    }
                }
            }, {
                key: "resize",
                value: function(e) {
                    te.resize(e);
                    for (var t = 0; t < oe.length; t++) oe[t].resize(te);
                    Z.setSize(e.x, e.y)
                }
            }]) && $(t.prototype, n), i && $(t, i), e
        }();

    function le(e, t, n, r, i, o, a) {
        try {
            var s = e[o](a),
                c = s.value
        } catch (e) {
            return void n(e)
        }
        s.done ? t(c) : Promise.resolve(c).then(r, i)
    }
    t.default = function() {
        return fe.apply(this, arguments)
    };

    function fe() {
        var e;
        return e = regeneratorRuntime.mark((function e() {
            var t, n, i, a, s, c, u;
            return regeneratorRuntime.wrap((function(e) {
                for (;;) switch (e.prev = e.next) {
                    case 0:
                        return t = new ue, n = new r.Vector2, i = document.getElementById("canvas-webgl"), a = document.querySelector(".p-preloader"), s = function() {
                            n.set(document.body.clientWidth, window.innerHeight), i.width = n.x, i.height = n.y, t.resize(n)
                        }, c = function() {
                            window.addEventListener("blur", (function() {
                                t.pause()
                            })), window.addEventListener("focus", (function() {
                                t.play()
                            })), window.addEventListener("resize", o()(s, 100))
                        }, u = function e() {
                            t.update(), requestAnimationFrame(e)
                        }, e.next = 9, t.start(i);
                    case 9:
                        c(), s(), a.classList.add("is-hidden"), t.play(), u();
                    case 14:
                    case "end":
                        return e.stop()
                }
            }), e)
        })), (fe = function() {
            var t = this,
                n = arguments;
            return new Promise((function(r, i) {
                var o = e.apply(t, n);

                function a(e) {
                    le(o, r, i, a, s, "next", e)
                }

                function s(e) {
                    le(o, r, i, a, s, "throw", e)
                }
                a(void 0)
            }))
        }).apply(this, arguments)
    }
}, function(e, t, n) {
    "use strict";
    n.r(t);
    var r = n(0),
        i = n(3),
        o = n.n(i),
        a = (n(12), n(4));

    function s(e) {
        return (s = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
            return typeof e
        } : function(e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
        })(e)
    }

    function c(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }

    function u(e, t) {
        return !t || "object" !== s(t) && "function" != typeof t ? function(e) {
            if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return e
        }(e) : t
    }

    function l(e) {
        return (l = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
            return e.__proto__ || Object.getPrototypeOf(e)
        })(e)
    }

    function f(e, t) {
        return (f = Object.setPrototypeOf || function(e, t) {
            return e.__proto__ = t, e
        })(e, t)
    }
    var d = function(e) {
            function t(e, n, i, o) {
                var a;
                return function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, t), (a = u(this, l(t).call(this, e, n, i, o))).cameraResolution = new r.Vector2, a
            }
            var n, i, o;
            return function(e, t) {
                if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
                e.prototype = Object.create(t && t.prototype, {
                    constructor: {
                        value: e,
                        writable: !0,
                        configurable: !0
                    }
                }), t && f(e, t)
            }(t, e), n = t, (i = [{
                key: "start",
                value: function() {
                    this.aspect = 1.5, this.far = 1e3, this.setFocalLength(50), this.position.set(0, 0, 50), this.lookAt(new r.Vector3)
                }
            }, {
                key: "update",
                value: function(e) {}
            }, {
                key: "resize",
                value: function(e) {
                    this.aspect = e.x / e.y, this.updateProjectionMatrix()
                }
            }]) && c(n.prototype, i), o && c(n, o), t
        }(r.PerspectiveCamera),
        h = n(153),
        v = n(1),
        p = n.n(v),
        m = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\nuniform float time;\nuniform float easeTransition;\nuniform vec2 imgRatio;\nuniform sampler2D noiseTex;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\nvarying vec2 vUpdateUv;\nvarying float vTime;\n\nvoid main(void) {\n  vec2 updateUv = uv * imgRatio + vec2(\n    (1.0 - imgRatio.x) * 0.5,\n    (1.0 - imgRatio.y) * 0.5\n    );\n\n  float noiseR = texture2D(noiseTex, updateUv + vec2(time * 0.1, 0.0)).r;\n  float noiseG = texture2D(noiseTex, updateUv + vec2(time * 0.2, 0.0)).g;\n  float slide = texture2D(noiseTex, uv * vec2(0.998) + 0.001).b;\n\n  float mask = easeTransition * 1.6 - slide;\n  float maskPrev = smoothstep(0.0, 0.3, mask);\n  float maskNext = 1.0 - smoothstep(0.3, 0.6, mask);\n  float height = maskPrev * maskNext * 4.0;\n\n  // coordinate transformation\n  vec4 mPosition = modelMatrix * vec4(position + vec3(0.0, 0.0, height), 1.0);\n\n  vPosition = position;\n  vUv = uv;\n  vUpdateUv = updateUv;\n  vTime = easeTransition;\n\n  gl_Position = projectionMatrix * viewMatrix * mPosition;\n}\n",
        y = "precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\nuniform float easeTransition;\nuniform vec2 imgRatio;\nuniform sampler2D noiseTex;\nuniform sampler2D imgPrevTex;\nuniform sampler2D imgNextTex;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\nvarying vec2 vUpdateUv;\nvarying float vTime;\n\nvoid main() {\n  vec2 ratio = vec2(\n    min(imgRatio.x / imgRatio.y / 3.0 * 2.0, 1.0),\n    min(imgRatio.y / imgRatio.x / 2.0 * 3.0, 1.0) / 3.0 * 2.0\n  );\n  vec2 imgUv = vec2(\n    vUv.x * ratio.x + (1.0 - ratio.x) * 0.5,\n    vUv.y * ratio.y  + (1.0 - ratio.y) * 0.5\n  );\n\n  float noiseR = texture2D(noiseTex, vUpdateUv + vec2(time * 0.1, 0.0)).r;\n  float noiseG = texture2D(noiseTex, vUpdateUv + vec2(time * 0.2, 0.0)).g;\n  float slide = texture2D(noiseTex, vUv * vec2(0.998) + 0.001).b;\n\n  float mask = vTime * 1.24 - (slide * 0.6 + noiseR * 0.2 + noiseG * 0.2);\n  float maskPrev = 1.0 - smoothstep(0.12, 0.16, mask);\n  float maskNext = smoothstep(0.16, 0.2, mask);\n  float maskEdge = smoothstep(0.04, 0.12, mask) * (1.0 - smoothstep(0.2, 0.28, mask));\n\n  vec4 imgPrev = texture2D(imgPrevTex, imgUv * (0.95 - 0.05 * easeTransition) + 0.025 + 0.025 * easeTransition);\n  vec4 imgNext = texture2D(imgNextTex, imgUv * (1.0 - 0.05 * easeTransition) + 0.025 * easeTransition);\n\n  // 0.9 - 0.8\n  // 1.0 - 0.9\n\n  vec3 color1 = imgPrev.rgb * maskPrev;\n  vec3 color2 = imgNext.rgb * maskNext;\n  vec3 color3 = vec3(0.0, 0.2, 1.0) * maskEdge;\n\n  gl_FragColor = vec4(color1 + color2 - color3, 1.0);\n}\n";

    function g(e) {
        return (g = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
            return typeof e
        } : function(e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
        })(e)
    }

    function x(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }

    function b(e, t) {
        return !t || "object" !== g(t) && "function" != typeof t ? function(e) {
            if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return e
        }(e) : t
    }

    function w(e) {
        return (w = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
            return e.__proto__ || Object.getPrototypeOf(e)
        })(e)
    }

    function M(e, t) {
        return (M = Object.setPrototypeOf || function(e, t) {
            return e.__proto__ = t, e
        })(e, t)
    }
    var _ = function(e) {
            function t() {
                var e;
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, t);
                var n = new r.PlaneBufferGeometry(1, 1, 64, 64),
                    i = new r.RawShaderMaterial({
                        uniforms: {
                            time: {
                                type: "f",
                                value: 0
                            },
                            easeTransition: {
                                type: "f",
                                value: 0
                            },
                            noiseTex: {
                                type: "t",
                                value: null
                            },
                            imgPrevTex: {
                                type: "t",
                                value: null
                            },
                            imgNextTex: {
                                type: "t",
                                value: null
                            },
                            imgRatio: {
                                type: "v2",
                                value: new r.Vector2
                            }
                        },
                        vertexShader: m,
                        fragmentShader: y
                    });
                return (e = b(this, w(t).call(this, n, i))).name = "Image", e.imgIndexPrev = 0, e.imgIndexNext = 1, e
            }
            var n, i, o;
            return function(e, t) {
                if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
                e.prototype = Object.create(t && t.prototype, {
                    constructor: {
                        value: e,
                        writable: !0,
                        configurable: !0
                    }
                }), t && M(e, t)
            }(t, e), n = t, (i = [{
                key: "start",
                value: function(e, t) {
                    this.imgTexes = t, this.material.uniforms.noiseTex.value = e, this.material.uniforms.imgPrevTex.value = this.imgTexes[this.imgIndexPrev], this.material.uniforms.imgNextTex.value = this.imgTexes[this.imgIndexNext]
                }
            }, {
                key: "update",
                value: function(e, t) {
                    this.material.uniforms.time.value += e, this.material.uniforms.easeTransition.value = t
                }
            }, {
                key: "resize",
                value: function(e) {
                    this.material.uniforms.imgRatio.value.set(Math.min(1, e.x / e.y), Math.min(1, e.y / e.x)), this.scale.copy(e)
                }
            }, {
                key: "changeTex",
                value: function() {
                    this.imgIndexPrev = this.imgIndexNext, this.imgIndexNext = this.imgIndexNext + 1 >= this.imgTexes.length ? 0 : this.imgIndexNext + 1, this.material.uniforms.imgPrevTex.value = this.imgTexes[this.imgIndexPrev], this.material.uniforms.imgNextTex.value = this.imgTexes[this.imgIndexNext]
                }
            }]) && x(n.prototype, i), o && x(n, o), t
        }(r.Mesh),
        S = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\nuniform float time;\nuniform float easeTransition;\nuniform vec2 imgRatio;\nuniform sampler2D noiseTex;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\nvarying float vOpacity;\nvarying float vTime;\n\nvoid main(void) {\n  vec2 p = uv * 2.0 - 1.0;\n  float edge = abs(p.x);\n\n  vec2 updateUv = uv * imgRatio + vec2(\n    (1.0 - imgRatio.x) * 0.5,\n    (1.0 - imgRatio.y) * 0.5\n    );\n\n  float noiseR = texture2D(noiseTex, updateUv + vec2(time * 0.1, 0.0)).r;\n  float noiseG = texture2D(noiseTex, updateUv + vec2(time * 0.2, 0.0)).g;\n  float slide = texture2D(noiseTex, uv * vec2(0.998) + 0.001).b;\n\n  float mask = easeTransition * 1.24 - (slide * 0.6 + noiseR * 0.2 + noiseG * 0.2);\n  float h1 = (1.0 - smoothstep(0.14, 0.24, mask)) * 12.0;\n\n  float mask2 = easeTransition * 1.6 - slide;\n  float maskPrev = smoothstep(0.0, 0.3, mask2);\n  float maskNext = 1.0 - smoothstep(0.3, 0.6, mask2);\n  float h2 = maskPrev * maskNext * 8.0;\n\n  float h = h1 + h2;\n\n  // coordinate transformation\n  vec4 mPosition = modelMatrix * vec4(position + vec3(slide * 0.2, slide * 0.2 + h * 0.006, h), 1.0);\n\n  float opacity = smoothstep(0.0, 2.0, h1) * (1.0 - smoothstep(8.0, 12.0, h1)) * (1.0 - pow(edge, 2.0));\n\n  vPosition = mPosition.xyz;\n  vUv = uv;\n  vOpacity = opacity;\n  vTime = easeTransition;\n\n  gl_Position = projectionMatrix * viewMatrix * mPosition;\n}\n",
        P = "precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\nuniform float duration;\nuniform vec2 imgRatio;\nuniform sampler2D noiseTex;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\nvarying float vOpacity;\nvarying float vTime;\n\nvoid main() {\n  vec2 updateUv = vUv * imgRatio + vec2(\n    (1.0 - imgRatio.x) * 0.5,\n    (1.0 - imgRatio.y) * 0.5\n    );\n\n  float noiseR = texture2D(noiseTex, updateUv + vec2(time * 0.1, 0.0)).r;\n  float noiseG = texture2D(noiseTex, updateUv + vec2(time * 0.2, 0.0)).g;\n\n  gl_FragColor = vec4(1.0, 0.38, 0.0, vOpacity * smoothstep(0.4, 0.6, noiseR));\n}\n";

    function T(e) {
        return (T = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
            return typeof e
        } : function(e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
        })(e)
    }

    function E(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }

    function z(e, t) {
        return !t || "object" !== T(t) && "function" != typeof t ? function(e) {
            if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return e
        }(e) : t
    }

    function L(e) {
        return (L = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
            return e.__proto__ || Object.getPrototypeOf(e)
        })(e)
    }

    function A(e, t) {
        return (A = Object.setPrototypeOf || function(e, t) {
            return e.__proto__ = t, e
        })(e, t)
    }
    var C = function(e) {
            function t() {
                var e;
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, t);
                var n = new r.PlaneBufferGeometry(1, 1, 128, 128),
                    i = new r.RawShaderMaterial({
                        uniforms: {
                            time: {
                                type: "f",
                                value: 0
                            },
                            easeTransition: {
                                type: "f",
                                value: 0
                            },
                            noiseTex: {
                                type: "t",
                                value: null
                            },
                            imgRatio: {
                                type: "v2",
                                value: new r.Vector2
                            }
                        },
                        vertexShader: S,
                        fragmentShader: P,
                        transparent: !0,
                        blending: r.AdditiveBlending
                    });
                return (e = z(this, L(t).call(this, n, i))).name = "ImageFire", e
            }
            var n, i, o;
            return function(e, t) {
                if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
                e.prototype = Object.create(t && t.prototype, {
                    constructor: {
                        value: e,
                        writable: !0,
                        configurable: !0
                    }
                }), t && A(e, t)
            }(t, e), n = t, (i = [{
                key: "start",
                value: function(e) {
                    this.material.uniforms.noiseTex.value = e
                }
            }, {
                key: "update",
                value: function(e, t) {
                    this.material.uniforms.time.value += e, this.material.uniforms.easeTransition.value = t
                }
            }, {
                key: "resize",
                value: function(e) {
                    this.material.uniforms.imgRatio.value.set(Math.min(1, e.x / e.y), Math.min(1, e.y / e.x)), this.scale.copy(e)
                }
            }]) && E(n.prototype, i), o && E(n, o), t
        }(r.Mesh),
        R = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\nuniform float time;\nuniform float easeTransition;\nuniform vec2 imgRatio;\nuniform sampler2D noiseTex;\nuniform float pixelRatio;\n\nvarying float vOpacity;\n\nvoid main(void) {\n  vec2 updateUv = uv * imgRatio + vec2(\n    (1.0 - imgRatio.x) * 0.5,\n    (1.0 - imgRatio.y) * 0.5\n    );\n\n  float noiseR = texture2D(noiseTex, updateUv + vec2(time * 0.1, 0.0)).r;\n  float noiseG = texture2D(noiseTex, updateUv + vec2(time * 0.2, 0.0)).g;\n  float slide = texture2D(noiseTex, uv * vec2(0.99) + 0.005).b;\n\n  float mask = easeTransition * 1.24 - (slide * 0.6 + noiseR * 0.2 + noiseG * 0.2);\n  float h = (easeTransition - slide) * 30.0;\n\n  float opacity = smoothstep(0.3, 0.5, easeTransition * 2.0 - slide) * (1.0 - smoothstep(0.8, 1.0, easeTransition * 2.0 - slide)) * 0.8;\n\n  // coordinate transformation\n  vec4 mPosition = modelMatrix * vec4(position + vec3(\n    cos(radians(noiseR * 360.0 + time * 200.0)) * 0.1,\n    sin(radians(noiseG * 360.0 + time * 200.0)) * 0.1,\n    h\n    ), 1.0);\n\n  float distanceFromCamera = length((viewMatrix * mPosition).xyz);\n  float pointSize = pixelRatio * 50.0 / distanceFromCamera * 4.0;\n\n  vOpacity = opacity;\n\n  gl_Position = projectionMatrix * viewMatrix * mPosition;\n  gl_PointSize = pointSize;\n}\n",
        O = "precision highp float;\n#define GLSLIFY 1\n\nvarying float vOpacity;\n\nvoid main() {\n  // Convert PointCoord to the other vec2 has a range from -1.0 to 1.0.\n  vec2 p = gl_PointCoord * 2.0 - 1.0;\n\n  // Draw circle\n  float radius = length(p);\n  float opacity = (1.0 - smoothstep(0.5, 1.0, radius));\n\n  // Define Colors\n  vec3 color = vec3(1.0, 0.38, 0.0);\n\n  gl_FragColor = vec4(color, opacity * vOpacity);\n}\n";

    function j(e) {
        return (j = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
            return typeof e
        } : function(e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
        })(e)
    }

    function I(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }

    function D(e, t) {
        return !t || "object" !== j(t) && "function" != typeof t ? function(e) {
            if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return e
        }(e) : t
    }

    function k(e) {
        return (k = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
            return e.__proto__ || Object.getPrototypeOf(e)
        })(e)
    }

    function F(e, t) {
        return (F = Object.setPrototypeOf || function(e, t) {
            return e.__proto__ = t, e
        })(e, t)
    }
    var G = function(e) {
        function t() {
            var e;
            ! function(e, t) {
                if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
            }(this, t);
            var n = new r.PlaneBufferGeometry(1, 1, 32, 32),
                i = new r.BufferGeometry;
            i.addAttribute("position", n.attributes.position), i.addAttribute("uv", n.attributes.uv);
            var o = new r.RawShaderMaterial({
                uniforms: {
                    time: {
                        type: "f",
                        value: 0
                    },
                    easeTransition: {
                        type: "f",
                        value: 0
                    },
                    noiseTex: {
                        type: "t",
                        value: null
                    },
                    imgRatio: {
                        type: "v2",
                        value: new r.Vector2
                    },
                    pixelRatio: {
                        type: "f",
                        value: window.devicePixelRatio
                    }
                },
                vertexShader: R,
                fragmentShader: O,
                transparent: !0,
                blending: r.AdditiveBlending
            });
            return (e = D(this, k(t).call(this, i, o))).name = "ImagePoints", e
        }
        var n, i, o;
        return function(e, t) {
            if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
            e.prototype = Object.create(t && t.prototype, {
                constructor: {
                    value: e,
                    writable: !0,
                    configurable: !0
                }
            }), t && F(e, t)
        }(t, e), n = t, (i = [{
            key: "start",
            value: function(e) {
                this.material.uniforms.noiseTex.value = e
            }
        }, {
            key: "update",
            value: function(e, t) {
                this.material.uniforms.time.value += e, this.material.uniforms.easeTransition.value = t
            }
        }, {
            key: "resize",
            value: function(e) {
                this.material.uniforms.imgRatio.value.set(Math.min(1, e.x / e.y), Math.min(1, e.y / e.x)), this.scale.copy(e)
            }
        }]) && I(n.prototype, i), o && I(n, o), t
    }(r.Points);

    function N(e) {
        return (N = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
            return typeof e
        } : function(e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
        })(e)
    }

    function B(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }

    function U(e, t) {
        return !t || "object" !== N(t) && "function" != typeof t ? function(e) {
            if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return e
        }(e) : t
    }

    function H(e) {
        return (H = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
            return e.__proto__ || Object.getPrototypeOf(e)
        })(e)
    }

    function V(e, t) {
        return (V = Object.setPrototypeOf || function(e, t) {
            return e.__proto__ = t, e
        })(e, t)
    }
    var W, Y = function(e) {
        function t() {
            var e;
            return function(e, t) {
                if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
            }(this, t), (e = U(this, H(t).call(this))).name = "ImageGroup", e.size = new r.Vector3, e.margin = new r.Vector2, e.timeTransition = 0, e
        }
        var n, i, o;
        return function(e, t) {
            if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
            e.prototype = Object.create(t && t.prototype, {
                constructor: {
                    value: e,
                    writable: !0,
                    configurable: !0
                }
            }), t && V(e, t)
        }(t, e), n = t, (i = [{
            key: "start",
            value: function(e, t) {
                var n = new _,
                    r = new C,
                    i = new G;
                n.start(e, t), r.start(e), i.start(e), r.renderOrder = 10, i.position.z = 5, this.add(n), this.add(r), this.add(i)
            }
        }, {
            key: "update",
            value: function(e) {
                if (this.timeTransition += e, this.timeTransition / 3 >= 1) this.timeTransition = 0, this.children[0].changeTex(), this.children[0].update(e, 0), this.children[1].update(e, 0), this.children[2].update(e, 0);
                else {
                    var t = Object(h.easeInOutQuad)(Math.min(this.timeTransition / 3, 1));
                    this.children[0].update(e, t), this.children[1].update(e, t), this.children[2].update(e, t)
                }
            }
        }, {
            key: "resize",
            value: function(e, t) {
                var n = Math.abs((e.position.z - this.position.z) * Math.tan(p.a.radians(e.fov) / 2) * 2),
                    r = n * e.aspect;
                this.margin.set(t.x > t.y ? .2 * t.y : .1 * t.x, t.x > t.y ? .2 * t.y : .333 * t.y), this.size.set(r * (t.x - this.margin.x) / t.x, n * (t.y - this.margin.y) / t.y, 1), this.children[0].resize(this.size), this.children[1].resize(this.size), this.children[2].resize(this.size)
            }
        }]) && B(n.prototype, i), o && B(n, o), t
    }(r.Group);

    function X(e, t, n, r, i, o, a) {
        try {
            var s = e[o](a),
                c = s.value
        } catch (e) {
            return void n(e)
        }
        s.done ? t(c) : Promise.resolve(c).then(r, i)
    }

    function q(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }
    var K = new r.Scene,
        Z = new d,
        J = new r.Clock({
            autoStart: !1
        }),
        Q = new Y,
        $ = function() {
            function e() {
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, e)
            }
            var t, n, i, o, s;
            return t = e, (n = [{
                key: "start",
                value: (o = regeneratorRuntime.mark((function e(t) {
                    return regeneratorRuntime.wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return (W = new r.WebGLRenderer({
                                    alpha: !0,
                                    antialias: !0,
                                    canvas: t
                                })).setPixelRatio(window.devicePixelRatio), W.setClearColor(921102, 1), e.next = 5, Promise.all([Object(a.default)("/sketch-threejs/img/sketch/burn/noise.png"), Object(a.default)("/sketch-threejs/img/sketch/burn/image01.jpg"), Object(a.default)("/sketch-threejs/img/sketch/burn/image02.jpg"), Object(a.default)("/sketch-threejs/img/sketch/burn/image03.jpg")]).then((function(e) {
                                    var t = e[0],
                                        n = e.slice(1);
                                    t.wrapS = r.RepeatWrapping, t.wrapT = r.RepeatWrapping, Q.start(t, n), K.add(Q)
                                }));
                            case 5:
                                Z.start();
                            case 6:
                            case "end":
                                return e.stop()
                        }
                    }), e)
                })), s = function() {
                    var e = this,
                        t = arguments;
                    return new Promise((function(n, r) {
                        var i = o.apply(e, t);

                        function a(e) {
                            X(i, n, r, a, s, "next", e)
                        }

                        function s(e) {
                            X(i, n, r, a, s, "throw", e)
                        }
                        a(void 0)
                    }))
                }, function(e) {
                    return s.apply(this, arguments)
                })
            }, {
                key: "play",
                value: function() {
                    J.start(), this.update()
                }
            }, {
                key: "pause",
                value: function() {
                    J.stop()
                }
            }, {
                key: "update",
                value: function() {
                    if (!1 !== J.running) {
                        var e = J.getDelta();
                        Z.update(e), Q.update(e), W.render(K, Z)
                    }
                }
            }, {
                key: "resize",
                value: function(e) {
                    Z.resize(e), W.setSize(e.x, e.y), Q.resize(Z, e)
                }
            }]) && q(t.prototype, n), i && q(t, i), e
        }();

    function ee(e, t, n, r, i, o, a) {
        try {
            var s = e[o](a),
                c = s.value
        } catch (e) {
            return void n(e)
        }
        s.done ? t(c) : Promise.resolve(c).then(r, i)
    }
    t.default = function() {
        return te.apply(this, arguments)
    };

    function te() {
        var e;
        return e = regeneratorRuntime.mark((function e() {
            var t, n, i, a, s, c, u;
            return regeneratorRuntime.wrap((function(e) {
                for (;;) switch (e.prev = e.next) {
                    case 0:
                        return t = new $, n = new r.Vector2, i = document.getElementById("canvas-webgl"), a = document.querySelector(".p-preloader"), s = function() {
                            n.set(document.body.clientWidth, window.innerHeight), i.width = n.x, i.height = n.y, t.resize(n)
                        }, c = function() {
                            window.addEventListener("blur", (function() {
                                t.pause()
                            })), window.addEventListener("focus", (function() {
                                t.play()
                            })), window.addEventListener("resize", o()(s, 100))
                        }, u = function e() {
                            t.update(), requestAnimationFrame(e)
                        }, e.next = 9, t.start(i);
                    case 9:
                        c(), s(), a.classList.add("is-hidden"), t.play(), u();
                    case 14:
                    case "end":
                        return e.stop()
                }
            }), e)
        })), (te = function() {
            var t = this,
                n = arguments;
            return new Promise((function(r, i) {
                var o = e.apply(t, n);

                function a(e) {
                    ee(o, r, i, a, s, "next", e)
                }

                function s(e) {
                    ee(o, r, i, a, s, "throw", e)
                }
                a(void 0)
            }))
        }).apply(this, arguments)
    }
}, function(e, t, n) {
    "use strict";
    n.r(t);
    var r = n(0),
        i = n(3),
        o = n.n(i),
        a = n(12),
        s = n.n(a),
        c = n(4),
        u = n(1),
        l = n.n(u),
        f = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\n\nvoid main(void) {\n  // coordinate transformation\n  vec4 mPosition = modelMatrix * vec4(position, 1.0);\n\n  vPosition = position;\n  vUv = uv;\n\n  gl_Position = projectionMatrix * viewMatrix * mPosition;\n}\n",
        d = "precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\nuniform sampler2D texture;\nuniform sampler2D textureNoise;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\n\nfloat random(vec2 c){\n  return fract(sin(dot(c.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec4 getGlitchColor(vec2 uv, float force) {\n  vec2 r = vec2(\n    random(vec2(ceil(time * 20.0), 0.0)) * 2.0 - 1.0,\n    random(vec2(0.0, ceil(time * 20.0))) * 2.0 - 1.0\n  );\n  vec2 noiseUv = uv + r * 0.001;\n  float mask = smoothstep(\n    length(vec3(1.0)) - force * 0.004,\n    length(vec3(1.0)),\n    length(texture2D(textureNoise, uv * vec2(0.2, 0.4) * r).rgb)\n    );\n  vec4 texColor = texture2D(texture, noiseUv + r * 0.01 * force) * (1.0 - mask);\n  vec4 texColorDiff = texture2D(texture, noiseUv + r * force) * mask;\n  return texColor + texColorDiff;\n}\n\nvoid main() {\n  float shake = random(vec2(time));\n  float force = smoothstep(0.5, 1.0, sin(time * 4.0) * 0.8 + sin(time * 5.0) + 0.2);\n\n  vec2 uvR = vUv + vec2(-0.008 - shake * 0.002, 0.0);\n  vec2 uvG = vUv + vec2( 0.0, 0.0);\n  vec2 uvB = vUv + vec2( 0.008 + shake * 0.002, 0.0);\n\n  vec4 r = getGlitchColor(uvR, force) * vec4(1.0, 0.0, 0.0, 1.0);\n  vec4 g = getGlitchColor(uvG, force) * vec4(0.0, 1.0, 0.0, 1.0);\n  vec4 b = getGlitchColor(uvB, force) * vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 color = r + g + b;\n\n  if (color.a < 0.1) discard;\n\n  gl_FragColor = color;\n}\n";

    function h(e) {
        return (h = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
            return typeof e
        } : function(e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
        })(e)
    }

    function v(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }

    function p(e, t) {
        return !t || "object" !== h(t) && "function" != typeof t ? function(e) {
            if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return e
        }(e) : t
    }

    function m(e) {
        return (m = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
            return e.__proto__ || Object.getPrototypeOf(e)
        })(e)
    }

    function y(e, t) {
        return (y = Object.setPrototypeOf || function(e, t) {
            return e.__proto__ = t, e
        })(e, t)
    }
    var g = function(e) {
            function t() {
                var e;
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, t);
                var n = new r.PlaneBufferGeometry(20, 10),
                    i = new r.RawShaderMaterial({
                        uniforms: {
                            time: {
                                type: "f",
                                value: 0
                            },
                            texture: {
                                type: "t",
                                value: null
                            },
                            textureNoise: {
                                type: "t",
                                value: null
                            }
                        },
                        vertexShader: f,
                        fragmentShader: d,
                        transparent: !0,
                        blending: r.AdditiveBlending
                    });
                return (e = p(this, m(t).call(this, n, i))).name = "Typo", e
            }
            var n, i, o;
            return function(e, t) {
                if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
                e.prototype = Object.create(t && t.prototype, {
                    constructor: {
                        value: e,
                        writable: !0,
                        configurable: !0
                    }
                }), t && y(e, t)
            }(t, e), n = t, (i = [{
                key: "start",
                value: function(e, t) {
                    this.material.uniforms.texture.value = e, this.material.uniforms.textureNoise.value = t
                }
            }, {
                key: "update",
                value: function(e) {
                    this.material.uniforms.time.value += e
                }
            }]) && v(n.prototype, i), o && v(n, o), t
        }(r.Mesh),
        x = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\nattribute vec3 iPosition;\nattribute float iIds;\n\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\nuniform float time;\n\nvarying vec3 vPosition;\n\nmat4 calcRotateMat4X(float radian) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, cos(radian), -sin(radian), 0.0,\n    0.0, sin(radian), cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4Y(float radian) {\n  return mat4(\n    cos(radian), 0.0, sin(radian), 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    -sin(radian), 0.0, cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4Z(float radian) {\n  return mat4(\n    cos(radian), -sin(radian), 0.0, 0.0,\n    sin(radian), cos(radian), 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 calcRotateMat4(vec3 radian) {\n  return calcRotateMat4X(radian.x) * calcRotateMat4Y(radian.y) * calcRotateMat4Z(radian.z);\n}\n\nvoid main(void) {\n  // coordinate transformation\n  mat4 rotateMat = calcRotateMat4(vec3(radians(iIds * 20.0 + time * 4.0)));\n  vec3 rotatePosition = (rotateMat * vec4(position, 1.0)).xyz;\n  mat4 rotateMatWorld = calcRotateMat4Y(radians(iIds * 56.0 + time * 0.5));\n  vec4 mPosition = modelMatrix * rotateMatWorld * vec4(iPosition + rotatePosition, 1.0);\n\n  vPosition = mPosition.xyz;\n\n  gl_Position = projectionMatrix * viewMatrix * mPosition;\n}\n",
        b = "precision highp float;\n#define GLSLIFY 1\n\nvarying vec3 vPosition;\n\nvoid main() {\n  vec3 light = normalize(vec3(1.0, 1.0, 1.0));\n  vec3 normal = normalize(cross(dFdx(vPosition), dFdy(vPosition)));\n  float diff = pow((dot(normal, light) + 1.0) / 2.0, 3.0);\n\n  vec3 rgb = vec3(10.0 / 255.0, 20.0 / 255.0, 38.0 / 255.0);\n\n  gl_FragColor = vec4(rgb + diff * 0.2, 1.0);\n}\n";

    function w(e) {
        return (w = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
            return typeof e
        } : function(e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
        })(e)
    }

    function M(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }

    function _(e, t) {
        return !t || "object" !== w(t) && "function" != typeof t ? function(e) {
            if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return e
        }(e) : t
    }

    function S(e) {
        return (S = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
            return e.__proto__ || Object.getPrototypeOf(e)
        })(e)
    }

    function P(e, t) {
        return (P = Object.setPrototypeOf || function(e, t) {
            return e.__proto__ = t, e
        })(e, t)
    }
    var T = function(e) {
            function t() {
                var e;
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, t);
                var n = new r.InstancedBufferGeometry,
                    i = new r.OctahedronBufferGeometry(2, 0);
                n.copy(i);
                for (var o = new r.InstancedBufferAttribute(new Float32Array(90), 3), a = new r.InstancedBufferAttribute(new Float32Array(30), 1), s = (r.Vector3(), 0); s < 30; s++) o.setXYZ(s, 3 * s + 15, 0, 0), a.setXYZ(s, s);
                n.addAttribute("iPosition", o), n.addAttribute("iIds", a);
                var c = new r.RawShaderMaterial({
                    uniforms: {
                        time: {
                            type: "f",
                            value: 0
                        }
                    },
                    vertexShader: x,
                    fragmentShader: b,
                    flatShading: !0
                });
                return (e = _(this, S(t).call(this, n, c))).rotation.set(0, l.a.radians(40), l.a.radians(30)), e.name = "Debris", e
            }
            var n, i, o;
            return function(e, t) {
                if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
                e.prototype = Object.create(t && t.prototype, {
                    constructor: {
                        value: e,
                        writable: !0,
                        configurable: !0
                    }
                }), t && P(e, t)
            }(t, e), n = t, (i = [{
                key: "start",
                value: function() {}
            }, {
                key: "update",
                value: function(e) {
                    this.material.uniforms.time.value += e
                }
            }]) && M(n.prototype, i), o && M(n, o), t
        }(r.Mesh),
        E = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\n\nvarying vec2 vUv;\n\nvoid main(void) {\n  // coordinate transformation\n  vec4 mPosition = modelMatrix * vec4(position, 1.0);\n\n  vUv = uv;\n\n  gl_Position = projectionMatrix * viewMatrix * mPosition;\n}\n",
        z = "precision highp float;\n#define GLSLIFY 1\n\nuniform float time;\n\nvarying vec2 vUv;\nvarying vec3 vColor;\n\nfloat random(vec2 c){\n  return fract(sin(dot(c.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nconst vec3 rgb1 = vec3(0.0 / 255.0, 0.0 / 255.0, 0.0 / 255.0);\nconst vec3 rgb2 = vec3(44.0 / 255.0, 58.0 / 255.0, 83.0 / 255.0);\n\nvoid main() {\n  vec3 rgb = mix(rgb1, rgb2, vUv.y * 4.0 - 1.0);\n  float noise = random(vUv + vec2(0.0, time * 0.01)) * 0.04;\n\n  gl_FragColor = vec4(rgb + noise, 1.0);\n}\n";

    function L(e) {
        return (L = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
            return typeof e
        } : function(e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
        })(e)
    }

    function A(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }

    function C(e, t) {
        return !t || "object" !== L(t) && "function" != typeof t ? function(e) {
            if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return e
        }(e) : t
    }

    function R(e) {
        return (R = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
            return e.__proto__ || Object.getPrototypeOf(e)
        })(e)
    }

    function O(e, t) {
        return (O = Object.setPrototypeOf || function(e, t) {
            return e.__proto__ = t, e
        })(e, t)
    }
    var j = function(e) {
        function t() {
            var e;
            ! function(e, t) {
                if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
            }(this, t);
            var n = new r.SphereBufferGeometry(100, 12, 12),
                i = new r.RawShaderMaterial({
                    uniforms: {
                        time: {
                            type: "f",
                            value: 0
                        }
                    },
                    vertexShader: E,
                    fragmentShader: z,
                    side: r.BackSide
                });
            return (e = C(this, R(t).call(this, n, i))).name = "Background", e
        }
        var n, i, o;
        return function(e, t) {
            if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
            e.prototype = Object.create(t && t.prototype, {
                constructor: {
                    value: e,
                    writable: !0,
                    configurable: !0
                }
            }), t && O(e, t)
        }(t, e), n = t, (i = [{
            key: "start",
            value: function() {}
        }, {
            key: "update",
            value: function(e) {
                this.material.uniforms.time.value += e
            }
        }]) && A(n.prototype, i), o && A(n, o), t
    }(r.Mesh);

    function I(e, t, n, r, i, o, a) {
        try {
            var s = e[o](a),
                c = s.value
        } catch (e) {
            return void n(e)
        }
        s.done ? t(c) : Promise.resolve(c).then(r, i)
    }
    t.default = function() {
        return D.apply(this, arguments)
    };

    function D() {
        var e;
        return e = regeneratorRuntime.mark((function e() {
            var t, n, i, a, u, l, f, d, h, v, p, m, y, x, b, w, M;
            return regeneratorRuntime.wrap((function(e) {
                for (;;) switch (e.prev = e.next) {
                    case 0:
                        return t = new r.Vector2, n = document.getElementById("canvas-webgl"), i = new r.WebGLRenderer({
                            alpha: !0,
                            antialias: !0,
                            canvas: n
                        }), a = new r.Scene, u = new r.PerspectiveCamera, l = new r.Vector2, f = new r.Clock({
                            autoStart: !1
                        }), d = document.querySelector(".p-preloader"), h = new g, v = new T, p = new j, y = function() {
                            var e = f.getDelta();
                            h.update(e), v.update(e), p.update(e), i.render(a, u)
                        }, x = function e() {
                            y(), requestAnimationFrame(e)
                        }, b = function() {
                            t.x > t.y ? l.set(t.x >= 1200 ? 1200 : t.x, t.x >= 1200 ? 800 : .66 * t.x) : l.set(.6 * (t.y >= 1200 ? 800 : .66 * t.y), .6 * (t.y >= 1200 ? 1200 : t.y)), u.setViewOffset(l.x, l.y, (t.x - l.x) / -2, (t.y - l.y) / -2, t.x, t.y), u.updateProjectionMatrix()
                        }, w = function() {
                            t.set(document.body.clientWidth, window.innerHeight), n.width = t.x, n.height = t.y, b(), i.setSize(t.x, t.y)
                        }, M = function() {
                            window.addEventListener("blur", (function() {
                                f.stop()
                            })), window.addEventListener("focus", (function() {
                                f.start()
                            })), window.addEventListener("resize", o()(w, 100))
                        }, i.setClearColor(1118481, 1), u.aspect = 1.5, u.far = 1e3, u.setFocalLength(50), u.position.set(0, 0, 50), u.lookAt(new r.Vector3), e.next = 24, Promise.all([Object(c.default)("../img/sketch/easy_glitch/typo.png"), Object(c.default)("../img/sketch/easy_glitch/noise.png")]).then((function(e) {
                            m = e
                        }));
                    case 24:
                        return m && (m[0].wrapS = r.RepeatWrapping, m[0].wrapT = r.RepeatWrapping, m[1].wrapS = r.RepeatWrapping, m[1].wrapT = r.RepeatWrapping, m[1].minFilter = r.NearestFilter, m[1].magFilter = r.NearestFilter, h.start(m[0], m[1]), a.add(h)), v.start(), p.start(), a.add(v), a.add(p), M(), w(), d.classList.add("is-hidden"), e.next = 34, s()(200);
                    case 34:
                        f.start(), x();
                    case 36:
                    case "end":
                        return e.stop()
                }
            }), e)
        })), (D = function() {
            var t = this,
                n = arguments;
            return new Promise((function(r, i) {
                var o = e.apply(t, n);

                function a(e) {
                    I(o, r, i, a, s, "next", e)
                }

                function s(e) {
                    I(o, r, i, a, s, "throw", e)
                }
                a(void 0)
            }))
        }).apply(this, arguments)
    }
}, function(e, t, n) {
    "use strict";
    n.r(t);
    var r = n(0),
        i = n(3),
        o = n.n(i);
    n(12);

    function a(e) {
        return (a = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
            return typeof e
        } : function(e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
        })(e)
    }

    function s(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }

    function c(e, t) {
        return !t || "object" !== a(t) && "function" != typeof t ? function(e) {
            if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return e
        }(e) : t
    }

    function u(e) {
        return (u = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
            return e.__proto__ || Object.getPrototypeOf(e)
        })(e)
    }

    function l(e, t) {
        return (l = Object.setPrototypeOf || function(e, t) {
            return e.__proto__ = t, e
        })(e, t)
    }
    var f = function(e) {
            function t(e, n, i, o) {
                var a;
                return function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, t), (a = c(this, u(t).call(this, e, n, i, o))).cameraResolution = new r.Vector2, a
            }
            var n, i, o;
            return function(e, t) {
                if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
                e.prototype = Object.create(t && t.prototype, {
                    constructor: {
                        value: e,
                        writable: !0,
                        configurable: !0
                    }
                }), t && l(e, t)
            }(t, e), n = t, (i = [{
                key: "start",
                value: function() {
                    this.aspect = 1.5, this.far = 1e3, this.setFocalLength(50), this.position.set(0, 6, 50), this.lookAt(new r.Vector3(0, 6, 0))
                }
            }, {
                key: "update",
                value: function(e) {}
            }, {
                key: "resize",
                value: function(e) {
                    e.x > e.y ? this.cameraResolution.set(e.x >= 1200 ? 1200 : e.x, e.x >= 1200 ? 800 : .66 * e.x) : this.cameraResolution.set(.6 * (e.y >= 1200 ? 800 : .66 * e.y), .6 * (e.y >= 1200 ? 1200 : e.y)), this.setViewOffset(this.cameraResolution.x, this.cameraResolution.y, (e.x - this.cameraResolution.x) / -2, (e.y - this.cameraResolution.y) / -2, e.x, e.y), this.updateProjectionMatrix()
                }
            }]) && s(n.prototype, i), o && s(n, o), t
        }(r.PerspectiveCamera),
        d = n(1),
        h = n.n(d),
        v = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\n\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\n\nvarying vec3 vPosition;\nvarying vec3 vNormal;\nvarying vec2 vUv;\nvarying vec3 vColor;\nvarying mat4 invertMatrix;\n\nfloat inverse(float m) {\n  return 1.0 / m;\n}\n\nmat2 inverse(mat2 m) {\n  return mat2(m[1][1],-m[0][1],\n             -m[1][0], m[0][0]) / (m[0][0]*m[1][1] - m[0][1]*m[1][0]);\n}\n\nmat3 inverse(mat3 m) {\n  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2];\n  float a10 = m[1][0], a11 = m[1][1], a12 = m[1][2];\n  float a20 = m[2][0], a21 = m[2][1], a22 = m[2][2];\n\n  float b01 = a22 * a11 - a12 * a21;\n  float b11 = -a22 * a10 + a12 * a20;\n  float b21 = a21 * a10 - a11 * a20;\n\n  float det = a00 * b01 + a01 * b11 + a02 * b21;\n\n  return mat3(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11),\n              b11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10),\n              b21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)) / det;\n}\n\nmat4 inverse(mat4 m) {\n  float\n      a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\n      a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\n      a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\n      a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3],\n\n      b00 = a00 * a11 - a01 * a10,\n      b01 = a00 * a12 - a02 * a10,\n      b02 = a00 * a13 - a03 * a10,\n      b03 = a01 * a12 - a02 * a11,\n      b04 = a01 * a13 - a03 * a11,\n      b05 = a02 * a13 - a03 * a12,\n      b06 = a20 * a31 - a21 * a30,\n      b07 = a20 * a32 - a22 * a30,\n      b08 = a20 * a33 - a23 * a30,\n      b09 = a21 * a32 - a22 * a31,\n      b10 = a21 * a33 - a23 * a31,\n      b11 = a22 * a33 - a23 * a32,\n\n      det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  return mat4(\n      a11 * b11 - a12 * b10 + a13 * b09,\n      a02 * b10 - a01 * b11 - a03 * b09,\n      a31 * b05 - a32 * b04 + a33 * b03,\n      a22 * b04 - a21 * b05 - a23 * b03,\n      a12 * b08 - a10 * b11 - a13 * b07,\n      a00 * b11 - a02 * b08 + a03 * b07,\n      a32 * b02 - a30 * b05 - a33 * b01,\n      a20 * b05 - a22 * b02 + a23 * b01,\n      a10 * b10 - a11 * b08 + a13 * b06,\n      a01 * b08 - a00 * b10 - a03 * b06,\n      a30 * b04 - a31 * b02 + a33 * b00,\n      a21 * b02 - a20 * b04 - a23 * b00,\n      a11 * b07 - a10 * b09 - a12 * b06,\n      a00 * b09 - a01 * b07 + a02 * b06,\n      a31 * b01 - a30 * b03 - a32 * b00,\n      a20 * b03 - a21 * b01 + a22 * b00) / det;\n}\n\nvoid main(void) {\n  // coordinate transformation\n  vec4 mPosition = modelMatrix * vec4(position, 1.0);\n\n  vPosition = position;\n  vNormal = normal;\n  vUv = uv;\n  vColor = vec3(1.0, 0.0, 0.0);\n  invertMatrix = inverse(modelMatrix);\n\n  gl_Position = projectionMatrix * viewMatrix * mPosition;\n}\n",
        p = "precision highp float;\n#define GLSLIFY 1\n\nuniform vec3 cameraPosition;\n\n#if NUM_DIR_LIGHTS > 0\n  struct DirectionalLight {\n    vec3 direction;\n    vec3 color;\n  };\n  uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n#endif\n\nvarying vec3 vPosition;\nvarying vec3 vNormal;\nvarying vec2 vUv;\nvarying vec3 vColor;\nvarying mat4 invertMatrix;\n\nvoid main() {\n  // Phong Shading\n  vec3 diff;\n  vec3 specular;\n  vec3 invLight;\n  vec3 invEye;\n  vec3 halfLE;\n\n  #if NUM_DIR_LIGHT_SHADOWS > 0\n    #pragma unroll_loop\n    for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n      invLight = normalize(invertMatrix * vec4(directionalLights[ i ].direction, 0.0)).xyz;\n      invEye = normalize(invertMatrix * vec4(cameraPosition, 0.0)).xyz;\n      diff += clamp(dot(vNormal, invLight), 0.0, 1.0);\n\n      halfLE = normalize(invLight + invEye);\n      specular += directionalLights[ i ].color * pow(max(dot(vNormal, halfLE), 0.0), 30.0);\n    }\n  #endif\n\n  vec4 destColor = vec4(vColor * diff + specular, 1.0);\n\n  gl_FragColor    = destColor;\n}\n";

    function m(e) {
        return (m = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
            return typeof e
        } : function(e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
        })(e)
    }

    function y(e, t) {
        var n = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
            var r = Object.getOwnPropertySymbols(e);
            t && (r = r.filter((function(t) {
                return Object.getOwnPropertyDescriptor(e, t).enumerable
            }))), n.push.apply(n, r)
        }
        return n
    }

    function g(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = null != arguments[t] ? arguments[t] : {};
            t % 2 ? y(n, !0).forEach((function(t) {
                x(e, t, n[t])
            })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : y(n).forEach((function(t) {
                Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
            }))
        }
        return e
    }

    function x(e, t, n) {
        return t in e ? Object.defineProperty(e, t, {
            value: n,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : e[t] = n, e
    }

    function b(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }

    function w(e, t) {
        return !t || "object" !== m(t) && "function" != typeof t ? function(e) {
            if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return e
        }(e) : t
    }

    function M(e) {
        return (M = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
            return e.__proto__ || Object.getPrototypeOf(e)
        })(e)
    }

    function _(e, t) {
        return (_ = Object.setPrototypeOf || function(e, t) {
            return e.__proto__ = t, e
        })(e, t)
    }
    var S = function(e) {
            function t() {
                var e;
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, t);
                var n = new r.TorusKnotBufferGeometry(2.4, .8, 200, 32),
                    i = new r.RawShaderMaterial({
                        uniforms: g({}, r.UniformsLib.lights, {
                            time: {
                                type: "f",
                                value: 0
                            }
                        }),
                        vertexShader: v,
                        fragmentShader: p,
                        lights: !0
                    });
                return (e = w(this, M(t).call(this, n, i))).name = "Blob", e.position.set(0, 8, 0), e.castShadow = !0, e.receiveShadow = !1, e
            }
            var n, i, o;
            return function(e, t) {
                if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
                e.prototype = Object.create(t && t.prototype, {
                    constructor: {
                        value: e,
                        writable: !0,
                        configurable: !0
                    }
                }), t && _(e, t)
            }(t, e), n = t, (i = [{
                key: "start",
                value: function() {}
            }, {
                key: "update",
                value: function(e) {
                    this.material.uniforms.time.value += e, this.rotation.set(this.material.uniforms.time.value, this.material.uniforms.time.value, 0)
                }
            }]) && b(n.prototype, i), o && b(n, o), t
        }(r.Mesh),
        P = "#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\nuniform mat4 directionalShadowMatrix[NUM_DIR_LIGHT_SHADOWS];\nuniform float time;\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\nvarying vec4 vDirectionalShadowCoord[NUM_DIR_LIGHT_SHADOWS];\n\nvoid main(void) {\n  // coordinate transformation\n  vec4 mPosition = modelMatrix * vec4(position + sin((uv.x + uv.y) * 10.0 + time) * 0.5, 1.0);\n\n  vPosition = mPosition.xyz;\n  vUv = uv;\n\n  #if NUM_DIR_LIGHT_SHADOWS > 0\n    #pragma unroll_loop\n    for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n      vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * mPosition;\n    }\n  #endif\n\n  gl_Position = projectionMatrix * viewMatrix * mPosition;\n}\n",
        T = "precision highp float;\n#define GLSLIFY 1\n\n#if NUM_DIR_LIGHTS > 0\n  struct DirectionalLight {\n    vec3 direction;\n    vec3 color;\n  };\n  uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n#endif\n\nuniform sampler2D directionalShadowMap[NUM_DIR_LIGHT_SHADOWS];\n\nvarying vec3 vPosition;\nvarying vec2 vUv;\nvarying vec4 vDirectionalShadowCoord[NUM_DIR_LIGHT_SHADOWS];\n\nvoid main() {\n  // Phong Shading\n  vec3 normal;\n  vec3 diff;\n  vec3 lightColor;\n\n  #if NUM_DIR_LIGHT_SHADOWS > 0\n    #pragma unroll_loop\n    for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n      normal = normalize(cross(dFdx(vPosition), dFdy(vPosition)));\n      diff += (dot(normal, directionalLights[ i ].direction) + 1.0) / 2.0;\n      lightColor += directionalLights[ i ].color;\n    }\n  #endif\n\n  vec4 shadow;\n\n  #if NUM_DIR_LIGHT_SHADOWS > 0\n    #pragma unroll_loop\n    for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n      shadow += texture2DProj(directionalShadowMap[ i ], vDirectionalShadowCoord[ i ]);\n    }\n  #endif\n\n  gl_FragColor = vec4(lightColor * diff, 1.0) * shadow;\n}\n";

    function E(e) {
        return (E = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
            return typeof e
        } : function(e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
        })(e)
    }

    function z(e, t) {
        var n = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
            var r = Object.getOwnPropertySymbols(e);
            t && (r = r.filter((function(t) {
                return Object.getOwnPropertyDescriptor(e, t).enumerable
            }))), n.push.apply(n, r)
        }
        return n
    }

    function L(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = null != arguments[t] ? arguments[t] : {};
            t % 2 ? z(n, !0).forEach((function(t) {
                A(e, t, n[t])
            })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : z(n).forEach((function(t) {
                Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
            }))
        }
        return e
    }

    function A(e, t, n) {
        return t in e ? Object.defineProperty(e, t, {
            value: n,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : e[t] = n, e
    }

    function C(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }

    function R(e, t) {
        return !t || "object" !== E(t) && "function" != typeof t ? function(e) {
            if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return e
        }(e) : t
    }

    function O(e) {
        return (O = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
            return e.__proto__ || Object.getPrototypeOf(e)
        })(e)
    }

    function j(e, t) {
        return (j = Object.setPrototypeOf || function(e, t) {
            return e.__proto__ = t, e
        })(e, t)
    }
    var I = function(e) {
        function t() {
            var e;
            ! function(e, t) {
                if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
            }(this, t);
            var n = new r.PlaneBufferGeometry(30, 30, 128, 128),
                i = new r.RawShaderMaterial({
                    uniforms: L({}, r.UniformsLib.lights, {
                        time: {
                            type: "f",
                            value: 0
                        }
                    }),
                    vertexShader: P,
                    fragmentShader: T,
                    flatShading: !0
                });
            return (e = R(this, O(t).call(this, n, i))).name = "Floor", e.rotation.set(h.a.radians(-90), 0, 0), e.receiveShadow = !0, e
        }
        var n, i, o;
        return function(e, t) {
            if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
            e.prototype = Object.create(t && t.prototype, {
                constructor: {
                    value: e,
                    writable: !0,
                    configurable: !0
                }
            }), t && j(e, t)
        }(t, e), n = t, (i = [{
            key: "start",
            value: function() {
                console.log(this.material.uniforms)
            }
        }, {
            key: "update",
            value: function(e) {
                this.material.uniforms.time.value += e
            }
        }]) && C(n.prototype, i), o && C(n, o), t
    }(r.Mesh);

    function D(e) {
        return (D = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
            return typeof e
        } : function(e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
        })(e)
    }

    function k(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }

    function F(e, t) {
        return !t || "object" !== D(t) && "function" != typeof t ? function(e) {
            if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return e
        }(e) : t
    }

    function G(e) {
        return (G = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
            return e.__proto__ || Object.getPrototypeOf(e)
        })(e)
    }

    function N(e, t) {
        return (N = Object.setPrototypeOf || function(e, t) {
            return e.__proto__ = t, e
        })(e, t)
    }
    var B, U = function(e) {
        function t() {
            var e;
            return function(e, t) {
                if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
            }(this, t), (e = F(this, G(t).call(this, 16776960, .5))).name = "Light", e.castShadow = !0, e.shadow.camera.left = e.shadow.camera.bottom = -10, e.shadow.camera.right = e.shadow.camera.top = 10, e.time = 0, e.isActive = !1, e
        }
        var n, r, i;
        return function(e, t) {
            if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
            e.prototype = Object.create(t && t.prototype, {
                constructor: {
                    value: e,
                    writable: !0,
                    configurable: !0
                }
            }), t && N(e, t)
        }(t, e), n = t, (r = [{
            key: "start",
            value: function() {
                this.isActive = !0
            }
        }, {
            key: "update",
            value: function(e) {
                !1 !== this.isActive && (this.time += e)
            }
        }]) && k(n.prototype, r), i && k(n, i), t
    }(r.DirectionalLight);

    function H(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }
    var V = new r.Scene,
        W = new f,
        Y = new r.Clock({
            autoStart: !1
        }),
        X = new S,
        q = new I,
        K = new U,
        Z = new U,
        J = function() {
            function e() {
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, e)
            }
            var t, n, i;
            return t = e, (n = [{
                key: "start",
                value: function(e) {
                    (B = new r.WebGLRenderer({
                        alpha: !0,
                        antialias: !0,
                        canvas: e
                    })).setPixelRatio(window.devicePixelRatio), B.setClearColor(921102, 1), B.shadowMap.enabled = !0, B.shadowMap.type = r.PCFSoftShadowMap, X.start(), q.start(), K.position.set(-10, 16, 10), Z.position.set(10, 16, -10), V.add(X), V.add(q), V.add(K), V.add(Z), W.start()
                }
            }, {
                key: "play",
                value: function() {
                    Y.start(), this.update()
                }
            }, {
                key: "pause",
                value: function() {
                    Y.stop()
                }
            }, {
                key: "update",
                value: function() {
                    if (!1 !== Y.running) {
                        var e = Y.getDelta();
                        W.update(e), X.update(e), q.update(e), K.update(e), Z.update(e), B.render(V, W)
                    }
                }
            }, {
                key: "resize",
                value: function(e) {
                    W.resize(e), B.setSize(e.x, e.y)
                }
            }]) && H(t.prototype, n), i && H(t, i), e
        }();

    function Q(e, t, n, r, i, o, a) {
        try {
            var s = e[o](a),
                c = s.value
        } catch (e) {
            return void n(e)
        }
        s.done ? t(c) : Promise.resolve(c).then(r, i)
    }
    t.default = function() {
        return $.apply(this, arguments)
    };

    function $() {
        var e;
        return e = regeneratorRuntime.mark((function e() {
            var t, n, i, a, s, c, u;
            return regeneratorRuntime.wrap((function(e) {
                for (;;) switch (e.prev = e.next) {
                    case 0:
                        return t = new J, n = new r.Vector2, i = document.getElementById("canvas-webgl"), a = document.querySelector(".p-preloader"), s = function() {
                            n.set(document.body.clientWidth, window.innerHeight), i.width = n.x, i.height = n.y, t.resize(n)
                        }, c = function() {
                            window.addEventListener("blur", (function() {
                                t.pause()
                            })), window.addEventListener("focus", (function() {
                                t.play()
                            })), window.addEventListener("resize", o()(s, 100))
                        }, u = function e() {
                            t.update(), requestAnimationFrame(e)
                        }, e.next = 9, t.start(i);
                    case 9:
                        c(), s(), a.classList.add("is-hidden"), t.play(), u();
                    case 14:
                    case "end":
                        return e.stop()
                }
            }), e)
        })), ($ = function() {
            var t = this,
                n = arguments;
            return new Promise((function(r, i) {
                var o = e.apply(t, n);

                function a(e) {
                    Q(o, r, i, a, s, "next", e)
                }

                function s(e) {
                    Q(o, r, i, a, s, "throw", e)
                }
                a(void 0)
            }))
        }).apply(this, arguments)
    }
}, function(e, t, n) {
    "use strict";
    n.r(t);
    var r = n(0),
        i = n(3),
        o = n.n(i),
        a = n(12),
        s = n.n(a),
        c = n(1),
        u = n.n(c);

    function l(e, t, n, r, i, o, a) {
        try {
            var s = e[o](a),
                c = s.value
        } catch (e) {
            return void n(e)
        }
        s.done ? t(c) : Promise.resolve(c).then(r, i)
    }

    function f(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }
    var d = n(47).default,
        h = n(4).default,
        v = function() {
            function e() {
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, e), this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    },
                    tex: {
                        type: "t",
                        value: null
                    }
                }, this.obj
            }
            var t, i, o, a, s;
            return t = e, (i = [{
                key: "createObj",
                value: (a = regeneratorRuntime.mark((function e() {
                    var t, i;
                    return regeneratorRuntime.wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return e.next = 2, d("/sketch-threejs/model/buddha/buddha_head.obj");
                            case 2:
                                return t = e.sent, e.next = 5, h("/sketch-threejs/model/buddha/buddha_ao.jpg");
                            case 5:
                                this.uniforms.tex.value = e.sent, i = new r.RawShaderMaterial({
                                    uniforms: this.uniforms,
                                    vertexShader: n(391).default,
                                    fragmentShader: n(392).default,
                                    flatShading: !0
                                }), this.obj = new r.Mesh(t.children[0].geometry, i), this.obj.position.y = 16, this.obj.scale.set(7, 7, 7);
                            case 10:
                            case "end":
                                return e.stop()
                        }
                    }), e, this)
                })), s = function() {
                    var e = this,
                        t = arguments;
                    return new Promise((function(n, r) {
                        var i = a.apply(e, t);

                        function o(e) {
                            l(i, n, r, o, s, "next", e)
                        }

                        function s(e) {
                            l(i, n, r, o, s, "throw", e)
                        }
                        o(void 0)
                    }))
                }, function() {
                    return s.apply(this, arguments)
                })
            }, {
                key: "render",
                value: function(e, t, n) {
                    this.uniforms.time.value += e, this.obj.rotation.set(u.a.radians(t - 15), u.a.radians(n + 15 - 5 * this.uniforms.time.value), u.a.radians(-20))
                }
            }]) && f(t.prototype, i), o && f(t, o), e
        }(),
        p = n(4);

    function m(e, t, n, r, i, o, a) {
        try {
            var s = e[o](a),
                c = s.value
        } catch (e) {
            return void n(e)
        }
        s.done ? t(c) : Promise.resolve(c).then(r, i)
    }

    function y(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }
    var g = 4,
        x = void 0,
        b = void 0,
        w = void 0,
        M = void 0,
        _ = void 0,
        S = void 0,
        P = void 0,
        T = 0,
        E = 0,
        z = 0,
        L = function() {
            function e() {
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, e), this.uniforms = {
                    time: {
                        type: "f",
                        value: 0
                    },
                    texHannyaShingyo: {
                        type: "t",
                        value: void 0
                    },
                    unitUv: {
                        type: "f",
                        value: 0
                    },
                    duration: {
                        type: "f",
                        value: g
                    }
                }, this.obj
            }
            var t, i, o, a, s;
            return t = e, (i = [{
                key: "createObj",
                value: (a = regeneratorRuntime.mark((function e() {
                    var t, i, o, a, s, c, l, f;
                    return regeneratorRuntime.wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                for (t = "観自在菩薩行深般若波羅蜜多時照見五蘊皆空度一切苦厄舎利子色不異空空不異色色即是空空即是色受想行識亦復如是舎利子是諸法空相不生不滅不垢不浄不増不減是故空中無色無受想行識無眼耳鼻舌身意無色声香味触法無眼界乃至無意識界無無明亦無無明尽乃至無老死亦無老死尽無苦集滅道無智亦無得以無所得故菩提薩埵依般若波羅蜜多故心無罣礙無罣礙故無有恐怖遠離一切顛倒夢想究竟涅槃三世諸仏依般若波羅蜜多故得阿耨多羅三藐三菩提故知般若波羅蜜多是大神呪是大明呪是無上呪是無等等呪能除一切苦真実不虚故説般若波羅蜜多呪即説呪日羯諦羯諦波羅羯諦波羅僧羯諦菩提薩婆訶般若心経", i = Math.ceil(Math.sqrt(t.length)), o = new r.InstancedBufferGeometry, a = new r.PlaneBufferGeometry(6, 6), o.copy(a), T = t.length, x = new r.InstancedBufferAttribute(new Float32Array(3 * T), 3), b = new r.InstancedBufferAttribute(new Float32Array(2 * T), 2), w = new r.InstancedBufferAttribute(new Float32Array(T), 1), M = new r.InstancedBufferAttribute(new Float32Array(T), 1), _ = new r.InstancedBufferAttribute(new Float32Array(T), 1), S = new r.InstancedBufferAttribute(new Float32Array(T), 1), P = new r.InstancedBufferAttribute(new Float32Array(T), 1), s = 0; s < i; s++)
                                    for (c = 0; c < i; c++) l = s * i + c, u.a.radians(360 * Math.random()), Math.random(), b.setXY(l, c / i, (i - s - 1) / i), w.setX(l, l);
                                return o.addAttribute("iPosition", x), o.addAttribute("iUv", b), o.addAttribute("iId", w), o.addAttribute("iTime", M), o.addAttribute("iIsAnimated", _), o.addAttribute("iScale", S), o.addAttribute("iMove", P), f = new r.RawShaderMaterial({
                                    uniforms: this.uniforms,
                                    vertexShader: n(393).default,
                                    fragmentShader: n(394).default,
                                    transparent: !0,
                                    depthWrite: !1
                                }), e.next = 26, Object(p.default)("/sketch-threejs/img/sketch/buddha/hannya_text.png");
                            case 26:
                                this.uniforms.texHannyaShingyo.value = e.sent, this.uniforms.unitUv.value = 1 / i, this.obj = new r.Mesh(o, f), this.obj.position.y = 0, this.obj.frustumCulled = !1;
                            case 31:
                            case "end":
                                return e.stop()
                        }
                    }), e, this)
                })), s = function() {
                    var e = this,
                        t = arguments;
                    return new Promise((function(n, r) {
                        var i = a.apply(e, t);

                        function o(e) {
                            m(i, n, r, o, s, "next", e)
                        }

                        function s(e) {
                            m(i, n, r, o, s, "throw", e)
                        }
                        o(void 0)
                    }))
                }, function() {
                    return s.apply(this, arguments)
                })
            }, {
                key: "render",
                value: function(e) {
                    if (this.uniforms.time.value += e, (z += e) > .5) {
                        var t = u.a.radians(270 * Math.random() - 45),
                            n = 12 * Math.random() + 12;
                        x.setXYZ(E, Math.cos(t) * n, 0, Math.sin(t) * n), _.setX(E, 1), S.setX(E, .1 * (Math.random() + Math.random() - 1) + 1), P.setX(E, 5 * (Math.random() + Math.random() - 1) + 30), x.needsUpdate = !0, _.needsUpdate = !0, S.needsUpdate = !0, P.needsUpdate = !0, z = 0, E = E >= T - 1 ? 0 : E + 1
                    }
                    for (var r = 0; r < T; r++)
                        if (0 !== _.getX(r)) {
                            var i = M.getX(r);
                            i > g ? (_.setX(r, 0), M.setX(r, 0)) : M.setX(r, i + e)
                        }
                    _.needsUpdate = !0, M.needsUpdate = !0
                }
            }]) && y(t.prototype, i), o && y(t, o), e
        }();

    function A(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }
    var C = function() {
        function e() {
            ! function(e, t) {
                if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
            }(this, e), this.uniforms = {
                time: {
                    type: "f",
                    value: 0
                }
            }, this.obj
        }
        var t, i, o;
        return t = e, (i = [{
            key: "createObj",
            value: function() {
                var e = new r.PlaneBufferGeometry(70, 70, 512, 512),
                    t = new r.RawShaderMaterial({
                        uniforms: this.uniforms,
                        vertexShader: n(395).default,
                        fragmentShader: n(396).default,
                        transparent: !0,
                        flatShading: !0
                    });
                this.obj = new r.Mesh(e, t), this.obj.rotation.set(u.a.radians(-90), 0, 0)
            }
        }, {
            key: "render",
            value: function(e) {
                this.uniforms.time.value += e
            }
        }]) && A(t.prototype, i), o && A(t, o), e
    }();

    function R(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }
    var O = function() {
        function e() {
            ! function(e, t) {
                if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
            }(this, e), this.uniforms = {
                time: {
                    type: "f",
                    value: 0
                }
            }, this.obj
        }
        var t, i, o;
        return t = e, (i = [{
            key: "createObj",
            value: function() {
                for (var e = new r.BufferGeometry, t = [], i = [], o = [], a = 0; a < 1800; a += 3) {
                    var s = Math.random() * Math.random() * 60 + 20,
                        c = u.a.radians(360 * Math.random());
                    t[a + 0] = Math.cos(c) * s, t[a + 1] = 0, t[a + 2] = Math.sin(c) * s, i[a / 3] = 120 * Math.random(), o[a / 3] = 120 * Math.random()
                }
                var l = new r.BufferAttribute(new Float32Array(t), 3),
                    f = new r.BufferAttribute(new Float32Array(i), 1),
                    d = new r.BufferAttribute(new Float32Array(o), 1);
                e.addAttribute("position", l), e.addAttribute("delay1", f), e.addAttribute("delay2", d);
                var h = new r.RawShaderMaterial({
                    uniforms: this.uniforms,
                    vertexShader: n(397).default,
                    fragmentShader: n(398).default,
                    transparent: !0,
                    depthWrite: !1,
                    blending: r.AdditiveBlending
                });
                this.obj = new r.Points(e, h)
            }
        }, {
            key: "render",
            value: function(e) {
                this.uniforms.time.value += e
            }
        }]) && R(t.prototype, i), o && R(t, o), e
    }();

    function j(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }
    var I = function() {
        function e() {
            ! function(e, t) {
                if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
            }(this, e), this.uniforms = {
                time: {
                    type: "f",
                    value: 0
                }
            }, this.obj
        }
        var t, i, o;
        return t = e, (i = [{
            key: "createObj",
            value: function() {
                var e = new r.PlaneBufferGeometry(60, 60, 512, 512),
                    t = new r.RawShaderMaterial({
                        uniforms: this.uniforms,
                        vertexShader: n(399).default,
                        fragmentShader: n(400).default,
                        transparent: !0,
                        flatShading: !0
                    });
                this.obj = new r.Mesh(e, t), this.obj.position.y = 16, this.obj.position.z = -30
            }
        }, {
            key: "render",
            value: function(e) {
                this.uniforms.time.value += e
            }
        }]) && j(t.prototype, i), o && j(t, o), e
    }();

    function D(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }
    var k = function() {
        function e() {
            ! function(e, t) {
                if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
            }(this, e), this.uniforms = {
                time: {
                    type: "f",
                    value: 0
                }
            }, this.obj
        }
        var t, i, o;
        return t = e, (i = [{
            key: "createObj",
            value: function() {
                var e = new r.SphereBufferGeometry(100, 128, 128),
                    t = new r.RawShaderMaterial({
                        uniforms: this.uniforms,
                        vertexShader: n(401).default,
                        fragmentShader: n(402).default,
                        side: r.BackSide
                    });
                this.obj = new r.Mesh(e, t), this.obj.position.y = 16
            }
        }, {
            key: "render",
            value: function(e) {
                this.uniforms.time.value += e
            }
        }]) && D(t.prototype, i), o && D(t, o), e
    }();

    function F(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }
    var G = function() {
        function e(t) {
            ! function(e, t) {
                if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
            }(this, e), this.uniforms = {
                time: {
                    type: "f",
                    value: 0
                },
                texture: {
                    type: "t",
                    value: t
                },
                resolution: {
                    type: "v2",
                    value: new r.Vector2
                }
            }, this.obj
        }
        var t, i, o;
        return t = e, (i = [{
            key: "createObj",
            value: function() {
                var e = new r.PlaneBufferGeometry(2, 2),
                    t = new r.RawShaderMaterial({
                        uniforms: this.uniforms,
                        vertexShader: n(403).default,
                        fragmentShader: n(404).default
                    });
                this.obj = new r.Mesh(e, t)
            }
        }, {
            key: "resize",
            value: function(e, t) {
                this.uniforms.resolution.value.set(e, t)
            }
        }, {
            key: "render",
            value: function(e) {
                this.uniforms.time.value += e
            }
        }]) && F(t.prototype, i), o && F(t, o), e
    }();

    function N(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }
    var B = function() {
        function e(t) {
            ! function(e, t) {
                if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
            }(this, e), this.resolution = t, this.vTouchStart = new r.Vector2, this.vPrev = new r.Vector2, this.v = new r.Vector2, this.a = new r.Vector2, this.anchor = new r.Vector2, this.isTouched = !1
        }
        var t, n, i;
        return t = e, (n = [{
            key: "touchStart",
            value: function(e) {
                e.touches || e.preventDefault(), this.vPrev.copy(this.v), this.a.set(0, 0), this.vTouchStart.set(e.touches ? e.touches[0].clientX : e.clientX, e.touches ? e.touches[0].clientY : e.clientY), this.isTouched = !0
            }
        }, {
            key: "touchMove",
            value: function(e) {
                e.touches && e.preventDefault();
                var t = e.touches ? e.touches[0].clientX : e.clientX,
                    n = e.touches ? e.touches[0].clientY : e.clientY;
                !1 !== this.isTouched && this.anchor.set((t - this.vTouchStart.x) / (this.resolution.x / 200) + this.vPrev.x, u.a.clamp((n - this.vTouchStart.y) / (this.resolution.y / 200) + this.vPrev.y, -90, 90))
            }
        }, {
            key: "touchEnd",
            value: function(e) {
                this.isTouched = !1
            }
        }, {
            key: "render",
            value: function() {
                this.a.set((this.anchor.x - this.v.x) / 10, (this.anchor.y - this.v.y) / 10), this.v.add(this.a)
            }
        }]) && N(t.prototype, n), i && N(t, i), e
    }();

    function U(e, t, n, r, i, o, a) {
        try {
            var s = e[o](a),
                c = s.value
        } catch (e) {
            return void n(e)
        }
        s.done ? t(c) : Promise.resolve(c).then(r, i)
    }
    t.default = function() {
        return H.apply(this, arguments)
    };

    function H() {
        var e;
        return e = regeneratorRuntime.mark((function e() {
            var t, n, i, a, c, u, l, f, d, h, p, m, y, g, x, b, w, M, _, S, P, T, E;
            return regeneratorRuntime.wrap((function(e) {
                for (;;) switch (e.prev = e.next) {
                    case 0:
                        return t = new r.Vector2, n = document.getElementById("canvas-webgl"), i = new r.WebGLRenderer({
                            alpha: !0,
                            antialias: !0,
                            canvas: n
                        }), a = new r.Scene, c = new r.PerspectiveCamera, u = new r.Clock({
                            autoStart: !1
                        }), l = new r.WebGLRenderTarget, f = new r.Scene, d = new r.OrthographicCamera(-1, 1, 1, -1, 1, 2), h = document.querySelector(".p-preloader"), p = new v, m = new L, y = new C, g = new O, x = new I, b = new k, w = new B(t), (M = new G(l.texture)).createObj(), f.add(M.obj), _ = function() {
                            var e = u.getDelta();
                            w.render(t), p.render(e, w.v.y, w.v.x), m.render(e), y.render(e), g.render(e), x.render(e), i.setRenderTarget(l), i.render(a, c), M.render(e), i.setRenderTarget(null), i.render(f, d)
                        }, S = function e() {
                            _(), requestAnimationFrame(e)
                        }, P = function() {
                            c.setFocalLength(35 * Math.min(t.x / 1200, 1) + 15), c.setViewOffset(1200, 800, (t.x - 1200) / -2, (t.y - 800) / -2, t.x, t.y), c.updateProjectionMatrix()
                        }, T = function() {
                            t.set(document.body.clientWidth, window.innerHeight), n.width = t.x, n.height = t.y, P(), i.setSize(t.x, t.y), l.setSize(t.x, t.y), M.resize(t.x, t.y)
                        }, E = function() {
                            var e = function(e) {
                                    w.touchStart(e)
                                },
                                t = function(e) {
                                    w.touchMove(e)
                                },
                                r = function(e) {
                                    w.touchEnd(e)
                                };
                            n.addEventListener("mousedown", e, {
                                passive: !1
                            }), window.addEventListener("mousemove", t, {
                                passive: !1
                            }), window.addEventListener("mouseup", r), n.addEventListener("touchstart", e, {
                                passive: !1
                            }), window.addEventListener("touchmove", t, {
                                passive: !1
                            }), window.addEventListener("touchend", r), window.addEventListener("resize", o()(T, 100))
                        }, i.setClearColor(592137, 1), c.aspect = 1.5, c.far = 1e3, c.position.set(0, 12, 85), c.lookAt(new r.Vector3(0, 14, 0)), e.next = 32, p.createObj();
                    case 32:
                        return e.next = 34, m.createObj();
                    case 34:
                        return y.createObj(), g.createObj(), x.createObj(), b.createObj(), m.obj.renderOrder = 10, a.add(p.obj), a.add(m.obj), a.add(y.obj), a.add(g.obj), a.add(x.obj), a.add(b.obj), E(), T(), h.classList.add("is-hidden"), e.next = 50, s()(200);
                    case 50:
                        u.start(), S();
                    case 52:
                    case "end":
                        return e.stop()
                }
            }), e)
        })), (H = function() {
            var t = this,
                n = arguments;
            return new Promise((function(r, i) {
                var o = e.apply(t, n);

                function a(e) {
                    U(o, r, i, a, s, "next", e)
                }

                function s(e) {
                    U(o, r, i, a, s, "throw", e)
                }
                a(void 0)
            }))
        }).apply(this, arguments)
    }
}, function(e, t, n) {
    "use strict";
    n.r(t);
    var r = n(0),
        i = n(3),
        o = n.n(i),
        a = (n(12), n(1)),
        s = n.n(a),
        c = "#define GLSLIFY 1\nattribute vec3 position;\nattribute float size;\n\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\n\nvoid main() {\n  // coordinate transformation\n  vec4 mvPosition = viewMatrix * modelMatrix * vec4(position, 1.0);\n\n  gl_Position = projectionMatrix * mvPosition;\n  gl_PointSize = 5.0 + size;\n}\n",
        u = "precision highp float;\n#define GLSLIFY 1\n\nvoid main() {\n  // Convert PointCoord to the other vec2 has a range from -1.0 to 1.0.\n  vec2 p = gl_PointCoord * 2.0 - 1.0;\n\n  // Draw circle\n  float radius = length(p);\n  float opacity = (1.0 - smoothstep(0.9, 1.0, radius));\n\n  vec3 color = vec3(0.1);\n\n  gl_FragColor = vec4(color, opacity);\n}\n";

    function l(e) {
        return (l = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
            return typeof e
        } : function(e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
        })(e)
    }

    function f(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }

    function d(e, t) {
        return !t || "object" !== l(t) && "function" != typeof t ? function(e) {
            if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return e
        }(e) : t
    }

    function h(e) {
        return (h = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
            return e.__proto__ || Object.getPrototypeOf(e)
        })(e)
    }

    function v(e, t) {
        return (v = Object.setPrototypeOf || function(e, t) {
            return e.__proto__ = t, e
        })(e, t)
    }
    var p = 100,
        m = new r.Vector2,
        y = new r.Vector3,
        g = new r.Vector3,
        x = function(e) {
            var t = e.fov * Math.PI / 180,
                n = Math.abs(e.position.z * Math.tan(t / 2) * 2);
            m.set(n * e.aspect, n)
        },
        b = function(e) {
            function t(e) {
                var n;
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, t);
                var i = new r.BufferGeometry,
                    o = new r.BufferAttribute(new Float32Array(3 * p), 3),
                    a = new r.BufferAttribute(new Float32Array(3 * p), 3),
                    l = new r.BufferAttribute(new Float32Array(p), 1);
                x(e);
                for (var f = 0; f < p; f++) {
                    o.setXYZ(f, m.x * (Math.random() - .5), m.y * (Math.random() - .5), 0);
                    var v = 6 * Math.random() + 1,
                        y = s.a.radians(360 * Math.random());
                    a.setXYZ(f, Math.cos(y) * (.1 - .01 * v), Math.sin(y) * (.1 - .01 * v), 0), l.setX(f, v)
                }
                i.addAttribute("position", o), i.addAttribute("acceralation", a), i.addAttribute("size", l);
                var g = new r.RawShaderMaterial({
                    uniforms: {
                        time: {
                            type: "f",
                            value: 0
                        }
                    },
                    vertexShader: c,
                    fragmentShader: u,
                    transparent: !0,
                    depthTest: !1
                });
                return (n = d(this, h(t).call(this, i, g))).name = "NodePoints", n
            }
            var n, i, o;
            return function(e, t) {
                if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
                e.prototype = Object.create(t && t.prototype, {
                    constructor: {
                        value: e,
                        writable: !0,
                        configurable: !0
                    }
                }), t && v(e, t)
            }(t, e), n = t, (i = [{
                key: "start",
                value: function() {}
            }, {
                key: "update",
                value: function(e, t) {
                    x(t);
                    for (var n = 0; n < p; n++) y.set(this.geometry.attributes.position.getX(n), this.geometry.attributes.position.getY(n), this.geometry.attributes.position.getZ(n)), g.set(this.geometry.attributes.acceralation.getX(n), this.geometry.attributes.acceralation.getY(n), this.geometry.attributes.acceralation.getZ(n)), y.add(g), y.x >= .6 * m.x ? y.x = .6 * -m.x : y.x < -.6 * m.x && (y.x = .6 * m.x), y.y >= .6 * m.y ? y.y = .6 * -m.y : y.y < -.6 * m.y && (y.y = .6 * m.y), this.geometry.attributes.position.setXYZ(n, y.x, y.y, y.z), this.geometry.attributes.acceralation.setXYZ(n, g.x, g.y, g.z);
                    this.geometry.attributes.position.needsUpdate = !0, this.geometry.attributes.acceralation.needsUpdate = !0
                }
            }]) && f(n.prototype, i), o && f(n, o), t
        }(r.Points),
        w = "#define GLSLIFY 1\nattribute vec3 position;\nattribute float opacity;\n\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\n\nvarying float vOpacity;\n\nvoid main(void) {\n  // coordinate transformation\n  vec4 mPosition = modelMatrix * vec4(position, 1.0);\n\n  vOpacity = opacity;\n\n  gl_Position = projectionMatrix * viewMatrix * mPosition;\n}\n",
        M = "precision highp float;\n#define GLSLIFY 1\n\nvarying float vOpacity;\n\nvoid main() {\n  vec3 color = vec3(0.1);\n\n  gl_FragColor = vec4(color, vOpacity);\n}\n";

    function _(e) {
        return (_ = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
            return typeof e
        } : function(e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
        })(e)
    }

    function S(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }

    function P(e, t) {
        return !t || "object" !== _(t) && "function" != typeof t ? function(e) {
            if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return e
        }(e) : t
    }

    function T(e) {
        return (T = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
            return e.__proto__ || Object.getPrototypeOf(e)
        })(e)
    }

    function E(e, t) {
        return (E = Object.setPrototypeOf || function(e, t) {
            return e.__proto__ = t, e
        })(e, t)
    }
    var z = 1e3,
        L = new r.Vector2,
        A = new r.Vector3,
        C = new r.Vector3,
        R = function(e) {
            function t() {
                var e;
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, t);
                for (var n = new r.BufferGeometry, i = new r.BufferAttribute(new Float32Array(3 * z * 2), 3), o = new r.BufferAttribute(new Float32Array(2 * z), 1), a = [], s = 0; s < 2 * z; s++) a.push(s);
                n.addAttribute("position", i), n.addAttribute("opacity", o), n.setIndex(new r.BufferAttribute(new Uint16Array(a), 1));
                var c = new r.RawShaderMaterial({
                    vertexShader: w,
                    fragmentShader: M,
                    transparent: !0,
                    depthTest: !1,
                    linewidth: 1
                });
                return (e = P(this, T(t).call(this, n, c))).name = "NodeLine", e
            }
            var n, i, o;
            return function(e, t) {
                if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
                e.prototype = Object.create(t && t.prototype, {
                    constructor: {
                        value: e,
                        writable: !0,
                        configurable: !0
                    }
                }), t && E(e, t)
            }(t, e), n = t, (i = [{
                key: "start",
                value: function() {}
            }, {
                key: "update",
                value: function(e, t) {
                    ! function(e) {
                        var t = e.fov * Math.PI / 180,
                            n = Math.abs(e.position.z * Math.tan(t / 2) * 2);
                        L.set(n * e.aspect, n)
                    }(t);
                    for (var n = 0, r = 0; r < e.geometry.attributes.position.count; r++)
                        for (var i = r + 1; i < e.geometry.attributes.position.count; i++) {
                            A.set(e.geometry.attributes.position.getX(r), e.geometry.attributes.position.getY(r), e.geometry.attributes.position.getZ(r)), C.set(e.geometry.attributes.position.getX(i), e.geometry.attributes.position.getY(i), e.geometry.attributes.position.getZ(i));
                            var o = A.distanceTo(C);
                            o < .15 * L.y && (this.geometry.attributes.position.setXYZ(2 * n, A.x, A.y, A.z), this.geometry.attributes.position.setXYZ(2 * n + 1, C.x, C.y, C.z), this.geometry.attributes.opacity.setXYZ(2 * n, 3 - o), this.geometry.attributes.opacity.setXYZ(2 * n + 1, 3 - o), n++)
                        }
                    for (var a = 2 * (n + 1); a < this.geometry.attributes.position.count; a++) this.geometry.attributes.position.setXYZ(a, 0, 0, 0);
                    this.geometry.attributes.position.needsUpdate = !0, this.geometry.attributes.opacity.needsUpdate = !0
                }
            }]) && S(n.prototype, i), o && S(n, o), t
        }(r.LineSegments);

    function O(e, t, n, r, i, o, a) {
        try {
            var s = e[o](a),
                c = s.value
        } catch (e) {
            return void n(e)
        }
        s.done ? t(c) : Promise.resolve(c).then(r, i)
    }

    function j(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }
    var I, D, k = document.getElementById("canvas-webgl"),
        F = new r.WebGLRenderer({
            alpha: !0,
            antialias: !0,
            canvas: k
        }),
        G = new r.Scene,
        N = new r.PerspectiveCamera,
        B = (new r.Vector2, new r.Clock({
            autoStart: !1
        })),
        U = function() {
            function e() {
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, e)
            }
            var t, n, i, o, a;
            return t = e, (n = [{
                key: "init",
                value: (o = regeneratorRuntime.mark((function e(t) {
                    return regeneratorRuntime.wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                F.setClearColor(16762368, 1), N.aspect = 1.5, N.far = 1e3, N.setFocalLength(50), N.position.set(0, 0, 50), N.lookAt(new r.Vector3), I = new b(N), D = new R, G.add(I), G.add(D), this.resize(t);
                            case 11:
                            case "end":
                                return e.stop()
                        }
                    }), e, this)
                })), a = function() {
                    var e = this,
                        t = arguments;
                    return new Promise((function(n, r) {
                        var i = o.apply(e, t);

                        function a(e) {
                            O(i, n, r, a, s, "next", e)
                        }

                        function s(e) {
                            O(i, n, r, a, s, "throw", e)
                        }
                        a(void 0)
                    }))
                }, function(e) {
                    return a.apply(this, arguments)
                })
            }, {
                key: "start",
                value: function() {
                    this.play()
                }
            }, {
                key: "stop",
                value: function() {
                    this.pause()
                }
            }, {
                key: "play",
                value: function() {
                    B.start()
                }
            }, {
                key: "pause",
                value: function() {
                    B.stop()
                }
            }, {
                key: "update",
                value: function() {
                    if (!1 !== B.running) {
                        var e = B.getDelta();
                        I.update(e, N), D.update(I, N), F.render(G, N)
                    }
                }
            }, {
                key: "resize",
                value: function(e) {
                    k.width = e.x, k.height = e.y,
                        function(e) {
                            N.aspect = e.x / e.y, N.updateProjectionMatrix()
                        }(e), F.setSize(e.x, e.y)
                }
            }]) && j(t.prototype, n), i && j(t, i), e
        }();

    function H(e, t, n, r, i, o, a) {
        try {
            var s = e[o](a),
                c = s.value
        } catch (e) {
            return void n(e)
        }
        s.done ? t(c) : Promise.resolve(c).then(r, i)
    }
    t.default = function() {
        return V.apply(this, arguments)
    };

    function V() {
        var e;
        return e = regeneratorRuntime.mark((function e() {
            var t, n, i, a, s;
            return regeneratorRuntime.wrap((function(e) {
                for (;;) switch (e.prev = e.next) {
                    case 0:
                        return t = new U, n = new r.Vector2, i = document.querySelector(".p-preloader"), a = function() {
                            n.set(document.body.clientWidth, window.innerHeight), t.resize(n)
                        }, s = function e() {
                            t.update(), requestAnimationFrame(e)
                        }, window.addEventListener("resize", o()(a, 100)), a(), e.next = 10, t.init(n);
                    case 10:
                        i.classList.add("is-hidden"), t.start(), s();
                    case 13:
                    case "end":
                        return e.stop()
                }
            }), e)
        })), (V = function() {
            var t = this,
                n = arguments;
            return new Promise((function(r, i) {
                var o = e.apply(t, n);

                function a(e) {
                    H(o, r, i, a, s, "next", e)
                }

                function s(e) {
                    H(o, r, i, a, s, "throw", e)
                }
                a(void 0)
            }))
        }).apply(this, arguments)
    }
}, function(e, t, n) {
    "use strict";
    n.r(t);
    var r = n(0),
        i = n(154),
        o = n.n(i),
        a = n(3),
        s = n.n(a),
        c = n(12),
        u = n.n(c),
        l = n(1),
        f = n.n(l),
        d = n(47);

    function h(e) {
        return (h = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
            return typeof e
        } : function(e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
        })(e)
    }

    function v(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }

    function p(e, t) {
        return !t || "object" !== h(t) && "function" != typeof t ? function(e) {
            if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return e
        }(e) : t
    }

    function m(e) {
        return (m = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
            return e.__proto__ || Object.getPrototypeOf(e)
        })(e)
    }

    function y(e, t) {
        return (y = Object.setPrototypeOf || function(e, t) {
            return e.__proto__ = t, e
        })(e, t)
    }
    var g = function(e) {
            function t(e) {
                var i;
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, t);
                var o = new r.RawShaderMaterial({
                    uniforms: {
                        time: {
                            type: "f",
                            value: -2
                        },
                        drawBrightOnly: {
                            type: "f",
                            value: 0
                        },
                        dissolveEdge: {
                            type: "f",
                            value: 0
                        }
                    },
                    vertexShader: n(381).default,
                    fragmentShader: n(382).default,
                    flatShading: !0,
                    transparent: !0
                });
                return (i = p(this, m(t).call(this, e, o))).v = new r.Vector3(0, 0, 0), i.a = new r.Vector3, i.anchor = new r.Vector3(0, 0, 0), i.sv = new r.Vector3(0, 0, 0), i.sa = new r.Vector3, i.sanchor = new r.Vector3(0, 0, 0), i.isOvered = !1, i.isCoolDowned = !1, i
            }
            var i, o, a;
            return function(e, t) {
                if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
                e.prototype = Object.create(t && t.prototype, {
                    constructor: {
                        value: e,
                        writable: !0,
                        configurable: !0
                    }
                }), t && y(e, t)
            }(t, e), i = t, (o = [{
                key: "rotate",
                value: function(e, t) {
                    this.anchor.set(e, t, 0)
                }
            }, {
                key: "render",
                value: function(e, t) {
                    this.material.uniforms.time.value += e, this.material.uniforms.dissolveEdge.value = .0055 * t, this.a.copy(this.anchor).sub(this.v).divideScalar(10), this.v.add(this.a), this.rotation.setFromVector3(this.v), this.sa.copy(this.sanchor).sub(this.sv).divideScalar(10), !1 === this.isOvered && this.sa.addScalar(.2 * t), this.sv.add(this.sa);
                    var n = .005 * (this.sv.length() + 1),
                        r = 5e-4 * this.sv.length() + 1;
                    !1 === this.isCoolDowned && (this.scale.set(r, r, r), this.position.set((2 * Math.random() - 1) * n, (2 * Math.random() - 1) * n, (2 * Math.random() - 1) * n))
                }
            }, {
                key: "over",
                value: function() {
                    this.isOvered = !0
                }
            }, {
                key: "coolDown",
                value: function() {
                    this.isOvered = !1, this.isCoolDowned = !0
                }
            }, {
                key: "returnFirstState",
                value: function() {
                    this.sv.set(0, 0, 0), this.sa.set(0, 0, 0), this.isCoolDowned = !1
                }
            }]) && v(i.prototype, o), a && v(i, a), t
        }(r.Mesh),
        x = n(4);

    function b(e) {
        return (b = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
            return typeof e
        } : function(e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
        })(e)
    }

    function w(e, t, n, r, i, o, a) {
        try {
            var s = e[o](a),
                c = s.value
        } catch (e) {
            return void n(e)
        }
        s.done ? t(c) : Promise.resolve(c).then(r, i)
    }

    function M(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }

    function _(e, t) {
        return !t || "object" !== b(t) && "function" != typeof t ? function(e) {
            if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return e
        }(e) : t
    }

    function S(e) {
        return (S = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
            return e.__proto__ || Object.getPrototypeOf(e)
        })(e)
    }

    function P(e, t) {
        return (P = Object.setPrototypeOf || function(e, t) {
            return e.__proto__ = t, e
        })(e, t)
    }
    var T = function(e) {
        function t() {
            var e;
            ! function(e, t) {
                if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
            }(this, t);
            var i = new r.PlaneBufferGeometry(36, 36),
                o = new r.RawShaderMaterial({
                    uniforms: {
                        time: {
                            type: "f",
                            value: 0
                        },
                        time2: {
                            type: "f",
                            value: 0
                        },
                        tex: {
                            type: "t",
                            value: null
                        },
                        drawBrightOnly: {
                            type: "f",
                            value: 0
                        }
                    },
                    vertexShader: n(383).default,
                    fragmentShader: n(384).default,
                    transparent: !0
                });
            return (e = _(this, S(t).call(this, i, o))).position.z = 40, e.isOver = !1, e
        }
        var i, o, a, s, c;
        return function(e, t) {
            if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
            e.prototype = Object.create(t && t.prototype, {
                constructor: {
                    value: e,
                    writable: !0,
                    configurable: !0
                }
            }), t && P(e, t)
        }(t, e), i = t, (o = [{
            key: "loadTexture",
            value: (s = regeneratorRuntime.mark((function e() {
                return regeneratorRuntime.wrap((function(e) {
                    for (;;) switch (e.prev = e.next) {
                        case 0:
                            return e.next = 2, Object(x.default)("/sketch-threejs/img/sketch/newyear2019/typo.png");
                        case 2:
                            this.material.uniforms.tex.value = e.sent;
                        case 3:
                        case "end":
                            return e.stop()
                    }
                }), e, this)
            })), c = function() {
                var e = this,
                    t = arguments;
                return new Promise((function(n, r) {
                    var i = s.apply(e, t);

                    function o(e) {
                        w(i, n, r, o, a, "next", e)
                    }

                    function a(e) {
                        w(i, n, r, o, a, "throw", e)
                    }
                    o(void 0)
                }))
            }, function() {
                return c.apply(this, arguments)
            })
        }, {
            key: "render",
            value: function(e) {
                this.material.uniforms.time.value += e, !0 === this.isOver && (this.material.uniforms.time2.value += e)
            }
        }, {
            key: "over",
            value: function(e) {
                this.material.uniforms.time2.value = 0, this.isOver = !0
            }
        }, {
            key: "coolDown",
            value: function() {
                this.isOver = !1
            }
        }]) && M(i.prototype, o), a && M(i, a), t
    }(r.Mesh);

    function E(e) {
        return (E = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
            return typeof e
        } : function(e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
        })(e)
    }

    function z(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }

    function L(e, t) {
        return !t || "object" !== E(t) && "function" != typeof t ? function(e) {
            if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return e
        }(e) : t
    }

    function A(e) {
        return (A = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
            return e.__proto__ || Object.getPrototypeOf(e)
        })(e)
    }

    function C(e, t) {
        return (C = Object.setPrototypeOf || function(e, t) {
            return e.__proto__ = t, e
        })(e, t)
    }
    var R = function(e) {
        function t() {
            var e;
            ! function(e, t) {
                if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
            }(this, t);
            var i = new r.InstancedBufferGeometry,
                o = new r.PlaneBufferGeometry(1.2, 1.2);
            i.copy(o);
            for (var a = new r.InstancedBufferAttribute(new Float32Array(1800), 3), s = new r.InstancedBufferAttribute(new Float32Array(1800), 3), c = new r.InstancedBufferAttribute(new Float32Array(1800), 3), u = new r.InstancedBufferAttribute(new Float32Array(600), 1), l = 0; l < 600; l++) {
                var d = f.a.radians(360 * Math.random()),
                    h = 50 * Math.random() + 25;
                a.setXYZ(l, Math.cos(d) * h, Math.sin(d) * h, 250 * Math.random() - 150), l % 2 == 1 ? s.setXYZ(l, .8, .1, .1) : s.setXYZ(l, 1, 1, 1), c.setXYZ(l, f.a.radians(360 * Math.random()), f.a.radians(360 * Math.random()), f.a.radians(360 * Math.random())), u.setXYZ(l, Math.random())
            }
            i.addAttribute("iPosition", a), i.addAttribute("iColor", s), i.addAttribute("iRotate", c), i.addAttribute("iDelay", u);
            var v = new r.RawShaderMaterial({
                uniforms: {
                    time: {
                        type: "f",
                        value: 0
                    }
                },
                vertexShader: n(385).default,
                fragmentShader: n(386).default,
                side: r.DoubleSide,
                transparent: !0
            });
            return (e = L(this, A(t).call(this, i, v))).name = "InstanceMesh", e.frustumCulled = !1, e.isOver = !1, e
        }
        var i, o, a;
        return function(e, t) {
            if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
            e.prototype = Object.create(t && t.prototype, {
                constructor: {
                    value: e,
                    writable: !0,
                    configurable: !0
                }
            }), t && C(e, t)
        }(t, e), i = t, (o = [{
            key: "render",
            value: function(e) {
                !0 === this.isOver && (this.material.uniforms.time.value += e)
            }
        }, {
            key: "over",
            value: function(e) {
                this.material.uniforms.time.value = 0, this.isOver = !0
            }
        }, {
            key: "coolDown",
            value: function() {
                this.isOver = !1
            }
        }]) && z(i.prototype, o), a && z(i, a), t
    }(r.Mesh);

    function O(e) {
        return (O = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
            return typeof e
        } : function(e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
        })(e)
    }

    function j(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }

    function I(e, t) {
        return !t || "object" !== O(t) && "function" != typeof t ? function(e) {
            if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return e
        }(e) : t
    }

    function D(e) {
        return (D = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
            return e.__proto__ || Object.getPrototypeOf(e)
        })(e)
    }

    function k(e, t) {
        return (k = Object.setPrototypeOf || function(e, t) {
            return e.__proto__ = t, e
        })(e, t)
    }
    var F = function(e) {
        function t() {
            var e;
            ! function(e, t) {
                if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
            }(this, t);
            var i = new r.SphereBufferGeometry(100, 128, 128),
                o = new r.RawShaderMaterial({
                    uniforms: {
                        time: {
                            type: "f",
                            value: 0
                        }
                    },
                    vertexShader: n(387).default,
                    fragmentShader: n(388).default,
                    side: r.BackSide,
                    depthWrite: !1
                });
            return (e = I(this, D(t).call(this, i, o))).position.y = 16, e.isOvered = !1, e
        }
        var i, o, a;
        return function(e, t) {
            if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
            e.prototype = Object.create(t && t.prototype, {
                constructor: {
                    value: e,
                    writable: !0,
                    configurable: !0
                }
            }), t && k(e, t)
        }(t, e), i = t, (o = [{
            key: "render",
            value: function(e) {
                !0 === this.isOvered ? this.material.uniforms.time.value += e : this.material.uniforms.time.value -= e, this.material.uniforms.time.value = f.a.clamp(this.material.uniforms.time.value, 0, .8)
            }
        }, {
            key: "over",
            value: function() {
                this.material.uniforms.time.value = 0, this.isOvered = !0
            }
        }, {
            key: "coolDown",
            value: function() {
                this.material.uniforms.time.value = .2, this.isOvered = !1
            }
        }]) && j(i.prototype, o), a && j(i, a), t
    }(r.Mesh);

    function G(e) {
        return (G = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
            return typeof e
        } : function(e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
        })(e)
    }

    function N(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }

    function B(e, t) {
        return !t || "object" !== G(t) && "function" != typeof t ? function(e) {
            if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return e
        }(e) : t
    }

    function U(e) {
        return (U = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
            return e.__proto__ || Object.getPrototypeOf(e)
        })(e)
    }

    function H(e, t) {
        return (H = Object.setPrototypeOf || function(e, t) {
            return e.__proto__ = t, e
        })(e, t)
    }
    var V = function(e) {
        function t(e, i) {
            ! function(e, t) {
                if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
            }(this, t);
            var o = new r.PlaneBufferGeometry(2, 2),
                a = new r.RawShaderMaterial({
                    uniforms: {
                        time: {
                            type: "f",
                            value: 0
                        },
                        texture1: {
                            type: "t",
                            value: e
                        },
                        texture2: {
                            type: "t",
                            value: i
                        },
                        resolution: {
                            type: "v2",
                            value: new r.Vector2
                        }
                    },
                    vertexShader: n(389).default,
                    fragmentShader: n(390).default
                });
            return B(this, U(t).call(this, o, a))
        }
        var i, o, a;
        return function(e, t) {
            if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
            e.prototype = Object.create(t && t.prototype, {
                constructor: {
                    value: e,
                    writable: !0,
                    configurable: !0
                }
            }), t && H(e, t)
        }(t, e), i = t, (o = [{
            key: "resize",
            value: function(e, t) {
                this.material.uniforms.resolution.value.set(e, t)
            }
        }, {
            key: "render",
            value: function(e) {
                this.material.uniforms.time.value += e
            }
        }]) && N(i.prototype, o), a && N(i, a), t
    }(r.Mesh);

    function W(e, t, n, r, i, o, a) {
        try {
            var s = e[o](a),
                c = s.value
        } catch (e) {
            return void n(e)
        }
        s.done ? t(c) : Promise.resolve(c).then(r, i)
    }

    function Y(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }
    var X = document.querySelector(".l-page"),
        q = function() {
            function e(t) {
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, e), this.os = t, this.btn = document.querySelector(".p-hold-button"), this.progress = document.querySelector(".p-hold-button__progress-in"), this.v = 0, this.a = 0, this.cv = new r.Vector2, this.ca = new r.Vector2, this.timeOver = 0, this.state = 0, this.isHolding = !1, this.isEnabled = !1
            }
            var t, n, i, o, a;
            return t = e, (n = [{
                key: "start",
                value: function(e) {
                    this.isEnabled = !0, "iOS" === this.os || "Android" === this.os ? this.btn.classList.add("is-enabled", "is-shown", "is-smartphone") : (this.cv.set(e.x / 2, e.y), this.btn.classList.add("is-pc"))
                }
            }, {
                key: "on",
                value: function(e, t) {
                    var n = this;
                    "iOS" === this.os || "Android" === this.os ? (this.btn.addEventListener("touchstart", (function(e) {
                        e.preventDefault(), 0 === n.state && (n.btn.classList.add("is-pressed"), n.btn.classList.remove("is-released"), n.isHolding = !0)
                    }), {
                        capture: !0
                    }), this.btn.addEventListener("touchend", (function(e) {
                        e.preventDefault(), n.a = 0, n.btn.classList.remove("is-pressed"), n.btn.classList.add("is-released"), n.isHolding = !1
                    }), {
                        capture: !0
                    })) : (e.addEventListener("mousedown", (function(t) {
                        t.preventDefault(), 0 === n.state && (e.style = "cursor: grabbing;", n.btn.classList.add("is-pressed"), n.btn.classList.remove("is-released"), n.isHolding = !0)
                    }), {
                        capture: !0
                    }), window.addEventListener("mousemove", (function(r) {
                        !1 === n.isHolding && (e.style = "cursor: grab;"), t.set(r.clientX, r.clientY)
                    })), window.addEventListener("mouseup", (function(e) {
                        e.preventDefault(), n.a = 0, n.btn.classList.remove("is-pressed"), n.btn.classList.add("is-released"), n.isHolding = !1
                    }), {
                        capture: !0
                    }), e.addEventListener("mouseenter", (function() {
                        n.btn.classList.add("is-shown"), n.btn.classList.remove("is-hidden")
                    })), X.addEventListener("mouseleave", (function() {
                        n.a = 0, n.btn.classList.remove("is-shown", "is-pressed", "is-released"), n.btn.classList.add("is-hidden"), n.isHolding = !1
                    })))
                }
            }, {
                key: "render",
                value: (o = regeneratorRuntime.mark((function e(t, n) {
                    var r, i;
                    return regeneratorRuntime.wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                if (!1 !== this.isEnabled) {
                                    e.next = 2;
                                    break
                                }
                                return e.abrupt("return");
                            case 2:
                                "iOS" !== this.os && "Android" !== this.os && (r = n.clone().sub(this.cv), this.ca.add(r.divideScalar(12)), i = this.ca.clone().multiplyScalar(-1).normalize().multiplyScalar(.28 * this.ca.length()), this.ca.add(i), this.cv.add(this.ca), this.btn.style = "transform: translate3d(".concat(this.cv.x + 8, "px, ").concat(this.cv.y + 8, "px, 0)")), 0 !== this.state && 2 !== this.state || (!0 === this.isHolding ? this.a = (1.4 * this.v + 1) * t : this.a = -3 * this.v * t, this.v += this.a, this.v = f.a.clamp(this.v, 0, 100), this.progress.style = "transform: skewX(-45deg) translateX(".concat(50 - this.v, "%);")), e.t0 = this.state, e.next = 0 === e.t0 ? 7 : 1 === e.t0 ? 17 : 2 === e.t0 ? 25 : 33;
                                break;
                            case 7:
                                if (!(this.v < 100)) {
                                    e.next = 11;
                                    break
                                }
                                return e.abrupt("return", 0);
                            case 11:
                                return this.state = 1, this.a = 0, this.btn.classList.remove("is-pressed"), this.btn.classList.add("is-released"), this.isHolding = !1, e.abrupt("return", 1);
                            case 17:
                                if (this.timeOver += t, !(this.timeOver < 5)) {
                                    e.next = 22;
                                    break
                                }
                                return e.abrupt("return", 2);
                            case 22:
                                return this.timeOver = 0, this.state = 2, e.abrupt("return", 3);
                            case 25:
                                if (!(this.v > .5)) {
                                    e.next = 29;
                                    break
                                }
                                return e.abrupt("return", 4);
                            case 29:
                                return this.state = 0, this.v = 0, this.a = 0, e.abrupt("return", 5);
                            case 33:
                            case "end":
                                return e.stop()
                        }
                    }), e, this)
                })), a = function() {
                    var e = this,
                        t = arguments;
                    return new Promise((function(n, r) {
                        var i = o.apply(e, t);

                        function a(e) {
                            W(i, n, r, a, s, "next", e)
                        }

                        function s(e) {
                            W(i, n, r, a, s, "throw", e)
                        }
                        a(void 0)
                    }))
                }, function(e, t) {
                    return a.apply(this, arguments)
                })
            }]) && Y(t.prototype, n), i && Y(t, i), e
        }();

    function K(e, t, n, r, i, o, a) {
        try {
            var s = e[o](a),
                c = s.value
        } catch (e) {
            return void n(e)
        }
        s.done ? t(c) : Promise.resolve(c).then(r, i)
    }
    t.default = function() {
        return Z.apply(this, arguments)
    };

    function Z() {
        var e;
        return e = regeneratorRuntime.mark((function e() {
            var t, n, i, a, c, l, h, v, p, m, y, x, b, w, M, _, S, P, E, z, L, A, C, O, j, I, D;
            return regeneratorRuntime.wrap((function(e) {
                for (;;) switch (e.prev = e.next) {
                    case 0:
                        return t = new o.a, n = t.getOS().name, i = new r.Vector2, a = new r.Vector2, c = document.getElementById("canvas-webgl"), l = new r.WebGLRenderer({
                            alpha: !0,
                            antialias: !0,
                            canvas: c
                        }), h = new r.Scene, v = new r.PerspectiveCamera, p = new r.Clock({
                            autoStart: !1
                        }), m = new r.WebGLRenderTarget, y = new r.WebGLRenderTarget, x = new r.Scene, b = new r.OrthographicCamera(-1, 1, 1, -1, 1, 2), w = document.querySelector(".p-preloader"), M = null, _ = new T, S = new R, P = new F, E = new V(m.texture, y.texture), z = new q(n), L = function() {
                            if (!1 !== p.running) {
                                var e = p.getDelta();
                                z.render(e, a).then((function(e) {
                                    switch (e) {
                                        case 1:
                                            M.over(), _.over(), S.over(), P.over();
                                            break;
                                        case 3:
                                            M.coolDown(), P.coolDown();
                                            break;
                                        case 5:
                                            M.returnFirstState(), _.coolDown(), S.coolDown()
                                    }
                                })), M.render(e, z.v), _.render(e), S.render(e), P.render(e), M.material.uniforms.drawBrightOnly.value = 0, _.material.uniforms.drawBrightOnly.value = 0, S.visible = !0, P.visible = !0, l.setRenderTarget(m), l.render(h, v), M.material.uniforms.drawBrightOnly.value = 1, _.material.uniforms.drawBrightOnly.value = 1, S.visible = !1, P.visible = !1, l.setRenderTarget(y), l.render(h, v), E.render(e), l.setRenderTarget(null), l.render(x, b)
                            }
                        }, A = function e() {
                            L(), requestAnimationFrame(e)
                        }, C = function() {
                            v.setFocalLength(50 * Math.min(i.x / 1200, 1) * f.a.step(1, i.x / i.y) + 50 * Math.min(i.x / 818, 1) * f.a.step(1, i.y / i.x)), v.setViewOffset(1200, 800, (i.x - 1200) / -2, (i.y - 800) / -2, i.x, i.y), v.updateProjectionMatrix()
                        }, O = function() {
                            i.set(document.body.clientWidth, window.innerHeight), c.width = i.x, c.height = i.y, C(), l.setSize(i.x, i.y), m.setSize(i.x, i.y), y.setSize(i.x, i.y), E.resize(i.x, i.y)
                        }, j = function() {
                            window.addEventListener("blur", (function() {
                                p.stop(), z.isEnabled = !1
                            })), window.addEventListener("focus", (function() {
                                p.start(), z.isEnabled = !0
                            })), window.addEventListener("resize", s()(O, 100)), "iOS" === n || "Android" === n ? window.addEventListener("deviceorientation", (function(e) {
                                var t = f.a.radians(.3 * (90 - e.beta)),
                                    n = f.a.radians(e.gamma) * Math.cos(f.a.radians(e.beta));
                                M.rotate(t, n)
                            })) : (window.addEventListener("mousemove", (function(e) {
                                M.rotate(f.a.radians(-20 * -(e.clientY / i.y * 2 - 1)), f.a.radians(20 * (e.clientX / i.x * 2 - 1)))
                            })), window.addEventListener("mouseout", (function(e) {
                                M.rotate(0, 0)
                            }))), z.on(c, a)
                        }, l.setClearColor(0, 1), v.aspect = 1.5, v.far = 1e3, v.position.z = 140, v.lookAt(new r.Vector3), e.next = 32, Object(d.default)("/sketch-threejs/model/newyear2019/boar_head.obj");
                    case 32:
                        return I = e.sent, D = I.children[0].geometry, M = new g(D), e.next = 37, _.loadTexture();
                    case 37:
                        return h.add(M), h.add(_), h.add(S), h.add(P), x.add(E), j(), O(), a.set(i.x / 2, 1.5 * i.y), w.classList.add("is-hidden"), e.next = 48, u()(200);
                    case 48:
                        z.start(i), p.start(), A();
                    case 51:
                    case "end":
                        return e.stop()
                }
            }), e)
        })), (Z = function() {
            var t = this,
                n = arguments;
            return new Promise((function(r, i) {
                var o = e.apply(t, n);

                function a(e) {
                    K(o, r, i, a, s, "next", e)
                }

                function s(e) {
                    K(o, r, i, a, s, "throw", e)
                }
                a(void 0)
            }))
        }).apply(this, arguments)
    }
}, function(e, t, n) {
    "use strict";
    n.r(t);
    var r = n(0),
        i = n(3),
        o = n.n(i),
        a = (n(12), n(4));

    function s(e) {
        return (s = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
            return typeof e
        } : function(e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
        })(e)
    }

    function c(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }

    function u(e, t) {
        return !t || "object" !== s(t) && "function" != typeof t ? function(e) {
            if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return e
        }(e) : t
    }

    function l(e) {
        return (l = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
            return e.__proto__ || Object.getPrototypeOf(e)
        })(e)
    }

    function f(e, t) {
        return (f = Object.setPrototypeOf || function(e, t) {
            return e.__proto__ = t, e
        })(e, t)
    }
    var d = function(e) {
            function t(e, n, i, o) {
                var a;
                return function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, t), (a = u(this, l(t).call(this, e, n, i, o))).cameraResolution = new r.Vector2, a
            }
            var n, i, o;
            return function(e, t) {
                if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
                e.prototype = Object.create(t && t.prototype, {
                    constructor: {
                        value: e,
                        writable: !0,
                        configurable: !0
                    }
                }), t && f(e, t)
            }(t, e), n = t, (i = [{
                key: "start",
                value: function() {
                    this.aspect = 1.5, this.far = 1e3, this.setFocalLength(50), this.position.set(0, 0, 50), this.lookAt(new r.Vector3)
                }
            }, {
                key: "update",
                value: function(e) {}
            }, {
                key: "resize",
                value: function(e) {
                    e.x > e.y ? this.cameraResolution.set(e.x >= 1200 ? 1200 : e.x, e.x >= 1200 ? 800 : .66 * e.x) : this.cameraResolution.set(.6 * (e.y >= 1200 ? 800 : .66 * e.y), .6 * (e.y >= 1200 ? 1200 : e.y)), this.setViewOffset(this.cameraResolution.x, this.cameraResolution.y, (e.x - this.cameraResolution.x) / -2, (e.y - this.cameraResolution.y) / -2, e.x, e.y), this.updateProjectionMatrix()
                }
            }]) && c(n.prototype, i), o && c(n, o), t
        }(r.PerspectiveCamera),
        h = (n(1), "#define GLSLIFY 1\nattribute vec3 position;\n\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\nuniform float time;\nuniform float alpha;\nuniform float pixelRatio;\nuniform sampler2D noiseTex;\n\nvarying vec3 vColor;\n\nvec3 convertHsvToRgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  // Coordinate transformation\n  float noiseR = texture2D(\n    noiseTex,\n    position.yz * 0.4 + vec2(time * 0.1, 0.0)\n    ).r * 2.0 - 1.0;\n  float noiseG = texture2D(\n    noiseTex,\n    position.zx * 0.4 + vec2(0.0, time * 0.1)\n    ).g * 2.0 - 1.0;\n  float noiseB = texture2D(\n    noiseTex,\n    position.xy * 0.4 - time * 0.1\n    ).b * 2.0 - 1.0;\n  vec3 noisePosition = vec3(noiseR, noiseG, noiseB) * (alpha * 0.6 + 0.6);\n  vec4 mvPosition = viewMatrix * modelMatrix * vec4(position + noisePosition, 1.0);\n  float distanceFromCamera = length(mvPosition.xyz);\n\n  // Define the point size.\n  float pointSize = pixelRatio * 240.0 / distanceFromCamera;\n\n  vColor = convertHsvToRgb(\n    vec3(\n      (noiseR + noiseG + noiseB) * 0.2 + time * 0.1,\n      0.8,\n      0.4\n      )\n    );\n\n  gl_Position = projectionMatrix * mvPosition;\n  gl_PointSize = pointSize;\n}\n"),
        v = "precision highp float;\n#define GLSLIFY 1\n\nuniform float alpha;\n\nvarying vec3 vColor;\n\nvoid main() {\n  // Convert PointCoord to the other vec2 has a range from -1.0 to 1.0.\n  vec2 p = gl_PointCoord * 2.0 - 1.0;\n\n  // Draw circle\n  float radius = length(p);\n  float opacity =\n    (\n      (1.0 - smoothstep(0.1, 0.2, radius)) * 0.2\n      + (1.0 - smoothstep(0.2, 1.0, radius)) * 0.1\n    )\n    * smoothstep(0.0, 0.1, alpha)\n    * (1.0 - smoothstep(0.1, 1.0, alpha));\n\n  // Define Colors\n  vec3 color = vColor;\n\n  gl_FragColor = vec4(color, opacity);\n}\n";

    function p(e) {
        return (p = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
            return typeof e
        } : function(e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
        })(e)
    }

    function m(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }

    function y(e, t) {
        return !t || "object" !== p(t) && "function" != typeof t ? function(e) {
            if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return e
        }(e) : t
    }

    function g(e) {
        return (g = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
            return e.__proto__ || Object.getPrototypeOf(e)
        })(e)
    }

    function x(e, t) {
        return (x = Object.setPrototypeOf || function(e, t) {
            return e.__proto__ = t, e
        })(e, t)
    }
    var b, w = function(e) {
        function t() {
            var e;
            ! function(e, t) {
                if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
            }(this, t);
            var n = new r.IcosahedronBufferGeometry(1, 5),
                i = new r.RawShaderMaterial({
                    uniforms: {
                        time: {
                            type: "f",
                            value: 0
                        },
                        alpha: {
                            type: "f",
                            value: 0
                        },
                        pixelRatio: {
                            type: "f",
                            value: window.devicePixelRatio
                        },
                        noiseTex: {
                            type: "t",
                            value: null
                        }
                    },
                    vertexShader: h,
                    fragmentShader: v,
                    transparent: !0,
                    blending: r.AdditiveBlending,
                    depthWrite: !1
                });
            return (e = y(this, g(t).call(this, n, i))).name = "Points", e.time = 0, e.scale.set(10, 10, 10), e
        }
        var n, i, o;
        return function(e, t) {
            if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
            e.prototype = Object.create(t && t.prototype, {
                constructor: {
                    value: e,
                    writable: !0,
                    configurable: !0
                }
            }), t && x(e, t)
        }(t, e), n = t, (i = [{
            key: "start",
            value: function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                this.time = -4 * t, this.material.uniforms.noiseTex.value = e
            }
        }, {
            key: "update",
            value: function(e) {
                this.time += e;
                var t = this.time % 4 / 4,
                    n = 30 * t;
                this.scale.set(n, n, n), this.material.uniforms.time.value += e, this.material.uniforms.alpha.value = t
            }
        }]) && m(n.prototype, i), o && m(n, o), t
    }(r.Points);

    function M(e, t, n, r, i, o, a) {
        try {
            var s = e[o](a),
                c = s.value
        } catch (e) {
            return void n(e)
        }
        s.done ? t(c) : Promise.resolve(c).then(r, i)
    }

    function _(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }
    var S = new r.Scene,
        P = new d,
        T = new r.Clock({
            autoStart: !1
        }),
        E = new w,
        z = new w,
        L = new w,
        A = function() {
            function e() {
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, e)
            }
            var t, n, i, o, s;
            return t = e, (n = [{
                key: "start",
                value: (o = regeneratorRuntime.mark((function e(t) {
                    return regeneratorRuntime.wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return (b = new r.WebGLRenderer({
                                    alpha: !0,
                                    antialias: !0,
                                    canvas: t
                                })).setPixelRatio(window.devicePixelRatio), b.setClearColor(921102, 1), e.next = 5, Promise.all([Object(a.default)("/sketch-threejs/img/sketch/splash/noise.png")]).then((function(e) {
                                    var t = e[0];
                                    t.wrapS = r.RepeatWrapping, t.wrapT = r.RepeatWrapping, E.start(t), z.start(t, .33), L.start(t, .66), S.add(E), S.add(z), S.add(L)
                                }));
                            case 5:
                                P.start();
                            case 6:
                            case "end":
                                return e.stop()
                        }
                    }), e)
                })), s = function() {
                    var e = this,
                        t = arguments;
                    return new Promise((function(n, r) {
                        var i = o.apply(e, t);

                        function a(e) {
                            M(i, n, r, a, s, "next", e)
                        }

                        function s(e) {
                            M(i, n, r, a, s, "throw", e)
                        }
                        a(void 0)
                    }))
                }, function(e) {
                    return s.apply(this, arguments)
                })
            }, {
                key: "play",
                value: function() {
                    T.start(), this.update()
                }
            }, {
                key: "pause",
                value: function() {
                    T.stop()
                }
            }, {
                key: "update",
                value: function() {
                    if (!1 !== T.running) {
                        var e = T.getDelta();
                        P.update(e), E.update(e), z.update(e), L.update(e), b.render(S, P)
                    }
                }
            }, {
                key: "resize",
                value: function(e) {
                    P.resize(e), b.setSize(e.x, e.y)
                }
            }]) && _(t.prototype, n), i && _(t, i), e
        }();

    function C(e, t, n, r, i, o, a) {
        try {
            var s = e[o](a),
                c = s.value
        } catch (e) {
            return void n(e)
        }
        s.done ? t(c) : Promise.resolve(c).then(r, i)
    }
    t.default = function() {
        return R.apply(this, arguments)
    };

    function R() {
        var e;
        return e = regeneratorRuntime.mark((function e() {
            var t, n, i, a, s, c, u;
            return regeneratorRuntime.wrap((function(e) {
                for (;;) switch (e.prev = e.next) {
                    case 0:
                        return t = new A, n = new r.Vector2, i = document.getElementById("canvas-webgl"), a = document.querySelector(".p-preloader"), s = function() {
                            n.set(document.body.clientWidth, window.innerHeight), i.width = n.x, i.height = n.y, t.resize(n)
                        }, c = function() {
                            window.addEventListener("resize", o()(s, 100))
                        }, u = function e() {
                            t.update(), requestAnimationFrame(e)
                        }, e.next = 9, t.start(i);
                    case 9:
                        c(), s(), a.classList.add("is-hidden"), t.play(), u();
                    case 14:
                    case "end":
                        return e.stop()
                }
            }), e)
        })), (R = function() {
            var t = this,
                n = arguments;
            return new Promise((function(r, i) {
                var o = e.apply(t, n);

                function a(e) {
                    C(o, r, i, a, s, "next", e)
                }

                function s(e) {
                    C(o, r, i, a, s, "throw", e)
                }
                a(void 0)
            }))
        }).apply(this, arguments)
    }
}, function(e, t, n) {
    "use strict";
    n.r(t);
    var r = n(0),
        i = n(3),
        o = n.n(i),
        a = n(12),
        s = n.n(a),
        c = n(1),
        u = n.n(c);

    function l(e) {
        return (l = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
            return typeof e
        } : function(e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
        })(e)
    }

    function f(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }

    function d(e, t) {
        return !t || "object" !== l(t) && "function" != typeof t ? function(e) {
            if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return e
        }(e) : t
    }

    function h(e) {
        return (h = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
            return e.__proto__ || Object.getPrototypeOf(e)
        })(e)
    }

    function v(e, t) {
        return (v = Object.setPrototypeOf || function(e, t) {
            return e.__proto__ = t, e
        })(e, t)
    }
    var p = function(e) {
        function t() {
            var e;
            ! function(e, t) {
                if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
            }(this, t);
            for (var i = new r.BufferGeometry, o = new r.BufferAttribute(new Float32Array(36e3), 3), a = new r.BufferAttribute(new Float32Array(12e3), 1), s = new r.BufferAttribute(new Float32Array(12e3), 1), c = new r.BufferAttribute(new Float32Array(12e3), 1), l = 0; l < 6e3; l++) {
                var f = Math.random(),
                    v = {
                        x: (2 * Math.random() - 1) * f * 6,
                        y: (2 * Math.random() - 1) * f * 6,
                        z: (2 * Math.random() - 1) * f * 6
                    };
                o.setXYZ(l, 150 * (l / 6e3 * 2 - 1) + v.x, v.y, v.z), a.setX(l, u.a.radians(l / 6e3 * 900 + l % 2 * 180)), s.setX(l, 18), c.setX(l, u.a.radians(360 * Math.random()))
            }
            for (var p = 0; p < 60; p++)
                for (var m = u.a.radians(p / 60 * 900), y = 0; y < 100; y++) {
                    var g = 100 * p + y + 6e3,
                        x = Math.random(),
                        b = {
                            x: (2 * Math.random() - 1) * x * 1,
                            y: (2 * Math.random() - 1) * x * 1,
                            z: (2 * Math.random() - 1) * x * 1
                        };
                    o.setXYZ(g, 150 * (p / 60 * 2 - 1) + b.x, b.y, b.z), a.setX(g, m), s.setX(g, 18 * (y / 100 * 2 - 1)), c.setX(g, u.a.radians(360 * Math.random()))
                }
            i.addAttribute("position", o), i.addAttribute("radian", a), i.addAttribute("radius", s), i.addAttribute("delay", c);
            var w = new r.RawShaderMaterial({
                uniforms: {
                    time: {
                        type: "f",
                        value: 0
                    }
                },
                vertexShader: n(376).default,
                fragmentShader: n(377).default,
                transparent: !0,
                blending: r.AdditiveBlending,
                depthWrite: !1
            });
            return (e = d(this, h(t).call(this, i, w))).name = "DNA Herix", e
        }
        var i, o, a;
        return function(e, t) {
            if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
            e.prototype = Object.create(t && t.prototype, {
                constructor: {
                    value: e,
                    writable: !0,
                    configurable: !0
                }
            }), t && v(e, t)
        }(t, e), i = t, (o = [{
            key: "render",
            value: function(e) {
                this.material.uniforms.time.value += e
            }
        }]) && f(i.prototype, o), a && f(i, a), t
    }(r.Points);

    function m(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }
    var y = function() {
        function e(t) {
            ! function(e, t) {
                if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
            }(this, e), this.uniforms = {
                time: {
                    type: "f",
                    value: 0
                },
                texture: {
                    type: "t",
                    value: t
                },
                resolution: {
                    type: "v2",
                    value: new r.Vector2
                }
            }, this.obj
        }
        var t, i, o;
        return t = e, (i = [{
            key: "createObj",
            value: function() {
                var e = new r.PlaneBufferGeometry(2, 2),
                    t = new r.RawShaderMaterial({
                        uniforms: this.uniforms,
                        vertexShader: n(378).default,
                        fragmentShader: n(379).default
                    });
                this.obj = new r.Mesh(e, t), this.obj.name = "PostEffect"
            }
        }, {
            key: "resize",
            value: function(e, t) {
                this.uniforms.resolution.value.set(e, t)
            }
        }, {
            key: "render",
            value: function(e) {
                this.uniforms.time.value += e
            }
        }]) && m(t.prototype, i), o && m(t, o), e
    }();

    function g(e, t, n, r, i, o, a) {
        try {
            var s = e[o](a),
                c = s.value
        } catch (e) {
            return void n(e)
        }
        s.done ? t(c) : Promise.resolve(c).then(r, i)
    }
    t.default = function() {
        return x.apply(this, arguments)
    };

    function x() {
        var e;
        return e = regeneratorRuntime.mark((function e() {
            var t, n, i, a, c, u, l, f, d, h, v, m, g, x, b, w, M;
            return regeneratorRuntime.wrap((function(e) {
                for (;;) switch (e.prev = e.next) {
                    case 0:
                        return t = new r.Vector2, n = document.getElementById("canvas-webgl"), i = new r.WebGLRenderer({
                            alpha: !0,
                            antialias: !0,
                            canvas: n
                        }), a = new r.Scene, c = new r.PerspectiveCamera, u = new r.Clock({
                            autoStart: !1
                        }), l = new r.WebGLRenderTarget, f = new r.Scene, d = new r.OrthographicCamera(-1, 1, 1, -1, 1, 2), h = document.querySelector(".p-preloader"), v = new p, (m = new y(l.texture)).createObj(), f.add(m.obj), g = function() {
                            var e = u.getDelta();
                            v.render(e), i.setRenderTarget(l), i.render(a, c), m.render(e), i.setRenderTarget(null), i.render(f, d)
                        }, x = function e() {
                            g(), requestAnimationFrame(e)
                        }, b = function() {
                            c.setFocalLength(50), c.setViewOffset(1200, 800, (t.x - 1200) / -2, (t.y - 800) / -2, t.x, t.y), c.updateProjectionMatrix()
                        }, w = function() {
                            t.set(document.body.clientWidth, window.innerHeight), n.width = t.x, n.height = t.y, b(), i.setSize(t.x, t.y), l.setSize(t.x, t.y), m.resize(t.x, t.y)
                        }, M = function() {
                            window.addEventListener("blur", (function() {
                                u.stop()
                            })), window.addEventListener("focus", (function() {
                                u.start()
                            })), window.addEventListener("resize", o()(w, 1e3))
                        }, i.setClearColor(0, 1), c.aspect = 1.5, c.far = 1e3, c.position.set(-110, -75, 45), c.lookAt(new r.Vector3(0, 0, 0)), a.add(v), M(), w(), h.classList.add("is-hidden"), e.next = 30, s()(200);
                    case 30:
                        u.start(), x();
                    case 32:
                    case "end":
                        return e.stop()
                }
            }), e)
        })), (x = function() {
            var t = this,
                n = arguments;
            return new Promise((function(r, i) {
                var o = e.apply(t, n);

                function a(e) {
                    g(o, r, i, a, s, "next", e)
                }

                function s(e) {
                    g(o, r, i, a, s, "throw", e)
                }
                a(void 0)
            }))
        }).apply(this, arguments)
    }
}, function(e, t, n) {
    "use strict";
    n.r(t);
    var r = n(0),
        i = n(3),
        o = n.n(i),
        a = n(12),
        s = n.n(a),
        c = n(4);

    function u(e) {
        return (u = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
            return typeof e
        } : function(e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
        })(e)
    }

    function l(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
        }
    }

    function f(e, t) {
        return !t || "object" !== u(t) && "function" != typeof t ? function(e) {
            if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return e
        }(e) : t
    }

    function d(e) {
        return (d = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
            return e.__proto__ || Object.getPrototypeOf(e)
        })(e)
    }

    function h(e, t) {
        return (h = Object.setPrototypeOf || function(e, t) {
            return e.__proto__ = t, e
        })(e, t)
    }
    var v = function(e) {
        function t() {
            var e;
            ! function(e, t) {
                if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
            }(this, t);
            var i = new r.PlaneBufferGeometry(2, 2),
                o = new r.RawShaderMaterial({
                    uniforms: {
                        time: {
                            type: "f",
                            value: 0
                        },
                        interval: {
                            type: "f",
                            value: 5
                        },
                        duration: {
                            type: "f",
                            value: 3
                        },
                        resolution: {
                            type: "v2",
                            value: new r.Vector2
                        },
                        imageResolution: {
                            type: "v2",
                            value: new r.Vector2(2048, 1356)
                        },
                        textures: {
                            type: "f",
                            value: 0
                        }
                    },
                    vertexShader: n(374).default,
                    fragmentShader: n(375).default
                });
            return (e = f(this, d(t).call(this, i, o))).name = "Mesh", e
        }
        var i, o, a;
        return function(e, t) {
            if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
            e.prototype = Object.create(t && t.prototype, {
                constructor: {
                    value: e,
                    writable: !0,
                    configurable: !0
                }
            }), t && h(e, t)
        }(t, e), i = t, (o = [{
            key: "start",
            value: function(e, t) {
                this.resize(e);
                for (var n = 0; n < t.length; n++) t[n].magFilter = r.NearestFilter, t[n].minFilter = r.NearestFilter;
                this.material.uniforms.textures.value = t
            }
        }, {
            key: "update",
            value: function(e) {
                this.material.uniforms.time.value += e
            }
        }, {
            key: "resize",
            value: function(e) {
                this.material.uniforms.resolution.value.copy(e)
            }
        }]) && l(i.prototype, o), a && l(i, a), t
    }(r.Mesh);

    function p(e, t, n, r, i, o, a) {
        try {
            var s = e[o](a),
                c = s.value
        } catch (e) {
            return void n(e)
        }
        s.done ? t(c) : Promise.resolve(c).then(r, i)
    }
    t.default = function() {
        return m.apply(this, arguments)
    };

    function m() {
        var e;
        return e = regeneratorRuntime.mark((function e() {
            var t, n, i, a, u, l, f, d, h, p, m, y, g;
            return regeneratorRuntime.wrap((function(e) {
                for (;;) switch (e.prev = e.next) {
                    case 0:
                        return t = new r.Vector2, n = document.getElementById("canvas-webgl"), i = new r.WebGLRenderer({
                            alpha: !0,
                            antialias: !0,
                            canvas: n
                        }), a = new r.Scene, u = new r.PerspectiveCamera, l = new r.Clock({
                            autoStart: !1
                        }), f = document.querySelector(".p-preloader"), d = new v, h = function() {
                            var e = l.getDelta();
                            d.update(e), i.render(a, u)
                        }, p = function e() {
                            h(), requestAnimationFrame(e)
                        }, m = function() {
                            u.setViewOffset(1200, 800, (t.x - 1200) / -2, (t.y - 800) / -2, t.x, t.y), u.updateProjectionMatrix()
                        }, y = function() {
                            t.set(document.body.clientWidth, window.innerHeight), n.width = t.x, n.height = t.y, m(), d.resize(t), i.setSize(t.x, t.y)
                        }, g = function() {
                            window.addEventListener("resize", o()(y, 1e3))
                        }, i.setClearColor(15658734, 1), u.aspect = 1.5, u.far = 1e3, u.setFocalLength(50), u.position.set(0, 0, 300), u.lookAt(new r.Vector3), g(), y(), e.next = 23, Promise.all([Object(c.default)("/sketch-threejs/img/sketch/dissolve/osaka01.jpg"), Object(c.default)("/sketch-threejs/img/sketch/dissolve/osaka02.jpg"), Object(c.default)("/sketch-threejs/img/sketch/dissolve/osaka03.jpg"), Object(c.default)("/sketch-threejs/img/sketch/dissolve/osaka04.jpg"), Object(c.default)("/sketch-threejs/img/sketch/dissolve/osaka05.jpg")]).then((function(e) {
                            d.start(t, e)
                        }));
                    case 23:
                        return a.add(d), f.classList.add("is-hidden"), e.next = 27, s()(200);
                    case 27:
                        l.start(), p();
                    case 29:
                    case "end":
                        return e.stop()
                }
            }), e)
        })), (m = function() {
            var t = this,
                n = arguments;
            return new Promise((function(r, i) {
                var o = e.apply(t, n);

                function a(e) {
                    p(o, r, i, a, s, "next", e)
                }

                function s(e) {
                    p(o, r, i, a, s, "throw", e)
                }
                a(void 0)
            }))
        }).apply(this, arguments)
    }
}]);